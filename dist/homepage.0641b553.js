// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"7Aums":[function(require,module,exports) {
"use strict";
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "fe4256060641b553";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ‚ú® Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>üìù <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"bNKaB":[function(require,module,exports) {
//Imports
var _api = require("@polkadot/api");
var _util = require("@polkadot/util");
var cytoscape = require("cytoscape");
let fcose = require("cytoscape-fcose");
cytoscape.use(fcose); // register extension
// Construct
const wsProvider = new (0, _api.WsProvider)("wss://kusama-rpc.polkadot.io");
const apiPromise = (0, _api.ApiPromise).create({
    provider: wsProvider
});
const queryString = window.location.search;
const urlParams = new URLSearchParams(queryString);
var preSearch = urlParams.get("s") ? urlParams.get("s") : "";
const explorers = [
    "https://sub.id/",
    "https://kusama.subscan.io/account/",
    "https://explorer.polkascan.io/kusama/account/",
    "https://kusama.polkaholic.io/account/", 
];
const explorerNames = [
    "Sub.ID (Multichain)",
    "Subscan (Kusama)",
    "Polkascan (Kusama)",
    "Polkaholic (Multichain)"
];
// main startup
async function main() {
    api = await apiPromise;
    autoupdate = api.query.proxy.proxies.entries(async (nodes)=>{
        nodes.sort((a, b)=>{
            return a[0].toHuman[0] - b[0].toHuman[0];
        });
        await draw(nodes);
    });
    autoannoncements = api.query.proxy.announcements.entries(async (announcements)=>{
        console.log(announcements);
        await draw();
    });
}
window.addEventListener("load", async (event)=>{
    await main();
});
var cy = cytoscape({
    container: document.getElementById("cy"),
    style: [
        // the stylesheet for the graph
        {
            selector: "node",
            style: {
                "background-color": "white",
                label: "data(label)",
                color: "white",
                "text-outline-color": "white"
            }
        },
        {
            selector: ".background",
            style: {
                "ghost": "yes",
                "opacity": 0.1
            }
        },
        {
            selector: "edge",
            style: {
                width: 3,
                "line-color": "data(color)",
                "target-arrow-color": "red",
                "target-arrow-shape": "vee",
                "curve-style": "bezier",
                "arrow-scale": 2,
                "control-point-step-size": 100,
                label: "data(label)",
                color: "white"
            }
        }
    ],
    layout: {
        name: "preset"
    },
    wheelSensitivity: 0.2
});
/*
cy.on("layoutstop", async (event) => {
    await draw();
});
*/ //Node selection logic
cy.on("select", "node", function(evt) {
    const node = evt.target;
    const related = node.openNeighborhood();
    const relrel = node.closedNeighborhood().closedNeighborhood();
    const notrelrel = cy.elements().not(relrel);
    notrelrel.addClass("background");
    relrel.removeClass("background");
    sidebar_display(node, related);
});
function sidebar_display(node, related) {
    sidebar = document.getElementById("sidebar");
    sidebar.textContent = "";
    // populate sidebar with node data
    accountElement = document.createElement("account");
    relatedElement = document.createElement("related");
    lastElement = document.createElement("related");
    sidebar.appendChild(accountElement);
    sidebar.appendChild(relatedElement);
    sidebar.appendChild(lastElement);
    objectToDomElement(accountElement, node.data());
    related.map((x)=>{
        if (!x.isEdge()) objectToDomElement(relatedElement, x.data());
    });
    const allElements = document.getElementsByTagName("object");
    for(let i = 0; i < allElements.length; i++){
        const element1 = allElements.item(i);
        // each object should either represent an account/node OR
        // an "additional" identity value - we determine which we 
        // are looking at by checking the first subelement.
        firstChild = element1.firstElementChild;
        if (firstChild.tagName == "ID") {
            const nodeAddress = firstChild.innerText;
            firstChild.innerText = "\n" + firstChild.innerText + "\n";
            firstChild.addEventListener("click", (evt)=>{
                cy.$id(nodeAddress).select();
                const existingLinks = document.getElementById("links");
                linksDiv = existingLinks ? existingLinks : document.createElement("div");
                linksDiv.innerHTML = "";
                linksDiv.id = "links";
                linksDiv.style.float = "left";
                lastElement.appendChild(linksDiv);
                for(index in explorers){
                    explorerLink = document.createElement("a");
                    explorerLink.href = explorers[index] + nodeAddress;
                    explorerLink.innerText = explorerNames[index];
                    linksDiv.appendChild(explorerLink);
                }
            });
            identityElement = element1.getElementsByTagName("identity").item(0);
        }
        firstChild.tagName;
        firstChild.tagName;
    }
}
// recursive function translates an object into a dom tree
// { key: "value" } == "<key>value</key>"
// we can create CSS styles for these individual key/components
// recursive logic looks redundant but look, it seems to break
// if I don't do it this way so...
function objectToDomElement(parent, object, objectTag = false) {
    var documentObject = document.createElement(objectTag ? objectTag : typeof object);
    if (object instanceof Object) {
        if (object instanceof Array) for (element of object)documentObject.append(objectToDomElement(documentObject, element));
        else for ([key, element] of Object.entries(object))documentObject.append(objectToDomElement(documentObject, element, key));
    } else {
        objectText = object ? object.toString() : "";
        documentObject.innerText = objectText;
    }
    parent.append(documentObject);
    return documentObject;
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------//
function onCirc(seedAngle1 = null) {
    var angle = seedAngle1 * Math.PI ? seedAngle1 : Math.random() * Math.PI * 2;
    return [
        Math.cos(angle),
        Math.sin(angle)
    ]; //The maximum is exclusive and the minimum is inclusive
}
function procColor(seed) {
    return "#" + ("00000" + Math.floor(onCirc(seedAngle = seed)[0] * Math.pow(16, 6)).toString(16)).slice(-6);
}
////////////////////////////////////MAIN FUNCTION //////////////////////////////////
// refactored to be an async generator function that can be called repeatedly to add
// or remove nodes from the graph
var pendingIdRequests = [] // universal scope pending ids (previous round supers and manually requested)
;
async function draw(nodes, nodes_remove = []) {
    const api1 = await apiPromise;
    var idRequests = pendingIdRequests;
    pendingIdRequests = [];
    cy.startBatch();
    for(const node in nodes){
        const node_point = nodes[node][0].toHuman()[0]; //nodes in graph
        const delegates = nodes[node][1][0].toHuman(); //node edges/graph connections
        if (cy.$id(node_point).length == 0) {
            // I want node positions to be mostly deterministic so that people can
            // look in roughly the same spot for the same thing across reloads
            [newX, newY] = onCirc(seedAngle = idRequests.length);
            cy.add({
                group: "nodes",
                data: {
                    id: node_point,
                    label: node_point
                },
                position: {
                    x: 10 * newX * (cy.width() / 5 + idRequests.length) + cy.width(),
                    y: 10 * newY * (cy.height() / 5 + idRequests.length) + cy.height()
                }
            });
            idRequests.push(node_point);
        }
        for ([index, delegate] of delegates.entries()){
            if (cy.$id(delegate.delegate).length == 0) {
                [newX, newY] = onCirc(seedAngle = index);
                cy.add({
                    group: "nodes",
                    data: {
                        id: delegate.delegate,
                        label: delegate.delegate
                    },
                    position: {
                        x: cy.$id(node_point).position("x") + newX * (cy.width() / 4 + index),
                        y: cy.$id(node_point).position("y") + newY * (cy.height() / 4 + index)
                    }
                });
                idRequests.push(delegate.delegate);
            }
            edgeId = delegate.delegate + node_point + delegate.proxyType;
            if (cy.$id(edgeId).length == 0) cy.add({
                group: "edges",
                data: {
                    id: edgeId,
                    label: delegate.proxyType,
                    source: delegate.delegate,
                    target: node_point,
                    delay: delegate.delay,
                    color: procColor(index)
                }
            });
        }
    }
    const reg = /(^[0x][0-9a-fA-F]*)\w/g;
    //check for pending idRequests (added to graph global data in cy.on for adding nodes)
    api1.query.identity.identityOf.multi(idRequests).then(async (results)=>{
        var superIds = await api1.query.identity.superOf.multi(idRequests);
        var output = [];
        for (const [index, identity] of results.entries())output.push([
            index,
            identity,
            superIds[index]
        ]);
        return output;
    }).then(async (results)=>{
        for (const [index, identity, superIdResponse] of results){
            if (identity.toHuman()) {
                identityJson = identity.toHuman();
                nametext = reg.test(identityJson["info"]["display"]["Raw"]) ? (0, _util.hexToString)(identityJson["info"]["display"]["Raw"]) : identityJson["info"]["display"]["Raw"];
                cy.$id(idRequests[index]).data("label", nametext);
                cy.$id(idRequests[index]).data("identity", identityJson);
            } else {
                superId = superIdResponse.toHuman();
                if (superId) {
                    var parsedSuperId = reg.test(superId[1]["Raw"]) ? (0, _util.hexToString)(superId[1]["Raw"]) : superId[1]["Raw"];
                    if (!cy.$id(superId[0]).length == 0) {
                        nametext = cy.$id(superId[0]).data("label") + "/" + parsedSuperId;
                        superEdgeId = idRequests[index] + superId[0] + "superidentity";
                        existingNode = cy.$id(superEdgeId);
                        if (existingNode.length == 0) cy.add({
                            group: "edges",
                            data: {
                                id: superEdgeId,
                                label: "Super Identity",
                                source: idRequests[index],
                                target: superId[0],
                                color: procColor(index)
                            }
                        });
                    } else {
                        nametext = idRequests[index];
                        [newX, newY] = onCirc(seedAngle = index);
                        cy.add([
                            {
                                group: "nodes",
                                data: {
                                    id: superId[0],
                                    label: superId[0]
                                },
                                position: {
                                    x: cy.$id(idRequests[index]).position("x") + newX * (cy.width() / 4 + index),
                                    y: cy.$id(idRequests[index]).position("y") + newY * (cy.height() / 4 + index)
                                }
                            }
                        ]);
                        //if superId is not in graph, after we add it to graph, 
                        //we add it to the next round for identification, 
                        //followed by it's child
                        pendingIdRequests.push(superId[0]);
                        pendingIdRequests.push(idRequests[index]);
                        // add edge to superID
                        superEdgeId = idRequests[index] + superId[0] + "superidentity";
                        existingNode = cy.$id(superEdgeId);
                        if (existingNode.length == 0) cy.add({
                            group: "edges",
                            data: {
                                id: idRequests[index] + superId[0] + "superidentity",
                                label: "Super Identity",
                                source: idRequests[index],
                                target: superId[0],
                                color: procColor(index)
                            }
                        });
                    }
                } else nametext = idRequests[index];
            }
            cy.$id(idRequests[index]).data("label", nametext);
        }
    });
    cy.endBatch();
    //console.log("executing layout");
    lay();
}
//Search function that uses searchbar input. Add reset of searchbar? Add choice between search for username or public address.
async function Search() {
    const searchTerm = document.getElementById("searchTerm").value;
    const elem = cy.$("#" + searchTerm);
    const label = elem.data("label");
    elem.select();
    //cy.fit(cy.$('#'+searchTerm));
    cy.zoom({
        level: 1.5,
        position: elem.position()
    });
    console.log("search Attempt for " + searchTerm + " Found " + label);
}
// event listeners for functions
const FsearchTerm = document.getElementById("searchButton");
FsearchTerm.addEventListener("click", Search);
function lay() {
    var layout = cy.layout({
        name: "fcose",
        quality: "default",
        randomize: false,
        animate: true,
        animationDuration: 2000,
        ungrabifyWhileSimulating: true,
        packComponents: false,
        nodeRepulsion: function(node) {
            const repulsionVal = 10000 / node.closedNeighborhood().size();
            return repulsionVal;
        },
        samplingType: true,
        sampleSize: 10,
        nodeSeparation: 100,
        idealEdgeLength: function(edge) {
            lengthval = 500 / edge.source().closedNeighborhood().size();
            return lengthval;
        },
        edgeElasticity: (edge)=>0.4,
        gravity: 0.05,
        gravityRange: 3,
        boundingBox: {
            x1: 0,
            y1: 0,
            w: cy.width(),
            h: cy.height()
        },
        nodeDimensionsIncludeLabels: true,
        // Maximum number of iterations to perform - this is a suggested value and might be adjusted by the algorithm as required
        numIter: 6500,
        // For enabling tiling
        tile: false,
        // Initial cooling factor for incremental layout  
        initialEnergyOnIncremental: 0.4,
        stop: ()=>{
            if (preSearch) {
                document.getElementById("searchTerm").value = preSearch;
                preSearch = false;
                Search();
            } else cy.$(":selected").select();
        }
    });
    layout.run();
    cy.fit();
    cy.center();
}

},{"@polkadot/api":"gqBQQ","@polkadot/util":"3HnHw","cytoscape":"cxe8j","cytoscape-fcose":"6GhNo"}],"gqBQQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"lj1FA","./bundle.js":"18vg0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lj1FA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"9TQUp","./packageInfo.js":"1czuv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3HnHw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"9c9bq","./bundle.js":"8hWQ4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9c9bq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
var _versionDetectJs = require("./versionDetect.js");
(0, _versionDetectJs.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"./detectOther.js":"baej9","./packageInfo.js":"6T6yl","./versionDetect.js":"a4erl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"baej9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xTextdecoder = require("@polkadot/x-textdecoder");
var _xTextencoder = require("@polkadot/x-textencoder");
exports.default = [
    (0, _xTextdecoder.packageInfo),
    (0, _xTextencoder.packageInfo)
];

},{"@polkadot/x-textdecoder":"fM3XH","@polkadot/x-textencoder":"1eRz6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fM3XH":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextDecoder = void 0;
Object.defineProperty(exports, "packageInfo", {
    enumerable: true,
    get: function() {
        return _packageInfo.packageInfo;
    }
});
var _xGlobal = require("@polkadot/x-global");
var _fallback = require("./fallback");
var _packageInfo = require("./packageInfo");
// Copyright 2017-2022 @polkadot/x-textencoder authors & contributors
// SPDX-License-Identifier: Apache-2.0
const TextDecoder = (0, _xGlobal.extractGlobal)("TextDecoder", _fallback.TextDecoder);
exports.TextDecoder = TextDecoder;

},{"@polkadot/x-global":"k9Iwp","./fallback":"f6dNL","./packageInfo":"bTksn"}],"k9Iwp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/x-global authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo)) // Ensure that we are able to run this without any @types/node definitions
;
parcelHelpers.export(exports, "xglobal", ()=>xglobal);
parcelHelpers.export(exports, "extractGlobal", ()=>extractGlobal);
parcelHelpers.export(exports, "exposeGlobal", ()=>exposeGlobal);
var _packageInfoJs = require("./packageInfo.js");
var global = arguments[3];
// and without having lib: ['dom'] in our TypeScript configuration
// (may not be available in all environments, e.g. Deno springs to mind)
function evaluateThis(fn) {
    return fn("return this");
}
const xglobal = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : evaluateThis(Function);
function extractGlobal(name, fallback) {
    // Not quite sure why this is here - snuck in with TS 4.7.2 with no real idea
    // (as of now) as to why this looks like an "any" when we do cast it to a T
    //
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return typeof xglobal[name] === "undefined" ? fallback : xglobal[name];
}
function exposeGlobal(name, fallback) {
    if (typeof xglobal[name] === "undefined") xglobal[name] = fallback;
}

},{"./packageInfo.js":"3NSHH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3NSHH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $2c5061ba5d08d3c3$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/x-global/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/x-global",
    path: $2c5061ba5d08d3c3$import_meta && "file:///node_modules/@polkadot/x-global/packageInfo.js" ? new URL("file:///node_modules/@polkadot/x-global/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/x-global/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "10.1.6"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"f6dNL":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextDecoder = void 0;
// Copyright 2017-2022 @polkadot/x-textencoder authors & contributors
// SPDX-License-Identifier: Apache-2.0
// This is very limited, only handling Ascii values
class TextDecoder {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,no-useless-constructor
    constructor(_){}
    decode(value) {
        let result = "";
        for(let i = 0; i < value.length; i++)result += String.fromCharCode(value[i]);
        return result;
    }
}
exports.TextDecoder = TextDecoder;

},{}],"bTksn":[function(require,module,exports) {
"use strict";
var __dirname = "node_modules/@polkadot/x-textdecoder/cjs";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.packageInfo = void 0;
// Copyright 2017-2022 @polkadot/x-textdecoder authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
const packageInfo = {
    name: "@polkadot/x-textdecoder",
    path: typeof __dirname === "string" ? __dirname : "auto",
    type: "cjs",
    version: "10.1.6"
};
exports.packageInfo = packageInfo;

},{}],"1eRz6":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextEncoder = void 0;
Object.defineProperty(exports, "packageInfo", {
    enumerable: true,
    get: function() {
        return _packageInfo.packageInfo;
    }
});
var _xGlobal = require("@polkadot/x-global");
var _fallback = require("./fallback");
var _packageInfo = require("./packageInfo");
// Copyright 2017-2022 @polkadot/x-textencoder authors & contributors
// SPDX-License-Identifier: Apache-2.0
const TextEncoder = (0, _xGlobal.extractGlobal)("TextEncoder", _fallback.TextEncoder);
exports.TextEncoder = TextEncoder;

},{"@polkadot/x-global":"k9Iwp","./fallback":"dfrqT","./packageInfo":"huhmx"}],"dfrqT":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextEncoder = void 0;
// Copyright 2017-2022 @polkadot/x-textencoder authors & contributors
// SPDX-License-Identifier: Apache-2.0
// This is very limited, only handling Ascii values
class TextEncoder {
    encode(value) {
        const u8a = new Uint8Array(value.length);
        for(let i = 0; i < value.length; i++)u8a[i] = value.charCodeAt(i);
        return u8a;
    }
}
exports.TextEncoder = TextEncoder;

},{}],"huhmx":[function(require,module,exports) {
"use strict";
var __dirname = "node_modules/@polkadot/x-textencoder/cjs";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.packageInfo = void 0;
// Copyright 2017-2022 @polkadot/x-textencoder authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
const packageInfo = {
    name: "@polkadot/x-textencoder",
    path: typeof __dirname === "string" ? __dirname : "auto",
    type: "cjs",
    version: "10.1.6"
};
exports.packageInfo = packageInfo;

},{}],"6T6yl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $503cf666ad554433$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/util/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/util",
    path: $503cf666ad554433$import_meta && "file:///node_modules/@polkadot/util/packageInfo.js" ? new URL("file:///node_modules/@polkadot/util/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/util/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "10.1.6"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a4erl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name detectPackage
 * @summary Checks that a specific package is only imported once
 * @description A `@polkadot/*` version detection utility, checking for one occurence of a package in addition to checking for ddependency versions.
 */ parcelHelpers.export(exports, "detectPackage", ()=>detectPackage);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xGlobal = require("@polkadot/x-global");
var _functionJs = require("./is/function.js");
const DEDUPE = "Either remove and explicitly install matching versions or dedupe using your package manager.\nThe following conflicting packages were found:";
/** @internal */ function getEntry(name) {
    const _global = (0, _xGlobal.xglobal);
    if (!_global.__polkadotjs) _global.__polkadotjs = {};
    if (!_global.__polkadotjs[name]) _global.__polkadotjs[name] = [];
    return _global.__polkadotjs[name];
}
/** @internal */ function formatDisplay(all, fmt) {
    let max = 0;
    for(let i = 0; i < all.length; i++)max = Math.max(max, all[i].version.length);
    return all.map((d)=>`\t${fmt(d.version.padEnd(max), d).join("	")}`).join("\n");
}
/** @internal */ function formatInfo(version, { name  }) {
    return [
        version,
        name
    ];
}
/** @internal */ function formatVersion(version, { path , type  }) {
    let extracted;
    if (path && path.length >= 5) {
        const nmIndex = path.indexOf("node_modules");
        extracted = nmIndex === -1 ? path : path.substring(nmIndex);
    } else extracted = "<unknown>";
    return [
        `${`${type || ""}`.padStart(3)} ${version}`,
        extracted
    ];
}
/** @internal */ function getPath(infoPath, pathOrFn) {
    if (infoPath) return infoPath;
    else if ((0, _functionJs.isFunction)(pathOrFn)) try {
        return pathOrFn() || "";
    } catch (error) {
        return "";
    }
    return pathOrFn || "";
}
/** @internal */ function warn(pre, all, fmt) {
    console.warn(`${pre}\n${DEDUPE}\n${formatDisplay(all, fmt)}`);
}
function detectPackage({ name , path , type , version  }, pathOrFn, deps = []) {
    if (!name.startsWith("@polkadot")) throw new Error(`Invalid package descriptor ${name}`);
    const entry = getEntry(name);
    entry.push({
        path: getPath(path, pathOrFn),
        type,
        version
    });
    if (entry.length !== 1) warn(`${name} has multiple versions, ensure that there is only one installed.`, entry, formatVersion);
    else {
        const mismatches = deps.filter((d)=>d && d.version !== version);
        if (mismatches.length) warn(`${name} requires direct dependencies exactly matching version ${version}.`, mismatches, formatInfo);
    }
}

},{"@polkadot/x-global":"k9Iwp","./is/function.js":"3nYod","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3nYod":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * @name isFunction
 * @summary Tests for a `function`.
 * @description
 * Checks to see if the input value is a JavaScript function.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isFunction } from '@polkadot/util';
 *
 * isFunction(() => false); // => true
 * ```
 */ parcelHelpers.export(exports, "isFunction", ()=>isFunction);
function isFunction(value) {
    return typeof value === "function";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8hWQ4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Utility methods for this package are split into groups
 */ parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
var _packageInfoJs = require("./packageInfo.js");
var _indexJs = require("./array/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var _assertJs = require("./assert.js");
parcelHelpers.exportAll(_assertJs, exports);
var _indexJs1 = require("./bi/index.js");
parcelHelpers.exportAll(_indexJs1, exports);
var _indexJs2 = require("./bn/index.js");
parcelHelpers.exportAll(_indexJs2, exports);
var _indexJs3 = require("./buffer/index.js");
parcelHelpers.exportAll(_indexJs3, exports);
var _indexJs4 = require("./compact/index.js");
parcelHelpers.exportAll(_indexJs4, exports);
var _extractTimeJs = require("./extractTime.js");
parcelHelpers.exportAll(_extractTimeJs, exports);
var _indexJs5 = require("./float/index.js");
parcelHelpers.exportAll(_indexJs5, exports);
var _indexJs6 = require("./format/index.js");
parcelHelpers.exportAll(_indexJs6, exports);
var _hasJs = require("./has.js");
parcelHelpers.exportAll(_hasJs, exports);
var _indexJs7 = require("./hex/index.js");
parcelHelpers.exportAll(_indexJs7, exports);
var _indexJs8 = require("./is/index.js");
parcelHelpers.exportAll(_indexJs8, exports);
var _lazyJs = require("./lazy.js");
parcelHelpers.exportAll(_lazyJs, exports);
var _loggerJs = require("./logger.js");
parcelHelpers.exportAll(_loggerJs, exports);
var _memoizeJs = require("./memoize.js");
parcelHelpers.exportAll(_memoizeJs, exports);
var _nextTickJs = require("./nextTick.js");
parcelHelpers.exportAll(_nextTickJs, exports);
var _indexJs9 = require("./number/index.js");
parcelHelpers.exportAll(_indexJs9, exports);
var _indexJs10 = require("./object/index.js");
parcelHelpers.exportAll(_indexJs10, exports);
var _promisifyJs = require("./promisify.js");
parcelHelpers.exportAll(_promisifyJs, exports);
var _indexJs11 = require("./string/index.js");
parcelHelpers.exportAll(_indexJs11, exports);
var _stringifyJs = require("./stringify.js");
parcelHelpers.exportAll(_stringifyJs, exports);
var _indexJs12 = require("./u8a/index.js");
parcelHelpers.exportAll(_indexJs12, exports);
var _versionDetectJs = require("./versionDetect.js");
parcelHelpers.exportAll(_versionDetectJs, exports);

},{"./packageInfo.js":"6T6yl","./array/index.js":"gL7B5","./assert.js":"jdCS2","./bi/index.js":"fmYOm","./bn/index.js":"jr1HC","./buffer/index.js":"29TBE","./compact/index.js":"cKdLW","./extractTime.js":"1Zq52","./float/index.js":"aoED9","./format/index.js":"adOCa","./has.js":"kBoWG","./hex/index.js":"foCYc","./is/index.js":"hZ2pz","./lazy.js":"g0R3i","./logger.js":"87mNm","./memoize.js":"fHTyq","./nextTick.js":"cyuHx","./number/index.js":"d2giP","./object/index.js":"iYuNH","./promisify.js":"dvS1W","./string/index.js":"9jYpH","./stringify.js":"4kzVD","./u8a/index.js":"7qmUM","./versionDetect.js":"a4erl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gL7B5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Utility methods that operates on arrays
 */ parcelHelpers.export(exports, "arrayChunk", ()=>(0, _chunkJs.arrayChunk));
parcelHelpers.export(exports, "arrayFilter", ()=>(0, _filterJs.arrayFilter));
parcelHelpers.export(exports, "arrayFlatten", ()=>(0, _flattenJs.arrayFlatten));
parcelHelpers.export(exports, "arrayRange", ()=>(0, _rangeJs.arrayRange));
parcelHelpers.export(exports, "arrayShuffle", ()=>(0, _shuffleJs.arrayShuffle));
parcelHelpers.export(exports, "arrayUnzip", ()=>(0, _unzipJs.arrayUnzip));
parcelHelpers.export(exports, "arrayZip", ()=>(0, _zipJs.arrayZip));
var _chunkJs = require("./chunk.js");
var _filterJs = require("./filter.js");
var _flattenJs = require("./flatten.js");
var _rangeJs = require("./range.js");
var _shuffleJs = require("./shuffle.js");
var _unzipJs = require("./unzip.js");
var _zipJs = require("./zip.js");

},{"./chunk.js":"euHur","./filter.js":"dn4mo","./flatten.js":"vqeg2","./range.js":"ie9Ui","./shuffle.js":"6s41c","./unzip.js":"7CegH","./zip.js":"bT90S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"euHur":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name arrayChunk
 * @summary Split T[] into T[][] based on the defind size
 * @description
 * Returns a set ao arrays based on the chunksize
 * @example
 * <BR>
 *
 * ```javascript
 * import { arrayChunk } from '@polkadot/util';
 *
 * arrayChunk([1, 2, 3, 4, 5]); // [[1, 2], [3, 4], [5]]
 * ```
 */ parcelHelpers.export(exports, "arrayChunk", ()=>arrayChunk);
function arrayChunk(array, chunkSize) {
    const outputSize = Math.ceil(array.length / chunkSize); // noop for the single-split case
    if (outputSize === 1) return [
        array
    ];
    const output = Array(outputSize);
    for(let i = 0; i < outputSize; i++){
        const offset = i * chunkSize;
        output[i] = array.slice(offset, offset + chunkSize);
    }
    return output;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dn4mo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name arrayFilter
 * @summary Filters undefined and (optionally) null values from an array
 * @description
 * Returns a new array with all `undefined` values removed. Optionally, when `allowNulls = false`, it removes the `null` values as well
 * @example
 * <BR>
 *
 * ```javascript
 * import { arrayFilter } from '@polkadot/util';
 *
 * arrayFilter([0, void 0, true, null, false, '']); // [0, true, null, false, '']
 * arrayFilter([0, void 0, true, null, false, ''], false); // [0, true, false, '']
 * ```
 */ parcelHelpers.export(exports, "arrayFilter", ()=>arrayFilter);
function arrayFilter(array, allowNulls = true) {
    return array.filter((v)=>v !== undefined && (allowNulls || v !== null));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"vqeg2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// This is supposed to be a faster concat...
// https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki
/**
 * @name arrayFlatten
 * @summary Merge T[][] into T[]
 * @description
 * Returns a new array with all arrays merged into one
 * @example
 * <BR>
 *
 * ```javascript
 * import { arrayFlatten } from '@polkadot/util';
 *
 * arrayFlatten([[1, 2], [3, 4], [5]]); // [1, 2, 3, 4, 5]
 * ```
 */ parcelHelpers.export(exports, "arrayFlatten", ()=>arrayFlatten);
function arrayFlatten(arrays) {
    // noop for the empty & single-entry case
    if (arrays.length === 0) return [];
    else if (arrays.length === 1) return arrays[0];
     // pre-allocate based on the combined size
    let size = 0;
    for(let i = 0; i < arrays.length; i++)size += arrays[i].length;
    const output = new Array(size);
    let i1 = -1;
    for(let j = 0; j < arrays.length; j++){
        const a = arrays[j]; // instead of pushing, we just set the entries
        for(let e = 0; e < a.length; e++)output[++i1] = a[e];
    }
    return output;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ie9Ui":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name arrayRange
 * @summary Returns a range of numbers ith the size and the specified offset
 * @description
 * Returns a new array of numbers with the specific size. Optionally, when `startAt`, is provided, it generates the range to start at a specific value.
 * @example
 * <BR>
 *
 * ```javascript
 * import { arrayRange } from '@polkadot/util';
 *
 * arrayRange(5); // [0, 1, 2, 3, 4]
 * arrayRange(3, 5); // [5, 6, 7]
 * ```
 */ parcelHelpers.export(exports, "arrayRange", ()=>arrayRange);
function arrayRange(size, startAt = 0) {
    if (size <= 0) throw new Error("Expected non-zero, positive number as a range size");
    const result = new Array(size);
    for(let i = 0; i < size; i++)result[i] = i + startAt;
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6s41c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name arrayShuffle
 * @description Shuffles the input array (unlike sort, this is not done in-place)
 */ parcelHelpers.export(exports, "arrayShuffle", ()=>arrayShuffle);
function arrayShuffle(input) {
    const result = input.slice();
    let curr = result.length; // noop for the single entry
    if (curr === 1) return result;
    while(curr !== 0){
        // ~~ is more performant than Math.floor
        const rand = ~~(Math.random() * curr);
        curr--;
        [result[curr], result[rand]] = [
            result[rand],
            result[curr]
        ];
    }
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CegH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name arrayUnzip
 * @description Splits a single [K, V][] into [K[], V[]]
 */ parcelHelpers.export(exports, "arrayUnzip", ()=>arrayUnzip);
function arrayUnzip(entries) {
    const keys = new Array(entries.length);
    const values = new Array(entries.length);
    for(let i = 0; i < entries.length; i++)[keys[i], values[i]] = entries[i];
    return [
        keys,
        values
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bT90S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name arrayZip
 * @description Combines 2 distinct key/value arrays into a single [K, V] array
 */ parcelHelpers.export(exports, "arrayZip", ()=>arrayZip);
function arrayZip(keys, values) {
    const result = new Array(keys.length);
    for(let i = 0; i < keys.length; i++)result[i] = [
        keys[i],
        values[i]
    ];
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jdCS2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name assert
 * @summary Checks for a valid test, if not Error is thrown.
 * @description
 * Checks that `test` is a truthy value. If value is falsy (`null`, `undefined`, `false`, ...), it throws an Error with the supplied `message`. When `test` passes, `true` is returned.
 * @example
 * <BR>
 *
 * ```javascript
 * const { assert } from '@polkadot/util';
 *
 * assert(true, 'True should be true'); // passes
 * assert(false, 'False should not be true'); // Error thrown
 * assert(false, () => 'message'); // Error with 'message'
 * ```
 */ parcelHelpers.export(exports, "assert", ()=>assert);
/**
 * @name assertReturn
 * @description Returns when the value is not undefined/null, otherwise throws assertion error
 */ parcelHelpers.export(exports, "assertReturn", ()=>assertReturn);
/**
 * @name assertUnreachable
 * @description An assertion helper that ensures all codepaths are followed
 */ parcelHelpers.export(exports, "assertUnreachable", ()=>assertUnreachable);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _functionJs = require("./is/function.js");
function assert(condition, message) {
    if (!condition) throw new Error((0, _functionJs.isFunction)(message) ? message() : message);
}
function assertReturn(value, message) {
    assert(value !== undefined && value !== null, message);
    return value;
}
function assertUnreachable(x) {
    throw new Error(`This codepath should be unreachable. Unhandled input: ${x}`);
}

},{"./is/function.js":"3nYod","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fmYOm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nSqrt", ()=>(0, _sqrtJs.nSqrt));
parcelHelpers.export(exports, "nToBigInt", ()=>(0, _toBigIntJs.nToBigInt));
parcelHelpers.export(exports, "nMax", ()=>(0, _minJs.nMax));
parcelHelpers.export(exports, "nMin", ()=>(0, _minJs.nMin));
parcelHelpers.export(exports, "nToHex", ()=>(0, _toHexJs.nToHex));
parcelHelpers.export(exports, "nToU8a", ()=>(0, _toU8AJs.nToU8a));
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Utility methods to convert to and from `bigint` objects
 */ var _constsJs = require("./consts.js");
parcelHelpers.exportAll(_constsJs, exports);
var _sqrtJs = require("./sqrt.js");
var _toBigIntJs = require("./toBigInt.js");
var _minJs = require("./min.js");
var _toHexJs = require("./toHex.js");
var _toU8AJs = require("./toU8a.js");

},{"./consts.js":"eBuQk","./sqrt.js":"gVCvP","./toBigInt.js":"fPApX","./min.js":"j30dw","./toHex.js":"agA38","./toU8a.js":"h9WLW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eBuQk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_0n", ()=>_0n);
parcelHelpers.export(exports, "_1n", ()=>_1n);
parcelHelpers.export(exports, "_1Mn", ()=>_1Mn);
parcelHelpers.export(exports, "_1Bn", ()=>_1Bn);
parcelHelpers.export(exports, "_1Qn", ()=>_1Qn);
parcelHelpers.export(exports, "_2pow53n", ()=>_2pow53n);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xBigint = require("@polkadot/x-bigint");
const _0n = (0, _xBigint.BigInt)(0);
const _1n = (0, _xBigint.BigInt)(1);
const _1Mn = (0, _xBigint.BigInt)(1000000);
const _1Bn = (0, _xBigint.BigInt)(1000000000);
const _1Qn = _1Bn * _1Bn;
const _2pow53n = (0, _xBigint.BigInt)(Number.MAX_SAFE_INTEGER);

},{"@polkadot/x-bigint":"6Blk3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Blk3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
parcelHelpers.export(exports, "BigInt", ()=>BigInt);
// Copyright 2017-2022 @polkadot/x-bigint authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xGlobal = require("@polkadot/x-global");
var _packageInfoJs = require("./packageInfo.js");
const BigInt = typeof (0, _xGlobal.xglobal).BigInt === "function" && typeof (0, _xGlobal.xglobal).BigInt.asIntN === "function" ? (0, _xGlobal.xglobal).BigInt : ()=>Number.NaN;

},{"@polkadot/x-global":"k9Iwp","./packageInfo.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gVCvP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SQRT_MAX_SAFE_INTEGER", ()=>SQRT_MAX_SAFE_INTEGER);
/**
 * @name nSqrt
 * @summary Calculates the integer square root of a bigint
 */ parcelHelpers.export(exports, "nSqrt", ()=>nSqrt);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xBigint = require("@polkadot/x-bigint");
var _constsJs = require("./consts.js");
var _toBigIntJs = require("./toBigInt.js");
const SQRT_MAX_SAFE_INTEGER = (0, _xBigint.BigInt)(94906265);
function nSqrt(value) {
    const n = (0, _toBigIntJs.nToBigInt)(value);
    if (n < (0, _constsJs._0n)) throw new Error("square root of negative numbers is not supported");
     // https://stackoverflow.com/questions/53683995/javascript-big-integer-square-root/
    // shortcut <= 2^53 - 1 to use the JS utils
    if (n <= (0, _constsJs._2pow53n)) // ~~ is more performant that Math.floor
    return (0, _xBigint.BigInt)(~~Math.sqrt(Number(n)));
     // Use sqrt(MAX_SAFE_INTEGER) as starting point. since we already know the
    // output will be larger than this, we expect this to be a safe start
    let x0 = SQRT_MAX_SAFE_INTEGER;
    while(true){
        const x1 = n / x0 + x0 >> (0, _constsJs._1n);
        if (x0 === x1 || x0 === x1 - (0, _constsJs._1n)) return x0;
        x0 = x1;
    }
}

},{"@polkadot/x-bigint":"6Blk3","./consts.js":"eBuQk","./toBigInt.js":"fPApX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fPApX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name nToBigInt
 * @summary Creates a bigInt value from a BN, bigint, string (base 10 or hex) or number input.
 */ parcelHelpers.export(exports, "nToBigInt", ()=>nToBigInt);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xBigint = require("@polkadot/x-bigint");
var _toBigIntJs = require("../hex/toBigInt.js");
var _bnJs = require("../is/bn.js");
var _hexJs = require("../is/hex.js");
var _toBigIntJs1 = require("../is/toBigInt.js");
var _toBnJs = require("../is/toBn.js");
function nToBigInt(value) {
    return typeof value === "bigint" ? value : !value ? (0, _xBigint.BigInt)(0) : (0, _hexJs.isHex)(value) ? (0, _toBigIntJs.hexToBigInt)(value.toString()) : (0, _bnJs.isBn)(value) ? (0, _xBigint.BigInt)(value.toString()) : (0, _toBigIntJs1.isToBigInt)(value) ? value.toBigInt() : (0, _toBnJs.isToBn)(value) ? (0, _xBigint.BigInt)(value.toBn().toString()) : (0, _xBigint.BigInt)(value);
}

},{"@polkadot/x-bigint":"6Blk3","../hex/toBigInt.js":"auyXM","../is/bn.js":"l418N","../is/hex.js":"1XrXF","../is/toBigInt.js":"7gXiE","../is/toBn.js":"klE8p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"auyXM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name hexToBigInt
 * @summary Creates a BigInt instance object from a hex string.
 */ parcelHelpers.export(exports, "hexToBigInt", ()=>hexToBigInt);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xBigint = require("@polkadot/x-bigint");
var _toBigIntJs = require("../u8a/toBigInt.js");
var _toU8AJs = require("./toU8a.js");
function hexToBigInt(value, { isLe =false , isNegative =false  } = {}) {
    return !value || value === "0x" ? (0, _xBigint.BigInt)(0) : (0, _toBigIntJs.u8aToBigInt)((0, _toU8AJs.hexToU8a)(value), {
        isLe,
        isNegative
    });
}

},{"@polkadot/x-bigint":"6Blk3","../u8a/toBigInt.js":"3aq9l","./toU8a.js":"g5dk6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3aq9l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u8aToBigInt
 * @summary Creates a BigInt from a Uint8Array object.
 */ parcelHelpers.export(exports, "u8aToBigInt", ()=>u8aToBigInt);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xBigint = require("@polkadot/x-bigint");
var _constsJs = require("../bi/consts.js");
const U8_MAX = (0, _xBigint.BigInt)(256);
const U16_MAX = (0, _xBigint.BigInt)(65536);
function u8aToBigInt(value, { isLe =true , isNegative =false  } = {}) {
    if (!value || !value.length) return (0, _xBigint.BigInt)(0);
    const u8a = isLe ? value : value.reverse();
    const dvI = new DataView(u8a.buffer, u8a.byteOffset);
    const mod = u8a.length % 2;
    let result = (0, _xBigint.BigInt)(0); // This is mostly written for readability (with the single isNegative shortcut),
    // as opposed to performance, e.g. `u8aToBn` does loop unrolling, etc.
    if (isNegative) {
        for(let i = u8a.length - 2; i >= mod; i -= 2)result = result * U16_MAX + (0, _xBigint.BigInt)(dvI.getUint16(i, true) ^ 0xffff);
        if (mod) result = result * U8_MAX + (0, _xBigint.BigInt)(dvI.getUint8(0) ^ 0xff);
    } else {
        for(let i1 = u8a.length - 2; i1 >= mod; i1 -= 2)result = result * U16_MAX + (0, _xBigint.BigInt)(dvI.getUint16(i1, true));
        if (mod) result = result * U8_MAX + (0, _xBigint.BigInt)(dvI.getUint8(0));
    }
    return isNegative ? result * -(0, _constsJs._1n) - (0, _constsJs._1n) : result;
}

},{"@polkadot/x-bigint":"6Blk3","../bi/consts.js":"eBuQk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g5dk6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name hexToU8a
 * @summary Creates a Uint8Array object from a hex string.
 * @description
 * `null` inputs returns an empty `Uint8Array` result. Hex input values return the actual bytes value converted to a Uint8Array. Anything that is not a hex string (including the `0x` prefix) throws an error.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexToU8a } from '@polkadot/util';
 *
 * hexToU8a('0x80001f'); // Uint8Array([0x80, 0x00, 0x1f])
 * hexToU8a('0x80001f', 32); // Uint8Array([0x00, 0x80, 0x00, 0x1f])
 * ```
 */ parcelHelpers.export(exports, "hexToU8a", ()=>hexToU8a);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
const CHR = "0123456789abcdef";
const U8 = new Array(256);
const U16 = new Array(65536);
for(let i = 0; i < CHR.length; i++){
    U8[CHR[i].charCodeAt(0) | 0] = i | 0;
    if (i > 9) U8[CHR[i].toUpperCase().charCodeAt(0) | 0] = i | 0;
}
for(let i1 = 0; i1 < 256; i1++){
    const s = i1 << 8;
    for(let j = 0; j < 256; j++)U16[s | j] = U8[i1] << 4 | U8[j];
}
function hexToU8a(value, bitLength = -1) {
    if (!value) return new Uint8Array();
    let s = value.startsWith("0x") ? 2 : 0;
    const decLength = Math.ceil((value.length - s) / 2);
    const endLength = Math.ceil(bitLength === -1 ? decLength : bitLength / 8);
    const result = new Uint8Array(endLength);
    const offset = endLength > decLength ? endLength - decLength : 0;
    for(let i = offset; i < endLength; i++, s += 2)// The big factor here is actually the string lookups. If we do
    // HEX_TO_U16[value.substring()] we get an 10x slowdown. In the
    // same vein using charCodeAt (as opposed to value[s] or value.charAt(s)) is
    // also the faster operation by at least 2x with the character map above
    result[i] = U16[value.charCodeAt(s) << 8 | value.charCodeAt(s + 1)];
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l418N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name isBn
 * @summary Tests for a `BN` object instance.
 * @description
 * Checks to see if the input object is an instance of `BN` (bn.js).
 * @example
 * <BR>
 *
 * ```javascript
 * import BN from 'bn.js';
 * import { isBn } from '@polkadot/util';
 *
 * console.log('isBn', isBn(new BN(1))); // => true
 * ```
 */ parcelHelpers.export(exports, "isBn", ()=>isBn);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bnJs = require("../bn/bn.js");
function isBn(value) {
    return (0, _bnJs.BN).isBN(value);
}

},{"../bn/bn.js":"6mwqp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6mwqp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BN", ()=>(0, _bnJsDefault.default));
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bnJs = require("bn.js");
var _bnJsDefault = parcelHelpers.interopDefault(_bnJs);

},{"bn.js":"VopIn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"VopIn":[function(require,module,exports) {
(function(module1, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module1 === "object") module1.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") Buffer = window.Buffer;
        else Buffer = require("buffer").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) this._parseHex(number, start, endian);
            else {
                this._parseBase(number, base, start);
                if (endian === "le") this._initArray(this.toArray(), base, endian);
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this._strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // '0' - '9'
        if (c >= 48 && c <= 57) return c - 48;
        else if (c >= 65 && c <= 70) return c - 55;
        else if (c >= 97 && c <= 102) return c - 87;
        else assert(false, "Invalid character in " + string);
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) r |= parseHex4Bits(string, index - 1) << 4;
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else off += 8;
        }
        else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else off += 8;
            }
        }
        this._strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) b = c - 49 + 0xa;
            else if (c >= 17) b = c - 17 + 0xa;
            else b = c;
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        this._strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
        move(dest, this);
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype._strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    // Check Symbol.for because not everywhere where Symbol defined
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
    } catch (e1) {
        BN.prototype.inspect = inspect;
    }
    else BN.prototype.inspect = inspect;
    function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modrn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
    };
    if (Buffer) BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe) return ArrayType.allocUnsafe(size);
        return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position++] = word & 0xff;
            if (position < res.length) res[position++] = word >> 8 & 0xff;
            if (position < res.length) res[position++] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position < res.length) res[position++] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position < res.length) {
            res[position++] = carry;
            while(position < res.length)res[position++] = 0;
        }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position--] = word & 0xff;
            if (position >= 0) res[position--] = word >> 8 & 0xff;
            if (position >= 0) res[position--] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position >= 0) res[position--] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position >= 0) {
            res[position--] = carry;
            while(position >= 0)res[position--] = 0;
        }
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 0x01;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this._strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this._strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this._strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this._strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this._strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out._strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out._strip();
    }
    function jumboMulTo(self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this._strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this._strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this._strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q._strip();
        a._strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return isNegNum ? -acc : acc;
    };
    // WARNING: DEPRECATED
    BN.prototype.modn = function modn(num) {
        return this.modrn(num);
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else if (r.strip !== undefined) // r is a BN v4 instance
        r.strip();
        else // r is a BN v5 instance
        r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"buffer":"jhUEF"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"1XrXF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "REGEX_HEX_PREFIXED", ()=>REGEX_HEX_PREFIXED);
parcelHelpers.export(exports, "REGEX_HEX_NOPREFIX", ()=>REGEX_HEX_NOPREFIX);
/**
 * @name isHex
 * @summary Tests for a hex string.
 * @description
 * Checks to see if the input value is a `0x` prefixed hex string. Optionally (`bitLength` !== -1) checks to see if the bitLength is correct.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isHex } from '@polkadot/util';
 *
 * isHex('0x1234'); // => true
 * isHex('0x1234', 8); // => false
 * ```
 */ parcelHelpers.export(exports, "isHex", ()=>isHex);
const REGEX_HEX_PREFIXED = /^0x[\da-fA-F]+$/;
const REGEX_HEX_NOPREFIX = /^[\da-fA-F]+$/;
function isHex(value, bitLength = -1, ignoreLength) {
    return typeof value === "string" && (value === "0x" || REGEX_HEX_PREFIXED.test(value)) && (bitLength === -1 ? ignoreLength || value.length % 2 === 0 : value.length === 2 + Math.ceil(bitLength / 4));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7gXiE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isToBigInt", ()=>isToBigInt);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _helpersJs = require("./helpers.js");
const isToBigInt = (0, _helpersJs.isOn)("toBigInt");

},{"./helpers.js":"h9gvY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h9gvY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isOn", ()=>isOn);
parcelHelpers.export(exports, "isOnObject", ()=>isOnObject);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _functionJs = require("./function.js");
var _objectJs = require("./object.js");
function isOn(...fns) {
    return (value)=>((0, _objectJs.isObject)(value) || (0, _functionJs.isFunction)(value)) && fns.every((f)=>(0, _functionJs.isFunction)(value[f]));
}
function isOnObject(...fns) {
    return (value)=>(0, _objectJs.isObject)(value) && fns.every((f)=>(0, _functionJs.isFunction)(value[f]));
}

},{"./function.js":"3nYod","./object.js":"cSHr5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cSHr5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isObject
 * @summary Tests for an `object`.
 * @description
 * Checks to see if the input value is a JavaScript object.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isObject } from '@polkadot/util';
 *
 * isObject({}); // => true
 * isObject('something'); // => false
 * ```
 */ parcelHelpers.export(exports, "isObject", ()=>isObject);
function isObject(value) {
    return !!value && typeof value === "object";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klE8p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isToBn", ()=>isToBn);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _helpersJs = require("./helpers.js");
const isToBn = (0, _helpersJs.isOn)("toBn");

},{"./helpers.js":"h9gvY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j30dw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nMax", ()=>nMax);
parcelHelpers.export(exports, "nMin", ()=>nMin);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _helpersJs = require("./helpers.js");
const nMax = (0, _helpersJs.createCmp)((a, b)=>a > b);
const nMin = (0, _helpersJs.createCmp)((a, b)=>a < b);

},{"./helpers.js":"9tnDJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9tnDJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/** @internal */ parcelHelpers.export(exports, "createCmp", ()=>createCmp);
function createCmp(cmp) {
    return (...items)=>{
        if (items.length === 0) throw new Error("Must provide one or more arguments");
        let result = items[0];
        for(let i = 1; i < items.length; i++)if (cmp(items[i], result)) result = items[i];
        return result;
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"agA38":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name nToHex
 * @summary Creates a hex value from a bigint object.
 */ parcelHelpers.export(exports, "nToHex", ()=>nToHex);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../u8a/index.js");
var _toU8AJs = require("./toU8a.js");
/** @internal */ const ZERO_STR = "0x00";
function nToHex(value, { bitLength , isLe =false , isNegative =false  } = {}) {
    return !value ? ZERO_STR : (0, _indexJs.u8aToHex)((0, _toU8AJs.nToU8a)(value, {
        bitLength,
        isLe,
        isNegative
    }));
}

},{"../u8a/index.js":"7qmUM","./toU8a.js":"h9WLW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7qmUM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Utility methods to convert to and from `Uint8Array` objects
 */ parcelHelpers.export(exports, "u8aCmp", ()=>(0, _cmpJs.u8aCmp));
parcelHelpers.export(exports, "u8aConcat", ()=>(0, _concatJs.u8aConcat));
parcelHelpers.export(exports, "u8aConcatStrict", ()=>(0, _concatJs.u8aConcatStrict));
parcelHelpers.export(exports, "u8aEmpty", ()=>(0, _emptyJs.u8aEmpty));
parcelHelpers.export(exports, "u8aEq", ()=>(0, _eqJs.u8aEq));
parcelHelpers.export(exports, "u8aFixLength", ()=>(0, _fixLengthJs.u8aFixLength));
parcelHelpers.export(exports, "u8aToFloat", ()=>(0, _toFloatJs.u8aToFloat));
parcelHelpers.export(exports, "u8aSorted", ()=>(0, _sortedJs.u8aSorted));
parcelHelpers.export(exports, "u8aToBigInt", ()=>(0, _toBigIntJs.u8aToBigInt));
parcelHelpers.export(exports, "u8aToBn", ()=>(0, _toBnJs.u8aToBn));
parcelHelpers.export(exports, "u8aToBuffer", ()=>(0, _toBufferJs.u8aToBuffer));
parcelHelpers.export(exports, "u8aToHex", ()=>(0, _toHexJs.u8aToHex));
parcelHelpers.export(exports, "u8aToNumber", ()=>(0, _toNumberJs.u8aToNumber));
parcelHelpers.export(exports, "u8aToString", ()=>(0, _toStringJs.u8aToString));
parcelHelpers.export(exports, "u8aToU8a", ()=>(0, _toU8AJs.u8aToU8a));
parcelHelpers.export(exports, "U8A_WRAP_ETHEREUM", ()=>(0, _wrapJs.U8A_WRAP_ETHEREUM));
parcelHelpers.export(exports, "U8A_WRAP_POSTFIX", ()=>(0, _wrapJs.U8A_WRAP_POSTFIX));
parcelHelpers.export(exports, "U8A_WRAP_PREFIX", ()=>(0, _wrapJs.U8A_WRAP_PREFIX));
parcelHelpers.export(exports, "u8aIsWrapped", ()=>(0, _wrapJs.u8aIsWrapped));
parcelHelpers.export(exports, "u8aWrapBytes", ()=>(0, _wrapJs.u8aWrapBytes));
parcelHelpers.export(exports, "u8aUnwrapBytes", ()=>(0, _wrapJs.u8aUnwrapBytes));
var _cmpJs = require("./cmp.js");
var _concatJs = require("./concat.js");
var _emptyJs = require("./empty.js");
var _eqJs = require("./eq.js");
var _fixLengthJs = require("./fixLength.js");
var _toFloatJs = require("./toFloat.js");
var _sortedJs = require("./sorted.js");
var _toBigIntJs = require("./toBigInt.js");
var _toBnJs = require("./toBn.js");
var _toBufferJs = require("./toBuffer.js");
var _toHexJs = require("./toHex.js");
var _toNumberJs = require("./toNumber.js");
var _toStringJs = require("./toString.js");
var _toU8AJs = require("./toU8a.js");
var _wrapJs = require("./wrap.js");

},{"./cmp.js":"9q5cr","./concat.js":"430bo","./empty.js":"d6sue","./eq.js":"j350s","./fixLength.js":"3zvFK","./toFloat.js":"d4AQW","./sorted.js":"aLp4Q","./toBigInt.js":"3aq9l","./toBn.js":"epnYc","./toBuffer.js":"fTCa6","./toHex.js":"cBjBN","./toNumber.js":"1nno4","./toString.js":"159cK","./toU8a.js":"2vZLl","./wrap.js":"7mde7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9q5cr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u8aCmp
 * @summary Compares two Uint8Arrays for sorting.
 * @description
 * For `UInt8Array` (or hex string) input values returning -1, 0 or +1
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aCmp } from '@polkadot/util';
 *
 * u8aCmp(new Uint8Array([0x67, 0x65]), new Uint8Array([0x68, 0x65])); // -1
 * u8aCmp(new Uint8Array([0x68, 0x65]), new Uint8Array([0x68, 0x65])); // 0
 * u8aCmp(new Uint8Array([0x69, 0x65]), new Uint8Array([0x68, 0x65])); // +1
 * ```
 */ parcelHelpers.export(exports, "u8aCmp", ()=>u8aCmp);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toU8AJs = require("./toU8a.js");
function u8aCmp(a, b) {
    const u8aa = (0, _toU8AJs.u8aToU8a)(a);
    const u8ab = (0, _toU8AJs.u8aToU8a)(b);
    let i = 0;
    while(true){
        const overA = i >= u8aa.length;
        const overB = i >= u8ab.length;
        if (overA && overB) // both ends reached
        return 0;
        else if (overA) // a has no more data, b has data
        return -1;
        else if (overB) // b has no more data, a has data
        return 1;
        else if (u8aa[i] !== u8ab[i]) // the number in this index doesn't match
        // (we don't use u8aa[i] - u8ab[i] since that doesn't match with localeCompare)
        return u8aa[i] > u8ab[i] ? 1 : -1;
        i++;
    }
}

},{"./toU8a.js":"2vZLl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2vZLl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u8aToU8a
 * @summary Creates a Uint8Array value from a Uint8Array, Buffer, string or hex input.
 * @description
 * `null` or `undefined` inputs returns a `[]` result, Uint8Array values returns the value, hex strings returns a Uint8Array representation.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToU8a } from '@polkadot/util';
 *
 * u8aToU8a(new Uint8Array([0x12, 0x34]); // => Uint8Array([0x12, 0x34])
 * u8aToU8a(0x1234); // => Uint8Array([0x12, 0x34])
 * ```
 */ parcelHelpers.export(exports, "u8aToU8a", ()=>u8aToU8a);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toU8AJs = require("../hex/toU8a.js");
var _bufferJs = require("../is/buffer.js");
var _hexJs = require("../is/hex.js");
var _u8AJs = require("../is/u8a.js");
var _toU8AJs1 = require("../string/toU8a.js");
function u8aToU8a(value) {
    return (0, _u8AJs.isU8a)(value) ? value : (0, _hexJs.isHex)(value) ? (0, _toU8AJs.hexToU8a)(value) : (0, _bufferJs.isBuffer)(value) || Array.isArray(value) ? new Uint8Array(value) : (0, _toU8AJs1.stringToU8a)(value);
}

},{"../hex/toU8a.js":"g5dk6","../is/buffer.js":"dQj1x","../is/hex.js":"1XrXF","../is/u8a.js":"a3N6N","../string/toU8a.js":"eeJou","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dQj1x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name isBuffer
 * @summary Tests for a `Buffer` object instance.
 * @description
 * Checks to see if the input object is an instance of `Buffer`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isBuffer } from '@polkadot/util';
 *
 * console.log('isBuffer', isBuffer(Buffer.from([]))); // => true
 * ```
 */ parcelHelpers.export(exports, "isBuffer", ()=>isBuffer);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _hasJs = require("../has.js");
var _functionJs = require("./function.js");
var Buffer = require("buffer").Buffer;
function isBuffer(value) {
    // we do check a function first, since it is slightly faster than isBuffer itself
    return (0, _hasJs.hasBuffer) && (0, _functionJs.isFunction)(value && value.readDoubleLE) && Buffer.isBuffer(value);
}

},{"../has.js":"kBoWG","./function.js":"3nYod","buffer":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kBoWG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasBigInt", ()=>hasBigInt);
parcelHelpers.export(exports, "hasBuffer", ()=>hasBuffer);
parcelHelpers.export(exports, "hasCjs", ()=>hasCjs);
parcelHelpers.export(exports, "hasDirname", ()=>hasDirname);
parcelHelpers.export(exports, "hasEsm", ()=>hasEsm);
parcelHelpers.export(exports, "hasProcess", ()=>hasProcess);
parcelHelpers.export(exports, "hasWasm", ()=>hasWasm);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xBigint = require("@polkadot/x-bigint"); // Since we run in very different environments, we have to ensure we have all
var Buffer = require("buffer").Buffer;
var process = require("process");
var __dirname = "node_modules/@polkadot/util";
const hasBigInt = typeof (0, _xBigint.BigInt) === "function" && typeof (0, _xBigint.BigInt).asIntN === "function";
const hasBuffer = typeof Buffer !== "undefined";
const hasCjs = true;
const hasDirname = typeof __dirname !== "undefined";
const hasEsm = !hasCjs;
const hasProcess = typeof process === "object";
const hasWasm = typeof WebAssembly !== "undefined";

},{"@polkadot/x-bigint":"6Blk3","buffer":"fCgem","process":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("base64-js");
const ieee754 = require("ieee754");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"base64-js":"eIiSV","ieee754":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e1) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e1) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"a3N6N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isU8a
 * @summary Tests for a `Uint8Array` object instance.
 * @description
 * Checks to see if the input object is an instance of `Uint8Array`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isUint8Array } from '@polkadot/util';
 *
 * console.log('isU8a', isU8a([])); // => false
 * ```
 */ parcelHelpers.export(exports, "isU8a", ()=>isU8a);
function isU8a(value) {
    // here we defer the instanceof check which is actually slightly
    // slower than just checking the constrctor (direct instances)
    return (value && value.constructor) === Uint8Array || value instanceof Uint8Array;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eeJou":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name stringToU8a
 * @summary Creates a Uint8Array object from a utf-8 string.
 * @description
 * String input values return the actual encoded `UInt8Array`. `null` or `undefined` values returns an empty encoded array.
 * @example
 * <BR>
 *
 * ```javascript
 * import { stringToU8a } from '@polkadot/util';
 *
 * stringToU8a('hello'); // [0x68, 0x65, 0x6c, 0x6c, 0x6f]
 * ```
 */ parcelHelpers.export(exports, "stringToU8a", ()=>stringToU8a);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xTextencoder = require("@polkadot/x-textencoder");
const encoder = new (0, _xTextencoder.TextEncoder)();
function stringToU8a(value) {
    return value ? encoder.encode(value.toString()) : new Uint8Array();
}

},{"@polkadot/x-textencoder":"1eRz6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"430bo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u8aConcat
 * @summary Creates a concatenated Uint8Array from the inputs.
 * @description
 * Concatenates the input arrays into a single `UInt8Array`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { { u8aConcat } from '@polkadot/util';
 *
 * u8aConcat(
 *   new Uint8Array([1, 2, 3]),
 *   new Uint8Array([4, 5, 6])
 * ); // [1, 2, 3, 4, 5, 6]
 * ```
 */ parcelHelpers.export(exports, "u8aConcat", ()=>u8aConcat);
/**
 * @name u8aConcatStrict
 * @description A strict version of [[u8aConcat]], accepting only Uint8Array inputs
 */ parcelHelpers.export(exports, "u8aConcatStrict", ()=>u8aConcatStrict);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toU8AJs = require("./toU8a.js");
function u8aConcat(...list) {
    const u8as = new Array(list.length);
    let length = 0;
    for(let i = 0; i < list.length; i++){
        u8as[i] = (0, _toU8AJs.u8aToU8a)(list[i]);
        length += u8as[i].length;
    }
    return u8aConcatStrict(u8as, length);
}
function u8aConcatStrict(u8as, length = 0) {
    let offset = 0;
    if (!length) for(let i = 0; i < u8as.length; i++)length += u8as[i].length;
    const result = new Uint8Array(length);
    for(let i1 = 0; i1 < u8as.length; i1++){
        result.set(u8as[i1], offset);
        offset += u8as[i1].length;
    }
    return result;
}

},{"./toU8a.js":"2vZLl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d6sue":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name u8aEmpty
 * @summary Tests for a `Uint8Array` for emptyness
 * @description
 * Checks to see if the input `Uint8Array` has zero length or contains all 0 values.
 */ parcelHelpers.export(exports, "u8aEmpty", ()=>u8aEmpty);
function u8aEmpty(value) {
    const len = value.length | 0; // on smaller sizes, the byte-by-byte compare is faster than allocating
    // another object for DataView (on very large arrays the DataView is faster)
    for(let i = 0; i < len; i++){
        if (value[i] | 0) return false;
    }
    return true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j350s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u8aEq
 * @summary Compares two Uint8Arrays for equality.
 * @description
 * For `UInt8Array` (or hex string) input values true if there is a match.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aEq } from '@polkadot/util';
 *
 * u8aEq(new Uint8Array([0x68, 0x65]), new Uint8Array([0x68, 0x65])); // true
 * ```
 */ parcelHelpers.export(exports, "u8aEq", ()=>u8aEq);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toU8AJs = require("./toU8a.js");
function u8aEq(a, b) {
    const u8aa = (0, _toU8AJs.u8aToU8a)(a);
    const u8ab = (0, _toU8AJs.u8aToU8a)(b);
    if (u8aa.length === u8ab.length) {
        const dvA = new DataView(u8aa.buffer, u8aa.byteOffset);
        const dvB = new DataView(u8ab.buffer, u8ab.byteOffset);
        const mod = u8aa.length % 4 | 0;
        const length = u8aa.length - mod | 0;
        for(let i = 0; i < length; i += 4){
            if (dvA.getUint32(i) !== dvB.getUint32(i)) return false;
        }
        for(let i1 = length; i1 < u8aa.length; i1++){
            if (u8aa[i1] !== u8ab[i1]) return false;
        }
        return true;
    }
    return false;
}

},{"./toU8a.js":"2vZLl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3zvFK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name u8aFixLength
 * @summary Shifts a Uint8Array to a specific bitLength
 * @description
 * Returns a uint8Array with the specified number of bits contained in the return value. (If bitLength is -1, length checking is not done). Values with more bits are trimmed to the specified length.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aFixLength } from '@polkadot/util';
 *
 * u8aFixLength('0x12') // => 0x12
 * u8aFixLength('0x12', 16) // => 0x0012
 * u8aFixLength('0x1234', 8) // => 0x12
 * ```
 */ parcelHelpers.export(exports, "u8aFixLength", ()=>u8aFixLength);
function u8aFixLength(value, bitLength = -1, atStart = false) {
    const byteLength = Math.ceil(bitLength / 8);
    if (bitLength === -1 || value.length === byteLength) return value;
    else if (value.length > byteLength) return value.subarray(0, byteLength);
    const result = new Uint8Array(byteLength);
    result.set(value, atStart ? 0 : byteLength - value.length);
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d4AQW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name u8aToFloat
 * @description Converts a Uint8Array value into the float (either 32 or 64-bit)
 * representation.
 */ parcelHelpers.export(exports, "u8aToFloat", ()=>u8aToFloat);
function u8aToFloat(value, { bitLength =32 , isLe =true  } = {}) {
    if (bitLength !== 32 && bitLength !== 64) throw new Error("Invalid bitLength provided, expected 32 or 64");
    else if (value.length < bitLength / 8) throw new Error(`Invalid input buffer provided, expected at least ${bitLength / 8} bytes, found ${value.length}`);
    const dv = new DataView(value.buffer, value.byteOffset);
    return bitLength === 32 ? dv.getFloat32(0, isLe) : dv.getFloat64(0, isLe);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aLp4Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u8aSorted
 * @summary Sorts an array of Uint8Arrays
 * @description
 * For input `UInt8Array[]` return the sorted result
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aSorted} from '@polkadot/util';
 *
 * u8aSorted([new Uint8Array([0x69]), new Uint8Array([0x68])]); // [0x68, 0x69]
 * ```
 */ parcelHelpers.export(exports, "u8aSorted", ()=>u8aSorted);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _cmpJs = require("./cmp.js");
function u8aSorted(u8as) {
    return u8as.sort((0, _cmpJs.u8aCmp));
}

},{"./cmp.js":"9q5cr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"epnYc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u8aToBn
 * @summary Creates a BN from a Uint8Array object.
 * @description
 * `UInt8Array` input values return the actual BN. `null` or `undefined` values returns an `0x0` value.
 * @param value The value to convert
 * @param options Options to pass while converting
 * @param options.isLe Convert using Little Endian (default)
 * @param options.isNegative Convert using two's complement
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToBn } from '@polkadot/util';
 *
 * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f
 * ```
 */ parcelHelpers.export(exports, "u8aToBn", ()=>u8aToBn);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bnJs = require("../bn/bn.js");
function u8aToBn(value, { isLe =true , isNegative =false  } = {}) {
    const count = value.length; // shortcut for <= u48 values - in this case the manual conversion
    // here seems to be more efficient than passing the full array
    if (count <= 6) {
        if (isNegative) {
            let result = 0;
            if (isLe) // Most common case i{8, 16, 32} default LE SCALE-encoded
            // For <= 32, we also optimize the xor to a single op
            // (see the comments around unrolling in the next section)
            switch(count){
                case 0:
                    return new (0, _bnJs.BN)(0);
                case 1:
                    result = value[0] ^ 0x000000ff;
                    break;
                case 2:
                    result = value[0] + (value[1] << 8) ^ 0x0000ffff;
                    break;
                case 3:
                    result = value[0] + (value[1] << 8) + (value[2] << 16) ^ 0x00ffffff;
                    break;
                case 4:
                    // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
                    // 32-bit, in the case where the top-most bit is set this yields a negative value
                    result = value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000 ^ 0xffffffff;
                    break;
                case 5:
                    result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000 ^ 0xffffffff) + (value[4] ^ 0xff) * 0x100000000;
                    break;
                default:
                    // 6
                    result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000 ^ 0xffffffff) + (value[4] + (value[5] << 8) ^ 0x0000ffff) * 0x100000000;
                    break;
            }
            else for(let i = 0; i < count; i++)result = result * 0x100 + (value[i] ^ 0xff);
            return count ? new (0, _bnJs.BN)(result * -1 - 1) : new (0, _bnJs.BN)(0);
        } else if (isLe) // Most common case - u{8, 16, 32} default LE SCALE-encoded
        //
        // There are some slight benefits in unrolling this specific loop,
        // however it comes with diminishing returns since here the actual
        // `new BN` does seem to take up the bulk of the time
        switch(count){
            case 0:
                return new (0, _bnJs.BN)(0);
            case 1:
                return new (0, _bnJs.BN)(value[0]);
            case 2:
                return new (0, _bnJs.BN)(value[0] + (value[1] << 8));
            case 3:
                return new (0, _bnJs.BN)(value[0] + (value[1] << 8) + (value[2] << 16));
            case 4:
                // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
                // 32-bit, in the case where the top-most bit is set this yields a negative value
                return new (0, _bnJs.BN)(value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000);
            case 5:
                return new (0, _bnJs.BN)(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 0x1000000);
            default:
                // 6
                return new (0, _bnJs.BN)(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 0x1000000);
        }
        else {
            let result1 = 0;
            for(let i1 = 0; i1 < count; i1++)result1 = result1 * 0x100 + value[i1];
            return new (0, _bnJs.BN)(result1);
        }
    }
    return isNegative ? new (0, _bnJs.BN)(value, isLe ? "le" : "be").fromTwos(value.length * 8) : new (0, _bnJs.BN)(value, isLe ? "le" : "be");
}

},{"../bn/bn.js":"6mwqp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fTCa6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name u8aToBuffer
 * @summary Creates a Buffer object from a hex string.
 * @description
 * `null` inputs returns an empty `Buffer` result. `UInt8Array` input values return the actual bytes value converted to a `Buffer`. Anything that is not a `UInt8Array` throws an error.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToBuffer } from '@polkadot/util';
 *
 * console.log('Buffer', u8aToBuffer('0x123480001f'));
 * ```
 */ parcelHelpers.export(exports, "u8aToBuffer", ()=>u8aToBuffer);
var Buffer = require("buffer").Buffer;
function u8aToBuffer(value) {
    return Buffer.from(value || []);
}

},{"buffer":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cBjBN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u8aToHex
 * @summary Creates a hex string from a Uint8Array object.
 * @description
 * `UInt8Array` input values return the actual hex string. `null` or `undefined` values returns an `0x` string.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToHex } from '@polkadot/util';
 *
 * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f
 * ```
 */ parcelHelpers.export(exports, "u8aToHex", ()=>u8aToHex);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
const U8 = new Array(256);
const U16 = new Array(65536);
for(let n = 0; n < 256; n++)U8[n] = n.toString(16).padStart(2, "0");
for(let i = 0; i < 256; i++){
    const s = i << 8;
    for(let j = 0; j < 256; j++)U16[s | j] = U8[i] + U8[j];
}
/** @internal */ function hex(value, result) {
    const mod = value.length % 2 | 0;
    const length = value.length - mod | 0;
    for(let i = 0; i < length; i += 2)result += U16[value[i] << 8 | value[i + 1]];
    if (mod) result += U8[value[length] | 0];
    return result;
}
function u8aToHex(value, bitLength = -1, isPrefixed = true) {
    // this is not 100% correct sinmce we support isPrefixed = false....
    const empty = isPrefixed ? "0x" : "";
    if (!value || !value.length) return empty;
    else if (bitLength > 0) {
        const length = Math.ceil(bitLength / 8);
        if (value.length > length) return `${hex(value.subarray(0, length / 2), empty)}‚Ä¶${hex(value.subarray(value.length - length / 2), "")}`;
    }
    return hex(value, empty);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1nno4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name u8aToNumber
 * @summary Creates a number from a Uint8Array object.
 */ parcelHelpers.export(exports, "u8aToNumber", ()=>u8aToNumber);
function u8aToNumber(value, { isNegative =false  } = {}) {
    const count = value.length;
    if (isNegative) {
        let result = 0;
        switch(count){
            case 0:
                return 0;
            case 1:
                result = value[0] ^ 0x000000ff;
                break;
            case 2:
                result = value[0] + (value[1] << 8) ^ 0x0000ffff;
                break;
            case 3:
                result = value[0] + (value[1] << 8) + (value[2] << 16) ^ 0x00ffffff;
                break;
            case 4:
                // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
                // 32-bit, in the case where the top-most bit is set this yields a negative value
                result = value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000 ^ 0xffffffff;
                break;
            case 5:
                result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000 ^ 0xffffffff) + (value[4] ^ 0xff) * 0x100000000;
                break;
            case 6:
                result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000 ^ 0xffffffff) + (value[4] + (value[5] << 8) ^ 0x0000ffff) * 0x100000000;
                break;
            default:
                throw new Error("Value more than 48-bits cannot be reliably converted");
        }
        return result * -1 - 1;
    }
    switch(count){
        case 0:
            return 0;
        case 1:
            return value[0];
        case 2:
            return value[0] + (value[1] << 8);
        case 3:
            return value[0] + (value[1] << 8) + (value[2] << 16);
        case 4:
            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
            // 32-bit, in the case where the top-most bit is set this yields a negative value
            return value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000;
        case 5:
            return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 0x1000000;
        case 6:
            return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 0x1000000;
        default:
            throw new Error("Value more than 48-bits cannot be reliably converted");
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"159cK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u8aToString
 * @summary Creates a utf-8 string from a Uint8Array object.
 * @description
 * `UInt8Array` input values return the actual decoded utf-8 string. `null` or `undefined` values returns an empty string.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToString } from '@polkadot/util';
 *
 * u8aToString(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // hello
 * ```
 */ parcelHelpers.export(exports, "u8aToString", ()=>u8aToString);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xTextdecoder = require("@polkadot/x-textdecoder");
const decoder = new (0, _xTextdecoder.TextDecoder)("utf-8");
function u8aToString(value) {
    return value ? decoder.decode(value) : "";
}

},{"@polkadot/x-textdecoder":"fM3XH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7mde7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "U8A_WRAP_ETHEREUM", ()=>U8A_WRAP_ETHEREUM);
parcelHelpers.export(exports, "U8A_WRAP_PREFIX", ()=>U8A_WRAP_PREFIX);
parcelHelpers.export(exports, "U8A_WRAP_POSTFIX", ()=>U8A_WRAP_POSTFIX);
/** @internal */ parcelHelpers.export(exports, "u8aIsWrapped", ()=>u8aIsWrapped);
/**
 * @name u8aUnwrapBytes
 * @description Removes all <Bytes>...</Bytes> wrappers from the supplied value
 */ parcelHelpers.export(exports, "u8aUnwrapBytes", ()=>u8aUnwrapBytes);
/**
 * @name u8aWrapBytes
 * @description Adds a <Bytes>...</Bytes> wrapper to the supplied value (if not already existing)
 */ parcelHelpers.export(exports, "u8aWrapBytes", ()=>u8aWrapBytes);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Originally from https://github.com/polkadot-js/extension/pull/743
var _concatJs = require("./concat.js");
var _eqJs = require("./eq.js");
var _toU8AJs = require("./toU8a.js");
const U8A_WRAP_ETHEREUM = (0, _toU8AJs.u8aToU8a)("\x19Ethereum Signed Message:\n");
const U8A_WRAP_PREFIX = (0, _toU8AJs.u8aToU8a)("<Bytes>");
const U8A_WRAP_POSTFIX = (0, _toU8AJs.u8aToU8a)("</Bytes>");
const WRAP_LEN = U8A_WRAP_PREFIX.length + U8A_WRAP_POSTFIX.length;
function u8aIsWrapped(u8a, withEthereum) {
    return u8a.length >= WRAP_LEN && (0, _eqJs.u8aEq)(u8a.subarray(0, U8A_WRAP_PREFIX.length), U8A_WRAP_PREFIX) && (0, _eqJs.u8aEq)(u8a.slice(-U8A_WRAP_POSTFIX.length), U8A_WRAP_POSTFIX) || withEthereum && u8a.length >= U8A_WRAP_ETHEREUM.length && (0, _eqJs.u8aEq)(u8a.subarray(0, U8A_WRAP_ETHEREUM.length), U8A_WRAP_ETHEREUM);
}
function u8aUnwrapBytes(bytes) {
    const u8a = (0, _toU8AJs.u8aToU8a)(bytes); // we don't want to unwrap Ethereum-style wraps
    return u8aIsWrapped(u8a, false) ? u8a.subarray(U8A_WRAP_PREFIX.length, u8a.length - U8A_WRAP_POSTFIX.length) : u8a;
}
function u8aWrapBytes(bytes) {
    const u8a = (0, _toU8AJs.u8aToU8a)(bytes); // if Ethereum-wrapping, we don't add our wrapping bytes
    return u8aIsWrapped(u8a, true) ? u8a : (0, _concatJs.u8aConcatStrict)([
        U8A_WRAP_PREFIX,
        u8a,
        U8A_WRAP_POSTFIX
    ]);
}

},{"./concat.js":"430bo","./eq.js":"j350s","./toU8a.js":"2vZLl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h9WLW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name nToU8a
 * @summary Creates a Uint8Array object from a bigint.
 */ parcelHelpers.export(exports, "nToU8a", ()=>nToU8a);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xBigint = require("@polkadot/x-bigint");
var _constsJs = require("./consts.js");
var _toBigIntJs = require("./toBigInt.js");
const DIV = (0, _xBigint.BigInt)(256);
const NEG_MASK = (0, _xBigint.BigInt)(0xff);
function toU8a(value, isLe, isNegative) {
    const arr = [];
    if (isNegative) value = (value + (0, _constsJs._1n)) * -(0, _constsJs._1n);
    while(value !== (0, _constsJs._0n)){
        const mod = value % DIV;
        const val = Number(isNegative ? mod ^ NEG_MASK : mod);
        if (isLe) arr.push(val);
        else arr.unshift(val);
        value = (value - mod) / DIV;
    }
    return Uint8Array.from(arr);
}
function nToU8a(value, { bitLength =-1 , isLe =true , isNegative =false  } = {}) {
    const valueBi = (0, _toBigIntJs.nToBigInt)(value);
    if (valueBi === (0, _constsJs._0n)) return bitLength === -1 ? new Uint8Array() : new Uint8Array(Math.ceil((bitLength || 0) / 8));
    const u8a = toU8a(valueBi, isLe, isNegative);
    if (bitLength === -1) return u8a;
    const byteLength = Math.ceil((bitLength || 0) / 8);
    const output = new Uint8Array(byteLength);
    if (isNegative) output.fill(0xff);
    output.set(u8a, isLe ? 0 : byteLength - u8a.length);
    return output;
}

},{"@polkadot/x-bigint":"6Blk3","./consts.js":"eBuQk","./toBigInt.js":"fPApX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jr1HC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BN", ()=>(0, _bnJs.BN));
parcelHelpers.export(exports, "bnFromHex", ()=>(0, _fromHexJs.bnFromHex));
parcelHelpers.export(exports, "bnMax", ()=>(0, _minJs.bnMax));
parcelHelpers.export(exports, "bnMin", ()=>(0, _minJs.bnMin));
parcelHelpers.export(exports, "bnSqrt", ()=>(0, _sqrtJs.bnSqrt));
parcelHelpers.export(exports, "bnToBn", ()=>(0, _toBnJs.bnToBn));
parcelHelpers.export(exports, "bnToHex", ()=>(0, _toHexJs.bnToHex));
parcelHelpers.export(exports, "bnToU8a", ()=>(0, _toU8AJs.bnToU8a));
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Utility methods to convert to and from `BN` objects
 */ var _constsJs = require("./consts.js");
parcelHelpers.exportAll(_constsJs, exports);
var _bnJs = require("./bn.js");
var _fromHexJs = require("./fromHex.js");
var _minJs = require("./min.js");
var _sqrtJs = require("./sqrt.js");
var _toBnJs = require("./toBn.js");
var _toHexJs = require("./toHex.js");
var _toU8AJs = require("./toU8a.js");

},{"./consts.js":"iWb8H","./bn.js":"6mwqp","./fromHex.js":"jROxF","./min.js":"1iFkW","./sqrt.js":"bQguI","./toBn.js":"iM6St","./toHex.js":"kjx2g","./toU8a.js":"gK1IE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iWb8H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BN_ZERO", ()=>BN_ZERO);
parcelHelpers.export(exports, "BN_ONE", ()=>BN_ONE);
parcelHelpers.export(exports, "BN_TWO", ()=>BN_TWO);
parcelHelpers.export(exports, "BN_THREE", ()=>BN_THREE);
parcelHelpers.export(exports, "BN_FOUR", ()=>BN_FOUR);
parcelHelpers.export(exports, "BN_FIVE", ()=>BN_FIVE);
parcelHelpers.export(exports, "BN_SIX", ()=>BN_SIX);
parcelHelpers.export(exports, "BN_SEVEN", ()=>BN_SEVEN);
parcelHelpers.export(exports, "BN_EIGHT", ()=>BN_EIGHT);
parcelHelpers.export(exports, "BN_NINE", ()=>BN_NINE);
parcelHelpers.export(exports, "BN_TEN", ()=>BN_TEN);
parcelHelpers.export(exports, "BN_HUNDRED", ()=>BN_HUNDRED);
parcelHelpers.export(exports, "BN_THOUSAND", ()=>BN_THOUSAND);
parcelHelpers.export(exports, "BN_MILLION", ()=>BN_MILLION);
parcelHelpers.export(exports, "BN_BILLION", ()=>BN_BILLION);
parcelHelpers.export(exports, "BN_QUINTILL", ()=>BN_QUINTILL);
parcelHelpers.export(exports, "BN_MAX_INTEGER", ()=>BN_MAX_INTEGER);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bnJs = require("./bn.js");
const BN_ZERO = new (0, _bnJs.BN)(0);
const BN_ONE = new (0, _bnJs.BN)(1);
const BN_TWO = new (0, _bnJs.BN)(2);
const BN_THREE = new (0, _bnJs.BN)(3);
const BN_FOUR = new (0, _bnJs.BN)(4);
const BN_FIVE = new (0, _bnJs.BN)(5);
const BN_SIX = new (0, _bnJs.BN)(6);
const BN_SEVEN = new (0, _bnJs.BN)(7);
const BN_EIGHT = new (0, _bnJs.BN)(8);
const BN_NINE = new (0, _bnJs.BN)(9);
const BN_TEN = new (0, _bnJs.BN)(10);
const BN_HUNDRED = new (0, _bnJs.BN)(100);
const BN_THOUSAND = new (0, _bnJs.BN)(1000);
const BN_MILLION = new (0, _bnJs.BN)(1000000);
const BN_BILLION = new (0, _bnJs.BN)(1000000000);
const BN_QUINTILL = BN_BILLION.mul(BN_BILLION);
const BN_MAX_INTEGER = new (0, _bnJs.BN)(Number.MAX_SAFE_INTEGER);

},{"./bn.js":"6mwqp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jROxF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "bnFromHex", ()=>(0, _toBnJs.hexToBn));
var _toBnJs = require("../hex/toBn.js");

},{"../hex/toBn.js":"dITJ7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dITJ7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name hexToBn
 * @summary Creates a BN.js object from a hex string.
 * @description
 * `null` inputs returns a `BN(0)` result. Hex input values return the actual value converted to a BN. Anything that is not a hex string (including the `0x` prefix) throws an error.
 * @param _value The value to convert
 * @param _options Options to pass while converting
 * @param _options.isLe Convert using Little Endian
 * @param _options.isNegative Convert using two's complement
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexToBn } from '@polkadot/util';
 *
 * hexToBn('0x123480001f'); // => BN(0x123480001f)
 * ```
 */ parcelHelpers.export(exports, "hexToBn", ()=>hexToBn);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bnJs = require("../bn/bn.js");
var _stripPrefixJs = require("./stripPrefix.js");
function hexToBn(value, { isLe =false , isNegative =false  } = {}) {
    if (!value || value === "0x") return new (0, _bnJs.BN)(0);
    const stripped = (0, _stripPrefixJs.hexStripPrefix)(value);
    const bn = new (0, _bnJs.BN)(stripped, 16, isLe ? "le" : "be"); // fromTwos takes as parameter the number of bits, which is the hex length
    // multiplied by 4 (2 bytes being 8 bits)
    return isNegative ? bn.fromTwos(stripped.length * 4) : bn;
}

},{"../bn/bn.js":"6mwqp","./stripPrefix.js":"5qaue","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5qaue":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name hexStripPrefix
 * @summary Strips any leading `0x` prefix.
 * @description
 * Tests for the existence of a `0x` prefix, and returns the value without the prefix. Un-prefixed values are returned as-is.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexStripPrefix } from '@polkadot/util';
 *
 * console.log('stripped', hexStripPrefix('0x1234')); // => 1234
 * ```
 */ parcelHelpers.export(exports, "hexStripPrefix", ()=>hexStripPrefix);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _hexJs = require("../is/hex.js");
function hexStripPrefix(value) {
    if (!value || value === "0x") return "";
    else if ((0, _hexJs.REGEX_HEX_PREFIXED).test(value)) return value.substring(2);
    else if ((0, _hexJs.REGEX_HEX_NOPREFIX).test(value)) return value;
    throw new Error(`Expected hex value to convert, found '${value}'`);
}

},{"../is/hex.js":"1XrXF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1iFkW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bnMax", ()=>bnMax);
parcelHelpers.export(exports, "bnMin", ()=>bnMin);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _helpersJs = require("../bi/helpers.js");
const bnMax = (0, _helpersJs.createCmp)((a, b)=>a.gt(b));
const bnMin = (0, _helpersJs.createCmp)((a, b)=>a.lt(b));

},{"../bi/helpers.js":"9tnDJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bQguI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SQRT_MAX_SAFE_INTEGER", ()=>SQRT_MAX_SAFE_INTEGER);
/**
 * @name bnSqrt
 * @summary Calculates the integer square root of a BN
 * @example
 * <BR>
 *
 * ```javascript
 * import BN from 'bn.js';
 * import { bnSqrt } from '@polkadot/util';
 *
 * bnSqrt(new BN(16)).toString(); // => '4'
 * ```
 */ parcelHelpers.export(exports, "bnSqrt", ()=>bnSqrt);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bnJs = require("./bn.js");
var _constsJs = require("./consts.js");
var _toBnJs = require("./toBn.js");
const SQRT_MAX_SAFE_INTEGER = new (0, _bnJs.BN)(94906265);
function bnSqrt(value) {
    const n = (0, _toBnJs.bnToBn)(value);
    if (n.isNeg()) throw new Error("square root of negative numbers is not supported");
     // https://stackoverflow.com/questions/53683995/javascript-big-integer-square-root/
    // shortcut <= 2^53 - 1 to use the JS utils
    if (n.lte((0, _constsJs.BN_MAX_INTEGER))) // ~~ More performant version of Math.floor
    return new (0, _bnJs.BN)(~~Math.sqrt(n.toNumber()));
     // Use sqrt(MAX_SAFE_INTEGER) as starting point. since we already know the
    // output will be larger than this, we expect this to be a safe start
    let x0 = SQRT_MAX_SAFE_INTEGER.clone();
    while(true){
        const x1 = n.div(x0).iadd(x0).ishrn(1);
        if (x0.eq(x1) || x0.eq(x1.sub((0, _constsJs.BN_ONE)))) return x0;
        x0 = x1;
    }
}

},{"./bn.js":"6mwqp","./consts.js":"iWb8H","./toBn.js":"iM6St","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iM6St":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name bnToBn
 * @summary Creates a BN value from a BN, bigint, string (base 10 or hex) or number input.
 * @description
 * `null` inputs returns a `0x0` result, BN values returns the value, numbers returns a BN representation.
 * @example
 * <BR>
 *
 * ```javascript
 * import BN from 'bn.js';
 * import { bnToBn } from '@polkadot/util';
 *
 * bnToBn(0x1234); // => BN(0x1234)
 * bnToBn(new BN(0x1234)); // => BN(0x1234)
 * ```
 */ parcelHelpers.export(exports, "bnToBn", ()=>bnToBn);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toBnJs = require("../hex/toBn.js");
var _bigIntJs = require("../is/bigInt.js");
var _hexJs = require("../is/hex.js");
var _toBigIntJs = require("../is/toBigInt.js");
var _toBnJs1 = require("../is/toBn.js");
var _bnJs = require("./bn.js");
function bnToBn(value) {
    return value ? (0, _bnJs.BN).isBN(value) ? value : (0, _hexJs.isHex)(value) ? (0, _toBnJs.hexToBn)(value.toString()) : (0, _bigIntJs.isBigInt)(value) ? new (0, _bnJs.BN)(value.toString()) : (0, _toBnJs1.isToBn)(value) ? value.toBn() : (0, _toBigIntJs.isToBigInt)(value) ? new (0, _bnJs.BN)(value.toBigInt().toString()) : new (0, _bnJs.BN)(value) : new (0, _bnJs.BN)(0);
}

},{"../hex/toBn.js":"dITJ7","../is/bigInt.js":"aHtst","../is/hex.js":"1XrXF","../is/toBigInt.js":"7gXiE","../is/toBn.js":"klE8p","./bn.js":"6mwqp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aHtst":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isBigInt
 * @summary Tests for a `BigInt` object instance.
 * @description
 * Checks to see if the input object is an instance of `BigInt`
 * @example
 * <BR>
 *
 * ```javascript
 * import { isBigInt } from '@polkadot/util';
 *
 * console.log('isBigInt', isBigInt(123_456n)); // => true
 * ```
 */ parcelHelpers.export(exports, "isBigInt", ()=>isBigInt);
function isBigInt(value) {
    return typeof value === "bigint";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kjx2g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name bnToHex
 * @summary Creates a hex value from a BN.js bignumber object.
 * @description
 * `null` inputs returns a `0x` result, BN values return the actual value as a `0x` prefixed hex value. Anything that is not a BN object throws an error. With `bitLength` set, it fixes the number to the specified length.
 * @example
 * <BR>
 *
 * ```javascript
 * import BN from 'bn.js';
 * import { bnToHex } from '@polkadot/util';
 *
 * bnToHex(new BN(0x123456)); // => '0x123456'
 * ```
 */ parcelHelpers.export(exports, "bnToHex", ()=>bnToHex);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../u8a/index.js");
var _toU8AJs = require("./toU8a.js");
const ZERO_STR = "0x00";
function bnToHex(value, { bitLength =-1 , isLe =false , isNegative =false  } = {}) {
    return !value ? ZERO_STR : (0, _indexJs.u8aToHex)((0, _toU8AJs.bnToU8a)(value, {
        bitLength,
        isLe,
        isNegative
    }));
}

},{"../u8a/index.js":"7qmUM","./toU8a.js":"gK1IE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gK1IE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name bnToU8a
 * @summary Creates a Uint8Array object from a BN.
 * @description
 * `null`/`undefined`/`NaN` inputs returns an empty `Uint8Array` result. `BN` input values return the actual bytes value converted to a `Uint8Array`. Optionally convert using little-endian format if `isLE` is set.
 * @example
 * <BR>
 *
 * ```javascript
 * import { bnToU8a } from '@polkadot/util';
 *
 * bnToU8a(new BN(0x1234)); // => [0x12, 0x34]
 * ```
 */ parcelHelpers.export(exports, "bnToU8a", ()=>bnToU8a);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toBnJs = require("./toBn.js");
const DEFAULT_OPTS = {
    bitLength: -1,
    isLe: true,
    isNegative: false
};
function bnToU8a(value, { bitLength =-1 , isLe =true , isNegative =false  } = DEFAULT_OPTS) {
    const valueBn = (0, _toBnJs.bnToBn)(value);
    const byteLength = bitLength === -1 ? Math.ceil(valueBn.bitLength() / 8) : Math.ceil((bitLength || 0) / 8);
    if (!value) return bitLength === -1 ? new Uint8Array() : new Uint8Array(byteLength);
    const output = new Uint8Array(byteLength);
    const bn = isNegative ? valueBn.toTwos(byteLength * 8) : valueBn;
    output.set(bn.toArray(isLe ? "le" : "be", byteLength), 0);
    return output;
}

},{"./toBn.js":"iM6St","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"29TBE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Utility methods to convert to and from `Buffer` objects
 */ parcelHelpers.export(exports, "bufferToU8a", ()=>(0, _toU8AJs.bufferToU8a));
var _toU8AJs = require("./toU8a.js");

},{"./toU8a.js":"cpS47","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cpS47":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name bufferToU8a
 * @summary Creates a Uint8Array value from a Buffer object.
 * @description
 * `null` inputs returns an empty result, `Buffer` values return the actual value as a `Uint8Array`. Anything that is not a `Buffer` object throws an error.
 * @example
 * <BR>
 *
 * ```javascript
 * import { bufferToU8a } from '@polkadot/util';
 *
 * bufferToU8a(Buffer.from([1, 2, 3]));
 * ```
 */ parcelHelpers.export(exports, "bufferToU8a", ()=>bufferToU8a);
function bufferToU8a(buffer) {
    return new Uint8Array(buffer || []);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cKdLW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @description
 * Encoding and decoding of parity-codec compact numbers. The codec is created
 * to take up the least amount of space for a specific number. It performs the
 * same function as Length, however differs in that it uses a variable number of
 * bytes to do the actual encoding. From the Rust implementation for compact
 * encoding:
 *
 *     0b00 00 00 00 / 00 00 00 00 / 00 00 00 00 / 00 00 00 00
 * (0 ... 2**6 - 1)    (u8)
 *     xx xx xx 00
 * (2**6 ... 2**14 - 1)  (u8, u16)  low LH high
 *     yL yL yL 01 / yH yH yH yL
 * (2**14 ... 2**30 - 1)  (u16, u32)  low LMMH high
 *     zL zL zL 10 / zM zM zM zL / zM zM zM zM / zH zH zH zM
 * (2**30 ... 2**536 - 1)  (u32, u64, u128, U256, U512, U520) straight LE-encoded
 *     nn nn nn 11 [ / zz zz zz zz ]{4 + n}
 *
 * Note: we use *LOW BITS* of the LSB in LE encoding to encode the 2 bit key.
 */ parcelHelpers.export(exports, "compactAddLength", ()=>(0, _addLengthJs.compactAddLength));
parcelHelpers.export(exports, "compactStripLength", ()=>(0, _stripLengthJs.compactStripLength));
parcelHelpers.export(exports, "compactFromU8a", ()=>(0, _fromU8AJs.compactFromU8a));
parcelHelpers.export(exports, "compactFromU8aLim", ()=>(0, _fromU8AJs.compactFromU8aLim));
parcelHelpers.export(exports, "compactToU8a", ()=>(0, _toU8AJs.compactToU8a));
var _addLengthJs = require("./addLength.js");
var _stripLengthJs = require("./stripLength.js");
var _fromU8AJs = require("./fromU8a.js");
var _toU8AJs = require("./toU8a.js");

},{"./addLength.js":"jN9DW","./stripLength.js":"kdb6H","./fromU8a.js":"faYLI","./toU8a.js":"1bv7B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jN9DW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name compactAddLength
 * @description Adds a length prefix to the input value
 * @example
 * <BR>
 *
 * ```javascript
 * import { compactAddLength } from '@polkadot/util';
 *
 * console.log(compactAddLength(new Uint8Array([0xde, 0xad, 0xbe, 0xef]))); // Uint8Array([4 << 2, 0xde, 0xad, 0xbe, 0xef])
 * ```
 */ parcelHelpers.export(exports, "compactAddLength", ()=>compactAddLength);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../u8a/index.js");
var _toU8AJs = require("./toU8a.js");
function compactAddLength(input) {
    return (0, _indexJs.u8aConcatStrict)([
        (0, _toU8AJs.compactToU8a)(input.length),
        input
    ]);
}

},{"../u8a/index.js":"7qmUM","./toU8a.js":"1bv7B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1bv7B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name compactToU8a
 * @description Encodes a number into a compact representation
 * @example
 * <BR>
 *
 * ```javascript
 * import { compactToU8a } from '@polkadot/util';
 *
 * console.log(compactToU8a(511, 32)); // Uint8Array([0b11111101, 0b00000111])
 * ```
 */ parcelHelpers.export(exports, "compactToU8a", ()=>compactToU8a);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../bn/index.js");
var _indexJs1 = require("../u8a/index.js");
const MAX_U8 = (0, _indexJs.BN_TWO).pow(new (0, _indexJs.BN)(6)).isub((0, _indexJs.BN_ONE));
const MAX_U16 = (0, _indexJs.BN_TWO).pow(new (0, _indexJs.BN)(14)).isub((0, _indexJs.BN_ONE));
const MAX_U32 = (0, _indexJs.BN_TWO).pow(new (0, _indexJs.BN)(30)).isub((0, _indexJs.BN_ONE));
const BL_16 = {
    bitLength: 16
};
const BL_32 = {
    bitLength: 32
};
function compactToU8a(value) {
    const bn = (0, _indexJs.bnToBn)(value);
    if (bn.lte(MAX_U8)) return new Uint8Array([
        bn.toNumber() << 2
    ]);
    else if (bn.lte(MAX_U16)) return (0, _indexJs.bnToU8a)(bn.shln(2).iadd((0, _indexJs.BN_ONE)), BL_16);
    else if (bn.lte(MAX_U32)) return (0, _indexJs.bnToU8a)(bn.shln(2).iadd((0, _indexJs.BN_TWO)), BL_32);
    const u8a = (0, _indexJs.bnToU8a)(bn);
    let length = u8a.length; // adjust to the minimum number of bytes
    while(u8a[length - 1] === 0)length--;
    if (length < 4) throw new Error("Invalid length, previous checks match anything less than 2^30");
    return (0, _indexJs1.u8aConcatStrict)([
        new Uint8Array([
            (length - 4 << 2) + 3
        ]),
        u8a.subarray(0, length)
    ]);
}

},{"../bn/index.js":"jr1HC","../u8a/index.js":"7qmUM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kdb6H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name compactStripLength
 * @description Removes the length prefix, returning both the total length (including the value + compact encoding) and the decoded value with the correct length
 * @example
 * <BR>
 *
 * ```javascript
 * import { compactStripLength } from '@polkadot/util';
 *
 * console.log(compactStripLength(new Uint8Array([2 << 2, 0xde, 0xad]))); // [2, Uint8Array[0xde, 0xad]]
 * ```
 */ parcelHelpers.export(exports, "compactStripLength", ()=>compactStripLength);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _fromU8AJs = require("./fromU8a.js");
function compactStripLength(input) {
    const [offset, length] = (0, _fromU8AJs.compactFromU8a)(input);
    const total = offset + length.toNumber();
    return [
        total,
        input.subarray(offset, total)
    ];
}

},{"./fromU8a.js":"faYLI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"faYLI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name compactFromU8a
 * @description Retrives the offset and encoded length from a compact-prefixed value
 * @example
 * <BR>
 *
 * ```javascript
 * import { compactFromU8a } from '@polkadot/util';
 *
 * const [offset, length] = compactFromU8a(new Uint8Array([254, 255, 3, 0]));
 *
 * console.log('value offset=', offset, 'length=', length); // 4, 0xffff
 * ```
 */ parcelHelpers.export(exports, "compactFromU8a", ()=>compactFromU8a);
/**
 * @name compactFromU8aLim
 * @description A limited version of [[compactFromU8a]], accepting only Uint8Array inputs for values <= 48 bits
 */ parcelHelpers.export(exports, "compactFromU8aLim", ()=>compactFromU8aLim);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../bn/index.js");
var _indexJs1 = require("../u8a/index.js");
function compactFromU8a(input) {
    const u8a = (0, _indexJs1.u8aToU8a)(input); // The u8a is manually converted here for 1, 2 & 4 lengths, it is 2x faster
    // than doing an additional call to u8aToBn (as with variable length)
    switch(u8a[0] & 3){
        case 0:
            return [
                1,
                new (0, _indexJs.BN)(u8a[0] >>> 2)
            ];
        case 1:
            return [
                2,
                new (0, _indexJs.BN)(u8a[0] + (u8a[1] << 8) >>> 2)
            ];
        case 2:
            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
            // 32-bit, in the case where the top-most bit is set this yields a negative value
            return [
                4,
                new (0, _indexJs.BN)(u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + u8a[3] * 0x1000000 >>> 2)
            ];
        // 0b11
        default:
            {
                // add 5 to shifted (4 for base length, 1 for this byte)
                const offset = (u8a[0] >>> 2) + 5; // we unroll the loop
                switch(offset){
                    // there still could be 4 bytes data, similar to 0b10 above (with offsets)
                    case 5:
                        // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
                        // 32-bit, in the case where the top-most bit is set this yields a negative value
                        return [
                            5,
                            new (0, _indexJs.BN)(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + u8a[4] * 0x1000000)
                        ];
                    case 6:
                        return [
                            6,
                            new (0, _indexJs.BN)(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8)) * 0x1000000)
                        ];
                    // 6 bytes data is the maximum, 48 bits (56 would overflow)
                    case 7:
                        return [
                            7,
                            new (0, _indexJs.BN)(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 0x1000000)
                        ];
                    // for anything else, use the non-unrolled version
                    default:
                        return [
                            offset,
                            (0, _indexJs1.u8aToBn)(u8a.subarray(1, offset))
                        ];
                }
            }
    }
}
function compactFromU8aLim(u8a) {
    // The u8a is manually converted here for 1, 2 & 4 lengths, it is 2x faster
    // than doing an additional call to u8aToBn (as with variable length)
    switch(u8a[0] & 3){
        case 0:
            return [
                1,
                u8a[0] >>> 2
            ];
        case 1:
            return [
                2,
                u8a[0] + (u8a[1] << 8) >>> 2
            ];
        case 2:
            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
            // 32-bit, in the case where the top-most bit is set this yields a negative value
            return [
                4,
                u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + u8a[3] * 0x1000000 >>> 2
            ];
        // 0b11
        default:
            // add 5 to shifted (4 for base length, 1 for this byte)
            // we unroll the loop
            switch((u8a[0] >>> 2) + 5){
                // there still could be 4 bytes data, similar to 0b10 above (with offsets)
                case 5:
                    return [
                        5,
                        u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + u8a[4] * 0x1000000
                    ];
                case 6:
                    return [
                        6,
                        u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8)) * 0x1000000
                    ];
                // 6 bytes data is the maximum, 48 bits (56 would overflow)
                case 7:
                    return [
                        7,
                        u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 0x1000000
                    ];
                // for anything else, we are above the actual MAX_SAFE_INTEGER - bail out
                default:
                    throw new Error("Compact input is > Number.MAX_SAFE_INTEGER");
            }
    }
}

},{"../bn/index.js":"jr1HC","../u8a/index.js":"7qmUM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Zq52":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name extractTime
 * @summary Convert a quantity of seconds to Time array representing accumulated {days, minutes, hours, seconds, milliseconds}
 * @example
 * <BR>
 *
 * ```javascript
 * import { extractTime } from '@polkadot/util';
 *
 * const { days, minutes, hours, seconds, milliseconds } = extractTime(6000); // 0, 0, 10, 0, 0
 * ```
 */ parcelHelpers.export(exports, "extractTime", ()=>extractTime);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
const MIN_MS = 60000;
const HR_MS = MIN_MS * 60;
const DAY_MS = HR_MS * 24;
const ZERO = {
    days: 0,
    hours: 0,
    milliseconds: 0,
    minutes: 0,
    seconds: 0
};
/** @internal */ function add(a, b) {
    return {
        days: (a.days || 0) + b.days,
        hours: (a.hours || 0) + b.hours,
        milliseconds: (a.milliseconds || 0) + b.milliseconds,
        minutes: (a.minutes || 0) + b.minutes,
        seconds: (a.seconds || 0) + b.seconds
    };
}
/** @internal */ function extractSecs(ms) {
    const s = ms / 1000;
    if (s < 60) {
        const seconds = ~~s;
        return add({
            seconds
        }, extractTime(ms - seconds * 1000));
    }
    const m = s / 60;
    if (m < 60) {
        const minutes = ~~m;
        return add({
            minutes
        }, extractTime(ms - minutes * MIN_MS));
    }
    const h = m / 60;
    if (h < 24) {
        const hours = ~~h;
        return add({
            hours
        }, extractTime(ms - hours * HR_MS));
    }
    const days = ~~(h / 24);
    return add({
        days
    }, extractTime(ms - days * DAY_MS));
}
function extractTime(milliseconds) {
    return !milliseconds ? ZERO : milliseconds < 1000 ? add({
        milliseconds
    }, ZERO) : extractSecs(milliseconds);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aoED9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "floatToU8a", ()=>(0, _toU8AJs.floatToU8a));
var _toU8AJs = require("./toU8a.js");

},{"./toU8a.js":"dtKba","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dtKba":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * @name floatToU8a
 * @description Converts a float into a U8a representation (While we don't use BE in SCALE
 * we still allow for either representation, although, as elsewhere, isLe is default)
 */ parcelHelpers.export(exports, "floatToU8a", ()=>floatToU8a);
function floatToU8a(value = 0.0, { bitLength =32 , isLe =true  } = {}) {
    if (bitLength !== 32 && bitLength !== 64) throw new Error("Invalid bitLength provided, expected 32 or 64");
    const result = new Uint8Array(bitLength / 8);
    const dv = new DataView(result.buffer, result.byteOffset);
    if (bitLength === 32) dv.setFloat32(0, Number(value), isLe);
    else dv.setFloat64(0, Number(value), isLe);
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"adOCa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "formatBalance", ()=>(0, _formatBalanceJs.formatBalance));
parcelHelpers.export(exports, "formatDate", ()=>(0, _formatDateJs.formatDate));
parcelHelpers.export(exports, "formatDecimal", ()=>(0, _formatDecimalJs.formatDecimal));
parcelHelpers.export(exports, "formatElapsed", ()=>(0, _formatElapsedJs.formatElapsed));
parcelHelpers.export(exports, "formatNumber", ()=>(0, _formatNumberJs.formatNumber));
parcelHelpers.export(exports, "calcSi", ()=>(0, _siJs.calcSi));
parcelHelpers.export(exports, "findSi", ()=>(0, _siJs.findSi));
var _formatBalanceJs = require("./formatBalance.js");
var _formatDateJs = require("./formatDate.js");
var _formatDecimalJs = require("./formatDecimal.js");
var _formatElapsedJs = require("./formatElapsed.js");
var _formatNumberJs = require("./formatNumber.js");
var _siJs = require("./si.js");

},{"./formatBalance.js":"4l0T7","./formatDate.js":"i5C3S","./formatDecimal.js":"g7sur","./formatElapsed.js":"evUux","./formatNumber.js":"62e9Y","./si.js":"6OhNs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4l0T7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatBalance", ()=>formatBalance);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toBnJs = require("../bn/toBn.js");
var _booleanJs = require("../is/boolean.js");
var _formatDecimalJs = require("./formatDecimal.js");
var _siJs = require("./si.js");
const DEFAULT_DECIMALS = 0;
const DEFAULT_UNIT = (0, _siJs.SI)[0, _siJs.SI_MID].text;
let defaultDecimals = DEFAULT_DECIMALS;
let defaultUnit = DEFAULT_UNIT;
function getUnits(si, withSi, withSiFull, withUnit) {
    const unit = (0, _booleanJs.isBoolean)(withUnit) ? (0, _siJs.SI)[0, _siJs.SI_MID].text : withUnit;
    return withSi || withSiFull ? si.value === "-" ? withUnit ? ` ${unit}` : "" : ` ${withSiFull ? `${si.text}${withUnit ? " " : ""}` : si.value}${withUnit ? unit : ""}` : "";
}
function getPrePost(text, decimals, forceUnit) {
    // NOTE We start at midpoint (8) minus 1 - this means that values display as
    // 123.456 instead of 0.123k (so always 6 relevant). Additionally we use ceil
    // so there are at most 3 decimal before the decimal separator
    const si = (0, _siJs.calcSi)(text, decimals, forceUnit);
    const mid = text.length - (decimals + si.power);
    const prefix = text.substring(0, mid);
    const padding = mid < 0 ? 0 - mid : 0;
    const postfix = `${`${new Array(padding + 1).join("0")}${text}`.substring(mid < 0 ? 0 : mid)}0000`.substring(0, 4);
    return [
        si,
        prefix || "0",
        postfix
    ];
} // Formats a string/number with <prefix>.<postfix><type> notation
function _formatBalance(input, { decimals =defaultDecimals , forceUnit , withSi =true , withSiFull =false , withUnit =true  } = {}) {
    let text = (0, _toBnJs.bnToBn)(input).toString();
    if (text.length === 0 || text === "0") return "0";
     // strip the negative sign so we can work with clean groupings, re-add this in the
    // end when we return the result (from here on we work with positive numbers)
    let sign = "";
    if (text[0].startsWith("-")) {
        sign = "-";
        text = text.substring(1);
    }
    const [si, prefix, postfix] = getPrePost(text, decimals, forceUnit);
    const units = getUnits(si, withSi, withSiFull, withUnit);
    return `${sign}${(0, _formatDecimalJs.formatDecimal)(prefix)}.${postfix}${units}`;
}
const formatBalance = _formatBalance; // eslint-disable-next-line @typescript-eslint/unbound-method
formatBalance.calcSi = (text, decimals = defaultDecimals)=>(0, _siJs.calcSi)(text, decimals); // eslint-disable-next-line @typescript-eslint/unbound-method
formatBalance.findSi = (0, _siJs.findSi); // eslint-disable-next-line @typescript-eslint/unbound-method
formatBalance.getDefaults = ()=>{
    return {
        decimals: defaultDecimals,
        unit: defaultUnit
    };
}; // get allowable options to display in a dropdown
// eslint-disable-next-line @typescript-eslint/unbound-method
formatBalance.getOptions = (decimals = defaultDecimals)=>{
    return (0, _siJs.SI).filter(({ power  })=>power < 0 ? decimals + power >= 0 : true);
}; // Sets the default decimals to use for formatting (ui-wide)
// eslint-disable-next-line @typescript-eslint/unbound-method
formatBalance.setDefaults = ({ decimals , unit  })=>{
    defaultDecimals = decimals === undefined ? defaultDecimals : Array.isArray(decimals) ? decimals[0] : decimals;
    defaultUnit = unit === undefined ? defaultUnit : Array.isArray(unit) ? unit[0] : unit;
    (0, _siJs.SI)[0, _siJs.SI_MID].text = defaultUnit;
};

},{"../bn/toBn.js":"iM6St","../is/boolean.js":"g4Bcm","./formatDecimal.js":"g7sur","./si.js":"6OhNs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g4Bcm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isBoolean
 * @summary Tests for a boolean value.
 * @description
 * Checks to see if the input value is a JavaScript boolean.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isBoolean } from '@polkadot/util';
 *
 * isBoolean(false); // => true
 * ```
 */ parcelHelpers.export(exports, "isBoolean", ()=>isBoolean);
function isBoolean(value) {
    return typeof value === "boolean";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g7sur":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name formatDecimal
 * @description Formats a number into string format with thousand seperators
 */ parcelHelpers.export(exports, "formatDecimal", ()=>formatDecimal);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// eslint-disable-next-line prefer-regex-literals
const NUMBER_REGEX = new RegExp("(\\d+?)(?=(\\d{3})+(?!\\d)|$)", "g");
function formatDecimal(value) {
    // We can do this by adjusting the regx, however for the sake of clarity
    // we rather strip and re-add the negative sign in the output
    const isNegative = value[0].startsWith("-");
    const matched = isNegative ? value.substring(1).match(NUMBER_REGEX) : value.match(NUMBER_REGEX);
    return matched ? `${isNegative ? "-" : ""}${matched.join(",")}` : value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6OhNs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SI_MID", ()=>SI_MID);
parcelHelpers.export(exports, "SI", ()=>SI);
/** @internal */ parcelHelpers.export(exports, "findSi", ()=>findSi);
/** @internal */ parcelHelpers.export(exports, "calcSi", ()=>calcSi);
const SI_MID = 8;
const SI = [
    {
        power: -24,
        text: "yocto",
        value: "y"
    },
    {
        power: -21,
        text: "zepto",
        value: "z"
    },
    {
        power: -18,
        text: "atto",
        value: "a"
    },
    {
        power: -15,
        text: "femto",
        value: "f"
    },
    {
        power: -12,
        text: "pico",
        value: "p"
    },
    {
        power: -9,
        text: "nano",
        value: "n"
    },
    {
        power: -6,
        text: "micro",
        value: "\xb5"
    },
    {
        power: -3,
        text: "milli",
        value: "m"
    },
    {
        power: 0,
        text: "Unit",
        value: "-"
    },
    {
        power: 3,
        text: "Kilo",
        value: "k"
    },
    {
        power: 6,
        text: "Mill",
        value: "M"
    },
    {
        power: 9,
        text: "Bill",
        value: "B"
    },
    {
        power: 12,
        text: "Tril",
        value: "T"
    },
    {
        power: 15,
        text: "Peta",
        value: "P"
    },
    {
        power: 18,
        text: "Exa",
        value: "E"
    },
    {
        power: 21,
        text: "Zeta",
        value: "Z"
    },
    {
        power: 24,
        text: "Yotta",
        value: "Y"
    }
]; // Given a SI type (e.g. k, m, Y) find the SI definition
function findSi(type) {
    // use a loop here, better RN support (which doesn't have [].find)
    for(let i = 0; i < SI.length; i++){
        if (SI[i].value === type) return SI[i];
    }
    return SI[SI_MID];
}
function calcSi(text, decimals, forceUnit) {
    if (forceUnit) return findSi(forceUnit);
    const siDefIndex = SI_MID - 1 + Math.ceil((text.length - decimals) / 3);
    return SI[siDefIndex] || SI[siDefIndex < 0 ? 0 : SI.length - 1];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i5C3S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name formatDate
 * @description Formats a date in CCYY-MM-DD HH:MM:SS format
 */ parcelHelpers.export(exports, "formatDate", ()=>formatDate);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/** @internal */ function zeroPad(value) {
    return value.toString().padStart(2, "0");
}
function formatDate(date) {
    const year = date.getFullYear().toString();
    const month = zeroPad(date.getMonth() + 1);
    const day = zeroPad(date.getDate());
    const hour = zeroPad(date.getHours());
    const minute = zeroPad(date.getMinutes());
    const second = zeroPad(date.getSeconds());
    return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"evUux":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name formatElapsed
 * @description Formats an elapsed value into s, m, h or day segments
 */ parcelHelpers.export(exports, "formatElapsed", ()=>formatElapsed);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toBnJs = require("../bn/toBn.js");
/** @internal */ function formatValue(elapsed) {
    if (elapsed < 15) return `${elapsed.toFixed(1)}s`;
    else if (elapsed < 60) return `${elapsed | 0}s`;
    else if (elapsed < 3600) return `${elapsed / 60 | 0}m`;
    return `${elapsed / 3600 | 0}h`;
}
function formatElapsed(now, value) {
    const tsNow = now && now.getTime() || 0;
    const tsValue = value instanceof Date ? value.getTime() : (0, _toBnJs.bnToBn)(value).toNumber();
    return tsNow && tsValue ? formatValue(Math.max(Math.abs(tsNow - tsValue), 0) / 1000) : "0.0s";
}

},{"../bn/toBn.js":"iM6St","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"62e9Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name formatNumber
 * @description Formats a number into string format with thousand seperators
 */ parcelHelpers.export(exports, "formatNumber", ()=>formatNumber);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toBnJs = require("../bn/toBn.js");
var _formatDecimalJs = require("./formatDecimal.js");
function formatNumber(value) {
    return (0, _formatDecimalJs.formatDecimal)((0, _toBnJs.bnToBn)(value).toString());
}

},{"../bn/toBn.js":"iM6St","./formatDecimal.js":"g7sur","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"foCYc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Internal utilities to create and test for hex values
 */ parcelHelpers.export(exports, "hexAddPrefix", ()=>(0, _addPrefixJs.hexAddPrefix));
parcelHelpers.export(exports, "hexFixLength", ()=>(0, _fixLengthJs.hexFixLength));
parcelHelpers.export(exports, "hexHasPrefix", ()=>(0, _hasPrefixJs.hexHasPrefix));
parcelHelpers.export(exports, "hexStripPrefix", ()=>(0, _stripPrefixJs.hexStripPrefix));
parcelHelpers.export(exports, "hexToBigInt", ()=>(0, _toBigIntJs.hexToBigInt));
parcelHelpers.export(exports, "hexToBn", ()=>(0, _toBnJs.hexToBn));
parcelHelpers.export(exports, "hexToNumber", ()=>(0, _toNumberJs.hexToNumber));
parcelHelpers.export(exports, "hexToString", ()=>(0, _toStringJs.hexToString));
parcelHelpers.export(exports, "hexToU8a", ()=>(0, _toU8AJs.hexToU8a));
var _addPrefixJs = require("./addPrefix.js");
var _fixLengthJs = require("./fixLength.js");
var _hasPrefixJs = require("./hasPrefix.js");
var _stripPrefixJs = require("./stripPrefix.js");
var _toBigIntJs = require("./toBigInt.js");
var _toBnJs = require("./toBn.js");
var _toNumberJs = require("./toNumber.js");
var _toStringJs = require("./toString.js");
var _toU8AJs = require("./toU8a.js");

},{"./addPrefix.js":"9C97i","./fixLength.js":"4D3dy","./hasPrefix.js":"h3vge","./stripPrefix.js":"5qaue","./toBigInt.js":"auyXM","./toBn.js":"dITJ7","./toNumber.js":"d2xfE","./toString.js":"cKFXc","./toU8a.js":"g5dk6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9C97i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name hexAddPrefix
 * @summary Adds the `0x` prefix to string values.
 * @description
 * Returns a `0x` prefixed string from the input value. If the input is already prefixed, it is returned unchanged.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexAddPrefix } from '@polkadot/util';
 *
 * console.log('With prefix', hexAddPrefix('0a0b12')); // => 0x0a0b12
 * ```
 */ parcelHelpers.export(exports, "hexAddPrefix", ()=>hexAddPrefix);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _hasPrefixJs = require("./hasPrefix.js");
function hexAddPrefix(value) {
    return value && (0, _hasPrefixJs.hexHasPrefix)(value) ? value : `0x${value && value.length % 2 === 1 ? "0" : ""}${value || ""}`;
}

},{"./hasPrefix.js":"h3vge","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h3vge":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name hexHasPrefix
 * @summary Tests for the existence of a `0x` prefix.
 * @description
 * Checks for a valid hex input value and if the start matched `0x`
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexHasPrefix } from '@polkadot/util';
 *
 * console.log('has prefix', hexHasPrefix('0x1234')); // => true
 * ```
 */ parcelHelpers.export(exports, "hexHasPrefix", ()=>hexHasPrefix);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _hexJs = require("../is/hex.js");
function hexHasPrefix(value) {
    return !!value && (0, _hexJs.isHex)(value, -1);
}

},{"../is/hex.js":"1XrXF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4D3dy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name hexFixLength
 * @summary Shifts a hex string to a specific bitLength
 * @description
 * Returns a `0x` prefixed string with the specified number of bits contained in the return value. (If bitLength is -1, length checking is not done). Values with more bits are trimmed to the specified length. Input values with less bits are returned as-is by default. When `withPadding` is set, shorter values are padded with `0`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexFixLength } from '@polkadot/util';
 *
 * console.log('fixed', hexFixLength('0x12', 16)); // => 0x12
 * console.log('fixed', hexFixLength('0x12', 16, true)); // => 0x0012
 * console.log('fixed', hexFixLength('0x0012', 8)); // => 0x12
 * ```
 */ parcelHelpers.export(exports, "hexFixLength", ()=>hexFixLength);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _addPrefixJs = require("./addPrefix.js");
var _stripPrefixJs = require("./stripPrefix.js");
function hexFixLength(value, bitLength = -1, withPadding = false) {
    const strLength = Math.ceil(bitLength / 4);
    const hexLength = strLength + 2;
    return (0, _addPrefixJs.hexAddPrefix)(bitLength === -1 || value.length === hexLength || !withPadding && value.length < hexLength ? (0, _stripPrefixJs.hexStripPrefix)(value) : value.length > hexLength ? (0, _stripPrefixJs.hexStripPrefix)(value).slice(-1 * strLength) : `${"0".repeat(strLength)}${(0, _stripPrefixJs.hexStripPrefix)(value)}`.slice(-1 * strLength));
}

},{"./addPrefix.js":"9C97i","./stripPrefix.js":"5qaue","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d2xfE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name hexToNumber
 * @summary Creates a Number value from a Buffer object.
 * @description
 * `null` inputs returns an NaN result, `hex` values return the actual value as a `Number`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexToNumber } from '@polkadot/util';
 *
 * hexToNumber('0x1234'); // => 0x1234
 * ```
 */ parcelHelpers.export(exports, "hexToNumber", ()=>hexToNumber);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toBnJs = require("./toBn.js");
function hexToNumber(value) {
    return value ? (0, _toBnJs.hexToBn)(value).toNumber() : NaN;
}

},{"./toBn.js":"dITJ7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cKFXc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name hexToU8a
 * @summary Creates a Uint8Array object from a hex string.
 * @description
 * Hex input values return the actual bytes value converted to a string. Anything that is not a hex string (including the `0x` prefix) throws an error.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexToString } from '@polkadot/util';
 *
 * hexToU8a('0x68656c6c6f'); // hello
 * ```
 */ parcelHelpers.export(exports, "hexToString", ()=>hexToString);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toStringJs = require("../u8a/toString.js");
var _toU8AJs = require("./toU8a.js");
function hexToString(_value) {
    return (0, _toStringJs.u8aToString)((0, _toU8AJs.hexToU8a)(_value));
}

},{"../u8a/toString.js":"159cK","./toU8a.js":"g5dk6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hZ2pz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Type checking utilities
 */ parcelHelpers.export(exports, "isArray", ()=>(0, _arrayJs.isArray));
parcelHelpers.export(exports, "isAscii", ()=>(0, _asciiJs.isAscii));
parcelHelpers.export(exports, "isBigInt", ()=>(0, _bigIntJs.isBigInt));
parcelHelpers.export(exports, "isBn", ()=>(0, _bnJs.isBn));
parcelHelpers.export(exports, "isBuffer", ()=>(0, _bufferJs.isBuffer));
parcelHelpers.export(exports, "isBoolean", ()=>(0, _booleanJs.isBoolean));
parcelHelpers.export(exports, "isChildClass", ()=>(0, _childClassJs.isChildClass));
parcelHelpers.export(exports, "isCodec", ()=>(0, _codecJs.isCodec));
parcelHelpers.export(exports, "isCompact", ()=>(0, _compactJs.isCompact));
parcelHelpers.export(exports, "isError", ()=>(0, _errorJs.isError));
parcelHelpers.export(exports, "isFunction", ()=>(0, _functionJs.isFunction));
parcelHelpers.export(exports, "isHex", ()=>(0, _hexJs.isHex));
parcelHelpers.export(exports, "isInstanceOf", ()=>(0, _instanceOfJs.isInstanceOf));
parcelHelpers.export(exports, "isIp", ()=>(0, _ipJs.isIp));
parcelHelpers.export(exports, "isJsonObject", ()=>(0, _jsonObjectJs.isJsonObject));
parcelHelpers.export(exports, "isNull", ()=>(0, _nullJs.isNull));
parcelHelpers.export(exports, "isNumber", ()=>(0, _numberJs.isNumber));
parcelHelpers.export(exports, "isObject", ()=>(0, _objectJs.isObject));
parcelHelpers.export(exports, "isObservable", ()=>(0, _observableJs.isObservable));
parcelHelpers.export(exports, "isPromise", ()=>(0, _promiseJs.isPromise));
parcelHelpers.export(exports, "isString", ()=>(0, _stringJs.isString));
parcelHelpers.export(exports, "isTestChain", ()=>(0, _testChainJs.isTestChain));
parcelHelpers.export(exports, "isToBigInt", ()=>(0, _toBigIntJs.isToBigInt));
parcelHelpers.export(exports, "isToBn", ()=>(0, _toBnJs.isToBn));
parcelHelpers.export(exports, "isU8a", ()=>(0, _u8AJs.isU8a));
parcelHelpers.export(exports, "isUndefined", ()=>(0, _undefinedJs.isUndefined));
parcelHelpers.export(exports, "isUtf8", ()=>(0, _utf8Js.isUtf8));
parcelHelpers.export(exports, "isWasm", ()=>(0, _wasmJs.isWasm));
var _arrayJs = require("./array.js");
var _asciiJs = require("./ascii.js");
var _bigIntJs = require("./bigInt.js");
var _bnJs = require("./bn.js");
var _bufferJs = require("./buffer.js");
var _booleanJs = require("./boolean.js");
var _childClassJs = require("./childClass.js");
var _codecJs = require("./codec.js");
var _compactJs = require("./compact.js");
var _errorJs = require("./error.js");
var _functionJs = require("./function.js");
var _hexJs = require("./hex.js");
var _instanceOfJs = require("./instanceOf.js");
var _ipJs = require("./ip.js");
var _jsonObjectJs = require("./jsonObject.js");
var _nullJs = require("./null.js");
var _numberJs = require("./number.js");
var _objectJs = require("./object.js");
var _observableJs = require("./observable.js");
var _promiseJs = require("./promise.js");
var _stringJs = require("./string.js");
var _testChainJs = require("./testChain.js");
var _toBigIntJs = require("./toBigInt.js");
var _toBnJs = require("./toBn.js");
var _u8AJs = require("./u8a.js");
var _undefinedJs = require("./undefined.js");
var _utf8Js = require("./utf8.js");
var _wasmJs = require("./wasm.js");

},{"./array.js":"dXot8","./ascii.js":"8Vnpf","./bigInt.js":"aHtst","./bn.js":"l418N","./buffer.js":"dQj1x","./boolean.js":"g4Bcm","./childClass.js":"l88uG","./codec.js":"bQ9BD","./compact.js":"5M2HJ","./error.js":"3GtE9","./function.js":"3nYod","./hex.js":"1XrXF","./instanceOf.js":"3MNYA","./ip.js":"24WER","./jsonObject.js":"2muRI","./null.js":"fvgGr","./number.js":"26LZv","./object.js":"cSHr5","./observable.js":"a0UM7","./promise.js":"f31bo","./string.js":"3nCC2","./testChain.js":"2yUdd","./toBigInt.js":"7gXiE","./toBn.js":"klE8p","./u8a.js":"a3N6N","./undefined.js":"N37tY","./utf8.js":"cO5AZ","./wasm.js":"lm8De","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dXot8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isArray
 * @summary Tests for a Array instance.
 */ parcelHelpers.export(exports, "isArray", ()=>isArray);
function isArray(value) {
    return Array.isArray(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Vnpf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name isAscii
 * @summary Tests if the input is printable ASCII
 * @description
 * Checks to see if the input string or Uint8Array is printable ASCII, 32-127 + formatters
 */ parcelHelpers.export(exports, "isAscii", ()=>isAscii);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toU8AJs = require("../u8a/toU8a.js");
var _hexJs = require("./hex.js");
var _stringJs = require("./string.js");
/** @internal */ function isAsciiStr(str) {
    const count = str.length | 0;
    for(let i = 0; i < count; i++){
        const b = str.charCodeAt(i); // check is inlined here, it is faster than making a call
        if (b < 32 || b > 126) return false;
    }
    return true;
}
/** @internal */ function isAsciiBytes(u8a) {
    const count = u8a.length | 0;
    for(let i = 0; i < count; i++){
        const b = u8a[i] | 0; // check is inlined here, it is faster than making a call
        if (b < 32 || b > 126) return false;
    }
    return true;
}
function isAscii(value) {
    return (0, _stringJs.isString)(value) ? (0, _hexJs.isHex)(value) ? isAsciiBytes((0, _toU8AJs.u8aToU8a)(value)) : isAsciiStr(value) : value ? isAsciiBytes(value) : false;
}

},{"../u8a/toU8a.js":"2vZLl","./hex.js":"1XrXF","./string.js":"3nCC2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3nCC2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isString
 * @summary Tests for a string.
 * @description
 * Checks to see if the input value is a JavaScript string.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isString } from '@polkadot/util';
 *
 * console.log('isString', isString('test')); // => true
 * ```
 */ parcelHelpers.export(exports, "isString", ()=>isString);
function isString(value) {
    return typeof value === "string" || value instanceof String;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l88uG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isChildClass
 * @summary Tests if the child extends the parent Class
 * @description
 * Checks to see if the child Class extends the parent Class
 * @example
 * <BR>
 *
 * ```javascript
 * import { isChildClass } from '@polkadot/util';
 *
 * console.log('isChildClass', isChildClass(BN, BN); // => true
 * console.log('isChildClass', isChildClass(BN, Uint8Array); // => false
 * ```
 */ parcelHelpers.export(exports, "isChildClass", ()=>isChildClass);
function isChildClass(Parent, Child) {
    // https://stackoverflow.com/questions/30993434/check-if-a-constructor-inherits-another-in-es6/30993664
    return Child // eslint-disable-next-line no-prototype-builtins
     ? Parent === Child || Parent.isPrototypeOf(Child) : false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bQ9BD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isCodec", ()=>isCodec);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _helpersJs = require("./helpers.js");
const checkCodec = (0, _helpersJs.isOnObject)("toHex", "toU8a");
const checkRegistry = (0, _helpersJs.isOnObject)("get");
function isCodec(value) {
    return checkCodec(value) && checkRegistry(value.registry);
}

},{"./helpers.js":"h9gvY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5M2HJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isCompact", ()=>isCompact);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _helpersJs = require("./helpers.js");
const isCompact = (0, _helpersJs.isOnObject)("toBigInt", "toBn", "toNumber", "unwrap");

},{"./helpers.js":"h9gvY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3GtE9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isError
 * @summary Tests for a `Error` object instance.
 * @description
 * Checks to see if the input object is an instance of `Error`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isError } from '@polkadot/util';
 *
 * console.log('isError', isError(new Error('message'))); // => true
 * ```
 */ parcelHelpers.export(exports, "isError", ()=>isError);
function isError(value) {
    return (value && value.constructor) === Error || value instanceof Error;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3MNYA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isInstanceOf
 * @summary Tests for a instance of a class.
 * @description
 * Checks to see if the input value is an instance of the test class.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isInstanceOf } from '@polkadot/util';
 *
 * console.log('isInstanceOf', isInstanceOf(new Array(0), Array)); // => true
 * ```
 */ // eslint-disable-next-line @typescript-eslint/ban-types
parcelHelpers.export(exports, "isInstanceOf", ()=>isInstanceOf);
function isInstanceOf(value, Clazz) {
    return (value && value.constructor) === Clazz || value instanceof Clazz;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"24WER":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name isIp
 * @summary Tests if the value is a valid IP address
 * @description
 * Checks to see if the value is a valid IP address. Optionally check for either v4/v6
 * @example
 * <BR>
 *
 * ```javascript
 * import { isIp } from '@polkadot/util';
 *
 * isIp('192.168.0.1')); // => true
 * isIp('1:2:3:4:5:6:7:8'); // => true
 * isIp('192.168.0.1', 'v6')); // => false
 * isIp('1:2:3:4:5:6:7:8', 'v4'); // => false
 * ```
 */ parcelHelpers.export(exports, "isIp", ()=>isIp);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// The regex patterns below were copied as-is from the ip-regex package 5.0.0,
// https://github.com/sindresorhus/ip-regex/blob/a2a44dfa7f776528158c2a5ff9d8a1be435ec1b9/index.js#L1
//
// MIT License
// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
//
// Changes made:
//  - boundary support option has been dropped
//  - only exact matching is used (isIp always passed exact: true)
//  - the newest ip-regex is ESM-only, we compile to all platforms
const v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
const v6s = "[a-fA-F\\d]{1,4}";
const v6 = `
(?:
(?:${v6s}:){7}(?:${v6s}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6s}:){6}(?:${v4}|:${v6s}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6s}:){5}(?::${v4}|(?::${v6s}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6s}:){4}(?:(?::${v6s}){0,1}:${v4}|(?::${v6s}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6s}:){3}(?:(?::${v6s}){0,2}:${v4}|(?::${v6s}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6s}:){2}(?:(?::${v6s}){0,3}:${v4}|(?::${v6s}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6s}:){1}(?:(?::${v6s}){0,4}:${v4}|(?::${v6s}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6s}){0,5}:${v4}|(?::${v6s}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
const v4exact = new RegExp(`^${v4}$`);
const v6exact = new RegExp(`^${v6}$`);
function isIp(value, type) {
    switch(type){
        case "v4":
            return v4exact.test(value);
        case "v6":
            return v6exact.test(value);
        default:
            return v46Exact.test(value);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2muRI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name isJsonObject
 * @summary Tests for a valid JSON `object`.
 * @description
 * Checks to see if the input value is a valid JSON object.
 * It returns false if the input is JSON parsable, but not an Javascript object.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isJsonObject } from '@polkadot/util';
 *
 * isJsonObject({}); // => true
 * isJsonObject({
 *  "Test": "1234",
 *  "NestedTest": {
 *   "Test": "5678"
 *  }
 * }); // => true
 * isJsonObject(1234); // JSON parsable, but not an object =>  false
 * isJsonObject(null); // JSON parsable, but not an object => false
 * isJsonObject('not an object'); // => false
 * ```
 */ parcelHelpers.export(exports, "isJsonObject", ()=>isJsonObject);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _stringifyJs = require("../stringify.js");
function isJsonObject(value) {
    const str = typeof value !== "string" ? (0, _stringifyJs.stringify)(value) : value;
    try {
        const obj = JSON.parse(str);
        return typeof obj === "object" && obj !== null;
    } catch (e) {
        return false;
    }
}

},{"../stringify.js":"4kzVD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kzVD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name stringify
 * @summary Performs a JSON.stringify, with BigInt handling
 * @description A wrapper for JSON.stringify that handles BigInt values transparently, converting them to string. No differences from the native JSON.stringify function otherwise.
 */ parcelHelpers.export(exports, "stringify", ()=>stringify);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bigIntJs = require("./is/bigInt.js");
/** @internal */ function replacer(_, v) {
    return (0, _bigIntJs.isBigInt)(v) ? v.toString() : v;
}
function stringify(value, space) {
    return JSON.stringify(value, replacer, space);
}

},{"./is/bigInt.js":"aHtst","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fvgGr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isNull
 * @summary Tests for a `null` values.
 * @description
 * Checks to see if the input value is `null`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isNull } from '@polkadot/util';
 *
 * console.log('isNull', isNull(null)); // => true
 * ```
 */ parcelHelpers.export(exports, "isNull", ()=>isNull);
function isNull(value) {
    return value === null;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"26LZv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isNumber
 * @summary Tests for a JavaScript number.
 * @description
 * Checks to see if the input value is a valid number.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isNumber } from '@polkadot/util';
 *
 * console.log('isNumber', isNumber(1234)); // => true
 * ```
 */ parcelHelpers.export(exports, "isNumber", ()=>isNumber);
function isNumber(value) {
    return typeof value === "number";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a0UM7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isObservable", ()=>isObservable);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _helpersJs = require("./helpers.js");
const isObservable = (0, _helpersJs.isOn)("next");

},{"./helpers.js":"h9gvY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f31bo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _helpersJs = require("./helpers.js");
const isPromise = (0, _helpersJs.isOnObject)("catch", "then");

},{"./helpers.js":"h9gvY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2yUdd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isTestChain", ()=>isTestChain);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
const REGEX_DEV = /(Development|Local Testnet)$/;
function isTestChain(chain) {
    if (!chain) return false;
    return !!REGEX_DEV.test(chain.toString());
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"N37tY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name isUndefined
 * @summary Tests for a `undefined` values.
 * @description
 * Checks to see if the input value is `undefined`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isUndefined } from '@polkadot/util';
 *
 * console.log('isUndefined', isUndefined(void(0))); // => true
 * ```
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
parcelHelpers.export(exports, "isUndefined", ()=>isUndefined);
function isUndefined(value) {
    return value === undefined;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cO5AZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name isUtf8
 * @summary Tests if the input is valid Utf8
 * @description
 * Checks to see if the input string or Uint8Array is valid Utf8
 */ parcelHelpers.export(exports, "isUtf8", ()=>isUtf8);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Adapted from https://github.com/JulienPalard/is_utf8/blob/master/is_utf8.c
var _toU8AJs = require("../u8a/toU8a.js");
var _stringJs = require("./string.js");
function isUtf8(value) {
    if (!value) return (0, _stringJs.isString)(value);
    const u8a = (0, _toU8AJs.u8aToU8a)(value);
    const len = u8a.length;
    let i = 0;
    while(i < len){
        if (u8a[i] <= 0x7F) i += 1;
        else if (u8a[i] >= 0xC2 && u8a[i] <= 0xDF) /* C2..DF 80..BF */ {
            if (i + 1 < len) /* Expect a 2nd byte */ {
                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) // *message = "After a first byte between C2 and DF, expecting a 2nd byte between 80 and BF";
                // *faulty_bytes = 2;
                return false;
            } else // *message = "After a first byte between C2 and DF, expecting a 2nd byte.";
            // *faulty_bytes = 1;
            return false;
            i += 2;
        } else if (u8a[i] === 0xE0) /* E0 A0..BF 80..BF */ {
            if (i + 2 < len) /* Expect a 2nd and 3rd byte */ {
                if (u8a[i + 1] < 0xA0 || u8a[i + 1] > 0xBF) // *message = "After a first byte of E0, expecting a 2nd byte between A0 and BF.";
                // *faulty_bytes = 2;
                return false;
                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) // *message = "After a first byte of E0, expecting a 3nd byte between 80 and BF.";
                // *faulty_bytes = 3;
                return false;
            } else // *message = "After a first byte of E0, expecting two following bytes.";
            // *faulty_bytes = 1;
            return false;
            i += 3;
        } else if (u8a[i] >= 0xE1 && u8a[i] <= 0xEC) /* E1..EC 80..BF 80..BF */ {
            if (i + 2 < len) /* Expect a 2nd and 3rd byte */ {
                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) // *message = "After a first byte between E1 and EC, expecting the 2nd byte between 80 and BF.";
                // *faulty_bytes = 2;
                return false;
                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) // *message = "After a first byte between E1 and EC, expecting the 3rd byte between 80 and BF.";
                // *faulty_bytes = 3;
                return false;
            } else // *message = "After a first byte between E1 and EC, expecting two following bytes.";
            // *faulty_bytes = 1;
            return false;
            i += 3;
        } else if (u8a[i] === 0xED) /* ED 80..9F 80..BF */ {
            if (i + 2 < len) /* Expect a 2nd and 3rd byte */ {
                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x9F) // *message = "After a first byte of ED, expecting 2nd byte between 80 and 9F.";
                // *faulty_bytes = 2;
                return false;
                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) // *message = "After a first byte of ED, expecting 3rd byte between 80 and BF.";
                // *faulty_bytes = 3;
                return false;
            } else // *message = "After a first byte of ED, expecting two following bytes.";
            // *faulty_bytes = 1;
            return false;
            i += 3;
        } else if (u8a[i] >= 0xEE && u8a[i] <= 0xEF) /* EE..EF 80..BF 80..BF */ {
            if (i + 2 < len) /* Expect a 2nd and 3rd byte */ {
                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) // *message = "After a first byte between EE and EF, expecting 2nd byte between 80 and BF.";
                // *faulty_bytes = 2;
                return false;
                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) // *message = "After a first byte between EE and EF, expecting 3rd byte between 80 and BF.";
                // *faulty_bytes = 3;
                return false;
            } else // *message = "After a first byte between EE and EF, two following bytes.";
            // *faulty_bytes = 1;
            return false;
            i += 3;
        } else if (u8a[i] === 0xF0) /* F0 90..BF 80..BF 80..BF */ {
            if (i + 3 < len) /* Expect a 2nd, 3rd 3th byte */ {
                if (u8a[i + 1] < 0x90 || u8a[i + 1] > 0xBF) // *message = "After a first byte of F0, expecting 2nd byte between 90 and BF.";
                // *faulty_bytes = 2;
                return false;
                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) // *message = "After a first byte of F0, expecting 3rd byte between 80 and BF.";
                // *faulty_bytes = 3;
                return false;
                if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) // *message = "After a first byte of F0, expecting 4th byte between 80 and BF.";
                // *faulty_bytes = 4;
                return false;
            } else // *message = "After a first byte of F0, expecting three following bytes.";
            // *faulty_bytes = 1;
            return false;
            i += 4;
        } else if (u8a[i] >= 0xF1 && u8a[i] <= 0xF3) /* F1..F3 80..BF 80..BF 80..BF */ {
            if (i + 3 < len) /* Expect a 2nd, 3rd 3th byte */ {
                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) // *message = "After a first byte of F1, F2, or F3, expecting a 2nd byte between 80 and BF.";
                // *faulty_bytes = 2;
                return false;
                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) // *message = "After a first byte of F1, F2, or F3, expecting a 3rd byte between 80 and BF.";
                // *faulty_bytes = 3;
                return false;
                if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) // *message = "After a first byte of F1, F2, or F3, expecting a 4th byte between 80 and BF.";
                // *faulty_bytes = 4;
                return false;
            } else // *message = "After a first byte of F1, F2, or F3, expecting three following bytes.";
            // *faulty_bytes = 1;
            return false;
            i += 4;
        } else if (u8a[i] === 0xF4) /* F4 80..8F 80..BF 80..BF */ {
            if (i + 3 < len) /* Expect a 2nd, 3rd 3th byte */ {
                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x8F) // *message = "After a first byte of F4, expecting 2nd byte between 80 and 8F.";
                // *faulty_bytes = 2;
                return false;
                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) // *message = "After a first byte of F4, expecting 3rd byte between 80 and BF.";
                // *faulty_bytes = 3;
                return false;
                if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) // *message = "After a first byte of F4, expecting 4th byte between 80 and BF.";
                // *faulty_bytes = 4;
                return false;
            } else // *message = "After a first byte of F4, expecting three following bytes.";
            // *faulty_bytes = 1;
            return false;
            i += 4;
        } else // *message = "Expecting bytes in the following ranges: 00..7F C2..F4.";
        // *faulty_bytes = 1;
        return false;
    }
    return true;
}

},{"../u8a/toU8a.js":"2vZLl","./string.js":"3nCC2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lm8De":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name isWasm
 * @summary Tests if the input has a WASM header
 * @description
 * Checks to see if the input Uint8Array contains a valid WASM header
 */ parcelHelpers.export(exports, "isWasm", ()=>isWasm);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _eqJs = require("../u8a/eq.js");
var _u8AJs = require("./u8a.js");
const WASM_MAGIC = new Uint8Array([
    0,
    97,
    115,
    109
]); // \0asm
function isWasm(value) {
    return (0, _u8AJs.isU8a)(value) && (0, _eqJs.u8aEq)(value.subarray(0, 4), WASM_MAGIC);
}

},{"../u8a/eq.js":"j350s","./u8a.js":"a3N6N","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g0R3i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name lazyMethod
 * @description
 * Creates a lazy, on-demand getter for the specific value. Upon get the value will be evaluated.
 */ parcelHelpers.export(exports, "lazyMethod", ()=>lazyMethod);
/**
 * @name lazyMethods
 * @description
 * Creates lazy, on-demand getters for the specific values.
 */ parcelHelpers.export(exports, "lazyMethods", ()=>lazyMethods);
function lazyMethod(result, item, creator, getName, index = 0) {
    const name = getName ? getName(item, index) : item.toString();
    let value;
    Object.defineProperty(result, name, {
        // This allows for re-configuration with the embedded defineProperty below
        // and ensures that on tested browsers and Node, it _will_ be redefined
        // and thus short-circuited for future access
        configurable: true,
        enumerable: true,
        // Use a function here, we don't want to capture the outer this, i.e.
        // don't use arrow functions in this context since we have a this inside
        get: function() {
            // This check should _always_ be false and unneeded, since we override
            // with a value below ... however we ensure we are quire vigilant against
            // all environment failures, so we are rather be safe than sorry
            if (value === undefined) {
                value = creator(item, index, this);
                try {
                    // re-define the property as a value, next time around this
                    // getter will only return the computed value
                    Object.defineProperty(this, name, {
                        value
                    });
                } catch  {
                // the "configurable" property above. But if it ever does
                // from here-on we will be the cached value the next time
                // around (with a very slight dip in performance)
                }
            }
            return value;
        }
    });
}
function lazyMethods(result, items, creator, getName) {
    for(let i = 0; i < items.length; i++)lazyMethod(result, items[i], creator, getName, i);
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"87mNm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loggerFormat", ()=>loggerFormat);
/**
 * @name Logger
 * @summary Creates a consistent log interface for messages
 * @description
 * Returns a `Logger` that has `.log`, `.error`, `.warn` and `.debug` (controlled with environment `DEBUG=typeA,typeB`) methods. Logging is done with a consistent prefix (type of logger, date) followed by the actual message using the underlying console.
 * @example
 * <BR>
 *
 * ```javascript
 * import { logger } from '@polkadot/util';
 *
 * const l = logger('test');
 * ```
 */ parcelHelpers.export(exports, "logger", ()=>logger);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _formatDateJs = require("./format/formatDate.js");
var _bnJs = require("./is/bn.js");
var _bufferJs = require("./is/buffer.js");
var _functionJs = require("./is/function.js");
var _objectJs = require("./is/object.js");
var _u8AJs = require("./is/u8a.js");
var _toHexJs = require("./u8a/toHex.js");
var _toU8AJs = require("./u8a/toU8a.js");
var _hasJs = require("./has.js");
var process = require("process");
const logTo = {
    debug: "log",
    error: "error",
    log: "log",
    warn: "warn"
};
function formatOther(value) {
    if (value && (0, _objectJs.isObject)(value) && value.constructor === Object) {
        const result = {};
        for (const k of Object.keys(value))result[k] = loggerFormat(value[k]);
        return result;
    }
    return value;
}
function loggerFormat(value) {
    if (Array.isArray(value)) return value.map(loggerFormat);
    else if ((0, _bnJs.isBn)(value)) return value.toString();
    else if ((0, _u8AJs.isU8a)(value) || (0, _bufferJs.isBuffer)(value)) return (0, _toHexJs.u8aToHex)((0, _toU8AJs.u8aToU8a)(value));
    return formatOther(value);
}
function formatWithLength(maxLength) {
    return (v)=>{
        if (maxLength <= 0) return v;
        const r = `${v}`;
        return r.length < maxLength ? v : `${r.substring(0, maxLength)} ...`;
    };
}
function apply(log, type, values, maxSize = -1) {
    if (values.length === 1 && (0, _functionJs.isFunction)(values[0])) {
        const fnResult = values[0]();
        return apply(log, type, Array.isArray(fnResult) ? fnResult : [
            fnResult
        ], maxSize);
    }
    console[logTo[log]]((0, _formatDateJs.formatDate)(new Date()), type, ...values.map(loggerFormat).map(formatWithLength(maxSize)));
}
function noop() {}
function isDebugOn(e, type) {
    return !!e && (e === "*" || type === e || e.endsWith("*") && type.startsWith(e.slice(0, -1)));
}
function isDebugOff(e, type) {
    return !!e && e.startsWith("-") && (type === e.slice(1) || e.endsWith("*") && type.startsWith(e.slice(1, -1)));
}
function getDebugFlag(env, type) {
    let flag = false;
    for (const e of env){
        if (isDebugOn(e, type)) flag = true;
        else if (isDebugOff(e, type)) flag = false;
    }
    return flag;
}
function parseEnv(type) {
    const env = ((0, _hasJs.hasProcess) ? process : {}).env || {};
    const maxSize = parseInt(env.DEBUG_MAX || "-1", 10);
    return [
        getDebugFlag((env.DEBUG || "").toLowerCase().split(","), type),
        isNaN(maxSize) ? -1 : maxSize
    ];
}
function logger(_type) {
    const type = `${_type.toUpperCase()}:`.padStart(16);
    const [isDebug, maxSize] = parseEnv(_type.toLowerCase());
    return {
        debug: isDebug ? (...values)=>apply("debug", type, values, maxSize) : noop,
        error: (...values)=>apply("error", type, values),
        log: (...values)=>apply("log", type, values),
        noop,
        warn: (...values)=>apply("warn", type, values)
    };
}

},{"./format/formatDate.js":"i5C3S","./is/bn.js":"l418N","./is/buffer.js":"dQj1x","./is/function.js":"3nYod","./is/object.js":"cSHr5","./is/u8a.js":"a3N6N","./u8a/toHex.js":"cBjBN","./u8a/toU8a.js":"2vZLl","./has.js":"kBoWG","process":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fHTyq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name memoize
 * @description Memomize the function with a specific instanceId
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
parcelHelpers.export(exports, "memoize", ()=>memoize);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _stringifyJs = require("./stringify.js");
function defaultGetId() {
    return "none";
}
function memoize(fn, { getInstanceId =defaultGetId  } = {}) {
    const cache = {};
    const memoized = (...args)=>{
        const stringParams = (0, _stringifyJs.stringify)(args);
        const instanceId = getInstanceId();
        if (!cache[instanceId]) cache[instanceId] = {};
        if (cache[instanceId][stringParams] === undefined) cache[instanceId][stringParams] = fn(...args);
        return cache[instanceId][stringParams];
    };
    memoized.unmemoize = (...args)=>{
        const stringParams = (0, _stringifyJs.stringify)(args);
        const instanceId = getInstanceId();
        if (cache[instanceId] && cache[instanceId][stringParams] !== undefined) delete cache[instanceId][stringParams];
    };
    return memoized;
}

},{"./stringify.js":"4kzVD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cyuHx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name nextTick
 * @description Defer the operation to the queue for evaluation on the next tick
 */ parcelHelpers.export(exports, "nextTick", ()=>nextTick);
function nextTick(onExec, onError) {
    // While Promise.resolve().then(...) would defer to the nextTick, this
    // actually does not play as nicely in browsers like the setTimeout(...)
    // approach. So the safer, though less optimal approach is the one taken here
    setTimeout(()=>{
        Promise.resolve().then(()=>{
            onExec();
        }).catch((error)=>{
            if (onError) onError(error);
            else console.error(error);
        });
    }, 0);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d2giP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Utility methods to convert to and from `number` values
 */ parcelHelpers.export(exports, "numberToHex", ()=>(0, _toHexJs.numberToHex));
parcelHelpers.export(exports, "numberToU8a", ()=>(0, _toU8AJs.numberToU8a));
var _toHexJs = require("./toHex.js");
var _toU8AJs = require("./toU8a.js");

},{"./toHex.js":"hFsoY","./toU8a.js":"hAonY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hFsoY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name numberToHex
 * @summary Creates a hex value from a number.
 * @description
 * `null`/`undefined`/`NaN` inputs returns an empty `0x` result. `number` input values return the actual bytes value converted to a `hex`. With `bitLength` set, it converts the number to the equivalent size.
 * @example
 * <BR>
 *
 * ```javascript
 * import { numberToHex } from '@polkadot/util';
 *
 * numberToHex(0x1234); // => '0x1234'
 * numberToHex(0x1234, 32); // => 0x00001234
 * ```
 */ parcelHelpers.export(exports, "numberToHex", ()=>numberToHex);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _fixLengthJs = require("../hex/fixLength.js");
function numberToHex(value, bitLength = -1) {
    if (value === undefined || value === null || isNaN(value)) return "0x";
    const hex = value.toString(16);
    return (0, _fixLengthJs.hexFixLength)(hex.length % 2 ? `0${hex}` : hex, bitLength, true);
}

},{"../hex/fixLength.js":"4D3dy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hAonY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name numberToU8a
 * @summary Creates a Uint8Array object from a number.
 * @description
 * `null`/`undefined`/`NaN` inputs returns an empty `Uint8Array` result. `number` input values return the actual bytes value converted to a `Uint8Array`. With `bitLength`, it converts the value to the equivalent size.
 * @example
 * <BR>
 *
 * ```javascript
 * import { numberToU8a } from '@polkadot/util';
 *
 * numberToU8a(0x1234); // => [0x12, 0x34]
 * ```
 */ parcelHelpers.export(exports, "numberToU8a", ()=>numberToU8a);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toU8AJs = require("../hex/toU8a.js");
var _toHexJs = require("./toHex.js");
function numberToU8a(value, bitLength = -1) {
    return value === undefined || value === null || isNaN(value) ? new Uint8Array() : (0, _toU8AJs.hexToU8a)((0, _toHexJs.numberToHex)(value, bitLength));
}

},{"../hex/toU8a.js":"g5dk6","./toHex.js":"hFsoY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iYuNH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "objectClear", ()=>(0, _clearJs.objectClear));
parcelHelpers.export(exports, "objectCopy", ()=>(0, _copyJs.objectCopy));
parcelHelpers.export(exports, "objectEntries", ()=>(0, _entriesJs.objectEntries));
parcelHelpers.export(exports, "objectKeys", ()=>(0, _keysJs.objectKeys));
parcelHelpers.export(exports, "objectProperty", ()=>(0, _propertyJs.objectProperty));
parcelHelpers.export(exports, "objectProperties", ()=>(0, _propertyJs.objectProperties));
parcelHelpers.export(exports, "objectSpread", ()=>(0, _spreadJs.objectSpread));
parcelHelpers.export(exports, "objectValues", ()=>(0, _valuesJs.objectValues));
var _clearJs = require("./clear.js");
var _copyJs = require("./copy.js");
var _entriesJs = require("./entries.js");
var _keysJs = require("./keys.js");
var _propertyJs = require("./property.js");
var _spreadJs = require("./spread.js");
var _valuesJs = require("./values.js");

},{"./clear.js":"f0GFo","./copy.js":"f1c7V","./entries.js":"4MElO","./keys.js":"euwYJ","./property.js":"6M1eI","./spread.js":"fM6GI","./values.js":"8FwSl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f0GFo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name objectClear
 * @summary Removes all the keys from the input object
 */ parcelHelpers.export(exports, "objectClear", ()=>objectClear);
function objectClear(value) {
    const keys = Object.keys(value);
    for(let i = 0; i < keys.length; i++)delete value[keys[i]];
    return value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f1c7V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name objectCopy
 * @summary Creates a shallow clone of the input object
 */ parcelHelpers.export(exports, "objectCopy", ()=>objectCopy);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _spreadJs = require("./spread.js");
function objectCopy(source) {
    return (0, _spreadJs.objectSpread)({}, source);
}

},{"./spread.js":"fM6GI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fM6GI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name objectSpread
 * @summary Concats all sources into the destination
 */ parcelHelpers.export(exports, "objectSpread", ()=>objectSpread);
function objectSpread(dest, ...sources) {
    for(let i = 0; i < sources.length; i++){
        const src = sources[i];
        if (src) {
            if (typeof src.entries === "function") for (const [key, value] of src.entries())dest[key] = value;
            else Object.assign(dest, src);
        }
    }
    return dest;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4MElO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name objectEntries
 * @summary A version of Object.entries that is typed for TS
 */ parcelHelpers.export(exports, "objectEntries", ()=>objectEntries);
function objectEntries(obj) {
    return Object.entries(obj);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"euwYJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name objectKeys
 * @summary A version of Object.keys that is typed for TS
 */ parcelHelpers.export(exports, "objectKeys", ()=>objectKeys);
function objectKeys(value) {
    return Object.keys(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6M1eI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name objectProperty
 * @summary Assign a get property on the input object
 */ parcelHelpers.export(exports, "objectProperty", ()=>objectProperty);
/**
 * @name objectProperties
 * @summary Assign get properties on the input object
 */ parcelHelpers.export(exports, "objectProperties", ()=>objectProperties);
function objectProperty(that, key, getter, getName, index = 0) {
    const name = getName ? getName(key, index) : key; // There are 3 approaches here -
    //  - Object.prototype.hasOwnProperty.call(that, key) - this only checks the current class, i.e
    //    will retuirn false if the property is set in the parent class
    //  - isUndefined(...) - this may yield a false positive when the property is there, but not set.
    //    Additionally, on pre-defined getters it may make a call
    //  - key in that - Does not need to be combined with either of the above and checks the full chain
    if (!(name in that)) Object.defineProperty(that, name, {
        enumerable: true,
        // Unlike in lazy, we always call into the upper function, i.e. this method
        // does not cache old values (it is expected to be used for dynamic values)
        get: function() {
            return getter(key, index, this);
        }
    });
}
function objectProperties(that, keys, getter, getName) {
    for(let i = 0; i < keys.length; i++)objectProperty(that, keys[i], getter, getName, i);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8FwSl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name objectValues
 * @summary A version of Object.values that is typed for TS
 */ parcelHelpers.export(exports, "objectValues", ()=>objectValues);
function objectValues(obj) {
    return Object.values(obj);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dvS1W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name promisify
 * @summary Wraps an async callback into a `Promise`
 * @description
 * Wraps the supplied async function `fn` that has a standard JS callback `(error: Error, result: any)` into a `Promise`, passing the supplied parameters. When `error` is set, the Promise is rejected, else the Promise resolves with the `result` value.
 * @example
 * <BR>
 *
 * ```javascript
 * const { promisify } from '@polkadot/util';
 *
 * await promisify(null, ((a, cb) => cb(null, a), true); // resolves with `true`
 * await promisify(null, (cb) => cb(new Error('error!'))); // rejects with `error!`
 * ```
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
parcelHelpers.export(exports, "promisify", ()=>promisify);
function promisify(self, fn, ...params) {
    return new Promise((resolve, reject)=>{
        fn.apply(self, params.concat((error, result)=>{
            if (error) reject(error);
            else resolve(result);
        }));
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9jYpH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Utility methods to convert to work with `string` values
 */ parcelHelpers.export(exports, "stringCamelCase", ()=>(0, _camelCaseJs.stringCamelCase));
parcelHelpers.export(exports, "stringPascalCase", ()=>(0, _camelCaseJs.stringPascalCase));
parcelHelpers.export(exports, "stringLowerFirst", ()=>(0, _lowerFirstJs.stringLowerFirst));
parcelHelpers.export(exports, "stringUpperFirst", ()=>(0, _lowerFirstJs.stringUpperFirst));
parcelHelpers.export(exports, "stringShorten", ()=>(0, _shortenJs.stringShorten));
parcelHelpers.export(exports, "stringToHex", ()=>(0, _toHexJs.stringToHex));
parcelHelpers.export(exports, "stringToU8a", ()=>(0, _toU8AJs.stringToU8a));
var _camelCaseJs = require("./camelCase.js");
var _lowerFirstJs = require("./lowerFirst.js");
var _shortenJs = require("./shorten.js");
var _toHexJs = require("./toHex.js");
var _toU8AJs = require("./toU8a.js");

},{"./camelCase.js":"bTkUv","./lowerFirst.js":"7RE6y","./shorten.js":"bFt6A","./toHex.js":"cRe5F","./toU8a.js":"eeJou","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bTkUv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CC_TO_UP", ()=>CC_TO_UP);
parcelHelpers.export(exports, "CC_TO_LO", ()=>CC_TO_LO);
parcelHelpers.export(exports, "stringCamelCase", ()=>stringCamelCase);
parcelHelpers.export(exports, "stringPascalCase", ()=>stringPascalCase);
const CC_TO_UP = new Array(256);
const CC_TO_LO = new Array(256);
for(let i = 0; i < CC_TO_UP.length; i++){
    CC_TO_LO[i] = String.fromCharCode(i).toLowerCase();
    CC_TO_UP[i] = String.fromCharCode(i).toUpperCase();
}
/** @internal */ function formatAllCaps(w) {
    return w.slice(0, w.length - 1).toLowerCase() + CC_TO_UP[w.charCodeAt(w.length - 1)];
}
/**
 * @internal
 *
 * Inspired by https://stackoverflow.com/a/2970667
 *
 * This is not as optimal as the original SO answer (we split into per-word),
 * however it does pass the tests (which the SO version doesn't) and is still
 * a major improvement over the original camelcase npm package -
 *
 *   camelcase: 20.88 Œºs/op
 *        this:  1.00 Œºs/op
 *
 * Caveat of this: only Ascii, but acceptable for the intended usecase
 */ function converter(format) {
    return (value)=>{
        const parts = value // replace all seperators (including consequtive) with spaces
        .replace(/[-_., ]+/g, " ") // we don't want leading or trailing spaces
        .trim() // split into words
        .split(" ");
        const count = parts.length;
        let result = "";
        for(let i = 0; i < count; i++){
            const w = parts[i]; // apply the formatting
            result += format(/^[\dA-Z]+$/.test(w) // all full uppercase + letters are changed to lowercase
             ? w.toLowerCase() // all consecutive capitals + letters are changed to lowercase
             : w.replace(/^[\dA-Z]{2,}[^a-z]/, formatAllCaps), i);
        }
        return result;
    };
}
const stringCamelCase = converter((w, i)=>(i ? CC_TO_UP[w.charCodeAt(0)] : CC_TO_LO[w.charCodeAt(0)]) + w.slice(1));
const stringPascalCase = converter((w)=>CC_TO_UP[w.charCodeAt(0)] + w.slice(1));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7RE6y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringLowerFirst", ()=>stringLowerFirst);
parcelHelpers.export(exports, "stringUpperFirst", ()=>stringUpperFirst);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _camelCaseJs = require("./camelCase.js");
/** @internal */ function converter(map) {
    return (value)=>value ? map[value.charCodeAt(0)] + value.slice(1) : "";
}
const stringLowerFirst = converter((0, _camelCaseJs.CC_TO_LO));
const stringUpperFirst = converter((0, _camelCaseJs.CC_TO_UP));

},{"./camelCase.js":"bTkUv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bFt6A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name stringShorten
 * @summary Returns a string with maximum length
 * @description
 * Checks the string against the `prefixLength`, if longer than double this, shortens it by placing `..` in the middle of it
 * @example
 * <BR>
 *
 * ```javascript
 * import { stringShorten } from '@polkadot/util';
 *
 * stringShorten('1234567890', 2); // => 12..90
 * ```
 */ parcelHelpers.export(exports, "stringShorten", ()=>stringShorten);
function stringShorten(value, prefixLength = 6) {
    return value.length <= 2 + 2 * prefixLength ? value.toString() : `${value.substring(0, prefixLength)}‚Ä¶${value.slice(-prefixLength)}`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cRe5F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name stringToHex
 * @summary Creates a hex string from a utf-8 string
 * @description
 * String input values return the actual encoded hex value.
 * @example
 * <BR>
 *
 * ```javascript
 * import { stringToHex } from '@polkadot/util';
 *
 * stringToU8a('hello'); // 0x68656c6c6f
 * ```
 */ parcelHelpers.export(exports, "stringToHex", ()=>stringToHex);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _toHexJs = require("../u8a/toHex.js");
var _toU8AJs = require("./toU8a.js");
function stringToHex(value) {
    return (0, _toHexJs.u8aToHex)((0, _toU8AJs.stringToU8a)(value));
}

},{"../u8a/toHex.js":"cBjBN","./toU8a.js":"eeJou","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9TQUp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/api-derive/packageInfo");
var _packageInfo1 = require("@polkadot/rpc-core/packageInfo");
var _packageInfo2 = require("@polkadot/rpc-provider/packageInfo");
var _packageInfo3 = require("@polkadot/types/packageInfo");
var _packageInfo4 = require("@polkadot/types-known/packageInfo");
exports.default = [
    (0, _packageInfo.packageInfo),
    (0, _packageInfo1.packageInfo),
    (0, _packageInfo2.packageInfo),
    (0, _packageInfo3.packageInfo),
    (0, _packageInfo4.packageInfo)
];

},{"@polkadot/api-derive/packageInfo":"bD5x4","@polkadot/rpc-core/packageInfo":"3xOtl","@polkadot/rpc-provider/packageInfo":"bkNCg","@polkadot/types/packageInfo":"cIucp","@polkadot/types-known/packageInfo":"kiObO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bD5x4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $8777a0d34e9a9df6$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/api-derive/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/api-derive",
    path: $8777a0d34e9a9df6$import_meta && "file:///node_modules/@polkadot/api-derive/packageInfo.js" ? new URL("file:///node_modules/@polkadot/api-derive/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/api-derive/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "8.14.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3xOtl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $294b9aeb89acee4a$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/rpc-core/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/rpc-core",
    path: $294b9aeb89acee4a$import_meta && "file:///node_modules/@polkadot/rpc-core/packageInfo.js" ? new URL("file:///node_modules/@polkadot/rpc-core/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/rpc-core/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "8.14.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bkNCg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $84080cb15e86384b$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/rpc-provider/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/rpc-provider",
    path: $84080cb15e86384b$import_meta && "file:///node_modules/@polkadot/rpc-provider/packageInfo.js" ? new URL("file:///node_modules/@polkadot/rpc-provider/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/rpc-provider/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "8.14.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cIucp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $942104ff22a16d1c$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/types/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/types",
    path: $942104ff22a16d1c$import_meta && "file:///node_modules/@polkadot/types/packageInfo.js" ? new URL("file:///node_modules/@polkadot/types/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/types/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "8.14.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kiObO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $ec7c6ba94ba72554$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/types-known/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/types-known",
    path: $ec7c6ba94ba72554$import_meta && "file:///node_modules/@polkadot/types-known/packageInfo.js" ? new URL("file:///node_modules/@polkadot/types-known/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/types-known/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "8.14.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1czuv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $0e027133a0ad358d$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/api/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/api",
    path: $0e027133a0ad358d$import_meta && "file:///node_modules/@polkadot/api/packageInfo.js" ? new URL("file:///node_modules/@polkadot/api/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/api/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "8.14.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"18vg0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Keyring", ()=>(0, _keyring.Keyring));
parcelHelpers.export(exports, "WsProvider", ()=>(0, _rpcProvider.WsProvider));
parcelHelpers.export(exports, "HttpProvider", ()=>(0, _rpcProvider.HttpProvider));
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
parcelHelpers.export(exports, "SubmittableResult", ()=>(0, _indexJs.SubmittableResult));
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rpcAugment = require("@polkadot/rpc-augment");
var _keyring = require("@polkadot/keyring");
var _rpcProvider = require("@polkadot/rpc-provider");
var _packageInfoJs = require("./packageInfo.js");
var _indexJs = require("./submittable/index.js");
var _indexJs1 = require("./promise/index.js");
parcelHelpers.exportAll(_indexJs1, exports);
var _indexJs2 = require("./rx/index.js");
parcelHelpers.exportAll(_indexJs2, exports);

},{"@polkadot/rpc-augment":"cYKme","@polkadot/keyring":"4nPMm","@polkadot/rpc-provider":"bvUtj","./packageInfo.js":"1czuv","./submittable/index.js":"IVbyl","./promise/index.js":"7tNjd","./rx/index.js":"7Nj2E","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cYKme":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-augment authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"a4ou1","./bundle.js":"9cqbF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a4ou1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/rpc-augment authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"1yYvs","./packageInfo.js":"kBoEK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1yYvs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-augment authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/rpc-core/packageInfo");
var _packageInfo1 = require("@polkadot/types/packageInfo");
exports.default = [
    (0, _packageInfo.packageInfo),
    (0, _packageInfo1.packageInfo)
];

},{"@polkadot/rpc-core/packageInfo":"3xOtl","@polkadot/types/packageInfo":"cIucp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kBoEK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $effa638d2be6b83a$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/rpc-augment/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/rpc-augment",
    path: $effa638d2be6b83a$import_meta && "file:///node_modules/@polkadot/rpc-augment/packageInfo.js" ? new URL("file:///node_modules/@polkadot/rpc-augment/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/rpc-augment/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "8.14.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9cqbF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
// Copyright 2017-2022 @polkadot/rpc-augment authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("./augment/index.js");
var _packageInfoJs = require("./packageInfo.js");

},{"./augment/index.js":"by6Iz","./packageInfo.js":"kBoEK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"by6Iz":[function(require,module,exports) {
// Copyright 2017-2022 @polkadot/rpc-augment authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _jsonrpcJs = require("./jsonrpc.js");

},{"./jsonrpc.js":"sHaCH"}],"sHaCH":[function(require,module,exports) {
// Auto-generated via `yarn polkadot-types-from-chain`, do not edit
/* eslint-disable */ // import type lookup before we augment - in some environments
// this is required to allow for ambient/previous definitions
var _jsonrpc = require("@polkadot/rpc-core/types/jsonrpc"); // declare module

},{"@polkadot/rpc-core/types/jsonrpc":"9zMul"}],"9zMul":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4nPMm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);
exports.default = (0, _bundleJs.Keyring);

},{"./detectPackage.js":"2pShn","./bundle.js":"4IBV9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2pShn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"ia2YG","./packageInfo.js":"6ZUvD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ia2YG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/util/packageInfo");
var _packageInfo1 = require("@polkadot/util-crypto/packageInfo");
exports.default = [
    (0, _packageInfo.packageInfo),
    (0, _packageInfo1.packageInfo)
];

},{"@polkadot/util/packageInfo":"6T6yl","@polkadot/util-crypto/packageInfo":"03o6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"03o6M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $00a2fb5eff5312f5$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/util-crypto/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/util-crypto",
    path: $00a2fb5eff5312f5$import_meta && "file:///node_modules/@polkadot/util-crypto/packageInfo.js" ? new URL("file:///node_modules/@polkadot/util-crypto/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/util-crypto/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "10.1.6"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6ZUvD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $51844628b1f6c31b$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/keyring/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/keyring",
    path: $51844628b1f6c31b$import_meta && "file:///node_modules/@polkadot/keyring/packageInfo.js" ? new URL("file:///node_modules/@polkadot/keyring/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/keyring/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "10.1.6"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4IBV9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeAddress", ()=>(0, _utilCrypto.decodeAddress));
parcelHelpers.export(exports, "encodeAddress", ()=>(0, _utilCrypto.encodeAddress));
parcelHelpers.export(exports, "setSS58Format", ()=>(0, _utilCrypto.setSS58Format));
parcelHelpers.export(exports, "createPair", ()=>(0, _indexJs.createPair));
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
parcelHelpers.export(exports, "createTestKeyring", ()=>(0, _testingJs.createTestKeyring));
parcelHelpers.export(exports, "createTestPairs", ()=>(0, _testingPairsJs.createTestPairs));
parcelHelpers.export(exports, "Keyring", ()=>(0, _keyringJs.Keyring));
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _keyringJs = require("./keyring.js");
var _utilCrypto = require("@polkadot/util-crypto");
var _defaultsJs = require("./defaults.js");
parcelHelpers.exportAll(_defaultsJs, exports);
var _indexJs = require("./pair/index.js");
var _packageInfoJs = require("./packageInfo.js");
var _testingJs = require("./testing.js");
var _testingPairsJs = require("./testingPairs.js");

},{"./keyring.js":"bVuzx","@polkadot/util-crypto":"f2ofx","./defaults.js":"8GAT6","./pair/index.js":"4L1Q8","./packageInfo.js":"6ZUvD","./testing.js":"cppCo","./testingPairs.js":"crdQq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bVuzx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * # @polkadot/keyring
 *
 * ## Overview
 *
 * @name Keyring
 * @summary Keyring management of user accounts
 * @description Allows generation of keyring pairs from a variety of input combinations, such as
 * json object containing account address or public key, account metadata, and account encoded using
 * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,
 * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.
 * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair
 * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform
 * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with
 * an account may be obtained using `toJson` accompanied by the account passphrase.
 */ parcelHelpers.export(exports, "Keyring", ()=>Keyring);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _defaultsJs = require("./defaults.js");
var _indexJs = require("./pair/index.js");
var _pairsJs = require("./pairs.js");
const PairFromSeed = {
    ecdsa: (seed)=>(0, _utilCrypto.secp256k1PairFromSeed)(seed),
    ed25519: (seed)=>(0, _utilCrypto.ed25519PairFromSeed)(seed),
    ethereum: (seed)=>(0, _utilCrypto.secp256k1PairFromSeed)(seed),
    sr25519: (seed)=>(0, _utilCrypto.sr25519PairFromSeed)(seed)
};
function pairToPublic({ publicKey  }) {
    return publicKey;
}
class Keyring {
    #pairs;
    #type;
    #ss58;
    decodeAddress = (0, _utilCrypto.decodeAddress);
    constructor(options = {}){
        options.type = options.type || "ed25519";
        if (![
            "ecdsa",
            "ethereum",
            "ed25519",
            "sr25519"
        ].includes(options.type || "undefined")) throw new Error(`Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || "unknown"}`);
        this.#pairs = new (0, _pairsJs.Pairs)();
        this.#ss58 = options.ss58Format;
        this.#type = options.type;
    }
    /**
   * @description retrieve the pairs (alias for getPairs)
   */ get pairs() {
        return this.getPairs();
    }
    /**
   * @description retrieve the publicKeys (alias for getPublicKeys)
   */ get publicKeys() {
        return this.getPublicKeys();
    }
    /**
   * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa
   */ get type() {
        return this.#type;
    }
    /**
   * @name addPair
   * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   */ addPair(pair) {
        return this.#pairs.add(pair);
    }
    /**
   * @name addFromAddress
   * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally
   * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file
   * of an account backup), and then generates a keyring pair from them that it passes to
   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */ addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {
        const publicKey = this.decodeAddress(address, ignoreChecksum);
        return this.addPair((0, _indexJs.createPair)({
            toSS58: this.encodeAddress,
            type
        }, {
            publicKey,
            secretKey: new Uint8Array()
        }, meta, encoded, encType));
    }
    /**
   * @name addFromJson
   * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file
   * of an account backup), and then generates a keyring pair from it that it passes to
   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */ addFromJson(json, ignoreChecksum) {
        return this.addPair(this.createFromJson(json, ignoreChecksum));
    }
    /**
   * @name addFromMnemonic
   * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)
   * argument and a metadata argument that contains account information (that may be obtained from the json file
   * of an account backup), and then generates a keyring pair from it that it passes to
   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */ addFromMnemonic(mnemonic, meta = {}, type = this.type) {
        return this.addFromUri(mnemonic, meta, type);
    }
    /**
   * @name addFromPair
   * @summary Stores an account created from an explicit publicKey/secreteKey combination
   */ addFromPair(pair, meta = {}, type = this.type) {
        return this.addPair(this.createFromPair(pair, meta, type));
    }
    /**
   * @name addFromSeed
   * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.
   * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to
   * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */ addFromSeed(seed, meta = {}, type = this.type) {
        return this.addPair((0, _indexJs.createPair)({
            toSS58: this.encodeAddress,
            type
        }, PairFromSeed[type](seed), meta, null));
    }
    /**
   * @name addFromUri
   * @summary Creates an account via an suri
   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)
   */ addFromUri(suri, meta = {}, type = this.type) {
        return this.addPair(this.createFromUri(suri, meta, type));
    }
    /**
   * @name createFromJson
   * @description Creates a pair from a JSON keyfile
   */ createFromJson({ address , encoded , encoding: { content , type , version  } , meta  }, ignoreChecksum) {
        if (version === "3" && content[0] !== "pkcs8") throw new Error(`Unable to decode non-pkcs8 type, [${content.join(",")}] found}`);
        const cryptoType = version === "0" || !Array.isArray(content) ? this.type : content[1];
        const encType = !Array.isArray(type) ? [
            type
        ] : type;
        if (![
            "ed25519",
            "sr25519",
            "ecdsa",
            "ethereum"
        ].includes(cryptoType)) throw new Error(`Unknown crypto type ${cryptoType}`);
         // Here the address and publicKey are 32 bytes and isomorphic. This is why the address field needs to be the public key for ethereum type pairs
        const publicKey = (0, _util.isHex)(address) ? (0, _util.hexToU8a)(address) : this.decodeAddress(address, ignoreChecksum);
        const decoded = (0, _util.isHex)(encoded) ? (0, _util.hexToU8a)(encoded) : (0, _utilCrypto.base64Decode)(encoded);
        return (0, _indexJs.createPair)({
            toSS58: this.encodeAddress,
            type: cryptoType
        }, {
            publicKey,
            secretKey: new Uint8Array()
        }, meta, decoded, encType);
    }
    /**
   * @name createFromPair
   * @summary Creates a pair from an explicit publicKey/secreteKey combination
   */ createFromPair(pair, meta = {}, type = this.type) {
        return (0, _indexJs.createPair)({
            toSS58: this.encodeAddress,
            type
        }, pair, meta, null);
    }
    /**
   * @name createFromUri
   * @summary Creates a Keypair from an suri
   * @description This creates a pair from the suri, but does not add it to the keyring
   */ createFromUri(_suri, meta = {}, type = this.type) {
        // here we only aut-add the dev phrase if we have a hard-derived path
        const suri = _suri.startsWith("//") ? `${0, _defaultsJs.DEV_PHRASE}${_suri}` : _suri;
        const { derivePath , password , path , phrase  } = (0, _utilCrypto.keyExtractSuri)(suri);
        let seed;
        const isPhraseHex = (0, _util.isHex)(phrase, 256);
        if (isPhraseHex) seed = (0, _util.hexToU8a)(phrase);
        else {
            const parts = phrase.split(" ");
            if ([
                12,
                15,
                18,
                21,
                24
            ].includes(parts.length)) seed = type === "ethereum" ? (0, _utilCrypto.mnemonicToLegacySeed)(phrase, "", false, 64) : (0, _utilCrypto.mnemonicToMiniSecret)(phrase, password);
            else {
                if (phrase.length > 32) throw new Error("specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes");
                seed = (0, _util.stringToU8a)(phrase.padEnd(32));
            }
        }
        const derived = type === "ethereum" ? isPhraseHex ? PairFromSeed[type](seed) // for eth, if the private key is provided as suri, it must be derived only once
         : (0, _utilCrypto.hdEthereum)(seed, derivePath.substring(1)) : (0, _utilCrypto.keyFromPath)(PairFromSeed[type](seed), path, type);
        return (0, _indexJs.createPair)({
            toSS58: this.encodeAddress,
            type
        }, derived, meta, null);
    }
    /**
   * @name encodeAddress
   * @description Encodes the input into an ss58 representation
   */ encodeAddress = (address, ss58Format)=>{
        return this.type === "ethereum" ? (0, _utilCrypto.ethereumEncode)(address) : (0, _utilCrypto.encodeAddress)(address, ss58Format === undefined ? this.#ss58 : ss58Format);
    };
    /**
   * @name getPair
   * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address
   * @description Returns a keyring pair value from the keyring pair dictionary by performing
   * a key lookup using the provided account address or public key (after decoding it).
   */ getPair(address) {
        return this.#pairs.get(address);
    }
    /**
   * @name getPairs
   * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary
   * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.
   */ getPairs() {
        return this.#pairs.all();
    }
    /**
   * @name getPublicKeys
   * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary
   * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.
   */ getPublicKeys() {
        return this.#pairs.all().map(pairToPublic);
    }
    /**
   * @name removePair
   * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.
   */ removePair(address) {
        this.#pairs.remove(address);
    }
    /**
   * @name setSS58Format;
   * @description Sets the ss58 format for the keyring
   */ setSS58Format(ss58) {
        this.#ss58 = ss58;
    }
    /**
   * @name toJson
   * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account
   * @description Returns a JSON object containing the metadata associated with an account
   * when valid address or public key and when the account passphrase is provided if the account secret
   * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user
   * may backup their account to a JSON file that contains this information.
   */ toJson(address, passphrase) {
        return this.#pairs.get(address).toJson(passphrase);
    }
}

},{"@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","./defaults.js":"8GAT6","./pair/index.js":"4L1Q8","./pairs.js":"dmmGz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f2ofx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"i6LDK","./bundle.js":"hTYop","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i6LDK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"fhqpe","./packageInfo.js":"03o6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fhqpe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/networks/packageInfo");
var _packageInfo1 = require("@polkadot/util/packageInfo");
var _xRandomvalues = require("@polkadot/x-randomvalues");
exports.default = [
    (0, _packageInfo.packageInfo),
    (0, _packageInfo1.packageInfo),
    (0, _xRandomvalues.packageInfo)
];

},{"@polkadot/networks/packageInfo":"599GG","@polkadot/util/packageInfo":"6T6yl","@polkadot/x-randomvalues":"jhlDT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"599GG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $3bf54ec1cc8d51ee$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/networks/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/networks",
    path: $3bf54ec1cc8d51ee$import_meta && "file:///node_modules/@polkadot/networks/packageInfo.js" ? new URL("file:///node_modules/@polkadot/networks/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/networks/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "10.1.6"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jhlDT":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getRandomValues = getRandomValues;
Object.defineProperty(exports, "packageInfo", {
    enumerable: true,
    get: function() {
        return _packageInfo.packageInfo;
    }
});
var _xGlobal = require("@polkadot/x-global");
var _packageInfo = require("./packageInfo");
// Copyright 2017-2022 @polkadot/x-randomvalues authors & contributors
// SPDX-License-Identifier: Apache-2.0
function getRandomValues(arr) {
    // We use x-global here - this prevents packagers such as rollup
    // confusing this with the "normal" Node.js import and stubbing it
    // (and also aligns with eg. x-fetch, where x-global is used)
    return _xGlobal.xglobal.crypto.getRandomValues(arr);
}

},{"@polkadot/x-global":"k9Iwp","./packageInfo":"5S6Zi"}],"5S6Zi":[function(require,module,exports) {
"use strict";
var __dirname = "node_modules/@polkadot/x-randomvalues/cjs";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.packageInfo = void 0;
// Copyright 2017-2022 @polkadot/x-randomvalues authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
const packageInfo = {
    name: "@polkadot/x-randomvalues",
    path: typeof __dirname === "string" ? __dirname : "auto",
    type: "cjs",
    version: "10.1.6"
};
exports.packageInfo = packageInfo;

},{}],"hTYop":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo)) // all internal exports
;
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bundleInitJs = require("./bundleInit.js");
var _packageInfoJs = require("./packageInfo.js");
var _indexJs = require("./address/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var _indexJs1 = require("./base32/index.js");
parcelHelpers.exportAll(_indexJs1, exports);
var _indexJs2 = require("./base58/index.js");
parcelHelpers.exportAll(_indexJs2, exports);
var _indexJs3 = require("./base64/index.js");
parcelHelpers.exportAll(_indexJs3, exports);
var _indexJs4 = require("./blake2/index.js");
parcelHelpers.exportAll(_indexJs4, exports);
var _cryptoJs = require("./crypto.js");
parcelHelpers.exportAll(_cryptoJs, exports);
var _indexJs5 = require("./ed25519/index.js");
parcelHelpers.exportAll(_indexJs5, exports);
var _indexJs6 = require("./ethereum/index.js");
parcelHelpers.exportAll(_indexJs6, exports);
var _indexJs7 = require("./hd/index.js");
parcelHelpers.exportAll(_indexJs7, exports);
var _indexJs8 = require("./hmac/index.js");
parcelHelpers.exportAll(_indexJs8, exports);
var _indexJs9 = require("./json/index.js");
parcelHelpers.exportAll(_indexJs9, exports);
var _indexJs10 = require("./keccak/index.js");
parcelHelpers.exportAll(_indexJs10, exports);
var _indexJs11 = require("./key/index.js");
parcelHelpers.exportAll(_indexJs11, exports);
var _indexJs12 = require("./mnemonic/index.js");
parcelHelpers.exportAll(_indexJs12, exports);
var _networksJs = require("./networks.js");
parcelHelpers.exportAll(_networksJs, exports);
var _indexJs13 = require("./nacl/index.js");
parcelHelpers.exportAll(_indexJs13, exports);
var _indexJs14 = require("./pbkdf2/index.js");
parcelHelpers.exportAll(_indexJs14, exports);
var _indexJs15 = require("./random/index.js");
parcelHelpers.exportAll(_indexJs15, exports);
var _indexJs16 = require("./scrypt/index.js");
parcelHelpers.exportAll(_indexJs16, exports);
var _indexJs17 = require("./secp256k1/index.js");
parcelHelpers.exportAll(_indexJs17, exports);
var _indexJs18 = require("./sha/index.js");
parcelHelpers.exportAll(_indexJs18, exports);
var _indexJs19 = require("./signature/index.js");
parcelHelpers.exportAll(_indexJs19, exports);
var _indexJs20 = require("./sr25519/index.js");
parcelHelpers.exportAll(_indexJs20, exports);
var _indexJs21 = require("./xxhash/index.js");
parcelHelpers.exportAll(_indexJs21, exports);

},{"./bundleInit.js":"e8E8G","./packageInfo.js":"03o6M","./address/index.js":"j5ZWw","./base32/index.js":"4vQZG","./base58/index.js":"kXPnW","./base64/index.js":"dCLyq","./blake2/index.js":"fBtmb","./crypto.js":"3GspH","./ed25519/index.js":"k5xh0","./ethereum/index.js":"huQFg","./hd/index.js":"51OaL","./hmac/index.js":"6zSTS","./json/index.js":"8mFM3","./keccak/index.js":"6zB64","./key/index.js":"4L2pj","./mnemonic/index.js":"7079C","./networks.js":"fgfoM","./nacl/index.js":"cX2uo","./pbkdf2/index.js":"7ynC4","./random/index.js":"63e69","./scrypt/index.js":"lhRfY","./secp256k1/index.js":"iZGLu","./sha/index.js":"erzH4","./signature/index.js":"dyqtj","./sr25519/index.js":"2JBt4","./xxhash/index.js":"9J4uy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e8E8G":[function(require,module,exports) {
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _shim = require("@polkadot/x-bigint/shim");
var _secp256K1 = require("@noble/secp256k1");
var _util = require("@polkadot/util");
var _cryptoJs = require("./crypto.js");
var _indexJs = require("./hmac/index.js"); // Set overrides on the secp256k1 utils
//   - hmacShaSync - This needs to be set, unset by default
(0, _secp256K1.utils).hmacSha256Sync = (key, ...messages)=>(0, _indexJs.hmacSha256AsU8a)(key, (0, _util.u8aConcat)(...messages)); // start init process immediately
(0, _cryptoJs.cryptoWaitReady)().catch(()=>{});

},{"@polkadot/x-bigint/shim":"5tCiY","@noble/secp256k1":"eyYsH","@polkadot/util":"3HnHw","./crypto.js":"3GspH","./hmac/index.js":"6zSTS"}],"5tCiY":[function(require,module,exports) {
// Copyright 2017-2022 @polkadot/x-bigint authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xBigint = require("@polkadot/x-bigint");
var _xGlobal = require("@polkadot/x-global");
(0, _xGlobal.exposeGlobal)("BigInt", (0, _xBigint.BigInt));

},{"@polkadot/x-bigint":"6Blk3","@polkadot/x-global":"k9Iwp"}],"eyYsH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CURVE", ()=>CURVE);
parcelHelpers.export(exports, "Point", ()=>Point);
parcelHelpers.export(exports, "Signature", ()=>Signature);
parcelHelpers.export(exports, "getPublicKey", ()=>getPublicKey);
parcelHelpers.export(exports, "recoverPublicKey", ()=>recoverPublicKey);
parcelHelpers.export(exports, "getSharedSecret", ()=>getSharedSecret);
parcelHelpers.export(exports, "sign", ()=>sign);
parcelHelpers.export(exports, "signSync", ()=>signSync);
parcelHelpers.export(exports, "verify", ()=>verify);
parcelHelpers.export(exports, "schnorr", ()=>schnorr);
parcelHelpers.export(exports, "utils", ()=>utils);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ var _crypto = require("crypto");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _3n = BigInt(3);
const _8n = BigInt(8);
const POW_2_256 = _2n ** BigInt(256);
const CURVE = {
    a: _0n,
    b: BigInt(7),
    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),
    n: POW_2_256 - BigInt("432420386565659656852420866394968145599"),
    h: _1n,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
};
function weistrass(x) {
    const { a , b  } = CURVE;
    const x2 = mod(x * x);
    const x3 = mod(x2 * x);
    return mod(x3 + a * x + b);
}
const USE_ENDOMORPHISM = CURVE.a === _0n;
class JacobianPoint {
    constructor(x, y, z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    static fromAffine(p) {
        if (!(p instanceof Point)) throw new TypeError("JacobianPoint#fromAffine: expected Point");
        return new JacobianPoint(p.x, p.y, _1n);
    }
    static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p)=>p.z));
        return points.map((p, i)=>p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
    equals(other) {
        if (!(other instanceof JacobianPoint)) throw new TypeError("JacobianPoint expected");
        const { x: X1 , y: Y1 , z: Z1  } = this;
        const { x: X2 , y: Y2 , z: Z2  } = other;
        const Z1Z1 = mod(Z1 ** _2n);
        const Z2Z2 = mod(Z2 ** _2n);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
    }
    negate() {
        return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
    double() {
        const { x: X1 , y: Y1 , z: Z1  } = this;
        const A = mod(X1 ** _2n);
        const B = mod(Y1 ** _2n);
        const C = mod(B ** _2n);
        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));
        const E = mod(_3n * A);
        const F = mod(E ** _2n);
        const X3 = mod(F - _2n * D);
        const Y3 = mod(E * (D - X3) - _8n * C);
        const Z3 = mod(_2n * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
    }
    add(other) {
        if (!(other instanceof JacobianPoint)) throw new TypeError("JacobianPoint expected");
        const { x: X1 , y: Y1 , z: Z1  } = this;
        const { x: X2 , y: Y2 , z: Z2  } = other;
        if (X2 === _0n || Y2 === _0n) return this;
        if (X1 === _0n || Y1 === _0n) return other;
        const Z1Z1 = mod(Z1 ** _2n);
        const Z2Z2 = mod(Z2 ** _2n);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        const H = mod(U2 - U1);
        const r = mod(S2 - S1);
        if (H === _0n) {
            if (r === _0n) return this.double();
            else return JacobianPoint.ZERO;
        }
        const HH = mod(H ** _2n);
        const HHH = mod(H * HH);
        const V = mod(U1 * HH);
        const X3 = mod(r ** _2n - HHH - _2n * V);
        const Y3 = mod(r * (V - X3) - S1 * HHH);
        const Z3 = mod(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiplyUnsafe(scalar) {
        const P0 = JacobianPoint.ZERO;
        if (typeof scalar === "bigint" && scalar === _0n) return P0;
        let n = normalizeScalar(scalar);
        if (n === _1n) return this;
        if (!USE_ENDOMORPHISM) {
            let p = P0;
            let d = this;
            while(n > _0n){
                if (n & _1n) p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        }
        let { k1neg , k1 , k2neg , k2  } = splitScalarEndo(n);
        let k1p = P0;
        let k2p = P0;
        let d1 = this;
        while(k1 > _0n || k2 > _0n){
            if (k1 & _1n) k1p = k1p.add(d1);
            if (k2 & _1n) k2p = k2p.add(d1);
            d1 = d1.double();
            k1 >>= _1n;
            k2 >>= _1n;
        }
        if (k1neg) k1p = k1p.negate();
        if (k2neg) k2p = k2p.negate();
        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
    }
    precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base = p;
        for(let window = 0; window < windows; window++){
            base = p;
            points.push(base);
            for(let i = 1; i < 2 ** (W - 1); i++){
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
                precomputes = JacobianPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
            }
        }
        let p = JacobianPoint.ZERO;
        let f = JacobianPoint.ZERO;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for(let window = 0; window < windows; window++){
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
            }
            if (wbits === 0) {
                let pr = precomputes[offset];
                if (window % 2) pr = pr.negate();
                f = f.add(pr);
            } else {
                let cached = precomputes[offset + Math.abs(wbits) - 1];
                if (wbits < 0) cached = cached.negate();
                p = p.add(cached);
            }
        }
        return {
            p,
            f
        };
    }
    multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
            const { k1neg , k1 , k2neg , k2  } = splitScalarEndo(n);
            let { p: k1p , f: f1p  } = this.wNAF(k1, affinePoint);
            let { p: k2p , f: f2p  } = this.wNAF(k2, affinePoint);
            if (k1neg) k1p = k1p.negate();
            if (k2neg) k2p = k2p.negate();
            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
        } else {
            const { p , f  } = this.wNAF(n, affinePoint);
            point = p;
            fake = f;
        }
        return JacobianPoint.normalizeZ([
            point,
            fake
        ])[0];
    }
    toAffine(invZ = invert(this.z)) {
        const { x , y , z  } = this;
        const iz1 = invZ;
        const iz2 = mod(iz1 * iz1);
        const iz3 = mod(iz2 * iz1);
        const ax = mod(x * iz2);
        const ay = mod(y * iz3);
        const zz = mod(z * iz1);
        if (zz !== _1n) throw new Error("invZ was invalid");
        return new Point(ax, ay);
    }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
const pointPrecomputes = new WeakMap();
class Point {
    constructor(x, y){
        this.x = x;
        this.y = y;
    }
    _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
    }
    static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x)) throw new Error("Point is not on curve");
        const y2 = weistrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n) === _1n;
        if (isShort) {
            if (isYOdd) y = mod(-y);
        } else {
            const isFirstByteOdd = (bytes[0] & 1) === 1;
            if (isFirstByteOdd !== isYOdd) y = mod(-y);
        }
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromUncompressedHex(bytes) {
        const x = bytesToNumber(bytes.subarray(1, 33));
        const y = bytesToNumber(bytes.subarray(33, 65));
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === 32 || len === 33 && (header === 0x02 || header === 0x03)) return this.fromCompressedHex(bytes);
        if (len === 65 && header === 0x04) return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
    }
    static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
    static fromSignature(msgHash, signature, recovery) {
        msgHash = ensureBytes(msgHash);
        const h = truncateHash(msgHash);
        const { r , s  } = normalizeSignature(signature);
        if (recovery !== 0 && recovery !== 1) throw new Error("Cannot recover signature: invalid recovery bit");
        const prefix = recovery & 1 ? "03" : "02";
        const R = Point.fromHex(prefix + numTo32bStr(r));
        const { n  } = CURVE;
        const rinv = invert(r, n);
        const u1 = mod(-h * rinv, n);
        const u2 = mod(s * rinv, n);
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q) throw new Error("Cannot recover signature: point at infinify");
        Q.assertValidity();
        return Q;
    }
    toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
            const prefix = this.y & _1n ? "03" : "02";
            return `${prefix}${x}`;
        } else return `04${x}${numTo32bStr(this.y)}`;
    }
    toHexX() {
        return this.toHex(true).slice(2);
    }
    toRawX() {
        return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
        const msg = "Point is not on elliptic curve";
        const { x , y  } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);
        const left = mod(y * y);
        const right = weistrass(x);
        if (mod(left - right) !== _0n) throw new Error(msg);
    }
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    negate() {
        return new Point(this.x, mod(-this.y));
    }
    double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
    }
    add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
    multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
    }
}
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
    return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
}
function parseDERInt(data) {
    if (data.length < 2 || data[0] !== 0x02) throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len) throw new Error(`Invalid signature integer: wrong length`);
    if (res[0] === 0x00 && res[1] <= 0x7f) throw new Error("Invalid signature integer: trailing length");
    return {
        data: bytesToNumber(res),
        left: data.subarray(len + 2)
    };
}
function parseDERSignature(data) {
    if (data.length < 2 || data[0] != 0x30) throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
    if (data[1] !== data.length - 2) throw new Error("Invalid signature: incorrect length");
    const { data: r , left: sBytes  } = parseDERInt(data.subarray(2));
    const { data: s , left: rBytesLeft  } = parseDERInt(sBytes);
    if (rBytesLeft.length) throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
    return {
        r,
        s
    };
}
class Signature {
    constructor(r, s){
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromCompact(hex) {
        const arr = isUint8a(hex);
        const name = "Signature.fromCompact";
        if (typeof hex !== "string" && !arr) throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128) throw new Error(`${name}: Expected 64-byte hex`);
        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
    }
    static fromDER(hex) {
        const arr = isUint8a(hex);
        if (typeof hex !== "string" && !arr) throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r , s  } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new Signature(r, s);
    }
    static fromHex(hex) {
        return this.fromDER(hex);
    }
    assertValidity() {
        const { r , s  } = this;
        if (!isWithinCurveOrder(r)) throw new Error("Invalid Signature: r must be 0 < r < n");
        if (!isWithinCurveOrder(s)) throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
    }
    normalizeS() {
        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;
    }
    toDERRawBytes(isCompressed = false) {
        return hexToBytes(this.toDERHex(isCompressed));
    }
    toDERHex(isCompressed = false) {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        if (isCompressed) return sHex;
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const rLen = numberToHexUnpadded(rHex.length / 2);
        const sLen = numberToHexUnpadded(sHex.length / 2);
        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
    }
    toRawBytes() {
        return this.toDERRawBytes();
    }
    toHex() {
        return this.toDERHex();
    }
    toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
}
function concatBytes(...arrays) {
    if (!arrays.every(isUint8a)) throw new Error("Uint8Array list expected");
    if (arrays.length === 1) return arrays[0];
    const length = arrays.reduce((a, arr)=>a + arr.length, 0);
    const result = new Uint8Array(length);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function isUint8a(bytes) {
    return bytes instanceof Uint8Array;
}
const hexes = Array.from({
    length: 256
}, (v, i)=>i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    let hex = "";
    for(let i = 0; i < uint8a.length; i++)hex += hexes[uint8a[i]];
    return hex;
}
function numTo32bStr(num) {
    if (num > POW_2_256) throw new Error("Expected number < 2^256");
    return num.toString(16).padStart(64, "0");
}
function numTo32b(num) {
    return hexToBytes(numTo32bStr(num));
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== "string") throw new TypeError("hexToNumber: expected string, got " + typeof hex);
    return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
    if (typeof hex !== "string") throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    if (hex.length % 2) throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
    const array = new Uint8Array(hex.length / 2);
    for(let i = 0; i < array.length; i++){
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) throw new Error("Invalid byte sequence");
        array[i] = byte;
    }
    return array;
}
function bytesToNumber(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function ensureBytes(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
    if (typeof num === "number" && Number.isSafeInteger(num) && num > 0) return BigInt(num);
    if (typeof num === "bigint" && isWithinCurveOrder(num)) return num;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod(a, b = CURVE.P) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
function pow2(x, power) {
    const { P  } = CURVE;
    let res = x;
    while((power--) > _0n){
        res *= res;
        res %= P;
    }
    return res;
}
function sqrtMod(x) {
    const { P  } = CURVE;
    const _6n = BigInt(6);
    const _11n = BigInt(11);
    const _22n = BigInt(22);
    const _23n = BigInt(23);
    const _44n = BigInt(44);
    const _88n = BigInt(88);
    const b2 = x * x * x % P;
    const b3 = b2 * b2 * x % P;
    const b6 = pow2(b3, _3n) * b3 % P;
    const b9 = pow2(b6, _3n) * b3 % P;
    const b11 = pow2(b9, _2n) * b2 % P;
    const b22 = pow2(b11, _11n) * b11 % P;
    const b44 = pow2(b22, _22n) * b22 % P;
    const b88 = pow2(b44, _44n) * b44 % P;
    const b176 = pow2(b88, _88n) * b88 % P;
    const b220 = pow2(b176, _44n) * b44 % P;
    const b223 = pow2(b220, _3n) * b3 % P;
    const t1 = pow2(b223, _23n) * b22 % P;
    const t2 = pow2(t1, _6n) * b2 % P;
    return pow2(t2, _2n);
}
function invert(number, modulo = CURVE.P) {
    if (number === _0n || modulo <= _0n) throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n) throw new Error("invert: does not exist");
    return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
    const scratch = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i)=>{
        if (num === _0n) return acc;
        scratch[i] = acc;
        return mod(acc * num, p);
    }, _1n);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i)=>{
        if (num === _0n) return acc;
        scratch[i] = mod(acc * scratch[i], p);
        return mod(acc * num, p);
    }, inverted);
    return scratch;
}
const divNearest = (a, b)=>(a + b / _2n) / b;
const POW_2_128 = _2n ** BigInt(128);
function splitScalarEndo(k) {
    const { n  } = CURVE;
    const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
    const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
    const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
    const b2 = a1;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = mod(k - c1 * a1 - c2 * a2, n);
    let k2 = mod(-c1 * b1 - c2 * b2, n);
    const k1neg = k1 > POW_2_128;
    const k2neg = k2 > POW_2_128;
    if (k1neg) k1 = n - k1;
    if (k2neg) k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
    return {
        k1neg,
        k1,
        k2neg,
        k2
    };
}
function truncateHash(hash) {
    const { n  } = CURVE;
    const byteLength = hash.length;
    const delta = byteLength * 8 - 256;
    let h = bytesToNumber(hash);
    if (delta > 0) h = h >> BigInt(delta);
    if (h >= n) h -= n;
    return h;
}
class HmacDrbg {
    constructor(){
        this.v = new Uint8Array(32).fill(1);
        this.k = new Uint8Array(32).fill(0);
        this.counter = 0;
    }
    hmac(...values) {
        return utils.hmacSha256(this.k, ...values);
    }
    hmacSync(...values) {
        if (typeof utils.hmacSha256Sync !== "function") throw new Error("utils.hmacSha256Sync is undefined, you need to set it");
        const res = utils.hmacSha256Sync(this.k, ...values);
        if (res instanceof Promise) throw new Error("To use sync sign(), ensure utils.hmacSha256 is sync");
        return res;
    }
    incr() {
        if (this.counter >= 1000) throw new Error("Tried 1,000 k values for sign(), all were invalid");
        this.counter += 1;
    }
    async reseed(seed = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([
            0x00
        ]), seed);
        this.v = await this.hmac(this.v);
        if (seed.length === 0) return;
        this.k = await this.hmac(this.v, Uint8Array.from([
            0x01
        ]), seed);
        this.v = await this.hmac(this.v);
    }
    reseedSync(seed = new Uint8Array()) {
        this.k = this.hmacSync(this.v, Uint8Array.from([
            0x00
        ]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0) return;
        this.k = this.hmacSync(this.v, Uint8Array.from([
            0x01
        ]), seed);
        this.v = this.hmacSync(this.v);
    }
    async generate() {
        this.incr();
        this.v = await this.hmac(this.v);
        return this.v;
    }
    generateSync() {
        this.incr();
        this.v = this.hmacSync(this.v);
        return this.v;
    }
}
function isWithinCurveOrder(num) {
    return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
    return _0n < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d) {
    const k = bytesToNumber(kBytes);
    if (!isWithinCurveOrder(k)) return;
    const { n  } = CURVE;
    const q = Point.BASE.multiply(k);
    const r = mod(q.x, n);
    if (r === _0n) return;
    const s = mod(invert(k, n) * mod(m + d * r, n), n);
    if (s === _0n) return;
    const sig = new Signature(r, s);
    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
    return {
        sig,
        recovery
    };
}
function normalizePrivateKey(key) {
    let num;
    if (typeof key === "bigint") num = key;
    else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) num = BigInt(key);
    else if (typeof key === "string") {
        if (key.length !== 64) throw new Error("Expected 32 bytes of private key");
        num = hexToNumber(key);
    } else if (isUint8a(key)) {
        if (key.length !== 32) throw new Error("Expected 32 bytes of private key");
        num = bytesToNumber(key);
    } else throw new TypeError("Expected valid private key");
    if (!isWithinCurveOrder(num)) throw new Error("Expected private key: 0 < key < n");
    return num;
}
function normalizePublicKey(publicKey) {
    if (publicKey instanceof Point) {
        publicKey.assertValidity();
        return publicKey;
    } else return Point.fromHex(publicKey);
}
function normalizeSignature(signature) {
    if (signature instanceof Signature) {
        signature.assertValidity();
        return signature;
    }
    try {
        return Signature.fromDER(signature);
    } catch (error) {
        return Signature.fromCompact(signature);
    }
}
function getPublicKey(privateKey, isCompressed = false) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
}
function isPub(item) {
    const arr = isUint8a(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr) return len === 33 || len === 65;
    if (str) return len === 66 || len === 130;
    if (item instanceof Point) return true;
    return false;
}
function getSharedSecret(privateA, publicB, isCompressed = false) {
    if (isPub(privateA)) throw new TypeError("getSharedSecret: first arg must be private key");
    if (!isPub(publicB)) throw new TypeError("getSharedSecret: second arg must be public key");
    const b = normalizePublicKey(publicB);
    b.assertValidity();
    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
}
function bits2int(bytes) {
    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;
    return bytesToNumber(slice);
}
function bits2octets(bytes) {
    const z1 = bits2int(bytes);
    const z2 = mod(z1, CURVE.n);
    return int2octets(z2 < _0n ? z1 : z2);
}
function int2octets(num) {
    if (typeof num !== "bigint") throw new Error("Expected bigint");
    const hex = numTo32bStr(num);
    return hexToBytes(hex);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
    if (msgHash == null) throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
    const h1 = ensureBytes(msgHash);
    const d = normalizePrivateKey(privateKey);
    const seedArgs = [
        int2octets(d),
        bits2octets(h1)
    ];
    if (extraEntropy != null) {
        if (extraEntropy === true) extraEntropy = utils.randomBytes(32);
        const e = ensureBytes(extraEntropy);
        if (e.length !== 32) throw new Error("sign: Expected 32 bytes of extra data");
        seedArgs.push(e);
    }
    const seed = concatBytes(...seedArgs);
    const m = bits2int(h1);
    return {
        seed,
        m,
        d
    };
}
function finalizeSig(recSig, opts) {
    let { sig , recovery  } = recSig;
    const { canonical , der , recovered  } = Object.assign({
        canonical: true,
        der: true
    }, opts);
    if (canonical && sig.hasHighS()) {
        sig = sig.normalizeS();
        recovery ^= 1;
    }
    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
    return recovered ? [
        hashed,
        recovery
    ] : hashed;
}
async function sign(msgHash, privKey, opts = {}) {
    const { seed , m , d  } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    let sig;
    const drbg = new HmacDrbg();
    await drbg.reseed(seed);
    while(!(sig = kmdToSig(await drbg.generate(), m, d)))await drbg.reseed();
    return finalizeSig(sig, opts);
}
function signSync(msgHash, privKey, opts = {}) {
    const { seed , m , d  } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    let sig;
    const drbg = new HmacDrbg();
    drbg.reseedSync(seed);
    while(!(sig = kmdToSig(drbg.generateSync(), m, d)))drbg.reseedSync();
    return finalizeSig(sig, opts);
}
const vopts = {
    strict: true
};
function verify(signature, msgHash, publicKey, opts = vopts) {
    let sig;
    try {
        sig = normalizeSignature(signature);
        msgHash = ensureBytes(msgHash);
    } catch (error) {
        return false;
    }
    const { r , s  } = sig;
    if (opts.strict && sig.hasHighS()) return false;
    const h = truncateHash(msgHash);
    let P;
    try {
        P = normalizePublicKey(publicKey);
    } catch (error1) {
        return false;
    }
    const { n  } = CURVE;
    const sinv = invert(s, n);
    const u1 = mod(h * sinv, n);
    const u2 = mod(r * sinv, n);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
    if (!R) return false;
    const v = mod(R.x, n);
    return v === r;
}
function finalizeSchnorrChallenge(ch) {
    return mod(bytesToNumber(ch), CURVE.n);
}
function hasEvenY(point) {
    return (point.y & _1n) === _0n;
}
class SchnorrSignature {
    constructor(r, s){
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        if (bytes.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
        const r = bytesToNumber(bytes.subarray(0, 32));
        const s = bytesToNumber(bytes.subarray(32, 64));
        return new SchnorrSignature(r, s);
    }
    assertValidity() {
        const { r , s  } = this;
        if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error("Invalid signature");
    }
    toHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
    toRawBytes() {
        return hexToBytes(this.toHex());
    }
}
function schnorrGetPublicKey(privateKey) {
    return Point.fromPrivateKey(privateKey).toRawX();
}
function initSchnorrSigArgs(message, privateKey, auxRand) {
    if (message == null) throw new TypeError(`sign: Expected valid message, not "${message}"`);
    const m = ensureBytes(message);
    const d0 = normalizePrivateKey(privateKey);
    const rand = ensureBytes(auxRand);
    if (rand.length !== 32) throw new TypeError("sign: Expected 32 bytes of aux randomness");
    const P = Point.fromPrivateKey(d0);
    const px = P.toRawX();
    const d = hasEvenY(P) ? d0 : CURVE.n - d0;
    return {
        m,
        P,
        px,
        d,
        rand
    };
}
function initSchnorrNonce(d, t0h) {
    return numTo32b(d ^ bytesToNumber(t0h));
}
function finalizeSchnorrNonce(k0h) {
    const k0 = mod(bytesToNumber(k0h), CURVE.n);
    if (k0 === _0n) throw new Error("sign: Creation of signature failed. k is zero");
    const R = Point.fromPrivateKey(k0);
    const rx = R.toRawX();
    const k = hasEvenY(R) ? k0 : CURVE.n - k0;
    return {
        R,
        rx,
        k
    };
}
function finalizeSchnorrSig(R, k, e, d) {
    return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
}
async function schnorrSign(message, privateKey, auxRand = utils.randomBytes()) {
    const { m , px , d , rand  } = initSchnorrSigArgs(message, privateKey, auxRand);
    const t = initSchnorrNonce(d, await utils.taggedHash(TAGS.aux, rand));
    const { R , rx , k  } = finalizeSchnorrNonce(await utils.taggedHash(TAGS.nonce, t, px, m));
    const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, rx, px, m));
    const sig = finalizeSchnorrSig(R, k, e, d);
    const isValid = await schnorrVerify(sig, m, px);
    if (!isValid) throw new Error("sign: Invalid signature produced");
    return sig;
}
function schnorrSignSync(message, privateKey, auxRand = utils.randomBytes()) {
    const { m , px , d , rand  } = initSchnorrSigArgs(message, privateKey, auxRand);
    const t = initSchnorrNonce(d, utils.taggedHashSync(TAGS.aux, rand));
    const { R , rx , k  } = finalizeSchnorrNonce(utils.taggedHashSync(TAGS.nonce, t, px, m));
    const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, rx, px, m));
    const sig = finalizeSchnorrSig(R, k, e, d);
    const isValid = schnorrVerifySync(sig, m, px);
    if (!isValid) throw new Error("sign: Invalid signature produced");
    return sig;
}
function initSchnorrVerify(signature, message, publicKey) {
    const raw = signature instanceof SchnorrSignature;
    const sig = raw ? signature : SchnorrSignature.fromHex(signature);
    if (raw) sig.assertValidity();
    return {
        ...sig,
        m: ensureBytes(message),
        P: normalizePublicKey(publicKey)
    };
}
function finalizeSchnorrVerify(r, P, s, e) {
    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
    if (!R || !hasEvenY(R) || R.x !== r) return false;
    return true;
}
async function schnorrVerify(signature, message, publicKey) {
    try {
        const { r , s , m , P  } = initSchnorrVerify(signature, message, publicKey);
        const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
    } catch (error) {
        return false;
    }
}
function schnorrVerifySync(signature, message, publicKey) {
    try {
        const { r , s , m , P  } = initSchnorrVerify(signature, message, publicKey);
        const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
    } catch (error) {
        return false;
    }
}
const schnorr = {
    Signature: SchnorrSignature,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    signSync: schnorrSignSync,
    verifySync: schnorrVerifySync
};
Point.BASE._setWindowSize(8);
const crypto = {
    node: _crypto,
    web: typeof self === "object" && "crypto" in self ? self.crypto : undefined
};
const TAGS = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
};
const TAGGED_HASH_PREFIXES = {};
const utils = {
    isValidPrivateKey (privateKey) {
        try {
            normalizePrivateKey(privateKey);
            return true;
        } catch (error) {
            return false;
        }
    },
    privateAdd: (privateKey, tweak)=>{
        const p = normalizePrivateKey(privateKey);
        const t = normalizePrivateKey(tweak);
        return numTo32b(mod(p + t, CURVE.n));
    },
    privateNegate: (privateKey)=>{
        const p = normalizePrivateKey(privateKey);
        return numTo32b(CURVE.n - p);
    },
    pointAddScalar: (p, tweak, isCompressed)=>{
        const P = Point.fromHex(p);
        const t = normalizePrivateKey(tweak);
        const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);
        if (!Q) throw new Error("Tweaked point at infinity");
        return Q.toRawBytes(isCompressed);
    },
    pointMultiply: (p, tweak, isCompressed)=>{
        const P = Point.fromHex(p);
        const t = bytesToNumber(ensureBytes(tweak));
        return P.multiply(t).toRawBytes(isCompressed);
    },
    hashToPrivateKey: (hash)=>{
        hash = ensureBytes(hash);
        if (hash.length < 40 || hash.length > 1024) throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
        return numTo32b(num);
    },
    randomBytes: (bytesLength = 32)=>{
        if (crypto.web) return crypto.web.getRandomValues(new Uint8Array(bytesLength));
        else if (crypto.node) {
            const { randomBytes  } = crypto.node;
            return Uint8Array.from(randomBytes(bytesLength));
        } else throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: ()=>{
        return utils.hashToPrivateKey(utils.randomBytes(40));
    },
    bytesToHex,
    hexToBytes,
    concatBytes,
    mod,
    invert,
    sha256: async (...messages)=>{
        if (crypto.web) {
            const buffer = await crypto.web.subtle.digest("SHA-256", concatBytes(...messages));
            return new Uint8Array(buffer);
        } else if (crypto.node) {
            const { createHash  } = crypto.node;
            const hash = createHash("sha256");
            messages.forEach((m)=>hash.update(m));
            return Uint8Array.from(hash.digest());
        } else throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (key, ...messages)=>{
        if (crypto.web) {
            const ckey = await crypto.web.subtle.importKey("raw", key, {
                name: "HMAC",
                hash: {
                    name: "SHA-256"
                }
            }, false, [
                "sign"
            ]);
            const message = concatBytes(...messages);
            const buffer = await crypto.web.subtle.sign("HMAC", ckey, message);
            return new Uint8Array(buffer);
        } else if (crypto.node) {
            const { createHmac  } = crypto.node;
            const hash = createHmac("sha256", key);
            messages.forEach((m)=>hash.update(m));
            return Uint8Array.from(hash.digest());
        } else throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: undefined,
    hmacSha256Sync: undefined,
    taggedHash: async (tag, ...messages)=>{
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = await utils.sha256(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return utils.sha256(tagP, ...messages);
    },
    taggedHashSync: (tag, ...messages)=>{
        if (typeof utils.sha256Sync !== "function") throw new Error("utils.sha256Sync is undefined, you need to set it");
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = utils.sha256Sync(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return utils.sha256Sync(tagP, ...messages);
    },
    precompute (windowSize = 8, point = Point.BASE) {
        const cached = point === Point.BASE ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
    }
};

},{"crypto":"jhUEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3GspH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cryptoIsReady", ()=>cryptoIsReady);
parcelHelpers.export(exports, "cryptoWaitReady", ()=>cryptoWaitReady);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _wasmCrypto = require("@polkadot/wasm-crypto");
const cryptoIsReady = (0, _wasmCrypto.isReady);
function cryptoWaitReady() {
    return (0, _wasmCrypto.waitReady)().then(()=>{
        if (!(0, _wasmCrypto.isReady)()) throw new Error("Unable to initialize @polkadot/util-crypto");
        return true;
    }).catch(()=>false);
}

},{"@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"19VJZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2019-2022 @polkadot/wasm-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"flYCP","./bundle.js":"NrdCB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"flYCP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/wasm-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"14uzF","./packageInfo.js":"kY7cc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"14uzF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/wasm-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/wasm-bridge/packageInfo");
var _packageInfo1 = require("@polkadot/wasm-crypto-asmjs/packageInfo");
var _packageInfo2 = require("@polkadot/wasm-crypto-init/packageInfo");
var _packageInfo3 = require("@polkadot/wasm-crypto-wasm/packageInfo");
var _packageInfo4 = require("@polkadot/wasm-util/packageInfo");
exports.default = [
    (0, _packageInfo.packageInfo),
    (0, _packageInfo1.packageInfo),
    (0, _packageInfo2.packageInfo),
    (0, _packageInfo3.packageInfo),
    (0, _packageInfo4.packageInfo)
];

},{"@polkadot/wasm-bridge/packageInfo":"3vtip","@polkadot/wasm-crypto-asmjs/packageInfo":"7FNIf","@polkadot/wasm-crypto-init/packageInfo":"hl2gZ","@polkadot/wasm-crypto-wasm/packageInfo":"9SDcP","@polkadot/wasm-util/packageInfo":"jwsVW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3vtip":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $28dafde1e5919b35$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/wasm-bridge/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/wasm-bridge",
    path: $28dafde1e5919b35$import_meta && "file:///node_modules/@polkadot/wasm-bridge/packageInfo.js" ? new URL("file:///node_modules/@polkadot/wasm-bridge/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/wasm-bridge/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "6.3.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7FNIf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $5962eca8e099f259$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/wasm-crypto-asmjs/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/wasm-crypto-asmjs",
    path: $5962eca8e099f259$import_meta && "file:///node_modules/@polkadot/wasm-crypto-asmjs/packageInfo.js" ? new URL("file:///node_modules/@polkadot/wasm-crypto-asmjs/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/wasm-crypto-asmjs/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "6.3.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hl2gZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $c9f62939efbe8097$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/wasm-crypto-init/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/wasm-crypto-init",
    path: $c9f62939efbe8097$import_meta && "file:///node_modules/@polkadot/wasm-crypto-init/packageInfo.js" ? new URL("file:///node_modules/@polkadot/wasm-crypto-init/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/wasm-crypto-init/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "6.3.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9SDcP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $731791b1416a18cf$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/wasm-crypto-wasm/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/wasm-crypto-wasm",
    path: $731791b1416a18cf$import_meta && "file:///node_modules/@polkadot/wasm-crypto-wasm/packageInfo.js" ? new URL("file:///node_modules/@polkadot/wasm-crypto-wasm/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/wasm-crypto-wasm/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "6.3.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jwsVW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $e3677316ad8bef26$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/wasm-util/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/wasm-util",
    path: $e3677316ad8bef26$import_meta && "file:///node_modules/@polkadot/wasm-util/packageInfo.js" ? new URL("file:///node_modules/@polkadot/wasm-util/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/wasm-util/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "6.3.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kY7cc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $f43efe308e600854$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/wasm-crypto/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/wasm-crypto",
    path: $f43efe308e600854$import_meta && "file:///node_modules/@polkadot/wasm-crypto/packageInfo.js" ? new URL("file:///node_modules/@polkadot/wasm-crypto/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/wasm-crypto/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "6.3.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"NrdCB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
parcelHelpers.export(exports, "bridge", ()=>(0, _initJs.bridge)) // Removes the first parameter (expected as WasmCryptoInstance) and leaves the
;
parcelHelpers.export(exports, "bip39Generate", ()=>bip39Generate);
parcelHelpers.export(exports, "bip39ToEntropy", ()=>bip39ToEntropy);
parcelHelpers.export(exports, "bip39ToMiniSecret", ()=>bip39ToMiniSecret);
parcelHelpers.export(exports, "bip39ToSeed", ()=>bip39ToSeed);
parcelHelpers.export(exports, "bip39Validate", ()=>bip39Validate);
parcelHelpers.export(exports, "ed25519KeypairFromSeed", ()=>ed25519KeypairFromSeed);
parcelHelpers.export(exports, "ed25519Sign", ()=>ed25519Sign);
parcelHelpers.export(exports, "ed25519Verify", ()=>ed25519Verify);
parcelHelpers.export(exports, "secp256k1FromSeed", ()=>secp256k1FromSeed);
parcelHelpers.export(exports, "secp256k1Compress", ()=>secp256k1Compress);
parcelHelpers.export(exports, "secp256k1Expand", ()=>secp256k1Expand);
parcelHelpers.export(exports, "secp256k1Recover", ()=>secp256k1Recover);
parcelHelpers.export(exports, "secp256k1Sign", ()=>secp256k1Sign);
parcelHelpers.export(exports, "sr25519DeriveKeypairHard", ()=>sr25519DeriveKeypairHard);
parcelHelpers.export(exports, "sr25519DeriveKeypairSoft", ()=>sr25519DeriveKeypairSoft);
parcelHelpers.export(exports, "sr25519DerivePublicSoft", ()=>sr25519DerivePublicSoft);
parcelHelpers.export(exports, "sr25519KeypairFromSeed", ()=>sr25519KeypairFromSeed);
parcelHelpers.export(exports, "sr25519Sign", ()=>sr25519Sign);
parcelHelpers.export(exports, "sr25519Verify", ()=>sr25519Verify);
parcelHelpers.export(exports, "sr25519Agree", ()=>sr25519Agree);
parcelHelpers.export(exports, "vrfSign", ()=>vrfSign);
parcelHelpers.export(exports, "vrfVerify", ()=>vrfVerify);
parcelHelpers.export(exports, "blake2b", ()=>blake2b);
parcelHelpers.export(exports, "hmacSha256", ()=>hmacSha256);
parcelHelpers.export(exports, "hmacSha512", ()=>hmacSha512);
parcelHelpers.export(exports, "keccak256", ()=>keccak256);
parcelHelpers.export(exports, "keccak512", ()=>keccak512);
parcelHelpers.export(exports, "pbkdf2", ()=>pbkdf2);
parcelHelpers.export(exports, "scrypt", ()=>scrypt);
parcelHelpers.export(exports, "sha256", ()=>sha256);
parcelHelpers.export(exports, "sha512", ()=>sha512);
parcelHelpers.export(exports, "twox", ()=>twox);
parcelHelpers.export(exports, "isReady", ()=>isReady);
parcelHelpers.export(exports, "waitReady", ()=>waitReady);
// Copyright 2019-2022 @polkadot/wasm-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _initJs = require("./init.js");
var _packageInfoJs = require("./packageInfo.js");
// rest of the parameters in-tack. This allows us to dynamically create a function
// return from the withWasm helper
/**
 * @internal
 * @description
 * This create an extenal interface function from the signature, all the while checking
 * the actual bridge wasm interface to ensure it has been initialized.
 *
 * This means that we can call it
 *
 *   withWasm(wasm: WasmCryptoInstance, a: number, b: string) => Uint8Array
 *
 * and in this case it will create an interface function with the signarure
 *
 *   (a: number, b: string) => Uint8Array
 */ function withWasm(fn) {
    return (...params)=>{
        if (!(0, _initJs.bridge).wasm) throw new Error("The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.");
        return fn((0, _initJs.bridge).wasm, ...params);
    };
}
const bip39Generate = withWasm((wasm, words)=>{
    wasm.ext_bip39_generate(8, words);
    return (0, _initJs.bridge).resultString();
});
const bip39ToEntropy = withWasm((wasm, phrase)=>{
    wasm.ext_bip39_to_entropy(8, ...(0, _initJs.bridge).allocString(phrase));
    return (0, _initJs.bridge).resultU8a();
});
const bip39ToMiniSecret = withWasm((wasm, phrase, password)=>{
    wasm.ext_bip39_to_mini_secret(8, ...(0, _initJs.bridge).allocString(phrase), ...(0, _initJs.bridge).allocString(password));
    return (0, _initJs.bridge).resultU8a();
});
const bip39ToSeed = withWasm((wasm, phrase, password)=>{
    wasm.ext_bip39_to_seed(8, ...(0, _initJs.bridge).allocString(phrase), ...(0, _initJs.bridge).allocString(password));
    return (0, _initJs.bridge).resultU8a();
});
const bip39Validate = withWasm((wasm, phrase)=>{
    const ret = wasm.ext_bip39_validate(...(0, _initJs.bridge).allocString(phrase));
    return ret !== 0;
});
const ed25519KeypairFromSeed = withWasm((wasm, seed)=>{
    wasm.ext_ed_from_seed(8, ...(0, _initJs.bridge).allocU8a(seed));
    return (0, _initJs.bridge).resultU8a();
});
const ed25519Sign = withWasm((wasm, pubkey, seckey, message)=>{
    wasm.ext_ed_sign(8, ...(0, _initJs.bridge).allocU8a(pubkey), ...(0, _initJs.bridge).allocU8a(seckey), ...(0, _initJs.bridge).allocU8a(message));
    return (0, _initJs.bridge).resultU8a();
});
const ed25519Verify = withWasm((wasm, signature, message, pubkey)=>{
    const ret = wasm.ext_ed_verify(...(0, _initJs.bridge).allocU8a(signature), ...(0, _initJs.bridge).allocU8a(message), ...(0, _initJs.bridge).allocU8a(pubkey));
    return ret !== 0;
});
const secp256k1FromSeed = withWasm((wasm, seckey)=>{
    wasm.ext_secp_from_seed(8, ...(0, _initJs.bridge).allocU8a(seckey));
    return (0, _initJs.bridge).resultU8a();
});
const secp256k1Compress = withWasm((wasm, pubkey)=>{
    wasm.ext_secp_pub_compress(8, ...(0, _initJs.bridge).allocU8a(pubkey));
    return (0, _initJs.bridge).resultU8a();
});
const secp256k1Expand = withWasm((wasm, pubkey)=>{
    wasm.ext_secp_pub_expand(8, ...(0, _initJs.bridge).allocU8a(pubkey));
    return (0, _initJs.bridge).resultU8a();
});
const secp256k1Recover = withWasm((wasm, msgHash, sig, recovery)=>{
    wasm.ext_secp_recover(8, ...(0, _initJs.bridge).allocU8a(msgHash), ...(0, _initJs.bridge).allocU8a(sig), recovery);
    return (0, _initJs.bridge).resultU8a();
});
const secp256k1Sign = withWasm((wasm, msgHash, seckey)=>{
    wasm.ext_secp_sign(8, ...(0, _initJs.bridge).allocU8a(msgHash), ...(0, _initJs.bridge).allocU8a(seckey));
    return (0, _initJs.bridge).resultU8a();
});
const sr25519DeriveKeypairHard = withWasm((wasm, pair, cc)=>{
    wasm.ext_sr_derive_keypair_hard(8, ...(0, _initJs.bridge).allocU8a(pair), ...(0, _initJs.bridge).allocU8a(cc));
    return (0, _initJs.bridge).resultU8a();
});
const sr25519DeriveKeypairSoft = withWasm((wasm, pair, cc)=>{
    wasm.ext_sr_derive_keypair_soft(8, ...(0, _initJs.bridge).allocU8a(pair), ...(0, _initJs.bridge).allocU8a(cc));
    return (0, _initJs.bridge).resultU8a();
});
const sr25519DerivePublicSoft = withWasm((wasm, pubkey, cc)=>{
    wasm.ext_sr_derive_public_soft(8, ...(0, _initJs.bridge).allocU8a(pubkey), ...(0, _initJs.bridge).allocU8a(cc));
    return (0, _initJs.bridge).resultU8a();
});
const sr25519KeypairFromSeed = withWasm((wasm, seed)=>{
    wasm.ext_sr_from_seed(8, ...(0, _initJs.bridge).allocU8a(seed));
    return (0, _initJs.bridge).resultU8a();
});
const sr25519Sign = withWasm((wasm, pubkey, secret, message)=>{
    wasm.ext_sr_sign(8, ...(0, _initJs.bridge).allocU8a(pubkey), ...(0, _initJs.bridge).allocU8a(secret), ...(0, _initJs.bridge).allocU8a(message));
    return (0, _initJs.bridge).resultU8a();
});
const sr25519Verify = withWasm((wasm, signature, message, pubkey)=>{
    const ret = wasm.ext_sr_verify(...(0, _initJs.bridge).allocU8a(signature), ...(0, _initJs.bridge).allocU8a(message), ...(0, _initJs.bridge).allocU8a(pubkey));
    return ret !== 0;
});
const sr25519Agree = withWasm((wasm, pubkey, secret)=>{
    wasm.ext_sr_agree(8, ...(0, _initJs.bridge).allocU8a(pubkey), ...(0, _initJs.bridge).allocU8a(secret));
    return (0, _initJs.bridge).resultU8a();
});
const vrfSign = withWasm((wasm, secret, context, message, extra)=>{
    wasm.ext_vrf_sign(8, ...(0, _initJs.bridge).allocU8a(secret), ...(0, _initJs.bridge).allocU8a(context), ...(0, _initJs.bridge).allocU8a(message), ...(0, _initJs.bridge).allocU8a(extra));
    return (0, _initJs.bridge).resultU8a();
});
const vrfVerify = withWasm((wasm, pubkey, context, message, extra, outAndProof)=>{
    const ret = wasm.ext_vrf_verify(...(0, _initJs.bridge).allocU8a(pubkey), ...(0, _initJs.bridge).allocU8a(context), ...(0, _initJs.bridge).allocU8a(message), ...(0, _initJs.bridge).allocU8a(extra), ...(0, _initJs.bridge).allocU8a(outAndProof));
    return ret !== 0;
});
const blake2b = withWasm((wasm, data, key, size)=>{
    wasm.ext_blake2b(8, ...(0, _initJs.bridge).allocU8a(data), ...(0, _initJs.bridge).allocU8a(key), size);
    return (0, _initJs.bridge).resultU8a();
});
const hmacSha256 = withWasm((wasm, key, data)=>{
    wasm.ext_hmac_sha256(8, ...(0, _initJs.bridge).allocU8a(key), ...(0, _initJs.bridge).allocU8a(data));
    return (0, _initJs.bridge).resultU8a();
});
const hmacSha512 = withWasm((wasm, key, data)=>{
    wasm.ext_hmac_sha512(8, ...(0, _initJs.bridge).allocU8a(key), ...(0, _initJs.bridge).allocU8a(data));
    return (0, _initJs.bridge).resultU8a();
});
const keccak256 = withWasm((wasm, data)=>{
    wasm.ext_keccak256(8, ...(0, _initJs.bridge).allocU8a(data));
    return (0, _initJs.bridge).resultU8a();
});
const keccak512 = withWasm((wasm, data)=>{
    wasm.ext_keccak512(8, ...(0, _initJs.bridge).allocU8a(data));
    return (0, _initJs.bridge).resultU8a();
});
const pbkdf2 = withWasm((wasm, data, salt, rounds)=>{
    wasm.ext_pbkdf2(8, ...(0, _initJs.bridge).allocU8a(data), ...(0, _initJs.bridge).allocU8a(salt), rounds);
    return (0, _initJs.bridge).resultU8a();
});
const scrypt = withWasm((wasm, password, salt, log2n, r, p)=>{
    wasm.ext_scrypt(8, ...(0, _initJs.bridge).allocU8a(password), ...(0, _initJs.bridge).allocU8a(salt), log2n, r, p);
    return (0, _initJs.bridge).resultU8a();
});
const sha256 = withWasm((wasm, data)=>{
    wasm.ext_sha256(8, ...(0, _initJs.bridge).allocU8a(data));
    return (0, _initJs.bridge).resultU8a();
});
const sha512 = withWasm((wasm, data)=>{
    wasm.ext_sha512(8, ...(0, _initJs.bridge).allocU8a(data));
    return (0, _initJs.bridge).resultU8a();
});
const twox = withWasm((wasm, data, rounds)=>{
    wasm.ext_twox(8, ...(0, _initJs.bridge).allocU8a(data), rounds);
    return (0, _initJs.bridge).resultU8a();
});
function isReady() {
    return !!(0, _initJs.bridge).wasm;
}
async function waitReady() {
    try {
        const wasm = await (0, _initJs.initBridge)();
        return !!wasm;
    } catch  {
        return false;
    }
}

},{"./init.js":"9JOe6","./packageInfo.js":"kY7cc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9JOe6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bridge", ()=>bridge);
/**
 * @name initBridge
 * @description
 * Creates a new bridge interface with the (optional) initialization function
 */ parcelHelpers.export(exports, "initBridge", ()=>initBridge);
// Copyright 2019-2022 @polkadot/wasm-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _wasmBridge = require("@polkadot/wasm-bridge");
var _wasmCryptoInit = require("@polkadot/wasm-crypto-init");
const bridge = new (0, _wasmBridge.Bridge)((0, _wasmCryptoInit.createWasm));
async function initBridge(createWasm) {
    return bridge.init(createWasm);
}

},{"@polkadot/wasm-bridge":"3wwiy","@polkadot/wasm-crypto-init":"2I20m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3wwiy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2019-2022 @polkadot/wasm-bridge authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"bjFTT","./bundle.js":"61xDe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bjFTT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/wasm-bridge authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"44Sc9","./packageInfo.js":"3vtip","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"44Sc9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/wasm-bridge authors & contributors
// SPDX-License-Identifier: Apache-2.0
exports.default = [];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"61xDe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2019-2022 @polkadot/wasm-bridge authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bridgeJs = require("./bridge.js");
parcelHelpers.exportAll(_bridgeJs, exports);
var _initJs = require("./init.js");
parcelHelpers.exportAll(_initJs, exports);

},{"./bridge.js":"bWpzk","./init.js":"bT7Lq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bWpzk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Bridge
 * @description
 * Creates a bridge between the JS and WASM environments.
 *
 * For any bridge it is passed an function white is then called internally at the
 * time of initialization. This affectively implements the layer between WASM and
 * the native environment, providing all the plumbing needed for the Wbg classes.
 */ parcelHelpers.export(exports, "Bridge", ()=>Bridge);
// Copyright 2019-2022 @polkadot/wasm-bridge authors & contributors
// SPDX-License-Identifier: Apache-2.0
// A number of functions are "unsafe" and purposefully so - it is
// assumed that where the bridge is used, it is correctly wrapped
// in a safeguard (see withWasm in the wasm-crypto package) which
// then ensures that the internal wasm instance here is available
/* eslint-disable @typescript-eslint/no-non-null-assertion */ var _util = require("@polkadot/util");
var _wbgJs = require("./wbg.js");
class Bridge {
    #cachegetInt32;
    #cachegetUint8;
    #createWasm;
    #heap;
    #heapNext;
    #wasm;
    #wasmError;
    #wasmPromise;
    #wbg;
    #type;
    constructor(createWasm){
        this.#createWasm = createWasm;
        this.#cachegetInt32 = null;
        this.#cachegetUint8 = null;
        this.#heap = new Array(32).fill(undefined).concat(undefined, null, true, false);
        this.#heapNext = this.#heap.length;
        this.#type = "none";
        this.#wasm = null;
        this.#wasmError = null;
        this.#wasmPromise = null;
        this.#wbg = {
            ...new (0, _wbgJs.Wbg)(this)
        };
    }
    /** @description Returns the init error */ get error() {
        return this.#wasmError;
    }
    /** @description Returns the init type */ get type() {
        return this.#type;
    }
    /** @description Returns the created wasm interface */ get wasm() {
        return this.#wasm;
    }
    /** @description Performs the wasm initialization */ async init(createWasm) {
        if (!this.#wasmPromise || createWasm) this.#wasmPromise = (createWasm || this.#createWasm)(this.#wbg);
        const { error , type , wasm  } = await this.#wasmPromise;
        this.#type = type;
        this.#wasm = wasm;
        this.#wasmError = error;
        return this.#wasm;
    }
    /**
   * @internal
   * @description Gets an object from the heap
   */ getObject(idx) {
        return this.#heap[idx];
    }
    /**
   * @internal
   * @description Removes an object from the heap
   */ dropObject(idx) {
        if (idx < 36) return;
        this.#heap[idx] = this.#heapNext;
        this.#heapNext = idx;
    }
    /**
   * @internal
   * @description Retrieves and removes an object to the heap
   */ takeObject(idx) {
        const ret = this.getObject(idx);
        this.dropObject(idx);
        return ret;
    }
    /**
   * @internal
   * @description Adds an object to the heap
   */ addObject(obj) {
        if (this.#heapNext === this.#heap.length) this.#heap.push(this.#heap.length + 1);
        const idx = this.#heapNext;
        this.#heapNext = this.#heap[idx];
        this.#heap[idx] = obj;
        return idx;
    }
    /**
   * @internal
   * @description Retrieve an Int32 in the WASM interface
   */ getInt32() {
        if (this.#cachegetInt32 === null || this.#cachegetInt32.buffer !== this.#wasm.memory.buffer) this.#cachegetInt32 = new Int32Array(this.#wasm.memory.buffer);
        return this.#cachegetInt32;
    }
    /**
   * @internal
   * @description Retrieve an Uint8Array in the WASM interface
   */ getUint8() {
        if (this.#cachegetUint8 === null || this.#cachegetUint8.buffer !== this.#wasm.memory.buffer) this.#cachegetUint8 = new Uint8Array(this.#wasm.memory.buffer);
        return this.#cachegetUint8;
    }
    /**
   * @internal
   * @description Retrieves an Uint8Array in the WASM interface
   */ getU8a(ptr, len) {
        return this.getUint8().subarray(ptr / 1, ptr / 1 + len);
    }
    /**
   * @internal
   * @description Retrieves a string in the WASM interface
   */ getString(ptr, len) {
        return (0, _util.u8aToString)(this.getU8a(ptr, len));
    }
    /**
   * @internal
   * @description Allocates an Uint8Array in the WASM interface
   */ allocU8a(arg) {
        const ptr = this.#wasm.__wbindgen_malloc(arg.length * 1);
        this.getUint8().set(arg, ptr / 1);
        return [
            ptr,
            arg.length
        ];
    }
    /**
   * @internal
   * @description Allocates a string in the WASM interface
   */ allocString(arg) {
        return this.allocU8a((0, _util.stringToU8a)(arg));
    }
    /**
   * @internal
   * @description Retrieves an Uint8Array from the WASM interface
   */ resultU8a() {
        const r0 = this.getInt32()[2];
        const r1 = this.getInt32()[3];
        const ret = this.getU8a(r0, r1).slice();
        this.#wasm.__wbindgen_free(r0, r1 * 1);
        return ret;
    }
    /**
   * @internal
   * @description Retrieve a string from the WASM interface
   */ resultString() {
        return (0, _util.u8aToString)(this.resultU8a());
    }
}

},{"@polkadot/util":"3HnHw","./wbg.js":"8Bvvj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Bvvj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Wbg
 * @description
 * This defines the internal interfaces that wasm-bindgen used to communicate
 * with the host layer. None of these functions are available to the user, rather
 * they are called internally from the WASM code itself.
 *
 * The interfaces here are exposed in the imports on the created WASM interfaces.
 *
 * Internally the implementation does a thin layer into the supplied bridge.
 */ parcelHelpers.export(exports, "Wbg", ()=>Wbg);
// Copyright 2019-2022 @polkadot/wasm-bridge authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xRandomvalues = require("@polkadot/x-randomvalues");
const DEFAULT_CRYPTO = {
    getRandomValues: (0, _xRandomvalues.getRandomValues)
};
const DEFAULT_SELF = {
    crypto: DEFAULT_CRYPTO
};
class Wbg {
    #bridge;
    constructor(bridge){
        this.#bridge = bridge;
    }
    /** @internal */ abort = ()=>{
        throw new Error("abort");
    };
    /** @internal */ __wbindgen_is_undefined = (idx)=>{
        return this.#bridge.getObject(idx) === undefined;
    };
    /** @internal */ __wbindgen_throw = (ptr, len)=>{
        throw new Error(this.#bridge.getString(ptr, len));
    };
    /** @internal */ __wbg_self_1b7a39e3a92c949c = ()=>{
        return this.#bridge.addObject(DEFAULT_SELF);
    };
    /** @internal */ __wbg_require_604837428532a733 = (ptr, len)=>{
        throw new Error(`Unable to require ${this.#bridge.getString(ptr, len)}`);
    };
    /** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    __wbg_crypto_968f1772287e2df0 = (_idx)=>{
        return this.#bridge.addObject(DEFAULT_CRYPTO);
    };
    /** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    __wbg_getRandomValues_a3d34b4fee3c2869 = (_idx)=>{
        return this.#bridge.addObject(DEFAULT_CRYPTO.getRandomValues);
    };
    /** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    __wbg_getRandomValues_f5e14ab7ac8e995d = (_arg0, ptr, len)=>{
        DEFAULT_CRYPTO.getRandomValues(this.#bridge.getU8a(ptr, len));
    };
    /** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    __wbg_randomFillSync_d5bd2d655fdf256a = (_idx, _ptr, _len)=>{
        throw new Error("randomFillsync is not available"); // getObject(idx).randomFillSync(getU8a(ptr, len));
    };
    /** @internal */ __wbindgen_object_drop_ref = (idx)=>{
        this.#bridge.takeObject(idx);
    };
}

},{"@polkadot/x-randomvalues":"jhlDT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bT7Lq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2019-2022 @polkadot/wasm-bundle authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name createWasmFn
 * @description
 * Create a WASM (or ASM.js) creator interface based on the supplied information.
 *
 * It will attempt to create a WASM interface first and if this fails or is not available in
 * the environment, will fallback to attempting to create an ASM.js interface.
 */ parcelHelpers.export(exports, "createWasmFn", ()=>createWasmFn);
function createWasmFn(root, wasmBytes, asmFn) {
    return async (wbg)=>{
        const result = {
            error: null,
            type: "none",
            wasm: null
        };
        try {
            if (!wasmBytes || !wasmBytes.length) throw new Error("No WebAssembly provided for initialization");
            else if (typeof WebAssembly !== "object" || typeof WebAssembly.instantiate !== "function") throw new Error("WebAssembly is not available in your environment");
            const source = await WebAssembly.instantiate(wasmBytes, {
                wbg
            });
            result.wasm = source.instance.exports;
            result.type = "wasm";
        } catch (error) {
            // if we have a valid supplied asm.js, return that
            if (typeof asmFn === "function") {
                result.wasm = asmFn(wbg);
                result.type = "asm";
            } else {
                result.error = `FATAL: Unable to initialize @polkadot/wasm-${root}:: ${error.message}`;
                console.error(result.error);
            }
        }
        return result;
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2I20m":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createWasm = void 0;
Object.defineProperty(exports, "packageInfo", {
    enumerable: true,
    get: function() {
        return _packageInfo.packageInfo;
    }
});
var _wasmBridge = require("@polkadot/wasm-bridge");
var _wasmCryptoWasm = require("@polkadot/wasm-crypto-wasm");
var _packageInfo = require("./packageInfo");
// Copyright 2019-2022 @polkadot/wasm-crypto-init authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name createWasm
 * @description
 * Creates an interface using only WASM
 */ const createWasm = (0, _wasmBridge.createWasmFn)("crypto", _wasmCryptoWasm.wasmBytes, null);
exports.createWasm = createWasm;

},{"@polkadot/wasm-bridge":"3wwiy","@polkadot/wasm-crypto-wasm":"5udbF","./packageInfo":"fRM9H"}],"5udbF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2019-2022 @polkadot/wasm-crypto-wasm authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"648QF","./bundle.js":"a3XHl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"648QF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/wasm-crypto-wasm authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"5SAQT","./packageInfo.js":"9SDcP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5SAQT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2019-2022 @polkadot/wasm-crypto-wasm authors & contributors
// SPDX-License-Identifier: Apache-2.0
exports.default = [];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a3XHl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
parcelHelpers.export(exports, "wasmBytes", ()=>wasmBytes);
// Copyright 2019-2022 @polkadot/wasm-crypto-wasm authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _wasmUtil = require("@polkadot/wasm-util");
var _bytesJs = require("./cjs/bytes.js");
var _packageInfoJs = require("./packageInfo.js");
const wasmBytes = (0, _wasmUtil.unzlibSync)((0, _wasmUtil.base64Decode)((0, _bytesJs.bytes), new Uint8Array((0, _bytesJs.lenIn))), new Uint8Array((0, _bytesJs.lenOut)));

},{"@polkadot/wasm-util":"101rX","./cjs/bytes.js":"fp4I6","./packageInfo.js":"9SDcP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"101rX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2019-2022 @polkadot/wasm-util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"5HcWI","./bundle.js":"cyPdx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5HcWI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/wasm-util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"bLLv9","./packageInfo.js":"jwsVW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bLLv9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2019-2022 @polkadot/wasm-util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/wasm-util/packageInfo");
exports.default = [
    (0, _packageInfo.packageInfo)
];

},{"@polkadot/wasm-util/packageInfo":"jwsVW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cyPdx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2019-2022 @polkadot/wasm-util authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "base64Decode", ()=>(0, _base64Js.base64Decode));
parcelHelpers.export(exports, "unzlibSync", ()=>(0, _fflateJs.unzlibSync));
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
var _base64Js = require("./base64.js");
var _fflateJs = require("./fflate.js");
var _packageInfoJs = require("./packageInfo.js");

},{"./base64.js":"c1i6o","./fflate.js":"aYMUh","./packageInfo.js":"jwsVW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c1i6o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name base64Decode
 * @description
 * A base64Decoding function that operates in all environments. Unlike decoding
 * from Buffer (Node.js only) or atob (browser-only) this implementation is
 * slightly slower, but it is platform independent.
 *
 * For our usage, since we have access to the static final size (where used), we
 * decode to a specified output buffer. This also means we have applied a number
 * of optimizations based on this - checking output position instead of chars.
 */ parcelHelpers.export(exports, "base64Decode", ()=>base64Decode);
// Copyright 2019-2022 @polkadot/wasm-util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Use an array for our indexer - this is faster than using map access. In
// this case we assume ASCII-only inputs, so we cannot overflow the array
const chr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const map = new Array(256); // We use charCodeAt for access here and in the decoder loop - this is faster
// on lookups (array + numbers) and also faster than accessing the specific
// character via data[i]
for(let i = 0; i < chr.length; i++)map[chr.charCodeAt(i)] = i;
function base64Decode(data, out) {
    const len = out.length;
    let byte = 0;
    let bits = 0;
    let pos = -1;
    for(let i = 0; pos < len; i++){
        // each character represents 6 bits
        byte = byte << 6 | map[data.charCodeAt(i)]; // each byte needs to contain 8 bits
        if ((bits += 6) >= 8) out[++pos] = byte >>> (bits -= 8) & 0xff;
    }
    return out;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aYMUh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Expands Zlib data
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */ parcelHelpers.export(exports, "unzlibSync", ()=>unzlibSync);
// Copyright 2019-2022 @polkadot/wasm-util authors & contributors
// SPDX-License-Identifier: Apache-2.0
// MIT License
//
// Copyright (c) 2020 Arjun Barrett
//
// Copied from https://github.com/101arrowz/fflate/blob/73c737941ec89d85cdf0ad39ee6f26c5fdc95fd7/src/index.ts
// This only contains the unzlibSync function, no compression, no async, no workers
//
// These 2 issues are addressed as a short-term, stop-gap solution
//   - https://github.com/polkadot-js/api/issues/2963
//   - https://github.com/101arrowz/fflate/issues/17
//
// Only tweaks make here are some TS adjustments (we use strict null checks), the code is otherwise as-is with
// only the single required function provided (compression is still being done in the build with fflate)
/* eslint-disable */ // inflate state
// aliases for shorter compressed code (most minifers don't do this)
const u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array; // code length index map
const clim = new u8([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]); // fixed length extra bits
const fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */ 0,
    0,
    /* impossible */ 0
]); // fixed distance extra bits
// see fleb note
const fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */ 0,
    0
]); // get base, reverse index map from extra bits
const freb = (eb, start)=>{
    const b = new u16(31);
    for(let i = 0; i < 31; ++i)b[i] = start += 1 << eb[i - 1];
     // numbers here are at max 18 bits
    const r = new u32(b[30]);
    for(let i1 = 1; i1 < 30; ++i1)for(let j = b[i1]; j < b[i1 + 1]; ++j)r[j] = j - b[i1] << 5 | i1;
    return [
        b,
        r
    ];
};
const [fl, revfl] = freb(fleb, 2); // we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
const [fd] = freb(fdeb, 0); // map of value to reverse (assuming 16 bits)
const rev = new u16(32768);
for(let i = 0; i < 32768; ++i){
    // reverse table algorithm from SO
    let x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;
    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;
    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;
    rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;
} // create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
const hMap = (cd, mb, r)=>{
    const s = cd.length; // index
    let i = 0; // u16 "map": index -> # of codes with bit length = index
    const l = new u16(mb); // length of cd must be 288 (total # of codes)
    for(; i < s; ++i)++l[cd[i] - 1]; // u16 "map": index -> minimum code for bit length = index
    const le = new u16(mb);
    for(i = 0; i < mb; ++i)le[i] = le[i - 1] + l[i - 1] << 1;
    let co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb); // bits to remove for reverser
        const rvb = 15 - mb;
        for(i = 0; i < s; ++i)// ignore 0 lengths
        if (cd[i]) {
            // num encoding both symbol and bits read
            const sv = i << 4 | cd[i]; // free bits
            const r1 = mb - cd[i]; // start value
            let v = (le[cd[i] - 1]++) << r1; // m is end value
            for(const m = v | (1 << r1) - 1; v <= m; ++v)// every 16 bit value starting with the code yields the same result
            co[rev[v] >>> rvb] = sv;
        }
    } else {
        co = new u16(s);
        for(i = 0; i < s; ++i)co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
    }
    return co;
}; // fixed length tree
const flt = new u8(288);
for(let i1 = 0; i1 < 144; ++i1)flt[i1] = 8;
for(let i2 = 144; i2 < 256; ++i2)flt[i2] = 9;
for(let i3 = 256; i3 < 280; ++i3)flt[i3] = 7;
for(let i4 = 280; i4 < 288; ++i4)flt[i4] = 8; // fixed distance tree
const fdt = new u8(32);
for(let i5 = 0; i5 < 32; ++i5)fdt[i5] = 5; // fixed length map
const flrm = hMap(flt, 9, 1); // fixed distance map
const fdrm = hMap(fdt, 5, 1); // read d, starting at bit p and mask with m
const bits = (d, p, m)=>{
    const o = p >>> 3;
    return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;
}; // read d, starting at bit p continuing for at least 16 bits
const bits16 = (d, p)=>{
    const o = p >>> 3;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);
}; // get end of byte
const shft = (p)=>(p >>> 3) + (p & 7 && 1); // typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
const slc = (v, s, e)=>{
    if (s == null || s < 0) s = 0;
    if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied
    const n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
    n.set(v.subarray(s, e));
    return n;
}; // find max of array
const max = (a)=>{
    let m = a[0];
    for(let i = 1; i < a.length; ++i)if (a[i] > m) m = a[i];
    return m;
}; // expands raw DEFLATE data
const inflt = (dat, buf, st)=>{
    const noSt = !st || st.i;
    if (!st) st = {}; // source length
    const sl = dat.length; // have to estimate size
    const noBuf = !buf || !noSt; // Assumes roughly 33% compression ratio average
    if (!buf) buf = new u8(sl * 3); // ensure buffer can fit at least l elements
    const cbuf = (l)=>{
        let bl = buf.length; // need to increase size to fit
        if (l > bl) {
            // Double or set to necessary, whichever is greater
            const nbuf = new u8(Math.max(bl << 1, l));
            nbuf.set(buf);
            buf = nbuf;
        }
    }; //  last chunk         bitpos           bytes
    let final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    if (final && !lm) return buf; // total bits
    const tbts = sl << 3;
    do {
        if (!lm) {
            // BFINAL - this is only 1 when last chunk is next
            st.f = final = bits(dat, pos, 1); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
            const type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
                // go to end of byte boundary
                const s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
                if (t > sl) {
                    if (noSt) throw "unexpected EOF";
                    break;
                } // ensure size
                if (noBuf) cbuf(bt + l); // Copy over uncompressed data
                buf.set(dat.subarray(s, t), bt); // Get new bitpos, update byte count
                st.b = bt += l, st.p = pos = t << 3;
                continue;
            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
                //  literal                            lengths
                const hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                const tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14; // length+distance tree
                const ldt = new u8(tl); // code length tree
                const clt = new u8(19);
                for(let i = 0; i < hcLen; ++i)// use index map to get real code
                clt[clim[i]] = bits(dat, pos + i * 3, 7);
                pos += hcLen * 3; // code lengths bits
                const clb = max(clt), clbmsk = (1 << clb) - 1;
                if (!noSt && pos + tl * (clb + 7) > tbts) break; // code lengths map
                const clm = hMap(clt, clb, 1);
                for(let i1 = 0; i1 < tl;){
                    const r = clm[bits(dat, pos, clbmsk)]; // bits read
                    pos += r & 15; // symbol
                    const s1 = r >>> 4; // code length to copy
                    if (s1 < 16) ldt[i1++] = s1;
                    else {
                        //  copy   count
                        let c = 0, n = 0;
                        if (s1 == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i1 - 1];
                        else if (s1 == 17) n = 3 + bits(dat, pos, 7), pos += 3;
                        else if (s1 == 18) n = 11 + bits(dat, pos, 127), pos += 7;
                        while(n--)ldt[i1++] = c;
                    }
                } //    length tree                 distance tree
                const lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit); // max length bits
                lbt = max(lt); // max dist bits
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
            } else throw "invalid block type";
            if (pos > tbts) throw "unexpected EOF";
        } // Make sure the buffer can hold this + the largest possible addition
        // maximum chunk size (practically, theoretically infinite) is 2^17;
        if (noBuf) cbuf(bt + 131072);
        const lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        const mxa = lbt + dbt + 18;
        while(noSt || pos + mxa < tbts){
            // bits read, code
            const c1 = lm[bits16(dat, pos) & lms], sym = c1 >>> 4;
            pos += c1 & 15;
            if (pos > tbts) throw "unexpected EOF";
            if (!c1) throw "invalid length/literal";
            if (sym < 256) buf[bt++] = sym;
            else if (sym == 256) {
                lm = undefined;
                break;
            } else {
                let add = sym - 254; // no extra bits needed if less
                if (sym > 264) {
                    // index
                    const i2 = sym - 257, b = fleb[i2];
                    add = bits(dat, pos, (1 << b) - 1) + fl[i2];
                    pos += b;
                } // dist
                const d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                if (!d) throw "invalid distance";
                pos += d & 15;
                let dt1 = fd[dsym];
                if (dsym > 3) {
                    const b1 = fdeb[dsym];
                    dt1 += bits16(dat, pos) & (1 << b1) - 1, pos += b1;
                }
                if (pos > tbts) throw "unexpected EOF";
                if (noBuf) cbuf(bt + 131072);
                const end = bt + add;
                for(; bt < end; bt += 4){
                    buf[bt] = buf[bt - dt1];
                    buf[bt + 1] = buf[bt + 1 - dt1];
                    buf[bt + 2] = buf[bt + 2 - dt1];
                    buf[bt + 3] = buf[bt + 3 - dt1];
                }
                bt = end;
            }
        }
        st.l = lm, st.p = pos, st.b = bt;
        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    }while (!final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
}; // zlib valid
const zlv = (d)=>{
    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw "invalid zlib data";
    if (d[1] & 32) throw "invalid zlib data: preset dictionaries not supported";
};
function unzlibSync(data, out) {
    return inflt((zlv(data), data.subarray(2, -4)), out);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fp4I6":[function(require,module,exports) {
// Copyright 2019-2022 @polkadot/wasm-crypto-wasm authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Generated as part of the build, do not edit
const lenIn = 171116;
const lenOut = 339508;
const bytes = "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";
module.exports = {
    bytes,
    lenIn,
    lenOut
};

},{}],"fRM9H":[function(require,module,exports) {
"use strict";
var __dirname = "node_modules/@polkadot/wasm-crypto-init/cjs";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.packageInfo = void 0;
// Copyright 2017-2022 @polkadot/wasm-crypto-init authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
const packageInfo = {
    name: "@polkadot/wasm-crypto-init",
    path: typeof __dirname === "string" ? __dirname : "auto",
    type: "cjs",
    version: "6.3.1"
};
exports.packageInfo = packageInfo;

},{}],"6zSTS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "hmacShaAsU8a", ()=>(0, _shaAsU8AJs.hmacShaAsU8a));
parcelHelpers.export(exports, "hmacSha256AsU8a", ()=>(0, _shaAsU8AJs.hmacSha256AsU8a));
parcelHelpers.export(exports, "hmacSha512AsU8a", ()=>(0, _shaAsU8AJs.hmacSha512AsU8a));
var _shaAsU8AJs = require("./shaAsU8a.js");

},{"./shaAsU8a.js":"bWTBm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bWTBm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name hmacShaAsU8a
 * @description creates a Hmac Sha (256/512) Uint8Array from the key & data
 */ parcelHelpers.export(exports, "hmacShaAsU8a", ()=>hmacShaAsU8a);
parcelHelpers.export(exports, "hmacSha256AsU8a", ()=>hmacSha256AsU8a);
parcelHelpers.export(exports, "hmacSha512AsU8a", ()=>hmacSha512AsU8a);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _hmac = require("@noble/hashes/hmac");
var _sha256 = require("@noble/hashes/sha256");
var _sha512 = require("@noble/hashes/sha512");
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
const JS_HASH = {
    256: (0, _sha256.sha256),
    512: (0, _sha512.sha512)
};
const WA_MHAC = {
    256: (0, _wasmCrypto.hmacSha256),
    512: (0, _wasmCrypto.hmacSha512)
};
function createSha(bitLength) {
    return (key, data, onlyJs)=>hmacShaAsU8a(key, data, bitLength, onlyJs);
}
function hmacShaAsU8a(key, data, bitLength = 256, onlyJs) {
    const u8aKey = (0, _util.u8aToU8a)(key);
    return !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? WA_MHAC[bitLength](u8aKey, data) : (0, _hmac.hmac)(JS_HASH[bitLength], u8aKey, data);
}
const hmacSha256AsU8a = createSha(256);
const hmacSha512AsU8a = createSha(512);

},{"@noble/hashes/hmac":"3IfCc","@noble/hashes/sha256":"JjjO8","@noble/hashes/sha512":"jlH7E","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3IfCc":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hmac = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key){
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (!(this.iHash instanceof utils_js_1.Hash)) throw new TypeError("Expected instance of class which extends utils.Hash");
        const blockLen = this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(let i1 = 0; i1 < pad.length; i1++)pad[i1] ^= 106;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash , iHash , finished , destroyed , blockLen , outputLen  } = this;
        to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key)=>new HMAC(hash, key);

},{"./_assert.js":"BFdql","./utils.js":"2ehgp"}],"BFdql":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== "boolean") throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== "function" || typeof hash.create !== "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output
};
exports.default = assert;

},{}],"2ehgp":[function(require,module,exports) {
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// The import here is via the package name. This is to ensure
// that exports mapping/resolution does fall into place.
const crypto_1 = require("@noble/hashes/crypto");
// Cast array to different type
const u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift)=>word << 32 - shift | word >>> shift;
exports.rotr = rotr;
exports.isLE = new Uint8Array(new Uint32Array([
    0x11223344
]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!exports.isLE) throw new Error("Non little-endian hardware is not supported");
const hexes = Array.from({
    length: 256
}, (v, i)=>i.toString(16).padStart(2, "0"));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
 */ function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array)) throw new Error("Uint8Array expected");
    let hex = "";
    for(let i = 0; i < uint8a.length; i++)hex += hexes[uint8a[i]];
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('deadbeef')
 */ function hexToBytes(hex) {
    if (typeof hex !== "string") throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    if (hex.length % 2) throw new Error("hexToBytes: received invalid unpadded hex");
    const array = new Uint8Array(hex.length / 2);
    for(let i = 0; i < array.length; i++){
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) throw new Error("Invalid byte sequence");
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
const nextTick = async ()=>{};
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
function utf8ToBytes(str) {
    if (typeof str !== "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function toBytes(data) {
    if (typeof data === "string") data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */ function concatBytes(...arrays) {
    if (!arrays.every((a)=>a instanceof Uint8Array)) throw new Error("Uint8Array list expected");
    if (arrays.length === 1) return arrays[0];
    const length = arrays.reduce((a, arr)=>a + arr.length, 0);
    const result = new Uint8Array(length);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj)=>Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== "object" || !isPlainObject(opts))) throw new TypeError("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashConstructor) {
    const hashC = (message)=>hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashConstructor();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
/**
 * Secure PRNG
 */ function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto.web) return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
    else if (crypto_1.crypto.node) return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
    else throw new Error("The environment doesn't have randomBytes function");
}
exports.randomBytes = randomBytes;

},{"@noble/hashes/crypto":"7XNEy"}],"7XNEy":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crypto = void 0;
exports.crypto = {
    node: undefined,
    web: typeof self === "object" && "crypto" in self ? self.crypto : undefined
};

},{}],"JjjO8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha256 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const utils_js_1 = require("./utils.js");
// Choice: a ? b : c
const Chi = (a, b, c)=>a & b ^ ~a & c;
// Majority function, true if any two inpust is true
const Maj = (a, b, c)=>a & b ^ a & c ^ b & c;
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor(){
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A , B , C , D , E , F , G , H  } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i1 = 16; i1 < 64; i1++){
            const W15 = SHA256_W[i1 - 15];
            const W2 = SHA256_W[i1 - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i1] = s1 + SHA256_W[i1 - 7] + s0 + SHA256_W[i1 - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A , B , C , D , E , F , G , H  } = this;
        for(let i2 = 0; i2 < 64; i2++){
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */ exports.sha256 = (0, utils_js_1.wrapConstructor)(()=>new SHA256());

},{"./_sha2.js":"6HKeB","./utils.js":"2ehgp"}],"6HKeB":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SHA2 = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { view , buffer , blockLen  } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer , view , blockLen , isLE  } = this;
        let { pos  } = this;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        this.get().forEach((v, i)=>oview.setUint32(4 * i, v, isLE));
    }
    digest() {
        const { buffer , outputLen  } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen , buffer , length , finished , destroyed , pos  } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;

},{"./_assert.js":"BFdql","./utils.js":"2ehgp"}],"jlH7E":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha384 = exports.sha512_256 = exports.sha512 = exports.SHA512 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((n)=>BigInt(n)));
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = new Uint32Array(80);
const SHA512_W_L = new Uint32Array(80);
class SHA512 extends _sha2_js_1.SHA2 {
    constructor(){
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 1779033703;
        this.Al = -205731576;
        this.Bh = -1150833019;
        this.Bl = -2067093701;
        this.Ch = 1013904242;
        this.Cl = -23791573;
        this.Dh = -1521486534;
        this.Dl = 1595750129;
        this.Eh = 1359893119;
        this.El = -1377402159;
        this.Fh = -1694144372;
        this.Fl = 725511199;
        this.Gh = 528734635;
        this.Gl = -79577749;
        this.Hh = 1541459225;
        this.Hl = 327033209;
    }
    // prettier-ignore
    get() {
        const { Ah , Al , Bh , Bl , Ch , Cl , Dh , Dl , Eh , El , Fh , Fl , Gh , Gl , Hh , Hl  } = this;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(let i1 = 16; i1 < 80; i1++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i1 - 15] | 0;
            const W15l = SHA512_W_L[i1 - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i1 - 2] | 0;
            const W2l = SHA512_W_L[i1 - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i1 - 7], SHA512_W_L[i1 - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i1 - 7], SHA512_W_H[i1 - 16]);
            SHA512_W_H[i1] = SUMh | 0;
            SHA512_W_L[i1] = SUMl | 0;
        }
        let { Ah , Al , Bh , Bl , Ch , Cl , Dh , Dl , Eh , El , Fh , Fl , Gh , Gl , Hh , Hl  } = this;
        // Compression function main loop, 80 rounds
        for(let i2 = 0; i2 < 80; i2++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh , l: El  } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        ({ h: Ah , l: Al  } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh , l: Bl  } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch , l: Cl  } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh , l: Dl  } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh , l: El  } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh , l: Fl  } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh , l: Gl  } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh , l: Hl  } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA512_256 extends SHA512 {
    constructor(){
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 573645204;
        this.Al = -64227540;
        this.Bh = -1621794909;
        this.Bl = -934517566;
        this.Ch = 596883563;
        this.Cl = 1867755857;
        this.Dh = -1774684391;
        this.Dl = 1497426621;
        this.Eh = -1775747358;
        this.El = -1467023389;
        this.Fh = -1101128155;
        this.Fl = 1401305490;
        this.Gh = 721525244;
        this.Gl = 746961066;
        this.Hh = 246885852;
        this.Hl = -2117784414;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor(){
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = -876896931;
        this.Al = -1056596264;
        this.Bh = 1654270250;
        this.Bl = 914150663;
        this.Ch = -1856437926;
        this.Cl = 812702999;
        this.Dh = 355462360;
        this.Dl = -150054599;
        this.Eh = 1731405415;
        this.El = -4191439;
        this.Fh = -1900787065;
        this.Fl = 1750603025;
        this.Gh = -619958771;
        this.Gl = 1694076839;
        this.Hh = 1203062813;
        this.Hl = -1090891868;
        this.outputLen = 48;
    }
}
exports.sha512 = (0, utils_js_1.wrapConstructor)(()=>new SHA512());
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(()=>new SHA512_256());
exports.sha384 = (0, utils_js_1.wrapConstructor)(()=>new SHA384());

},{"./_sha2.js":"6HKeB","./_u64.js":"8TbxJ","./utils.js":"2ehgp"}],"8TbxJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for(let i = 0; i < lst.length; i++){
        const { h , l  } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
exports.split = split;
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s)=>h >>> s;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l)=>l;
const rotr32L = (h, l)=>h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig: exports.toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
exports.default = u64;

},{}],"j5ZWw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "addressToEvm", ()=>(0, _addressToEvmJs.addressToEvm));
parcelHelpers.export(exports, "checkAddress", ()=>(0, _checkJs.checkAddress));
parcelHelpers.export(exports, "checkAddressChecksum", ()=>(0, _checksumJs.checkAddressChecksum));
parcelHelpers.export(exports, "createKeyMulti", ()=>(0, _keyMultiJs.createKeyMulti));
parcelHelpers.export(exports, "createKeyDerived", ()=>(0, _keyDerivedJs.createKeyDerived));
parcelHelpers.export(exports, "decodeAddress", ()=>(0, _decodeJs.decodeAddress));
parcelHelpers.export(exports, "deriveAddress", ()=>(0, _deriveJs.deriveAddress));
parcelHelpers.export(exports, "encodeAddress", ()=>(0, _encodeJs.encodeAddress));
parcelHelpers.export(exports, "encodeDerivedAddress", ()=>(0, _encodeDerivedJs.encodeDerivedAddress));
parcelHelpers.export(exports, "encodeMultiAddress", ()=>(0, _encodeMultiJs.encodeMultiAddress));
parcelHelpers.export(exports, "evmToAddress", ()=>(0, _evmToAddressJs.evmToAddress));
parcelHelpers.export(exports, "addressEq", ()=>(0, _eqJs.addressEq));
parcelHelpers.export(exports, "isAddress", ()=>(0, _isJs.isAddress));
parcelHelpers.export(exports, "setSS58Format", ()=>(0, _setSS58FormatJs.setSS58Format));
parcelHelpers.export(exports, "sortAddresses", ()=>(0, _sortJs.sortAddresses));
parcelHelpers.export(exports, "validateAddress", ()=>(0, _validateJs.validateAddress));
var _addressToEvmJs = require("./addressToEvm.js");
var _checkJs = require("./check.js");
var _checksumJs = require("./checksum.js");
var _keyMultiJs = require("./keyMulti.js");
var _keyDerivedJs = require("./keyDerived.js");
var _decodeJs = require("./decode.js");
var _deriveJs = require("./derive.js");
var _encodeJs = require("./encode.js");
var _encodeDerivedJs = require("./encodeDerived.js");
var _encodeMultiJs = require("./encodeMulti.js");
var _evmToAddressJs = require("./evmToAddress.js");
var _eqJs = require("./eq.js");
var _isJs = require("./is.js");
var _setSS58FormatJs = require("./setSS58Format.js");
var _sortJs = require("./sort.js");
var _validateJs = require("./validate.js");

},{"./addressToEvm.js":"ljx8A","./check.js":"812rG","./checksum.js":"hXHdg","./keyMulti.js":"gJriE","./keyDerived.js":"jAPQm","./decode.js":"1wUOF","./derive.js":"jL6vS","./encode.js":"gkF5r","./encodeDerived.js":"gX3uS","./encodeMulti.js":"l3WPi","./evmToAddress.js":"egedG","./eq.js":"4yq86","./is.js":"2z18S","./setSS58Format.js":"fB8TL","./sort.js":"f2kEP","./validate.js":"9kCMO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ljx8A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name addressToEvm
 * @summary Converts an SS58 address to its corresponding EVM address.
 */ parcelHelpers.export(exports, "addressToEvm", ()=>addressToEvm);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _decodeJs = require("./decode.js");
function addressToEvm(address, ignoreChecksum) {
    return (0, _decodeJs.decodeAddress)(address, ignoreChecksum).subarray(0, 20);
}

},{"./decode.js":"1wUOF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1wUOF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeAddress", ()=>decodeAddress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L6
var _util = require("@polkadot/util");
var _indexJs = require("../base58/index.js");
var _checksumJs = require("./checksum.js");
var _defaultsJs = require("./defaults.js");
function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
    if (!encoded) throw new Error("Invalid empty address passed");
    if ((0, _util.isU8a)(encoded) || (0, _util.isHex)(encoded)) return (0, _util.u8aToU8a)(encoded);
    try {
        const decoded = (0, _indexJs.base58Decode)(encoded);
        if (!(0, _defaultsJs.defaults).allowedEncodedLengths.includes(decoded.length)) throw new Error("Invalid decoded address length");
        const [isValid, endPos, ss58Length, ss58Decoded] = (0, _checksumJs.checkAddressChecksum)(decoded);
        if (!isValid && !ignoreChecksum) throw new Error("Invalid decoded address checksum");
        else if (ss58Format !== -1 && ss58Format !== ss58Decoded) throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
        return decoded.slice(ss58Length, endPos);
    } catch (error) {
        throw new Error(`Decoding ${encoded}: ${error.message}`);
    }
}

},{"@polkadot/util":"3HnHw","../base58/index.js":"kXPnW","./checksum.js":"hXHdg","./defaults.js":"cxlL5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXPnW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Encode and decode base58 values
 */ parcelHelpers.export(exports, "base58Decode", ()=>(0, _bs58Js.base58Decode));
parcelHelpers.export(exports, "base58Encode", ()=>(0, _bs58Js.base58Encode));
parcelHelpers.export(exports, "base58Validate", ()=>(0, _bs58Js.base58Validate));
parcelHelpers.export(exports, "isBase58", ()=>(0, _bs58Js.isBase58));
var _bs58Js = require("./bs58.js");

},{"./bs58.js":"01wtS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"01wtS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base58Validate", ()=>base58Validate);
parcelHelpers.export(exports, "base58Decode", ()=>base58Decode);
parcelHelpers.export(exports, "base58Encode", ()=>base58Encode);
parcelHelpers.export(exports, "isBase58", ()=>isBase58);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _base = require("@scure/base");
var _helpersJs = require("../base32/helpers.js");
const config = {
    chars: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
    coder: (0, _base.base58),
    ipfs: "z",
    type: "base58"
};
const base58Validate = (0, _helpersJs.createValidate)(config);
const base58Decode = (0, _helpersJs.createDecode)(config, base58Validate);
const base58Encode = (0, _helpersJs.createEncode)(config);
const isBase58 = (0, _helpersJs.createIs)(base58Validate);

},{"@scure/base":"cvmUK","../base32/helpers.js":"azXie","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cvmUK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ parcelHelpers.export(exports, "assertNumber", ()=>assertNumber);
parcelHelpers.export(exports, "utils", ()=>utils);
parcelHelpers.export(exports, "base16", ()=>base16);
parcelHelpers.export(exports, "base32", ()=>base32);
parcelHelpers.export(exports, "base32hex", ()=>base32hex);
parcelHelpers.export(exports, "base32crockford", ()=>base32crockford);
parcelHelpers.export(exports, "base64", ()=>base64);
parcelHelpers.export(exports, "base64url", ()=>base64url);
parcelHelpers.export(exports, "base58", ()=>base58);
parcelHelpers.export(exports, "base58flickr", ()=>base58flickr);
parcelHelpers.export(exports, "base58xrp", ()=>base58xrp);
parcelHelpers.export(exports, "base58xmr", ()=>base58xmr);
parcelHelpers.export(exports, "base58check", ()=>base58check);
parcelHelpers.export(exports, "bech32", ()=>bech32);
parcelHelpers.export(exports, "bech32m", ()=>bech32m);
parcelHelpers.export(exports, "utf8", ()=>utf8);
parcelHelpers.export(exports, "hex", ()=>hex);
parcelHelpers.export(exports, "bytesToString", ()=>bytesToString);
parcelHelpers.export(exports, "str", ()=>str);
parcelHelpers.export(exports, "stringToBytes", ()=>stringToBytes);
parcelHelpers.export(exports, "bytes", ()=>bytes);
function assertNumber(n) {
    if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);
}
function chain(...args) {
    const wrap = (a, b)=>(c)=>a(b(c));
    const encode = Array.from(args).reverse().reduce((acc, i)=>acc ? wrap(acc, i.encode) : i.encode, undefined);
    const decode = args.reduce((acc, i)=>acc ? wrap(acc, i.decode) : i.decode, undefined);
    return {
        encode,
        decode
    };
}
function alphabet(alphabet) {
    return {
        encode: (digits)=>{
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number") throw new Error("alphabet.encode input should be an array of numbers");
            return digits.map((i)=>{
                assertNumber(i);
                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);
                return alphabet[i];
            });
        },
        decode: (input)=>{
            if (!Array.isArray(input) || input.length && typeof input[0] !== "string") throw new Error("alphabet.decode input should be array of strings");
            return input.map((letter)=>{
                if (typeof letter !== "string") throw new Error(`alphabet.decode: not string element=${letter}`);
                const index = alphabet.indexOf(letter);
                if (index === -1) throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet}`);
                return index;
            });
        }
    };
}
function join(separator = "") {
    if (typeof separator !== "string") throw new Error("join separator should be string");
    return {
        encode: (from)=>{
            if (!Array.isArray(from) || from.length && typeof from[0] !== "string") throw new Error("join.encode input should be array of strings");
            for (let i of from)if (typeof i !== "string") throw new Error(`join.encode: non-string input=${i}`);
            return from.join(separator);
        },
        decode: (to)=>{
            if (typeof to !== "string") throw new Error("join.decode input should be string");
            return to.split(separator);
        }
    };
}
function padding(bits, chr = "=") {
    assertNumber(bits);
    if (typeof chr !== "string") throw new Error("padding chr should be string");
    return {
        encode (data) {
            if (!Array.isArray(data) || data.length && typeof data[0] !== "string") throw new Error("padding.encode input should be array of strings");
            for (let i of data)if (typeof i !== "string") throw new Error(`padding.encode: non-string input=${i}`);
            while(data.length * bits % 8)data.push(chr);
            return data;
        },
        decode (input) {
            if (!Array.isArray(input) || input.length && typeof input[0] !== "string") throw new Error("padding.encode input should be array of strings");
            for (let i of input)if (typeof i !== "string") throw new Error(`padding.decode: non-string input=${i}`);
            let end = input.length;
            if (end * bits % 8) throw new Error("Invalid padding: string should have whole number of bytes");
            for(; end > 0 && input[end - 1] === chr; end--){
                if (!((end - 1) * bits % 8)) throw new Error("Invalid padding: string has too much padding");
            }
            return input.slice(0, end);
        }
    };
}
function normalize(fn) {
    if (typeof fn !== "function") throw new Error("normalize fn should be function");
    return {
        encode: (from)=>from,
        decode: (to)=>fn(to)
    };
}
function convertRadix(data, from, to) {
    if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
    if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
    if (!Array.isArray(data)) throw new Error("convertRadix: data should be array");
    if (!data.length) return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data);
    digits.forEach((d)=>{
        assertNumber(d);
        if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);
    });
    while(true){
        let carry = 0;
        let done = true;
        for(let i = pos; i < digits.length; i++){
            const digit = digits[i];
            const digitBase = from * carry + digit;
            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) throw new Error("convertRadix: carry overflow");
            carry = digitBase % to;
            digits[i] = Math.floor(digitBase / to);
            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase) throw new Error("convertRadix: carry overflow");
            if (!done) continue;
            else if (!digits[i]) pos = i;
            else done = false;
        }
        res.push(carry);
        if (done) break;
    }
    for(let i1 = 0; i1 < data.length - 1 && data[i1] === 0; i1++)res.push(0);
    return res.reverse();
}
const gcd = (a, b)=>!b ? a : gcd(b, a % b);
const radix2carry = (from, to)=>from + (to - gcd(from, to));
function convertRadix2(data, from, to, padding) {
    if (!Array.isArray(data)) throw new Error("convertRadix2: data should be array");
    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    let carry = 0;
    let pos = 0;
    const mask = 2 ** to - 1;
    const res = [];
    for (const n of data){
        assertNumber(n);
        if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);
        carry &= 2 ** pos - 1;
    }
    carry = carry << to - pos & mask;
    if (!padding && pos >= from) throw new Error("Excess padding");
    if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0) res.push(carry >>> 0);
    return res;
}
function radix(num) {
    assertNumber(num);
    return {
        encode: (bytes)=>{
            if (!(bytes instanceof Uint8Array)) throw new Error("radix.encode input should be Uint8Array");
            return convertRadix(Array.from(bytes), 256, num);
        },
        decode: (digits)=>{
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number") throw new Error("radix.decode input should be array of strings");
            return Uint8Array.from(convertRadix(digits, num, 256));
        }
    };
}
function radix2(bits, revPadding = false) {
    assertNumber(bits);
    if (bits <= 0 || bits > 32) throw new Error("radix2: bits should be in (0..32]");
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error("radix2: carry overflow");
    return {
        encode: (bytes)=>{
            if (!(bytes instanceof Uint8Array)) throw new Error("radix2.encode input should be Uint8Array");
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits)=>{
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number") throw new Error("radix2.decode input should be array of strings");
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
    };
}
function unsafeWrapper(fn) {
    if (typeof fn !== "function") throw new Error("unsafeWrapper fn should be function");
    return function(...args) {
        try {
            return fn.apply(null, args);
        } catch (e) {}
    };
}
function checksum(len, fn) {
    assertNumber(len);
    if (typeof fn !== "function") throw new Error("checksum fn should be function");
    return {
        encode (data) {
            if (!(data instanceof Uint8Array)) throw new Error("checksum.encode: input should be Uint8Array");
            const checksum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(checksum, data.length);
            return res;
        },
        decode (data) {
            if (!(data instanceof Uint8Array)) throw new Error("checksum.decode: input should be Uint8Array");
            const payload = data.slice(0, -len);
            const newChecksum = fn(payload).slice(0, len);
            const oldChecksum = data.slice(-len);
            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error("Invalid checksum");
            return payload;
        }
    };
}
const utils = {
    alphabet,
    chain,
    checksum,
    radix,
    radix2,
    join,
    padding
};
const base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
const base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
const base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
const base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s)=>s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
const base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
const base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
const genBase58 = (abc)=>chain(radix(58), alphabet(abc), join(""));
const base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
const base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
const base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
const XMR_BLOCK_LEN = [
    0,
    2,
    3,
    5,
    6,
    7,
    9,
    10,
    11
];
const base58xmr = {
    encode (data) {
        let res = "";
        for(let i = 0; i < data.length; i += 8){
            const block = data.subarray(i, i + 8);
            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
    },
    decode (str) {
        let res = [];
        for(let i = 0; i < str.length; i += 11){
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = base58.decode(slice);
            for(let j = 0; j < block.length - blockLen; j++){
                if (block[j] !== 0) throw new Error("base58xmr: wrong padding");
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    }
};
const base58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);
const BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
const POLYMOD_GENERATORS = [
    0x3b6a57b2,
    0x26508e6d,
    0x1ea119fa,
    0x3d4233dd,
    0x2a1462b3
];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for(let i = 0; i < POLYMOD_GENERATORS.length; i++)if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for(let i = 0; i < len; i++){
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c >> 5;
    }
    chk = bech32Polymod(chk);
    for(let i1 = 0; i1 < len; i1++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i1) & 0x1f;
    for (let v of words)chk = bech32Polymod(chk) ^ v;
    for(let i2 = 0; i2 < 6; i2++)chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([
        chk % 2 ** 30
    ], 30, 5, false));
}
function genBech32(encoding) {
    const ENCODING_CONST = encoding === "bech32" ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        if (typeof prefix !== "string") throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || words.length && typeof words[0] !== "number") throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        prefix = prefix.toLowerCase();
        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
    }
    function decode(str, limit = 90) {
        if (typeof str !== "string") throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words = str.slice(sepIndex + 1);
        if (_words.length < 6) throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET.decode(_words).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return {
            prefix,
            words
        };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix , words  } = decode(str, false);
        return {
            prefix,
            words,
            bytes: fromWords(words)
        };
    }
    return {
        encode,
        decode,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords
    };
}
const bech32 = genBech32("bech32");
const bech32m = genBech32("bech32m");
const utf8 = {
    encode: (data)=>new TextDecoder().decode(data),
    decode: (str)=>new TextEncoder().encode(str)
};
const hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s)=>{
    if (typeof s !== "string" || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
const CODERS = {
    utf8,
    hex,
    base16,
    base32,
    base64,
    base64url,
    base58,
    base58xmr
};
const coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;
const bytesToString = (type, bytes)=>{
    if (typeof type !== "string" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (!(bytes instanceof Uint8Array)) throw new TypeError("bytesToString() expects Uint8Array");
    return CODERS[type].encode(bytes);
};
const str = bytesToString;
const stringToBytes = (type, str)=>{
    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (typeof str !== "string") throw new TypeError("stringToBytes() expects string");
    return CODERS[type].decode(str);
};
const bytes = stringToBytes;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"azXie":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "createDecode", ()=>createDecode);
/** @internal */ parcelHelpers.export(exports, "createEncode", ()=>createEncode);
/** @internal */ parcelHelpers.export(exports, "createIs", ()=>createIs);
/** @internal */ parcelHelpers.export(exports, "createValidate", ()=>createValidate);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util"); // re-export the type so *.d.ts files don't have ../src imports
function createDecode({ coder , ipfs  }, validate) {
    return (value, ipfsCompat)=>{
        validate(value, ipfsCompat);
        return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);
    };
}
function createEncode({ coder , ipfs  }) {
    return (value, ipfsCompat)=>{
        const out = coder.encode((0, _util.u8aToU8a)(value));
        return ipfs && ipfsCompat ? `${ipfs}${out}` : out;
    };
}
function createIs(validate) {
    return (value, ipfsCompat)=>{
        try {
            return validate(value, ipfsCompat);
        } catch (error) {
            return false;
        }
    };
}
function createValidate({ chars , ipfs , type  }) {
    return (value, ipfsCompat)=>{
        if (!value || typeof value !== "string") throw new Error(`Expected non-null, non-empty ${type} string input`);
        if (ipfs && ipfsCompat && value[0] !== ipfs) throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);
        for(let i = ipfsCompat ? 1 : 0; i < value.length; i++){
            if (!(chars.includes(value[i]) || value[i] === "=" && (i === value.length - 1 || !chars.includes(value[i + 1])))) throw new Error(`Invalid ${type} character "${value[i]}" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);
        }
        return true;
    };
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hXHdg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkAddressChecksum", ()=>checkAddressChecksum);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _sshashJs = require("./sshash.js");
function checkAddressChecksum(decoded) {
    const ss58Length = decoded[0] & 64 ? 2 : 1;
    const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 63) << 2 | decoded[1] >> 6 | (decoded[1] & 63) << 8; // 32/33 bytes public + 2 bytes checksum + prefix
    const isPublicKey = [
        34 + ss58Length,
        35 + ss58Length
    ].includes(decoded.length);
    const length = decoded.length - (isPublicKey ? 2 : 1); // calculate the hash and do the checksum byte checks
    const hash = (0, _sshashJs.sshash)(decoded.subarray(0, length));
    const isValid = (decoded[0] & 128) === 0 && ![
        46,
        47
    ].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1] : decoded[decoded.length - 1] === hash[0]);
    return [
        isValid,
        length,
        ss58Length,
        ss58Decoded
    ];
}

},{"./sshash.js":"4NFl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4NFl1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sshash", ()=>sshash);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _asU8AJs = require("../blake2/asU8a.js");
const SS58_PREFIX = (0, _util.stringToU8a)("SS58PRE");
function sshash(key) {
    return (0, _asU8AJs.blake2AsU8a)((0, _util.u8aConcat)(SS58_PREFIX, key), 512);
}

},{"@polkadot/util":"3HnHw","../blake2/asU8a.js":"3rNsT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3rNsT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name blake2AsU8a
 * @summary Creates a blake2b u8a from the input.
 * @description
 * From a `Uint8Array` input, create the blake2b and return the result as a u8a with the specified `bitLength`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { blake2AsU8a } from '@polkadot/util-crypto';
 *
 * blake2AsU8a('abc'); // => [0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d]
 * ```
 */ parcelHelpers.export(exports, "blake2AsU8a", ()=>blake2AsU8a);
parcelHelpers.export(exports, "blake2AsHex", ()=>blake2AsHex);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _blake2B = require("@noble/hashes/blake2b");
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _helpersJs = require("../helpers.js");
function blake2AsU8a(data, bitLength = 256, key, onlyJs) {
    const byteLength = Math.ceil(bitLength / 8);
    const u8a = (0, _util.u8aToU8a)(data);
    return !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.blake2b)(u8a, (0, _util.u8aToU8a)(key), byteLength) : (0, _blake2B.blake2b)(u8a, {
        dkLen: byteLength,
        key: key || undefined
    });
}
const blake2AsHex = (0, _helpersJs.createAsHex)(blake2AsU8a);

},{"@noble/hashes/blake2b":"f8gy4","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","../helpers.js":"by01j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f8gy4":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.blake2b = void 0;
const _blake2_js_1 = require("./_blake2.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Same as SHA-512 but LE
// prettier-ignore
const IV = new Uint32Array([
    0xf3bcc908,
    0x6a09e667,
    0x84caa73b,
    0xbb67ae85,
    0xfe94f82b,
    0x3c6ef372,
    0x5f1d36f1,
    0xa54ff53a,
    0xade682d1,
    0x510e527f,
    0x2b3e6c1f,
    0x9b05688c,
    0xfb41bd6b,
    0x1f83d9ab,
    0x137e2179,
    0x5be0cd19
]);
// Temporary buffer
const BUF = new Uint32Array(32);
// Mixing function G splitted in two halfs
function G1(a, b, c, d, msg, x) {
    // NOTE: V is LE here
    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore
    let Al = BUF[2 * a], Ah = BUF[2 * a + 1]; // prettier-ignore
    let Bl = BUF[2 * b], Bh = BUF[2 * b + 1]; // prettier-ignore
    let Cl = BUF[2 * c], Ch = BUF[2 * c + 1]; // prettier-ignore
    let Dl = BUF[2 * d], Dh = BUF[2 * d + 1]; // prettier-ignore
    // v[a] = (v[a] + v[b] + x) | 0;
    let ll = _u64_js_1.default.add3L(Al, Bl, Xl);
    Ah = _u64_js_1.default.add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    ({ Dh , Dl  } = {
        Dh: Dh ^ Ah,
        Dl: Dl ^ Al
    });
    ({ Dh , Dl  } = {
        Dh: _u64_js_1.default.rotr32H(Dh, Dl),
        Dl: _u64_js_1.default.rotr32L(Dh, Dl)
    });
    ({ h: Ch , l: Cl  } = _u64_js_1.default.add(Ch, Cl, Dh, Dl));
    ({ Bh , Bl  } = {
        Bh: Bh ^ Ch,
        Bl: Bl ^ Cl
    });
    ({ Bh , Bl  } = {
        Bh: _u64_js_1.default.rotrSH(Bh, Bl, 24),
        Bl: _u64_js_1.default.rotrSL(Bh, Bl, 24)
    });
    BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;
    BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;
    BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;
    BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;
}
function G2(a, b, c, d, msg, x) {
    // NOTE: V is LE here
    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore
    let Al = BUF[2 * a], Ah = BUF[2 * a + 1]; // prettier-ignore
    let Bl = BUF[2 * b], Bh = BUF[2 * b + 1]; // prettier-ignore
    let Cl = BUF[2 * c], Ch = BUF[2 * c + 1]; // prettier-ignore
    let Dl = BUF[2 * d], Dh = BUF[2 * d + 1]; // prettier-ignore
    // v[a] = (v[a] + v[b] + x) | 0;
    let ll = _u64_js_1.default.add3L(Al, Bl, Xl);
    Ah = _u64_js_1.default.add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    ({ Dh , Dl  } = {
        Dh: Dh ^ Ah,
        Dl: Dl ^ Al
    });
    ({ Dh , Dl  } = {
        Dh: _u64_js_1.default.rotrSH(Dh, Dl, 16),
        Dl: _u64_js_1.default.rotrSL(Dh, Dl, 16)
    });
    ({ h: Ch , l: Cl  } = _u64_js_1.default.add(Ch, Cl, Dh, Dl));
    ({ Bh , Bl  } = {
        Bh: Bh ^ Ch,
        Bl: Bl ^ Cl
    });
    ({ Bh , Bl  } = {
        Bh: _u64_js_1.default.rotrBH(Bh, Bl, 63),
        Bl: _u64_js_1.default.rotrBL(Bh, Bl, 63)
    });
    BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;
    BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;
    BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;
    BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;
}
class BLAKE2b extends _blake2_js_1.BLAKE2 {
    constructor(opts = {}){
        super(128, opts.dkLen === undefined ? 64 : opts.dkLen, opts, 64, 16, 16);
        // Same as SHA-512, but LE
        this.v0l = IV[0] | 0;
        this.v0h = IV[1] | 0;
        this.v1l = IV[2] | 0;
        this.v1h = IV[3] | 0;
        this.v2l = IV[4] | 0;
        this.v2h = IV[5] | 0;
        this.v3l = IV[6] | 0;
        this.v3h = IV[7] | 0;
        this.v4l = IV[8] | 0;
        this.v4h = IV[9] | 0;
        this.v5l = IV[10] | 0;
        this.v5h = IV[11] | 0;
        this.v6l = IV[12] | 0;
        this.v6h = IV[13] | 0;
        this.v7l = IV[14] | 0;
        this.v7h = IV[15] | 0;
        const keyLength = opts.key ? opts.key.length : 0;
        this.v0l ^= this.outputLen | keyLength << 8 | 16842752;
        if (opts.salt) {
            const salt = (0, utils_js_1.u32)((0, utils_js_1.toBytes)(opts.salt));
            this.v4l ^= salt[0];
            this.v4h ^= salt[1];
            this.v5l ^= salt[2];
            this.v5h ^= salt[3];
        }
        if (opts.personalization) {
            const pers = (0, utils_js_1.u32)((0, utils_js_1.toBytes)(opts.personalization));
            this.v6l ^= pers[0];
            this.v6h ^= pers[1];
            this.v7l ^= pers[2];
            this.v7h ^= pers[3];
        }
        if (opts.key) {
            // Pad to blockLen and update
            const tmp = new Uint8Array(this.blockLen);
            tmp.set((0, utils_js_1.toBytes)(opts.key));
            this.update(tmp);
        }
    }
    // prettier-ignore
    get() {
        let { v0l , v0h , v1l , v1h , v2l , v2h , v3l , v3h , v4l , v4h , v5l , v5h , v6l , v6h , v7l , v7h  } = this;
        return [
            v0l,
            v0h,
            v1l,
            v1h,
            v2l,
            v2h,
            v3l,
            v3h,
            v4l,
            v4h,
            v5l,
            v5h,
            v6l,
            v6h,
            v7l,
            v7h
        ];
    }
    // prettier-ignore
    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
        this.v0l = v0l | 0;
        this.v0h = v0h | 0;
        this.v1l = v1l | 0;
        this.v1h = v1h | 0;
        this.v2l = v2l | 0;
        this.v2h = v2h | 0;
        this.v3l = v3l | 0;
        this.v3h = v3h | 0;
        this.v4l = v4l | 0;
        this.v4h = v4h | 0;
        this.v5l = v5l | 0;
        this.v5h = v5h | 0;
        this.v6l = v6l | 0;
        this.v6h = v6h | 0;
        this.v7l = v7l | 0;
        this.v7h = v7h | 0;
    }
    compress(msg, offset, isLast) {
        this.get().forEach((v, i)=>BUF[i] = v); // First half from state.
        BUF.set(IV, 16); // Second half from IV.
        let { h , l  } = _u64_js_1.default.fromBig(BigInt(this.length));
        BUF[24] = IV[8] ^ l; // Low word of the offset.
        BUF[25] = IV[9] ^ h; // High word.
        // Invert all bits for last block
        if (isLast) {
            BUF[28] = ~BUF[28];
            BUF[29] = ~BUF[29];
        }
        let j = 0;
        const s = _blake2_js_1.SIGMA;
        for(let i = 0; i < 12; i++){
            G1(0, 4, 8, 12, msg, offset + 2 * s[j++]);
            G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);
            G1(1, 5, 9, 13, msg, offset + 2 * s[j++]);
            G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);
            G1(2, 6, 10, 14, msg, offset + 2 * s[j++]);
            G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);
            G1(3, 7, 11, 15, msg, offset + 2 * s[j++]);
            G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);
            G1(0, 5, 10, 15, msg, offset + 2 * s[j++]);
            G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);
            G1(1, 6, 11, 12, msg, offset + 2 * s[j++]);
            G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);
            G1(2, 7, 8, 13, msg, offset + 2 * s[j++]);
            G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);
            G1(3, 4, 9, 14, msg, offset + 2 * s[j++]);
            G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);
        }
        this.v0l ^= BUF[0] ^ BUF[16];
        this.v0h ^= BUF[1] ^ BUF[17];
        this.v1l ^= BUF[2] ^ BUF[18];
        this.v1h ^= BUF[3] ^ BUF[19];
        this.v2l ^= BUF[4] ^ BUF[20];
        this.v2h ^= BUF[5] ^ BUF[21];
        this.v3l ^= BUF[6] ^ BUF[22];
        this.v3h ^= BUF[7] ^ BUF[23];
        this.v4l ^= BUF[8] ^ BUF[24];
        this.v4h ^= BUF[9] ^ BUF[25];
        this.v5l ^= BUF[10] ^ BUF[26];
        this.v5h ^= BUF[11] ^ BUF[27];
        this.v6l ^= BUF[12] ^ BUF[28];
        this.v6h ^= BUF[13] ^ BUF[29];
        this.v7l ^= BUF[14] ^ BUF[30];
        this.v7h ^= BUF[15] ^ BUF[31];
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer32.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
/**
 * BLAKE2b - optimized for 64-bit platforms. JS doesn't have uint64, so it's slower than BLAKE2s.
 * @param msg - message that would be hashed
 * @param opts - dkLen, key, salt, personalization
 */ exports.blake2b = (0, utils_js_1.wrapConstructorWithOpts)((opts)=>new BLAKE2b(opts));

},{"./_blake2.js":"kbe9J","./_u64.js":"8TbxJ","./utils.js":"2ehgp"}],"kbe9J":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BLAKE2 = exports.SIGMA = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// prettier-ignore
exports.SIGMA = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    // For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3, 
]);
class BLAKE2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen){
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.length = 0;
        this.pos = 0;
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.number(blockLen);
        _assert_js_1.default.number(outputLen);
        _assert_js_1.default.number(keyLen);
        if (outputLen < 0 || outputLen > keyLen) throw new Error("Blake2: outputLen bigger than keyLen");
        if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen)) throw new Error(`Key should be up 1..${keyLen} byte long or undefined`);
        if (opts.salt !== undefined && opts.salt.length !== saltLen) throw new Error(`Salt should be ${saltLen} byte long or undefined`);
        if (opts.personalization !== undefined && opts.personalization.length !== persLen) throw new Error(`Personalization should be ${persLen} byte long or undefined`);
        this.buffer32 = (0, utils_js_1.u32)(this.buffer = new Uint8Array(blockLen));
    }
    update(data) {
        _assert_js_1.default.exists(this);
        // Main difference with other hashes: there is flag for last block,
        // so we cannot process current block before we know that there
        // is the next one. This significantly complicates logic and reduces ability
        // to do zero-copy processing
        const { blockLen , buffer , buffer32  } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            // If buffer is full and we still have input (don't process last block, same as blake2s)
            if (this.pos === blockLen) {
                this.compress(buffer32, 0, false);
                this.pos = 0;
            }
            const take = Math.min(blockLen - this.pos, len - pos);
            const dataOffset = data.byteOffset + pos;
            // full block && aligned to 4 bytes && not last in input
            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
                const data32 = new Uint32Array(data.buffer, dataOffset, Math.floor((len - pos) / 4));
                for(let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen){
                    this.length += blockLen;
                    this.compress(data32, pos32, false);
                }
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            this.length += take;
            pos += take;
        }
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        const { pos , buffer32  } = this;
        this.finished = true;
        // Padding
        this.buffer.subarray(pos).fill(0);
        this.compress(buffer32, 0, true);
        const out32 = (0, utils_js_1.u32)(out);
        this.get().forEach((v, i)=>out32[i] = v);
    }
    digest() {
        const { buffer , outputLen  } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        const { buffer , length , finished , destroyed , outputLen , pos  } = this;
        to || (to = new this.constructor({
            dkLen: outputLen
        }));
        to.set(...this.get());
        to.length = length;
        to.finished = finished;
        to.destroyed = destroyed;
        to.outputLen = outputLen;
        to.buffer.set(buffer);
        to.pos = pos;
        return to;
    }
}
exports.BLAKE2 = BLAKE2;

},{"./_assert.js":"BFdql","./utils.js":"2ehgp"}],"by01j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "createAsHex", ()=>createAsHex);
/** @internal */ parcelHelpers.export(exports, "createBitHasher", ()=>createBitHasher);
/** @internal */ parcelHelpers.export(exports, "createDualHasher", ()=>createDualHasher);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto"); // re-export so TS *.d.ts generation is correct
function createAsHex(fn) {
    return (...args)=>(0, _util.u8aToHex)(fn(...args));
}
function createBitHasher(bitLength, fn) {
    return (data, onlyJs)=>fn(data, bitLength, onlyJs);
}
function createDualHasher(wa, js) {
    return (value, bitLength = 256, onlyJs)=>{
        const u8a = (0, _util.u8aToU8a)(value);
        return !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? wa[bitLength](u8a) : js[bitLength](u8a);
    };
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cxlL5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaults", ()=>defaults);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _networksJs = require("../networks.js");
const defaults = {
    allowedDecodedLengths: [
        1,
        2,
        4,
        8,
        32,
        33
    ],
    // publicKey has prefix + 2 checksum bytes, short only prefix + 1 checksum byte
    allowedEncodedLengths: [
        3,
        4,
        6,
        10,
        35,
        36,
        37,
        38
    ],
    allowedPrefix: (0, _networksJs.availableNetworks).map(({ prefix  })=>prefix),
    prefix: 42
};

},{"../networks.js":"fgfoM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fgfoM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Don't use a export * since we don't want to duplicate packageInfo
parcelHelpers.export(exports, "allNetworks", ()=>(0, _networks.allNetworks));
parcelHelpers.export(exports, "availableNetworks", ()=>(0, _networks.availableNetworks));
parcelHelpers.export(exports, "selectableNetworks", ()=>(0, _networks.selectableNetworks));
var _networks = require("@polkadot/networks");

},{"@polkadot/networks":"1v38R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1v38R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
// Copyright 2017-2022 @polkadot/networks authors & contributors
// SPDX-License-Identifier: Apache-2.0
// TODO: This was removed, really cannot recall the reason...
// ... put it back, but keep it removed
// import './detectPackage';
var _interfacesJs = require("./interfaces.js");
parcelHelpers.exportAll(_interfacesJs, exports);
var _packageInfoJs = require("./packageInfo.js");

},{"./interfaces.js":"3cEnh","./packageInfo.js":"599GG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3cEnh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "allNetworks", ()=>allNetworks);
parcelHelpers.export(exports, "availableNetworks", ()=>availableNetworks);
parcelHelpers.export(exports, "selectableNetworks", ()=>selectableNetworks);
// Copyright 2017-2022 @polkadot/networks authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _ss58Registry = require("@substrate/ss58-registry");
var _ss58RegistryDefault = parcelHelpers.interopDefault(_ss58Registry);
var _indexJs = require("./defaults/index.js"); // These are known prefixes that are not sorted
const UNSORTED = [
    0,
    2,
    42
];
const TESTNETS = [
    "testnet"
];
function toExpanded(o) {
    const network = o.network || "";
    const nameParts = network.replace(/_/g, "-").split("-");
    const n = o; // ledger additions
    n.slip44 = (0, _indexJs.knownLedger)[network];
    n.hasLedgerSupport = !!n.slip44; // general items
    n.genesisHash = (0, _indexJs.knownGenesis)[network] || [];
    n.icon = (0, _indexJs.knownIcon)[network] || "substrate"; // filtering
    n.isTestnet = !!(0, _indexJs.knownTestnet)[network] || TESTNETS.includes(nameParts[nameParts.length - 1]);
    n.isIgnored = n.isTestnet || !(o.standardAccount && o.decimals && o.decimals.length && o.symbols && o.symbols.length) && o.prefix !== 42;
    return n;
}
function filterSelectable({ genesisHash , prefix  }) {
    return !!genesisHash.length || prefix === 42;
}
function filterAvailable(n) {
    return !n.isIgnored && !!n.network;
}
function sortNetworks(a, b) {
    const isUnSortedA = UNSORTED.includes(a.prefix);
    const isUnSortedB = UNSORTED.includes(b.prefix);
    return isUnSortedA === isUnSortedB ? isUnSortedA ? 0 : a.displayName.localeCompare(b.displayName) : isUnSortedA ? -1 : 1;
} // This is all the Substrate networks with our additional information
const allNetworks = (0, _ss58RegistryDefault.default).map(toExpanded); // The list of available/claimed prefixes
const availableNetworks = allNetworks.filter(filterAvailable).sort(sortNetworks); // A filtered list of those chains we have details about (genesisHashes)
const selectableNetworks = availableNetworks.filter(filterSelectable);

},{"@substrate/ss58-registry":"e0Lzj","./defaults/index.js":"f5nUP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e0Lzj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright (C) 2021-2022 Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
exports.default = [
    {
        "prefix": 0,
        "network": "polkadot",
        "displayName": "Polkadot Relay Chain",
        "symbols": [
            "DOT"
        ],
        "decimals": [
            10
        ],
        "standardAccount": "*25519",
        "website": "https://polkadot.network"
    },
    {
        "prefix": 1,
        "network": "BareSr25519",
        "displayName": "Bare 32-bit Schnorr/Ristretto (S/R 25519) public key.",
        "symbols": [],
        "decimals": [],
        "standardAccount": "Sr25519",
        "website": null
    },
    {
        "prefix": 2,
        "network": "kusama",
        "displayName": "Kusama Relay Chain",
        "symbols": [
            "KSM"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://kusama.network"
    },
    {
        "prefix": 3,
        "network": "BareEd25519",
        "displayName": "Bare 32-bit Ed25519 public key.",
        "symbols": [],
        "decimals": [],
        "standardAccount": "Ed25519",
        "website": null
    },
    {
        "prefix": 4,
        "network": "katalchain",
        "displayName": "Katal Chain",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": null
    },
    {
        "prefix": 5,
        "network": "astar",
        "displayName": "Astar Network",
        "symbols": [
            "ASTR"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://astar.network"
    },
    {
        "prefix": 6,
        "network": "bifrost",
        "displayName": "Bifrost",
        "symbols": [
            "BNC"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://bifrost.finance/"
    },
    {
        "prefix": 7,
        "network": "edgeware",
        "displayName": "Edgeware",
        "symbols": [
            "EDG"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://edgewa.re"
    },
    {
        "prefix": 8,
        "network": "karura",
        "displayName": "Karura",
        "symbols": [
            "KAR"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://karura.network/"
    },
    {
        "prefix": 9,
        "network": "reynolds",
        "displayName": "Laminar Reynolds Canary",
        "symbols": [
            "REY"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "http://laminar.network/"
    },
    {
        "prefix": 10,
        "network": "acala",
        "displayName": "Acala",
        "symbols": [
            "ACA"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://acala.network/"
    },
    {
        "prefix": 11,
        "network": "laminar",
        "displayName": "Laminar",
        "symbols": [
            "LAMI"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "http://laminar.network/"
    },
    {
        "prefix": 12,
        "network": "polymesh",
        "displayName": "Polymesh",
        "symbols": [
            "POLYX"
        ],
        "decimals": [
            6
        ],
        "standardAccount": "*25519",
        "website": "https://polymath.network/"
    },
    {
        "prefix": 13,
        "network": "integritee",
        "displayName": "Integritee",
        "symbols": [
            "TEER"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://integritee.network"
    },
    {
        "prefix": 14,
        "network": "totem",
        "displayName": "Totem",
        "symbols": [
            "TOTEM"
        ],
        "decimals": [
            0
        ],
        "standardAccount": "*25519",
        "website": "https://totemaccounting.com"
    },
    {
        "prefix": 15,
        "network": "synesthesia",
        "displayName": "Synesthesia",
        "symbols": [
            "SYN"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://synesthesia.network/"
    },
    {
        "prefix": 16,
        "network": "kulupu",
        "displayName": "Kulupu",
        "symbols": [
            "KLP"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://kulupu.network/"
    },
    {
        "prefix": 17,
        "network": "dark",
        "displayName": "Dark Mainnet",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": null
    },
    {
        "prefix": 18,
        "network": "darwinia",
        "displayName": "Darwinia Network",
        "symbols": [
            "RING",
            "KTON"
        ],
        "decimals": [
            9,
            9
        ],
        "standardAccount": "*25519",
        "website": "https://darwinia.network/"
    },
    {
        "prefix": 19,
        "network": "watr",
        "displayName": "Watr Protocol",
        "symbols": [
            "WATR"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://www.watr.org"
    },
    {
        "prefix": 20,
        "network": "stafi",
        "displayName": "Stafi",
        "symbols": [
            "FIS"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://stafi.io"
    },
    {
        "prefix": 22,
        "network": "dock-pos-mainnet",
        "displayName": "Dock Mainnet",
        "symbols": [
            "DCK"
        ],
        "decimals": [
            6
        ],
        "standardAccount": "*25519",
        "website": "https://dock.io"
    },
    {
        "prefix": 23,
        "network": "shift",
        "displayName": "ShiftNrg",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": null
    },
    {
        "prefix": 24,
        "network": "zero",
        "displayName": "ZERO",
        "symbols": [
            "ZERO"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://zero.io"
    },
    {
        "prefix": 25,
        "network": "zero-alphaville",
        "displayName": "ZERO Alphaville",
        "symbols": [
            "ZERO"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://zero.io"
    },
    {
        "prefix": 26,
        "network": "jupiter",
        "displayName": "Jupiter",
        "symbols": [
            "jDOT"
        ],
        "decimals": [
            10
        ],
        "standardAccount": "*25519",
        "website": "https://jupiter.patract.io"
    },
    {
        "prefix": 27,
        "network": "kabocha",
        "displayName": "Kabocha",
        "symbols": [
            "KAB"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://kabocha.network"
    },
    {
        "prefix": 28,
        "network": "subsocial",
        "displayName": "Subsocial",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": null
    },
    {
        "prefix": 29,
        "network": "cord",
        "displayName": "CORD Network",
        "symbols": [
            "DHI",
            "WAY"
        ],
        "decimals": [
            12,
            12
        ],
        "standardAccount": "*25519",
        "website": "https://cord.network/"
    },
    {
        "prefix": 30,
        "network": "phala",
        "displayName": "Phala Network",
        "symbols": [
            "PHA"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://phala.network"
    },
    {
        "prefix": 31,
        "network": "litentry",
        "displayName": "Litentry Network",
        "symbols": [
            "LIT"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://litentry.com/"
    },
    {
        "prefix": 32,
        "network": "robonomics",
        "displayName": "Robonomics",
        "symbols": [
            "XRT"
        ],
        "decimals": [
            9
        ],
        "standardAccount": "*25519",
        "website": "https://robonomics.network"
    },
    {
        "prefix": 33,
        "network": "datahighway",
        "displayName": "DataHighway",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": null
    },
    {
        "prefix": 34,
        "network": "ares",
        "displayName": "Ares Protocol",
        "symbols": [
            "ARES"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://www.aresprotocol.com/"
    },
    {
        "prefix": 35,
        "network": "vln",
        "displayName": "Valiu Liquidity Network",
        "symbols": [
            "USDv"
        ],
        "decimals": [
            15
        ],
        "standardAccount": "*25519",
        "website": "https://valiu.com/"
    },
    {
        "prefix": 36,
        "network": "centrifuge",
        "displayName": "Centrifuge Chain",
        "symbols": [
            "CFG"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://centrifuge.io/"
    },
    {
        "prefix": 37,
        "network": "nodle",
        "displayName": "Nodle Chain",
        "symbols": [
            "NODL"
        ],
        "decimals": [
            11
        ],
        "standardAccount": "*25519",
        "website": "https://nodle.io/"
    },
    {
        "prefix": 38,
        "network": "kilt",
        "displayName": "KILT Spiritnet",
        "symbols": [
            "KILT"
        ],
        "decimals": [
            15
        ],
        "standardAccount": "*25519",
        "website": "https://kilt.io/"
    },
    {
        "prefix": 39,
        "network": "mathchain",
        "displayName": "MathChain mainnet",
        "symbols": [
            "MATH"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://mathwallet.org"
    },
    {
        "prefix": 40,
        "network": "mathchain-testnet",
        "displayName": "MathChain testnet",
        "symbols": [
            "MATH"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://mathwallet.org"
    },
    {
        "prefix": 41,
        "network": "poli",
        "displayName": "Polimec Chain",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": "https://polimec.io/"
    },
    {
        "prefix": 42,
        "network": "substrate",
        "displayName": "Substrate",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": "https://substrate.io/"
    },
    {
        "prefix": 43,
        "network": "BareSecp256k1",
        "displayName": "Bare 32-bit ECDSA SECP-256k1 public key.",
        "symbols": [],
        "decimals": [],
        "standardAccount": "secp256k1",
        "website": null
    },
    {
        "prefix": 44,
        "network": "chainx",
        "displayName": "ChainX",
        "symbols": [
            "PCX"
        ],
        "decimals": [
            8
        ],
        "standardAccount": "*25519",
        "website": "https://chainx.org/"
    },
    {
        "prefix": 45,
        "network": "uniarts",
        "displayName": "UniArts Network",
        "symbols": [
            "UART",
            "UINK"
        ],
        "decimals": [
            12,
            12
        ],
        "standardAccount": "*25519",
        "website": "https://uniarts.me"
    },
    {
        "prefix": 46,
        "network": "reserved46",
        "displayName": "This prefix is reserved.",
        "symbols": [],
        "decimals": [],
        "standardAccount": null,
        "website": null
    },
    {
        "prefix": 47,
        "network": "reserved47",
        "displayName": "This prefix is reserved.",
        "symbols": [],
        "decimals": [],
        "standardAccount": null,
        "website": null
    },
    {
        "prefix": 48,
        "network": "neatcoin",
        "displayName": "Neatcoin Mainnet",
        "symbols": [
            "NEAT"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://neatcoin.org"
    },
    {
        "prefix": 49,
        "network": "picasso",
        "displayName": "Picasso",
        "symbols": [
            "PICA"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://picasso.composable.finance"
    },
    {
        "prefix": 50,
        "network": "composable",
        "displayName": "Composable",
        "symbols": [
            "LAYR"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://composable.finance"
    },
    {
        "prefix": 51,
        "network": "oak",
        "displayName": "OAK Network",
        "symbols": [
            "OAK",
            "TUR"
        ],
        "decimals": [
            10,
            10
        ],
        "standardAccount": "*25519",
        "website": "https://oak.tech"
    },
    {
        "prefix": 52,
        "network": "KICO",
        "displayName": "KICO",
        "symbols": [
            "KICO"
        ],
        "decimals": [
            14
        ],
        "standardAccount": "*25519",
        "website": "https://dico.io"
    },
    {
        "prefix": 53,
        "network": "DICO",
        "displayName": "DICO",
        "symbols": [
            "DICO"
        ],
        "decimals": [
            14
        ],
        "standardAccount": "*25519",
        "website": "https://dico.io"
    },
    {
        "prefix": 54,
        "network": "cere",
        "displayName": "Cere Network",
        "symbols": [
            "CERE"
        ],
        "decimals": [
            10
        ],
        "standardAccount": "*25519",
        "website": "https://cere.network"
    },
    {
        "prefix": 55,
        "network": "xxnetwork",
        "displayName": "xx network",
        "symbols": [
            "XX"
        ],
        "decimals": [
            9
        ],
        "standardAccount": "*25519",
        "website": "https://xx.network"
    },
    {
        "prefix": 56,
        "network": "pendulum",
        "displayName": "Pendulum chain",
        "symbols": [
            "PEN"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://pendulumchain.org/"
    },
    {
        "prefix": 57,
        "network": "amplitude",
        "displayName": "Amplitude chain",
        "symbols": [
            "AMPE"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://pendulumchain.org/"
    },
    {
        "prefix": 63,
        "network": "hydradx",
        "displayName": "HydraDX",
        "symbols": [
            "HDX"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://hydradx.io"
    },
    {
        "prefix": 65,
        "network": "aventus",
        "displayName": "AvN Mainnet",
        "symbols": [
            "AVT"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://aventus.io"
    },
    {
        "prefix": 66,
        "network": "crust",
        "displayName": "Crust Network",
        "symbols": [
            "CRU"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://crust.network"
    },
    {
        "prefix": 67,
        "network": "genshiro",
        "displayName": "Genshiro Network",
        "symbols": [
            "GENS",
            "EQD",
            "LPT0"
        ],
        "decimals": [
            9,
            9,
            9
        ],
        "standardAccount": "*25519",
        "website": "https://genshiro.equilibrium.io"
    },
    {
        "prefix": 68,
        "network": "equilibrium",
        "displayName": "Equilibrium Network",
        "symbols": [
            "EQ"
        ],
        "decimals": [
            9
        ],
        "standardAccount": "*25519",
        "website": "https://equilibrium.io"
    },
    {
        "prefix": 69,
        "network": "sora",
        "displayName": "SORA Network",
        "symbols": [
            "XOR"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://sora.org"
    },
    {
        "prefix": 71,
        "network": "p3d",
        "displayName": "3DP network",
        "symbols": [
            "P3D"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://3dpass.org"
    },
    {
        "prefix": 72,
        "network": "p3dt",
        "displayName": "3DP test network",
        "symbols": [
            "P3Dt"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://3dpass.org"
    },
    {
        "prefix": 73,
        "network": "zeitgeist",
        "displayName": "Zeitgeist",
        "symbols": [
            "ZTG"
        ],
        "decimals": [
            10
        ],
        "standardAccount": "*25519",
        "website": "https://zeitgeist.pm"
    },
    {
        "prefix": 77,
        "network": "manta",
        "displayName": "Manta network",
        "symbols": [
            "MANTA"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://manta.network"
    },
    {
        "prefix": 78,
        "network": "calamari",
        "displayName": "Calamari: Manta Canary Network",
        "symbols": [
            "KMA"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://manta.network"
    },
    {
        "prefix": 88,
        "network": "polkadex",
        "displayName": "Polkadex Mainnet",
        "symbols": [
            "PDEX"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://polkadex.trade"
    },
    {
        "prefix": 89,
        "network": "polkadexparachain",
        "displayName": "Polkadex Parachain",
        "symbols": [
            "PDEX"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://polkadex.trade"
    },
    {
        "prefix": 92,
        "network": "anmol",
        "displayName": "Anmol Network",
        "symbols": [
            "ANML"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://anmol.network/"
    },
    {
        "prefix": 93,
        "network": "fragnova",
        "displayName": "Fragnova Network",
        "symbols": [
            "NOVA"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://fragnova.com"
    },
    {
        "prefix": 98,
        "network": "polkasmith",
        "displayName": "PolkaSmith Canary Network",
        "symbols": [
            "PKS"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://polkafoundry.com"
    },
    {
        "prefix": 99,
        "network": "polkafoundry",
        "displayName": "PolkaFoundry Network",
        "symbols": [
            "PKF"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://polkafoundry.com"
    },
    {
        "prefix": 100,
        "network": "ibtida",
        "displayName": "Anmol Network Ibtida Canary network",
        "symbols": [
            "IANML"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://anmol.network/"
    },
    {
        "prefix": 101,
        "network": "origintrail-parachain",
        "displayName": "OriginTrail Parachain",
        "symbols": [
            "OTP"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://parachain.origintrail.io/"
    },
    {
        "prefix": 105,
        "network": "pontem-network",
        "displayName": "Pontem Network",
        "symbols": [
            "PONT"
        ],
        "decimals": [
            10
        ],
        "standardAccount": "*25519",
        "website": "https://pontem.network"
    },
    {
        "prefix": 110,
        "network": "heiko",
        "displayName": "Heiko",
        "symbols": [
            "HKO"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://parallel.fi/"
    },
    {
        "prefix": 113,
        "network": "integritee-incognito",
        "displayName": "Integritee Incognito",
        "symbols": [],
        "decimals": [],
        "standardAccount": "*25519",
        "website": "https://integritee.network"
    },
    {
        "prefix": 117,
        "network": "tinker",
        "displayName": "Tinker",
        "symbols": [
            "TNKR"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://invarch.network"
    },
    {
        "prefix": 126,
        "network": "joystream",
        "displayName": "Joystream",
        "symbols": [
            "JOY"
        ],
        "decimals": [
            10
        ],
        "standardAccount": "*25519",
        "website": "https://www.joystream.org"
    },
    {
        "prefix": 128,
        "network": "clover",
        "displayName": "Clover Finance",
        "symbols": [
            "CLV"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://clover.finance"
    },
    {
        "prefix": 129,
        "network": "dorafactory-polkadot",
        "displayName": "Dorafactory Polkadot Network",
        "symbols": [
            "DORA"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://dorafactory.org"
    },
    {
        "prefix": 131,
        "network": "litmus",
        "displayName": "Litmus Network",
        "symbols": [
            "LIT"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://litentry.com/"
    },
    {
        "prefix": 136,
        "network": "altair",
        "displayName": "Altair",
        "symbols": [
            "AIR"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://centrifuge.io/"
    },
    {
        "prefix": 172,
        "network": "parallel",
        "displayName": "Parallel",
        "symbols": [
            "PARA"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://parallel.fi/"
    },
    {
        "prefix": 252,
        "network": "social-network",
        "displayName": "Social Network",
        "symbols": [
            "NET"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://social.network"
    },
    {
        "prefix": 255,
        "network": "quartz_mainnet",
        "displayName": "QUARTZ by UNIQUE",
        "symbols": [
            "QTZ"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://unique.network"
    },
    {
        "prefix": 268,
        "network": "pioneer_network",
        "displayName": "Pioneer Network by Bit.Country",
        "symbols": [
            "NEER"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://bit.country"
    },
    {
        "prefix": 420,
        "network": "sora_kusama_para",
        "displayName": "SORA Kusama Parachain",
        "symbols": [
            "XOR"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://sora.org"
    },
    {
        "prefix": 789,
        "network": "geek",
        "displayName": "GEEK Network",
        "symbols": [
            "GEEK"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://geek.gl"
    },
    {
        "prefix": 1110,
        "network": "efinity",
        "displayName": "Efinity",
        "symbols": [
            "EFI"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://efinity.io/"
    },
    {
        "prefix": 1221,
        "network": "peaq",
        "displayName": "Peaq Network",
        "symbols": [
            "PEAQ"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "Sr25519",
        "website": "https://www.peaq.network/"
    },
    {
        "prefix": 1222,
        "network": "apex",
        "displayName": "Apex Network",
        "symbols": [
            "APEX"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "Sr25519",
        "website": "https://www.peaq.network/"
    },
    {
        "prefix": 1284,
        "network": "moonbeam",
        "displayName": "Moonbeam",
        "symbols": [
            "GLMR"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "secp256k1",
        "website": "https://moonbeam.network"
    },
    {
        "prefix": 1285,
        "network": "moonriver",
        "displayName": "Moonriver",
        "symbols": [
            "MOVR"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "secp256k1",
        "website": "https://moonbeam.network"
    },
    {
        "prefix": 1328,
        "network": "ajuna",
        "displayName": "Ajuna Network",
        "symbols": [
            "AJUN"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://ajuna.io"
    },
    {
        "prefix": 1337,
        "network": "bajun",
        "displayName": "Bajun Network",
        "symbols": [
            "BAJU"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://ajuna.io"
    },
    {
        "prefix": 1985,
        "network": "seals",
        "displayName": "Seals Network",
        "symbols": [
            "SEAL"
        ],
        "decimals": [
            9
        ],
        "standardAccount": "*25519",
        "website": "https://seals.app"
    },
    {
        "prefix": 2007,
        "network": "kapex",
        "displayName": "Kapex",
        "symbols": [
            "KAPEX"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://totemaccounting.com"
    },
    {
        "prefix": 2032,
        "network": "interlay",
        "displayName": "Interlay",
        "symbols": [
            "INTR"
        ],
        "decimals": [
            10
        ],
        "standardAccount": "*25519",
        "website": "https://interlay.io/"
    },
    {
        "prefix": 2092,
        "network": "kintsugi",
        "displayName": "Kintsugi",
        "symbols": [
            "KINT"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://interlay.io/"
    },
    {
        "prefix": 2112,
        "network": "chainflip",
        "displayName": "Chainflip",
        "symbols": [
            "FLIP"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://chainflip.io/"
    },
    {
        "prefix": 2114,
        "network": "Turing",
        "displayName": "Turing Network",
        "symbols": [
            "TUR"
        ],
        "decimals": [
            10
        ],
        "standardAccount": "*25519",
        "website": "https://oak.tech/turing/home/"
    },
    {
        "prefix": 2207,
        "network": "SNOW",
        "displayName": "SNOW: ICE Canary Network",
        "symbols": [
            "ICZ"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://icenetwork.io"
    },
    {
        "prefix": 2208,
        "network": "ICE",
        "displayName": "ICE Network",
        "symbols": [
            "ICY"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://icenetwork.io"
    },
    {
        "prefix": 2254,
        "network": "subspace_testnet",
        "displayName": "Subspace testnet",
        "symbols": [
            "tSSC"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://subspace.network"
    },
    {
        "prefix": 3000,
        "network": "hashed",
        "displayName": "Hashed Network",
        "symbols": [
            "HASH"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://hashed.network"
    },
    {
        "prefix": 4000,
        "network": "luhn",
        "displayName": "Luhn Network",
        "symbols": [
            "LUHN"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://luhn.network"
    },
    {
        "prefix": 4006,
        "network": "tangle",
        "displayName": "Tangle Network",
        "symbols": [
            "TNT"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://www.webb.tools/"
    },
    {
        "prefix": 6094,
        "network": "subspace",
        "displayName": "Subspace",
        "symbols": [
            "SSC"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://subspace.network"
    },
    {
        "prefix": 7007,
        "network": "tidefi",
        "displayName": "Tidefi",
        "symbols": [
            "TDFY"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://tidefi.com"
    },
    {
        "prefix": 7013,
        "network": "gm",
        "displayName": "GM",
        "symbols": [
            "FREN",
            "GM",
            "GN"
        ],
        "decimals": [
            12,
            0,
            0
        ],
        "standardAccount": "*25519",
        "website": "https://gmordie.com"
    },
    {
        "prefix": 7391,
        "network": "unique_mainnet",
        "displayName": "Unique Network",
        "symbols": [
            "UNQ"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://unique.network"
    },
    {
        "prefix": 8883,
        "network": "sapphire_mainnet",
        "displayName": "Sapphire by Unique",
        "symbols": [
            "QTZ"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://unique.network"
    },
    {
        "prefix": 9807,
        "network": "dentnet",
        "displayName": "DENTNet",
        "symbols": [
            "DENTX"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://www.dentnet.io"
    },
    {
        "prefix": 10041,
        "network": "basilisk",
        "displayName": "Basilisk",
        "symbols": [
            "BSX"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://bsx.fi"
    },
    {
        "prefix": 11330,
        "network": "cess-testnet",
        "displayName": "CESS Testnet",
        "symbols": [
            "TCESS"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://cess.cloud"
    },
    {
        "prefix": 11331,
        "network": "cess",
        "displayName": "CESS",
        "symbols": [
            "CESS"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://cess.cloud"
    },
    {
        "prefix": 11820,
        "network": "contextfree",
        "displayName": "Automata ContextFree",
        "symbols": [
            "CTX"
        ],
        "decimals": [
            18
        ],
        "standardAccount": "*25519",
        "website": "https://ata.network"
    },
    {
        "prefix": 12191,
        "network": "nftmart",
        "displayName": "NFTMart",
        "symbols": [
            "NMT"
        ],
        "decimals": [
            12
        ],
        "standardAccount": "*25519",
        "website": "https://nftmart.io"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f5nUP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/networks authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "knownGenesis", ()=>(0, _genesisJs.knownGenesis));
parcelHelpers.export(exports, "knownIcon", ()=>(0, _iconsJs.knownIcon));
parcelHelpers.export(exports, "knownLedger", ()=>(0, _ledgerJs.knownLedger));
parcelHelpers.export(exports, "knownTestnet", ()=>(0, _testnetsJs.knownTestnet));
var _genesisJs = require("./genesis.js");
var _iconsJs = require("./icons.js");
var _ledgerJs = require("./ledger.js");
var _testnetsJs = require("./testnets.js");

},{"./genesis.js":"dDhqE","./icons.js":"kPmBV","./ledger.js":"gBi33","./testnets.js":"60HYb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dDhqE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "knownGenesis", ()=>knownGenesis);
const knownGenesis = {
    acala: [
        "0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c"
    ],
    "aleph-node": [
        "0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e"
    ],
    astar: [
        "0x9eb76c5184c4ab8679d2d5d819fdf90b9c001403e9e17da2e14b6d8aec4029c6"
    ],
    basilisk: [
        "0xa85cfb9b9fd4d622a5b28289a02347af987d8f73fa3108450e2b4a11c1ce5755"
    ],
    bifrost: [
        "0x262e1b2ad728475fd6fe88e62d34c200abe6fd693931ddad144059b1eb884e5b"
    ],
    "bifrost-kusama": [
        "0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed"
    ],
    centrifuge: [
        "0xb3db41421702df9a7fcac62b53ffeac85f7853cc4e689e0b93aeb3db18c09d82",
        "0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5"
    ],
    composable: [
        "0xdaab8df776eb52ec604a5df5d388bb62a050a0aaec4556a64265b9d42755552d"
    ],
    "dock-mainnet": [
        "0x6bfe24dca2a3be10f22212678ac13a6446ec764103c0f3471c71609eac384aae",
        "0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9"
    ],
    edgeware: [
        "0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b"
    ],
    equilibrium: [
        "0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925"
    ],
    genshiro: [
        "0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243"
    ],
    hydradx: [
        "0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d",
        "0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc",
        "0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9",
        "0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047",
        "0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2" // Snakenet Gen1
    ],
    "interlay-parachain": [
        "0xbf88efe70e9e0e916416e8bed61f2b45717f517d7f3523e33c7b001e5ffcbc72"
    ],
    karura: [
        "0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b"
    ],
    kulupu: [
        "0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba"
    ],
    kusama: [
        "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",
        "0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636",
        "0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf" // Kusama CC1
    ],
    "nodle-para": [
        "0x97da7ede98d7bad4e36b4d734b6055425a3be036da2a332ea5a7037656427a21"
    ],
    parallel: [
        "0xe61a41c53f5dcd0beb09df93b34402aada44cb05117b71059cce40a2723a4e97"
    ],
    picasso: [
        "0xe8e7f0f4c4f5a00720b4821dbfddefea7490bcf0b19009961cc46957984e2c1c"
    ],
    polkadex: [
        "0x3920bcb4960a1eef5580cd5367ff3f430eef052774f78468852f7b9cb39f8a3c"
    ],
    polkadot: [
        "0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"
    ],
    polymesh: [
        "0x6fbd74e5e1d0a61d52ccfe9d4adaed16dd3a7caa37c6bc4d0c2fa12e8b2f4063"
    ],
    rococo: [
        "0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e",
        "0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897",
        "0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770",
        "0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff",
        "0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a",
        "0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9",
        "0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779",
        "0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215",
        "0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9",
        "0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147",
        "0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd",
        "0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299"
    ],
    sora: [
        "0x7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5"
    ],
    stafi: [
        "0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80"
    ],
    statemine: [
        "0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a"
    ],
    statemint: [
        "0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f"
    ],
    subsocial: [
        "0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8"
    ],
    unique: [
        "0x84322d9cddbf35088f1e54e9a85c967a41a56a4f43445768125e61af166c7d31"
    ],
    westend: [
        "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"
    ],
    xxnetwork: [
        "0x50dd5d206917bf10502c68fb4d18a59fc8aa31586f4e8856b493e43544aa82aa"
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kPmBV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "knownIcon", ()=>knownIcon);
const knownIcon = {
    centrifuge: "polkadot",
    kusama: "polkadot",
    polkadot: "polkadot",
    sora: "polkadot",
    statemine: "polkadot",
    statemint: "polkadot",
    westmint: "polkadot"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gBi33":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "knownLedger", ()=>knownLedger);
const knownLedger = {
    acala: 0x00000313,
    "aleph-node": 0x00000283,
    astar: 0x0000032a,
    bifrost: 0x00000314,
    "bifrost-kusama": 0x00000314,
    centrifuge: 0x000002eb,
    composable: 0x00000162,
    "dock-mainnet": 0x00000252,
    edgeware: 0x0000020b,
    equilibrium: 0x05f5e0fd,
    genshiro: 0x05f5e0fc,
    "interlay-parachain": 0x00000162,
    karura: 0x000002ae,
    kusama: 0x000001b2,
    "nodle-para": 0x000003eb,
    parallel: 0x00000162,
    polkadex: 0x0000031f,
    polkadot: 0x00000162,
    polymesh: 0x00000253,
    sora: 0x00000269,
    stafi: 0x0000038b,
    statemine: 0x000001b2,
    // common-good on Kusama, shares derivation
    statemint: 0x00000162,
    // common-good on Polkadot, shares derivation
    unique: 0x00000162,
    xxnetwork: 0x000007a3
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"60HYb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "knownTestnet", ()=>knownTestnet);
const knownTestnet = {
    "": true,
    // this is the default non-network entry
    "cess-testnet": true,
    "dock-testnet": true,
    jupiter: true,
    "mathchain-testnet": true,
    p3dt: true,
    subspace_testnet: true,
    "zero-alphaville": true
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"812rG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name checkAddress
 * @summary Validates an ss58 address.
 * @description
 * From the provided input, validate that the address is a valid input.
 */ parcelHelpers.export(exports, "checkAddress", ()=>checkAddress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../base58/index.js");
var _checksumJs = require("./checksum.js");
var _defaultsJs = require("./defaults.js");
function checkAddress(address, prefix) {
    let decoded;
    try {
        decoded = (0, _indexJs.base58Decode)(address);
    } catch (error) {
        return [
            false,
            error.message
        ];
    }
    const [isValid, , , ss58Decoded] = (0, _checksumJs.checkAddressChecksum)(decoded);
    if (ss58Decoded !== prefix) return [
        false,
        `Prefix mismatch, expected ${prefix}, found ${ss58Decoded}`
    ];
    else if (!(0, _defaultsJs.defaults).allowedEncodedLengths.includes(decoded.length)) return [
        false,
        "Invalid decoded address length"
    ];
    return [
        isValid,
        isValid ? null : "Invalid decoded address checksum"
    ];
}

},{"../base58/index.js":"kXPnW","./checksum.js":"hXHdg","./defaults.js":"cxlL5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gJriE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createKeyMulti", ()=>createKeyMulti);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _asU8AJs = require("../blake2/asU8a.js");
var _bnJs = require("../bn.js");
var _utilJs = require("./util.js");
const PREFIX = (0, _util.stringToU8a)("modlpy/utilisuba");
function createKeyMulti(who, threshold) {
    return (0, _asU8AJs.blake2AsU8a)((0, _util.u8aConcat)(PREFIX, (0, _util.compactToU8a)(who.length), ...(0, _util.u8aSorted)(who.map((0, _utilJs.addressToU8a))), (0, _util.bnToU8a)(threshold, (0, _bnJs.BN_LE_16_OPTS))));
}

},{"@polkadot/util":"3HnHw","../blake2/asU8a.js":"3rNsT","../bn.js":"h6UHx","./util.js":"96saF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h6UHx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BN_BE_OPTS", ()=>BN_BE_OPTS);
parcelHelpers.export(exports, "BN_LE_OPTS", ()=>BN_LE_OPTS);
parcelHelpers.export(exports, "BN_LE_16_OPTS", ()=>BN_LE_16_OPTS);
parcelHelpers.export(exports, "BN_BE_32_OPTS", ()=>BN_BE_32_OPTS);
parcelHelpers.export(exports, "BN_LE_32_OPTS", ()=>BN_LE_32_OPTS);
parcelHelpers.export(exports, "BN_BE_256_OPTS", ()=>BN_BE_256_OPTS);
parcelHelpers.export(exports, "BN_LE_256_OPTS", ()=>BN_LE_256_OPTS);
parcelHelpers.export(exports, "BN_LE_512_OPTS", ()=>BN_LE_512_OPTS);
const BN_BE_OPTS = {
    isLe: false
};
const BN_LE_OPTS = {
    isLe: true
};
const BN_LE_16_OPTS = {
    bitLength: 16,
    isLe: true
};
const BN_BE_32_OPTS = {
    bitLength: 32,
    isLe: false
};
const BN_LE_32_OPTS = {
    bitLength: 32,
    isLe: true
};
const BN_BE_256_OPTS = {
    bitLength: 256,
    isLe: false
};
const BN_LE_256_OPTS = {
    bitLength: 256,
    isLe: true
};
const BN_LE_512_OPTS = {
    bitLength: 512,
    isLe: true
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"96saF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addressToU8a", ()=>addressToU8a);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _decodeJs = require("./decode.js");
function addressToU8a(who) {
    return (0, _decodeJs.decodeAddress)(who);
}

},{"./decode.js":"1wUOF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jAPQm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createKeyDerived", ()=>createKeyDerived);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _asU8AJs = require("../blake2/asU8a.js");
var _bnJs = require("../bn.js");
var _decodeJs = require("./decode.js");
const PREFIX = (0, _util.stringToU8a)("modlpy/utilisuba");
function createKeyDerived(who, index) {
    return (0, _asU8AJs.blake2AsU8a)((0, _util.u8aConcat)(PREFIX, (0, _decodeJs.decodeAddress)(who), (0, _util.bnToU8a)(index, (0, _bnJs.BN_LE_16_OPTS))));
}

},{"@polkadot/util":"3HnHw","../blake2/asU8a.js":"3rNsT","../bn.js":"h6UHx","./decode.js":"1wUOF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jL6vS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name deriveAddress
 * @summary Creates a sr25519 derived address from the supplied and path.
 * @description
 * Creates a sr25519 derived address based on the input address/publicKey and the uri supplied.
 */ parcelHelpers.export(exports, "deriveAddress", ()=>deriveAddress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../key/index.js");
var _indexJs1 = require("../sr25519/index.js");
var _decodeJs = require("./decode.js");
var _encodeJs = require("./encode.js");
function filterHard({ isHard  }) {
    return isHard;
}
function deriveAddress(who, suri, ss58Format) {
    const { path  } = (0, _indexJs.keyExtractPath)(suri);
    if (!path.length || path.every(filterHard)) throw new Error("Expected suri to contain a combination of non-hard paths");
    let publicKey = (0, _decodeJs.decodeAddress)(who);
    for (const { chainCode  } of path)publicKey = (0, _indexJs1.sr25519DerivePublic)(publicKey, chainCode);
    return (0, _encodeJs.encodeAddress)(publicKey, ss58Format);
}

},{"../key/index.js":"4L2pj","../sr25519/index.js":"2JBt4","./decode.js":"1wUOF","./encode.js":"gkF5r","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4L2pj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Create keys from paths, seeds and password
 */ parcelHelpers.export(exports, "keyExtractPath", ()=>(0, _extractPathJs.keyExtractPath));
parcelHelpers.export(exports, "keyExtractSuri", ()=>(0, _extractSuriJs.keyExtractSuri));
parcelHelpers.export(exports, "keyFromPath", ()=>(0, _fromPathJs.keyFromPath));
parcelHelpers.export(exports, "keyHdkdEd25519", ()=>(0, _hdkdEd25519Js.keyHdkdEd25519));
parcelHelpers.export(exports, "keyHdkdSr25519", ()=>(0, _hdkdSr25519Js.keyHdkdSr25519));
parcelHelpers.export(exports, "keyHdkdEcdsa", ()=>(0, _hdkdEcdsaJs.keyHdkdEcdsa));
var _extractPathJs = require("./extractPath.js");
var _extractSuriJs = require("./extractSuri.js");
var _fromPathJs = require("./fromPath.js");
var _hdkdEd25519Js = require("./hdkdEd25519.js");
var _hdkdSr25519Js = require("./hdkdSr25519.js");
var _hdkdEcdsaJs = require("./hdkdEcdsa.js");

},{"./extractPath.js":"coFt6","./extractSuri.js":"ltPyn","./fromPath.js":"4dFQx","./hdkdEd25519.js":"2f6HU","./hdkdSr25519.js":"1C8I0","./hdkdEcdsa.js":"h4xNj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"coFt6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Extract derivation junctions from the supplied path
 */ parcelHelpers.export(exports, "keyExtractPath", ()=>keyExtractPath);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _deriveJunctionJs = require("./DeriveJunction.js");
const RE_JUNCTION = /\/(\/?)([^/]+)/g;
function keyExtractPath(derivePath) {
    const parts = derivePath.match(RE_JUNCTION);
    const path = [];
    let constructed = "";
    if (parts) {
        constructed = parts.join("");
        for (const p of parts)path.push((0, _deriveJunctionJs.DeriveJunction).from(p.substring(1)));
    }
    if (constructed !== derivePath) throw new Error(`Re-constructed path "${constructed}" does not match input`);
    return {
        parts,
        path
    };
}

},{"./DeriveJunction.js":"8qsai","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8qsai":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DeriveJunction", ()=>DeriveJunction);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _asU8AJs = require("../blake2/asU8a.js");
var _bnJs = require("../bn.js");
const RE_NUMBER = /^\d+$/;
const JUNCTION_ID_LEN = 32;
class DeriveJunction {
    #chainCode = new Uint8Array(32);
    #isHard = false;
    static from(value) {
        const result = new DeriveJunction();
        const [code, isHard] = value.startsWith("/") ? [
            value.substring(1),
            true
        ] : [
            value,
            false
        ];
        result.soft(RE_NUMBER.test(code) ? new (0, _util.BN)(code, 10) : code);
        return isHard ? result.harden() : result;
    }
    get chainCode() {
        return this.#chainCode;
    }
    get isHard() {
        return this.#isHard;
    }
    get isSoft() {
        return !this.#isHard;
    }
    hard(value) {
        return this.soft(value).harden();
    }
    harden() {
        this.#isHard = true;
        return this;
    }
    soft(value) {
        if ((0, _util.isNumber)(value) || (0, _util.isBn)(value) || (0, _util.isBigInt)(value)) return this.soft((0, _util.bnToU8a)(value, (0, _bnJs.BN_LE_256_OPTS)));
        else if ((0, _util.isHex)(value)) return this.soft((0, _util.hexToU8a)(value));
        else if ((0, _util.isString)(value)) return this.soft((0, _util.compactAddLength)((0, _util.stringToU8a)(value)));
        else if (value.length > JUNCTION_ID_LEN) return this.soft((0, _asU8AJs.blake2AsU8a)(value));
        this.#chainCode.fill(0);
        this.#chainCode.set(value, 0);
        return this;
    }
    soften() {
        this.#isHard = false;
        return this;
    }
}

},{"@polkadot/util":"3HnHw","../blake2/asU8a.js":"3rNsT","../bn.js":"h6UHx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ltPyn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed).
 */ parcelHelpers.export(exports, "keyExtractSuri", ()=>keyExtractSuri);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _extractPathJs = require("./extractPath.js");
const RE_CAPTURE = /^(\w+( \w+)*)((\/\/?[^/]+)*)(\/\/\/(.*))?$/;
function keyExtractSuri(suri) {
    // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
    const matches = suri.match(RE_CAPTURE);
    if (matches === null) throw new Error("Unable to match provided value to a secret URI");
    const [, phrase, , derivePath, , , password] = matches;
    const { path  } = (0, _extractPathJs.keyExtractPath)(derivePath);
    return {
        derivePath,
        password,
        path,
        phrase
    };
}

},{"./extractPath.js":"coFt6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4dFQx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keyFromPath", ()=>keyFromPath);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _hdkdEcdsaJs = require("./hdkdEcdsa.js");
var _hdkdEd25519Js = require("./hdkdEd25519.js");
var _hdkdSr25519Js = require("./hdkdSr25519.js");
const generators = {
    ecdsa: (0, _hdkdEcdsaJs.keyHdkdEcdsa),
    ed25519: (0, _hdkdEd25519Js.keyHdkdEd25519),
    // FIXME This is Substrate-compatible, not Ethereum-compatible
    ethereum: (0, _hdkdEcdsaJs.keyHdkdEcdsa),
    sr25519: (0, _hdkdSr25519Js.keyHdkdSr25519)
};
function keyFromPath(pair, path, type) {
    const keyHdkd = generators[type];
    let result = pair;
    for (const junction of path)result = keyHdkd(result, junction);
    return result;
}

},{"./hdkdEcdsa.js":"h4xNj","./hdkdEd25519.js":"2f6HU","./hdkdSr25519.js":"1C8I0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h4xNj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keyHdkdEcdsa", ()=>keyHdkdEcdsa);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _deriveHardJs = require("../secp256k1/deriveHard.js");
var _fromSeedJs = require("../secp256k1/pair/fromSeed.js");
var _hdkdDeriveJs = require("./hdkdDerive.js");
const keyHdkdEcdsa = (0, _hdkdDeriveJs.createSeedDeriveFn)((0, _fromSeedJs.secp256k1PairFromSeed), (0, _deriveHardJs.secp256k1DeriveHard));

},{"../secp256k1/deriveHard.js":"bZG9b","../secp256k1/pair/fromSeed.js":"6vhYg","./hdkdDerive.js":"aFbsT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bZG9b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "secp256k1DeriveHard", ()=>secp256k1DeriveHard);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _asU8AJs = require("../blake2/asU8a.js");
const HDKD = (0, _util.compactAddLength)((0, _util.stringToU8a)("Secp256k1HDKD"));
function secp256k1DeriveHard(seed, chainCode) {
    if (!(0, _util.isU8a)(chainCode) || chainCode.length !== 32) throw new Error("Invalid chainCode passed to derive");
     // NOTE This is specific to the Substrate HDD derivation, so always use the blake2 hasher
    return (0, _asU8AJs.blake2AsU8a)((0, _util.u8aConcat)(HDKD, seed, chainCode), 256);
}

},{"@polkadot/util":"3HnHw","../blake2/asU8a.js":"3rNsT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6vhYg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name secp256k1PairFromSeed
 * @description Returns a object containing a `publicKey` & `secretKey` generated from the supplied seed.
 */ parcelHelpers.export(exports, "secp256k1PairFromSeed", ()=>secp256k1PairFromSeed);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _secp256K1 = require("@noble/secp256k1");
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
function secp256k1PairFromSeed(seed, onlyJs) {
    if (seed.length !== 32) throw new Error("Expected valid 32-byte private key as a seed");
    if (!(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)()) {
        const full = (0, _wasmCrypto.secp256k1FromSeed)(seed);
        const publicKey = full.slice(32); // There is an issue with the secp256k1 when running in an ASM.js environment where
        // it seems that the lazy static section yields invalid results on the _first_ run.
        // If this happens, fail outright, we cannot allow invalid return values
        // https://github.com/polkadot-js/wasm/issues/307
        if ((0, _util.u8aEmpty)(publicKey)) throw new Error("Invalid publicKey generated from WASM interface");
        return {
            publicKey,
            secretKey: full.slice(0, 32)
        };
    }
    return {
        publicKey: (0, _secp256K1.getPublicKey)(seed, true),
        secretKey: seed
    };
}

},{"@noble/secp256k1":"eyYsH","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFbsT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "createSeedDeriveFn", ()=>createSeedDeriveFn);
function createSeedDeriveFn(fromSeed, derive) {
    return (keypair, { chainCode , isHard  })=>{
        if (!isHard) throw new Error("A soft key was found in the path and is not supported");
        return fromSeed(derive(keypair.secretKey.subarray(0, 32), chainCode));
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2f6HU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keyHdkdEd25519", ()=>keyHdkdEd25519);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../ed25519/index.js");
var _hdkdDeriveJs = require("./hdkdDerive.js");
const keyHdkdEd25519 = (0, _hdkdDeriveJs.createSeedDeriveFn)((0, _indexJs.ed25519PairFromSeed), (0, _indexJs.ed25519DeriveHard));

},{"../ed25519/index.js":"k5xh0","./hdkdDerive.js":"aFbsT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k5xh0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Implements ed25519 operations
 */ parcelHelpers.export(exports, "convertPublicKeyToCurve25519", ()=>(0, _convertKeyJs.convertPublicKeyToCurve25519));
parcelHelpers.export(exports, "convertSecretKeyToCurve25519", ()=>(0, _convertKeyJs.convertSecretKeyToCurve25519));
parcelHelpers.export(exports, "ed25519DeriveHard", ()=>(0, _deriveHardJs.ed25519DeriveHard));
parcelHelpers.export(exports, "ed25519PairFromRandom", ()=>(0, _fromRandomJs.ed25519PairFromRandom));
parcelHelpers.export(exports, "ed25519PairFromSecret", ()=>(0, _fromSecretJs.ed25519PairFromSecret));
parcelHelpers.export(exports, "ed25519PairFromSeed", ()=>(0, _fromSeedJs.ed25519PairFromSeed));
parcelHelpers.export(exports, "ed25519PairFromString", ()=>(0, _fromStringJs.ed25519PairFromString));
parcelHelpers.export(exports, "ed25519Sign", ()=>(0, _signJs.ed25519Sign));
parcelHelpers.export(exports, "ed25519Verify", ()=>(0, _verifyJs.ed25519Verify));
var _convertKeyJs = require("./convertKey.js");
var _deriveHardJs = require("./deriveHard.js");
var _fromRandomJs = require("./pair/fromRandom.js");
var _fromSecretJs = require("./pair/fromSecret.js");
var _fromSeedJs = require("./pair/fromSeed.js");
var _fromStringJs = require("./pair/fromString.js");
var _signJs = require("./sign.js");
var _verifyJs = require("./verify.js");

},{"./convertKey.js":"c57HT","./deriveHard.js":"4zYlX","./pair/fromRandom.js":"2EaW5","./pair/fromSecret.js":"h6CY8","./pair/fromSeed.js":"d6ZVh","./pair/fromString.js":"2880J","./sign.js":"eiljI","./verify.js":"eizeP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c57HT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "convertSecretKeyToCurve25519", ()=>convertSecretKeyToCurve25519);
parcelHelpers.export(exports, "convertPublicKeyToCurve25519", ()=>convertPublicKeyToCurve25519);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _ed2Curve = require("ed2curve");
var _ed2CurveDefault = parcelHelpers.interopDefault(_ed2Curve);
var _util = require("@polkadot/util");
function convertSecretKeyToCurve25519(secretKey) {
    return (0, _ed2CurveDefault.default).convertSecretKey(secretKey);
}
function convertPublicKeyToCurve25519(publicKey) {
    return (0, _util.assertReturn)((0, _ed2CurveDefault.default).convertPublicKey(publicKey), "Unable to convert publicKey to ed25519");
}

},{"ed2curve":"1l6DQ","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1l6DQ":[function(require,module,exports) {
/*
 * ed2curve: convert Ed25519 signing key pair into Curve25519
 * key pair suitable for Diffie-Hellman key exchange.
 *
 * Written by Dmitry Chestnykh in 2014. Public domain.
 */ /* jshint newcap: false */ (function(root, f) {
    "use strict";
    if (module.exports) module.exports = f(require("tweetnacl"));
    else root.ed2curve = f(root.nacl);
})(this, function(nacl) {
    "use strict";
    if (!nacl) throw new Error("tweetnacl not loaded");
    // -- Operations copied from TweetNaCl.js. --
    var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for(i = 0; i < init.length; i++)r[i] = init[i];
        return r;
    };
    var gf0 = gf(), gf1 = gf([
        1
    ]), D = gf([
        0x78a3,
        0x1359,
        0x4dca,
        0x75eb,
        0xd8ab,
        0x4141,
        0x0a4d,
        0x0070,
        0xe898,
        0x7779,
        0x4079,
        0x8cc7,
        0xfe73,
        0x2b6f,
        0x6cee,
        0x5203
    ]), I = gf([
        0xa0b0,
        0x4a0e,
        0x1b27,
        0xc4ee,
        0xe478,
        0xad2f,
        0x1806,
        0x2f43,
        0xd7a7,
        0x3dfb,
        0x0099,
        0x2b4d,
        0xdf0b,
        0x4fc1,
        0x2480,
        0x2b83
    ]);
    function car25519(o) {
        var c;
        var i;
        for(i = 0; i < 16; i++){
            o[i] += 65536;
            c = Math.floor(o[i] / 65536);
            o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);
            o[i] -= c * 65536;
        }
    }
    function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for(var i = 0; i < 16; i++){
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
        }
    }
    function unpack25519(o, n) {
        var i;
        for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 0x7fff;
    }
    // addition
    function A(o, a, b) {
        var i;
        for(i = 0; i < 16; i++)o[i] = a[i] + b[i] | 0;
    }
    // subtraction
    function Z(o, a, b) {
        var i;
        for(i = 0; i < 16; i++)o[i] = a[i] - b[i] | 0;
    }
    // multiplication
    function M(o, a, b) {
        var i, j, t = new Float64Array(31);
        for(i = 0; i < 31; i++)t[i] = 0;
        for(i = 0; i < 16; i++)for(j = 0; j < 16; j++)t[i + j] += a[i] * b[j];
        for(i = 0; i < 15; i++)t[i] += 38 * t[i + 16];
        for(i = 0; i < 16; i++)o[i] = t[i];
        car25519(o);
        car25519(o);
    }
    // squaring
    function S(o, a) {
        M(o, a, a);
    }
    // inversion
    function inv25519(o, i) {
        var c = gf();
        var a;
        for(a = 0; a < 16; a++)c[a] = i[a];
        for(a = 253; a >= 0; a--){
            S(c, c);
            if (a !== 2 && a !== 4) M(c, c, i);
        }
        for(a = 0; a < 16; a++)o[a] = c[a];
    }
    function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for(i = 0; i < 16; i++)t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for(j = 0; j < 2; j++){
            m[0] = t[0] - 0xffed;
            for(i = 1; i < 15; i++){
                m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
                m[i - 1] &= 0xffff;
            }
            m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 0xffff;
            sel25519(t, m, 1 - b);
        }
        for(i = 0; i < 16; i++){
            o[2 * i] = t[i] & 0xff;
            o[2 * i + 1] = t[i] >> 8;
        }
    }
    function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
    }
    function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
    }
    function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
    }
    function pow2523(o, i) {
        var c = gf();
        var a;
        for(a = 0; a < 16; a++)c[a] = i[a];
        for(a = 250; a >= 0; a--){
            S(c, c);
            if (a !== 1) M(c, c, i);
        }
        for(a = 0; a < 16; a++)o[a] = c[a];
    }
    function set25519(r, a) {
        var i;
        for(i = 0; i < 16; i++)r[i] = a[i] | 0;
    }
    function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
    }
    // ----
    // Converts Ed25519 public key to Curve25519 public key.
    // montgomeryX = (edwardsY + 1)*inverse(1 - edwardsY) mod p
    function convertPublicKey(pk) {
        var z = new Uint8Array(32), q = [
            gf(),
            gf(),
            gf(),
            gf()
        ], a = gf(), b = gf();
        if (unpackneg(q, pk)) return null; // reject invalid key
        var y = q[1];
        A(a, gf1, y);
        Z(b, gf1, y);
        inv25519(b, b);
        M(a, a, b);
        pack25519(z, a);
        return z;
    }
    // Converts Ed25519 secret key to Curve25519 secret key.
    function convertSecretKey(sk) {
        var d = new Uint8Array(64), o = new Uint8Array(32), i;
        nacl.lowlevel.crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        for(i = 0; i < 32; i++)o[i] = d[i];
        for(i = 0; i < 64; i++)d[i] = 0;
        return o;
    }
    function convertKeyPair(edKeyPair) {
        var publicKey = convertPublicKey(edKeyPair.publicKey);
        if (!publicKey) return null;
        return {
            publicKey: publicKey,
            secretKey: convertSecretKey(edKeyPair.secretKey)
        };
    }
    return {
        convertPublicKey: convertPublicKey,
        convertSecretKey: convertSecretKey,
        convertKeyPair: convertKeyPair
    };
});

},{"tweetnacl":"3J9rh"}],"3J9rh":[function(require,module,exports) {
(function(nacl) {
    "use strict";
    // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
    // Public domain.
    //
    // Implementation derived from TweetNaCl version 20140427.
    // See for details: http://tweetnacl.cr.yp.to/
    var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for(i = 0; i < init.length; i++)r[i] = init[i];
        return r;
    };
    //  Pluggable, initialized in high-level API below.
    var randombytes = function() {
        throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([
        1
    ]), _121665 = gf([
        0xdb41,
        1
    ]), D = gf([
        0x78a3,
        0x1359,
        0x4dca,
        0x75eb,
        0xd8ab,
        0x4141,
        0x0a4d,
        0x0070,
        0xe898,
        0x7779,
        0x4079,
        0x8cc7,
        0xfe73,
        0x2b6f,
        0x6cee,
        0x5203
    ]), D2 = gf([
        0xf159,
        0x26b2,
        0x9b94,
        0xebd6,
        0xb156,
        0x8283,
        0x149a,
        0x00e0,
        0xd130,
        0xeef3,
        0x80f2,
        0x198e,
        0xfce7,
        0x56df,
        0xd9dc,
        0x2406
    ]), X = gf([
        0xd51a,
        0x8f25,
        0x2d60,
        0xc956,
        0xa7b2,
        0x9525,
        0xc760,
        0x692c,
        0xdc5c,
        0xfdd6,
        0xe231,
        0xc0a4,
        0x53fe,
        0xcd6e,
        0x36d3,
        0x2169
    ]), Y = gf([
        0x6658,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666
    ]), I = gf([
        0xa0b0,
        0x4a0e,
        0x1b27,
        0xc4ee,
        0xe478,
        0xad2f,
        0x1806,
        0x2f43,
        0xd7a7,
        0x3dfb,
        0x0099,
        0x2b4d,
        0xdf0b,
        0x4fc1,
        0x2480,
        0x2b83
    ]);
    function ts64(x, i, h, l) {
        x[i] = h >> 24 & 0xff;
        x[i + 1] = h >> 16 & 0xff;
        x[i + 2] = h >> 8 & 0xff;
        x[i + 3] = h & 0xff;
        x[i + 4] = l >> 24 & 0xff;
        x[i + 5] = l >> 16 & 0xff;
        x[i + 6] = l >> 8 & 0xff;
        x[i + 7] = l & 0xff;
    }
    function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24, j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24, j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24, j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24, j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24, j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24, j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24, j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24, j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24, j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24, j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24, j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24, j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24, j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24, j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24, j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for(var i = 0; i < 20; i += 2){
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 25;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 23;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 19;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 14;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 25;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 23;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 19;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 14;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 25;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 23;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 19;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 14;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 25;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 23;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 19;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 14;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 25;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 23;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 19;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 14;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 25;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 23;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 19;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 14;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 25;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 23;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 19;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 14;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 25;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 23;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 19;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 14;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 0xff;
        o[1] = x0 >>> 8 & 0xff;
        o[2] = x0 >>> 16 & 0xff;
        o[3] = x0 >>> 24 & 0xff;
        o[4] = x1 >>> 0 & 0xff;
        o[5] = x1 >>> 8 & 0xff;
        o[6] = x1 >>> 16 & 0xff;
        o[7] = x1 >>> 24 & 0xff;
        o[8] = x2 >>> 0 & 0xff;
        o[9] = x2 >>> 8 & 0xff;
        o[10] = x2 >>> 16 & 0xff;
        o[11] = x2 >>> 24 & 0xff;
        o[12] = x3 >>> 0 & 0xff;
        o[13] = x3 >>> 8 & 0xff;
        o[14] = x3 >>> 16 & 0xff;
        o[15] = x3 >>> 24 & 0xff;
        o[16] = x4 >>> 0 & 0xff;
        o[17] = x4 >>> 8 & 0xff;
        o[18] = x4 >>> 16 & 0xff;
        o[19] = x4 >>> 24 & 0xff;
        o[20] = x5 >>> 0 & 0xff;
        o[21] = x5 >>> 8 & 0xff;
        o[22] = x5 >>> 16 & 0xff;
        o[23] = x5 >>> 24 & 0xff;
        o[24] = x6 >>> 0 & 0xff;
        o[25] = x6 >>> 8 & 0xff;
        o[26] = x6 >>> 16 & 0xff;
        o[27] = x6 >>> 24 & 0xff;
        o[28] = x7 >>> 0 & 0xff;
        o[29] = x7 >>> 8 & 0xff;
        o[30] = x7 >>> 16 & 0xff;
        o[31] = x7 >>> 24 & 0xff;
        o[32] = x8 >>> 0 & 0xff;
        o[33] = x8 >>> 8 & 0xff;
        o[34] = x8 >>> 16 & 0xff;
        o[35] = x8 >>> 24 & 0xff;
        o[36] = x9 >>> 0 & 0xff;
        o[37] = x9 >>> 8 & 0xff;
        o[38] = x9 >>> 16 & 0xff;
        o[39] = x9 >>> 24 & 0xff;
        o[40] = x10 >>> 0 & 0xff;
        o[41] = x10 >>> 8 & 0xff;
        o[42] = x10 >>> 16 & 0xff;
        o[43] = x10 >>> 24 & 0xff;
        o[44] = x11 >>> 0 & 0xff;
        o[45] = x11 >>> 8 & 0xff;
        o[46] = x11 >>> 16 & 0xff;
        o[47] = x11 >>> 24 & 0xff;
        o[48] = x12 >>> 0 & 0xff;
        o[49] = x12 >>> 8 & 0xff;
        o[50] = x12 >>> 16 & 0xff;
        o[51] = x12 >>> 24 & 0xff;
        o[52] = x13 >>> 0 & 0xff;
        o[53] = x13 >>> 8 & 0xff;
        o[54] = x13 >>> 16 & 0xff;
        o[55] = x13 >>> 24 & 0xff;
        o[56] = x14 >>> 0 & 0xff;
        o[57] = x14 >>> 8 & 0xff;
        o[58] = x14 >>> 16 & 0xff;
        o[59] = x14 >>> 24 & 0xff;
        o[60] = x15 >>> 0 & 0xff;
        o[61] = x15 >>> 8 & 0xff;
        o[62] = x15 >>> 16 & 0xff;
        o[63] = x15 >>> 24 & 0xff;
    }
    function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24, j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24, j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24, j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24, j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24, j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24, j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24, j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24, j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24, j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24, j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24, j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24, j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24, j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24, j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24, j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for(var i = 0; i < 20; i += 2){
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 25;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 23;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 19;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 14;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 25;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 23;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 19;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 14;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 25;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 23;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 19;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 14;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 25;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 23;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 19;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 14;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 25;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 23;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 19;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 14;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 25;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 23;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 19;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 14;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 25;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 23;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 19;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 14;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 25;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 23;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 19;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 14;
        }
        o[0] = x0 >>> 0 & 0xff;
        o[1] = x0 >>> 8 & 0xff;
        o[2] = x0 >>> 16 & 0xff;
        o[3] = x0 >>> 24 & 0xff;
        o[4] = x5 >>> 0 & 0xff;
        o[5] = x5 >>> 8 & 0xff;
        o[6] = x5 >>> 16 & 0xff;
        o[7] = x5 >>> 24 & 0xff;
        o[8] = x10 >>> 0 & 0xff;
        o[9] = x10 >>> 8 & 0xff;
        o[10] = x10 >>> 16 & 0xff;
        o[11] = x10 >>> 24 & 0xff;
        o[12] = x15 >>> 0 & 0xff;
        o[13] = x15 >>> 8 & 0xff;
        o[14] = x15 >>> 16 & 0xff;
        o[15] = x15 >>> 24 & 0xff;
        o[16] = x6 >>> 0 & 0xff;
        o[17] = x6 >>> 8 & 0xff;
        o[18] = x6 >>> 16 & 0xff;
        o[19] = x6 >>> 24 & 0xff;
        o[20] = x7 >>> 0 & 0xff;
        o[21] = x7 >>> 8 & 0xff;
        o[22] = x7 >>> 16 & 0xff;
        o[23] = x7 >>> 24 & 0xff;
        o[24] = x8 >>> 0 & 0xff;
        o[25] = x8 >>> 8 & 0xff;
        o[26] = x8 >>> 16 & 0xff;
        o[27] = x8 >>> 24 & 0xff;
        o[28] = x9 >>> 0 & 0xff;
        o[29] = x9 >>> 8 & 0xff;
        o[30] = x9 >>> 16 & 0xff;
        o[31] = x9 >>> 24 & 0xff;
    }
    function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([
        101,
        120,
        112,
        97,
        110,
        100,
        32,
        51,
        50,
        45,
        98,
        121,
        116,
        101,
        32,
        107
    ]);
    // "expand 32-byte k"
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for(i = 0; i < 16; i++)z[i] = 0;
        for(i = 0; i < 8; i++)z[i] = n[i];
        while(b >= 64){
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < 64; i++)c[cpos + i] = m[mpos + i] ^ x[i];
            u = 1;
            for(i = 8; i < 16; i++){
                u = u + (z[i] & 0xff) | 0;
                z[i] = u & 0xff;
                u >>>= 8;
            }
            b -= 64;
            cpos += 64;
            mpos += 64;
        }
        if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < b; i++)c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for(i = 0; i < 16; i++)z[i] = 0;
        for(i = 0; i < 8; i++)z[i] = n[i];
        while(b >= 64){
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < 64; i++)c[cpos + i] = x[i];
            u = 1;
            for(i = 8; i < 16; i++){
                u = u + (z[i] & 0xff) | 0;
                z[i] = u & 0xff;
                u >>>= 8;
            }
            b -= 64;
            cpos += 64;
        }
        if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < b; i++)c[cpos + i] = x[i];
        }
        return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for(var i = 0; i < 8; i++)sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for(var i = 0; i < 8; i++)sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    /*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/ var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 0xff | (key[1] & 0xff) << 8;
        this.r[0] = t0 & 0x1fff;
        t1 = key[2] & 0xff | (key[3] & 0xff) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
        t2 = key[4] & 0xff | (key[5] & 0xff) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
        t3 = key[6] & 0xff | (key[7] & 0xff) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
        t4 = key[8] & 0xff | (key[9] & 0xff) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
        this.r[5] = t4 >>> 1 & 0x1ffe;
        t5 = key[10] & 0xff | (key[11] & 0xff) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
        t6 = key[12] & 0xff | (key[13] & 0xff) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
        t7 = key[14] & 0xff | (key[15] & 0xff) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
        this.r[9] = t7 >>> 5 & 0x007f;
        this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
        this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
        this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
        this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
        this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
        this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
        this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
        this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 2048;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while(bytes >= 16){
            t0 = m[mpos + 0] & 0xff | (m[mpos + 1] & 0xff) << 8;
            h0 += t0 & 0x1fff;
            t1 = m[mpos + 2] & 0xff | (m[mpos + 3] & 0xff) << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;
            t2 = m[mpos + 4] & 0xff | (m[mpos + 5] & 0xff) << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;
            t3 = m[mpos + 6] & 0xff | (m[mpos + 7] & 0xff) << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;
            t4 = m[mpos + 8] & 0xff | (m[mpos + 9] & 0xff) << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;
            h5 += t4 >>> 1 & 0x1fff;
            t5 = m[mpos + 10] & 0xff | (m[mpos + 11] & 0xff) << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;
            t6 = m[mpos + 12] & 0xff | (m[mpos + 13] & 0xff) << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;
            t7 = m[mpos + 14] & 0xff | (m[mpos + 15] & 0xff) << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;
            h9 += t7 >>> 5 | hibit;
            c = 0;
            d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 0x1fff;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 0x1fff;
            d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 0x1fff;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 0x1fff;
            d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 0x1fff;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 0x1fff;
            d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = d3 >>> 13;
            d3 &= 0x1fff;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += d3 >>> 13;
            d3 &= 0x1fff;
            d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 0x1fff;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 0x1fff;
            d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 0x1fff;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 0x1fff;
            d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 0x1fff;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 0x1fff;
            d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 0x1fff;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 0x1fff;
            d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 0x1fff;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 0x1fff;
            d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 0x1fff;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 0x1fff;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 0x1fff;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
            i = this.leftover;
            this.buffer[i++] = 1;
            for(; i < 16; i++)this.buffer[i] = 0;
            this.fin = 1;
            this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 0x1fff;
        for(i = 2; i < 10; i++){
            this.h[i] += c;
            c = this.h[i] >>> 13;
            this.h[i] &= 0x1fff;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 0x1fff;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 0x1fff;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for(i = 1; i < 10; i++){
            g[i] = this.h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= 8192;
        mask = (c ^ 1) - 1;
        for(i = 0; i < 10; i++)g[i] &= mask;
        mask = ~mask;
        for(i = 0; i < 10; i++)this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 0xffff;
        for(i = 1; i < 8; i++){
            f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
            this.h[i] = f & 0xffff;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 0xff;
        mac[macpos + 1] = this.h[0] >>> 8 & 0xff;
        mac[macpos + 2] = this.h[1] >>> 0 & 0xff;
        mac[macpos + 3] = this.h[1] >>> 8 & 0xff;
        mac[macpos + 4] = this.h[2] >>> 0 & 0xff;
        mac[macpos + 5] = this.h[2] >>> 8 & 0xff;
        mac[macpos + 6] = this.h[3] >>> 0 & 0xff;
        mac[macpos + 7] = this.h[3] >>> 8 & 0xff;
        mac[macpos + 8] = this.h[4] >>> 0 & 0xff;
        mac[macpos + 9] = this.h[4] >>> 8 & 0xff;
        mac[macpos + 10] = this.h[5] >>> 0 & 0xff;
        mac[macpos + 11] = this.h[5] >>> 8 & 0xff;
        mac[macpos + 12] = this.h[6] >>> 0 & 0xff;
        mac[macpos + 13] = this.h[6] >>> 8 & 0xff;
        mac[macpos + 14] = this.h[7] >>> 0 & 0xff;
        mac[macpos + 15] = this.h[7] >>> 8 & 0xff;
    };
    poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
            want = 16 - this.leftover;
            if (want > bytes) want = bytes;
            for(i = 0; i < want; i++)this.buffer[this.leftover + i] = m[mpos + i];
            bytes -= want;
            mpos += want;
            this.leftover += want;
            if (this.leftover < 16) return;
            this.blocks(this.buffer, 0, 16);
            this.leftover = 0;
        }
        if (bytes >= 16) {
            want = bytes - bytes % 16;
            this.blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
        }
        if (bytes) {
            for(i = 0; i < bytes; i++)this.buffer[this.leftover + i] = m[mpos + i];
            this.leftover += bytes;
        }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for(i = 0; i < 16; i++)c[i] = 0;
        return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for(i = 0; i < 32; i++)m[i] = 0;
        return 0;
    }
    function set25519(r, a) {
        var i;
        for(i = 0; i < 16; i++)r[i] = a[i] | 0;
    }
    function car25519(o) {
        var i, v, c = 1;
        for(i = 0; i < 16; i++){
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for(var i = 0; i < 16; i++){
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
        }
    }
    function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for(i = 0; i < 16; i++)t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for(j = 0; j < 2; j++){
            m[0] = t[0] - 0xffed;
            for(i = 1; i < 15; i++){
                m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
                m[i - 1] &= 0xffff;
            }
            m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 0xffff;
            sel25519(t, m, 1 - b);
        }
        for(i = 0; i < 16; i++){
            o[2 * i] = t[i] & 0xff;
            o[2 * i + 1] = t[i] >> 8;
        }
    }
    function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
    }
    function unpack25519(o, n) {
        var i;
        for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 0x7fff;
    }
    function A(o, a, b) {
        for(var i = 0; i < 16; i++)o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
        for(var i = 0; i < 16; i++)o[i] = a[i] - b[i];
    }
    function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        // t15 left as is
        // first car
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        // second car
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
    }
    function S(o, a) {
        M(o, a, a);
    }
    function inv25519(o, i) {
        var c = gf();
        var a;
        for(a = 0; a < 16; a++)c[a] = i[a];
        for(a = 253; a >= 0; a--){
            S(c, c);
            if (a !== 2 && a !== 4) M(c, c, i);
        }
        for(a = 0; a < 16; a++)o[a] = c[a];
    }
    function pow2523(o, i) {
        var c = gf();
        var a;
        for(a = 0; a < 16; a++)c[a] = i[a];
        for(a = 250; a >= 0; a--){
            S(c, c);
            if (a !== 1) M(c, c, i);
        }
        for(a = 0; a < 16; a++)o[a] = c[a];
    }
    function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for(i = 0; i < 31; i++)z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for(i = 0; i < 16; i++){
            b[i] = x[i];
            d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for(i = 254; i >= 0; --i){
            r = z[i >>> 3] >>> (i & 7) & 1;
            sel25519(a, b, r);
            sel25519(c, d, r);
            A(e, a, c);
            Z(a, a, c);
            A(c, b, d);
            Z(b, b, d);
            S(d, e);
            S(f, a);
            M(a, c, a);
            M(c, b, e);
            A(e, a, c);
            Z(a, a, c);
            S(b, a);
            Z(c, d, f);
            M(a, c, _121665);
            A(a, a, d);
            M(c, c, a);
            M(a, d, f);
            M(d, b, x);
            S(b, e);
            sel25519(a, b, r);
            sel25519(c, d, r);
        }
        for(i = 0; i < 16; i++){
            x[i + 16] = a[i];
            x[i + 32] = c[i];
            x[i + 48] = b[i];
            x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
    }
    function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
    }
    function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K = [
        0x428a2f98,
        0xd728ae22,
        0x71374491,
        0x23ef65cd,
        0xb5c0fbcf,
        0xec4d3b2f,
        0xe9b5dba5,
        0x8189dbbc,
        0x3956c25b,
        0xf348b538,
        0x59f111f1,
        0xb605d019,
        0x923f82a4,
        0xaf194f9b,
        0xab1c5ed5,
        0xda6d8118,
        0xd807aa98,
        0xa3030242,
        0x12835b01,
        0x45706fbe,
        0x243185be,
        0x4ee4b28c,
        0x550c7dc3,
        0xd5ffb4e2,
        0x72be5d74,
        0xf27b896f,
        0x80deb1fe,
        0x3b1696b1,
        0x9bdc06a7,
        0x25c71235,
        0xc19bf174,
        0xcf692694,
        0xe49b69c1,
        0x9ef14ad2,
        0xefbe4786,
        0x384f25e3,
        0x0fc19dc6,
        0x8b8cd5b5,
        0x240ca1cc,
        0x77ac9c65,
        0x2de92c6f,
        0x592b0275,
        0x4a7484aa,
        0x6ea6e483,
        0x5cb0a9dc,
        0xbd41fbd4,
        0x76f988da,
        0x831153b5,
        0x983e5152,
        0xee66dfab,
        0xa831c66d,
        0x2db43210,
        0xb00327c8,
        0x98fb213f,
        0xbf597fc7,
        0xbeef0ee4,
        0xc6e00bf3,
        0x3da88fc2,
        0xd5a79147,
        0x930aa725,
        0x06ca6351,
        0xe003826f,
        0x14292967,
        0x0a0e6e70,
        0x27b70a85,
        0x46d22ffc,
        0x2e1b2138,
        0x5c26c926,
        0x4d2c6dfc,
        0x5ac42aed,
        0x53380d13,
        0x9d95b3df,
        0x650a7354,
        0x8baf63de,
        0x766a0abb,
        0x3c77b2a8,
        0x81c2c92e,
        0x47edaee6,
        0x92722c85,
        0x1482353b,
        0xa2bfe8a1,
        0x4cf10364,
        0xa81a664b,
        0xbc423001,
        0xc24b8b70,
        0xd0f89791,
        0xc76c51a3,
        0x0654be30,
        0xd192e819,
        0xd6ef5218,
        0xd6990624,
        0x5565a910,
        0xf40e3585,
        0x5771202a,
        0x106aa070,
        0x32bbd1b8,
        0x19a4c116,
        0xb8d2d0c8,
        0x1e376c08,
        0x5141ab53,
        0x2748774c,
        0xdf8eeb99,
        0x34b0bcb5,
        0xe19b48a8,
        0x391c0cb3,
        0xc5c95a63,
        0x4ed8aa4a,
        0xe3418acb,
        0x5b9cca4f,
        0x7763e373,
        0x682e6ff3,
        0xd6b2b8a3,
        0x748f82ee,
        0x5defb2fc,
        0x78a5636f,
        0x43172f60,
        0x84c87814,
        0xa1f0ab72,
        0x8cc70208,
        0x1a6439ec,
        0x90befffa,
        0x23631e28,
        0xa4506ceb,
        0xde82bde9,
        0xbef9a3f7,
        0xb2c67915,
        0xc67178f2,
        0xe372532b,
        0xca273ece,
        0xea26619c,
        0xd186b8c7,
        0x21c0c207,
        0xeada7dd6,
        0xcde0eb1e,
        0xf57d4f7f,
        0xee6ed178,
        0x06f067aa,
        0x72176fba,
        0x0a637dc5,
        0xa2c898a6,
        0x113f9804,
        0xbef90dae,
        0x1b710b35,
        0x131c471b,
        0x28db77f5,
        0x23047d84,
        0x32caab7b,
        0x40c72493,
        0x3c9ebe0a,
        0x15c9bebc,
        0x431d67c4,
        0x9c100d4c,
        0x4cc5d4be,
        0xcb3e42b6,
        0x597f299c,
        0xfc657e2a,
        0x5fcb6fab,
        0x3ad6faec,
        0x6c44198c,
        0x4a475817
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while(n >= 128){
            for(i = 0; i < 16; i++){
                j = 8 * i + pos;
                wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
                wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
            }
            for(i = 0; i < 80; i++){
                bh0 = ah0;
                bh1 = ah1;
                bh2 = ah2;
                bh3 = ah3;
                bh4 = ah4;
                bh5 = ah5;
                bh6 = ah6;
                bh7 = ah7;
                bl0 = al0;
                bl1 = al1;
                bl2 = al2;
                bl3 = al3;
                bl4 = al4;
                bl5 = al5;
                bl6 = al6;
                bl7 = al7;
                // add
                h = ah7;
                l = al7;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                // Sigma1
                h = (ah4 >>> 14 | al4 << 18) ^ (ah4 >>> 18 | al4 << 14) ^ (al4 >>> 9 | ah4 << 23);
                l = (al4 >>> 14 | ah4 << 18) ^ (al4 >>> 18 | ah4 << 14) ^ (ah4 >>> 9 | al4 << 23);
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // Ch
                h = ah4 & ah5 ^ ~ah4 & ah6;
                l = al4 & al5 ^ ~al4 & al6;
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // K
                h = K[i * 2];
                l = K[i * 2 + 1];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // w
                h = wh[i % 16];
                l = wl[i % 16];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                th = c & 0xffff | d << 16;
                tl = a & 0xffff | b << 16;
                // add
                h = th;
                l = tl;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                // Sigma0
                h = (ah0 >>> 28 | al0 << 4) ^ (al0 >>> 2 | ah0 << 30) ^ (al0 >>> 7 | ah0 << 25);
                l = (al0 >>> 28 | ah0 << 4) ^ (ah0 >>> 2 | al0 << 30) ^ (ah0 >>> 7 | al0 << 25);
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // Maj
                h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
                l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                bh7 = c & 0xffff | d << 16;
                bl7 = a & 0xffff | b << 16;
                // add
                h = bh3;
                l = bl3;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = th;
                l = tl;
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                bh3 = c & 0xffff | d << 16;
                bl3 = a & 0xffff | b << 16;
                ah1 = bh0;
                ah2 = bh1;
                ah3 = bh2;
                ah4 = bh3;
                ah5 = bh4;
                ah6 = bh5;
                ah7 = bh6;
                ah0 = bh7;
                al1 = bl0;
                al2 = bl1;
                al3 = bl2;
                al4 = bl3;
                al5 = bl4;
                al6 = bl5;
                al7 = bl6;
                al0 = bl7;
                if (i % 16 === 15) for(j = 0; j < 16; j++){
                    // add
                    h = wh[j];
                    l = wl[j];
                    a = l & 0xffff;
                    b = l >>> 16;
                    c = h & 0xffff;
                    d = h >>> 16;
                    h = wh[(j + 9) % 16];
                    l = wl[(j + 9) % 16];
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma0
                    th = wh[(j + 1) % 16];
                    tl = wl[(j + 1) % 16];
                    h = (th >>> 1 | tl << 31) ^ (th >>> 8 | tl << 24) ^ th >>> 7;
                    l = (tl >>> 1 | th << 31) ^ (tl >>> 8 | th << 24) ^ (tl >>> 7 | th << 25);
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma1
                    th = wh[(j + 14) % 16];
                    tl = wl[(j + 14) % 16];
                    h = (th >>> 19 | tl << 13) ^ (tl >>> 29 | th << 3) ^ th >>> 6;
                    l = (tl >>> 19 | th << 13) ^ (th >>> 29 | tl << 3) ^ (tl >>> 6 | th << 26);
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    wh[j] = c & 0xffff | d << 16;
                    wl[j] = a & 0xffff | b << 16;
                }
            }
            // add
            h = ah0;
            l = al0;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[0];
            l = hl[0];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[0] = ah0 = c & 0xffff | d << 16;
            hl[0] = al0 = a & 0xffff | b << 16;
            h = ah1;
            l = al1;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[1];
            l = hl[1];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[1] = ah1 = c & 0xffff | d << 16;
            hl[1] = al1 = a & 0xffff | b << 16;
            h = ah2;
            l = al2;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[2];
            l = hl[2];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[2] = ah2 = c & 0xffff | d << 16;
            hl[2] = al2 = a & 0xffff | b << 16;
            h = ah3;
            l = al3;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[3];
            l = hl[3];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[3] = ah3 = c & 0xffff | d << 16;
            hl[3] = al3 = a & 0xffff | b << 16;
            h = ah4;
            l = al4;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[4];
            l = hl[4];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[4] = ah4 = c & 0xffff | d << 16;
            hl[4] = al4 = a & 0xffff | b << 16;
            h = ah5;
            l = al5;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[5];
            l = hl[5];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[5] = ah5 = c & 0xffff | d << 16;
            hl[5] = al5 = a & 0xffff | b << 16;
            h = ah6;
            l = al6;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[6];
            l = hl[6];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[6] = ah6 = c & 0xffff | d << 16;
            hl[6] = al6 = a & 0xffff | b << 16;
            h = ah7;
            l = al7;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[7];
            l = hl[7];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[7] = ah7 = c & 0xffff | d << 16;
            hl[7] = al7 = a & 0xffff | b << 16;
            pos += 128;
            n -= 128;
        }
        return n;
    }
    function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 0x6a09e667;
        hh[1] = 0xbb67ae85;
        hh[2] = 0x3c6ef372;
        hh[3] = 0xa54ff53a;
        hh[4] = 0x510e527f;
        hh[5] = 0x9b05688c;
        hh[6] = 0x1f83d9ab;
        hh[7] = 0x5be0cd19;
        hl[0] = 0xf3bcc908;
        hl[1] = 0x84caa73b;
        hl[2] = 0xfe94f82b;
        hl[3] = 0x5f1d36f1;
        hl[4] = 0xade682d1;
        hl[5] = 0x2b3e6c1f;
        hl[6] = 0xfb41bd6b;
        hl[7] = 0x137e2179;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for(i = 0; i < n; i++)x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 0x20000000 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for(i = 0; i < 8; i++)ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
    }
    function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
    }
    function cswap(p, q, b) {
        var i;
        for(i = 0; i < 4; i++)sel25519(p[i], q[i], b);
    }
    function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for(i = 255; i >= 0; --i){
            b = s[i / 8 | 0] >> (i & 7) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
        }
    }
    function scalarbase(p, s) {
        var q = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for(i = 0; i < 32; i++)sk[i + 32] = pk[i];
        return 0;
    }
    var L = new Float64Array([
        0xed,
        0xd3,
        0xf5,
        0x5c,
        0x1a,
        0x63,
        0x12,
        0x58,
        0xd6,
        0x9c,
        0xf7,
        0xa2,
        0xde,
        0xf9,
        0xde,
        0x14,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0x10
    ]);
    function modL(r, x) {
        var carry, i, j, k;
        for(i = 63; i >= 32; --i){
            carry = 0;
            for(j = i - 32, k = i - 12; j < k; ++j){
                x[j] += carry - 16 * x[i] * L[j - (i - 32)];
                carry = Math.floor((x[j] + 128) / 256);
                x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
        }
        carry = 0;
        for(j = 0; j < 32; j++){
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
        }
        for(j = 0; j < 32; j++)x[j] -= carry * L[j];
        for(i = 0; i < 32; i++){
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
        }
    }
    function reduce(r) {
        var x = new Float64Array(64), i;
        for(i = 0; i < 64; i++)x[i] = r[i];
        for(i = 0; i < 64; i++)r[i] = 0;
        modL(r, x);
    }
    // Note: difference from C - smlen returned, not passed as argument.
    function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for(i = 0; i < n; i++)sm[64 + i] = m[i];
        for(i = 0; i < 32; i++)sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for(i = 32; i < 64; i++)sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for(i = 0; i < 64; i++)x[i] = 0;
        for(i = 0; i < 32; i++)x[i] = r[i];
        for(i = 0; i < 32; i++)for(j = 0; j < 32; j++)x[i + j] += h[i] * d[j];
        modL(sm.subarray(32), x);
        return smlen;
    }
    function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [
            gf(),
            gf(),
            gf(),
            gf()
        ], q = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for(i = 0; i < n; i++)m[i] = sm[i];
        for(i = 0; i < 32; i++)m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
            for(i = 0; i < n; i++)m[i] = 0;
            return -1;
        }
        for(i = 0; i < n; i++)m[i] = sm[i + 64];
        return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
        crypto_core_hsalsa20: crypto_core_hsalsa20,
        crypto_stream_xor: crypto_stream_xor,
        crypto_stream: crypto_stream,
        crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
        crypto_stream_salsa20: crypto_stream_salsa20,
        crypto_onetimeauth: crypto_onetimeauth,
        crypto_onetimeauth_verify: crypto_onetimeauth_verify,
        crypto_verify_16: crypto_verify_16,
        crypto_verify_32: crypto_verify_32,
        crypto_secretbox: crypto_secretbox,
        crypto_secretbox_open: crypto_secretbox_open,
        crypto_scalarmult: crypto_scalarmult,
        crypto_scalarmult_base: crypto_scalarmult_base,
        crypto_box_beforenm: crypto_box_beforenm,
        crypto_box_afternm: crypto_box_afternm,
        crypto_box: crypto_box,
        crypto_box_open: crypto_box_open,
        crypto_box_keypair: crypto_box_keypair,
        crypto_hash: crypto_hash,
        crypto_sign: crypto_sign,
        crypto_sign_keypair: crypto_sign_keypair,
        crypto_sign_open: crypto_sign_open,
        crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES: crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
        crypto_hash_BYTES: crypto_hash_BYTES,
        gf: gf,
        D: D,
        L: L,
        pack25519: pack25519,
        unpack25519: unpack25519,
        M: M,
        A: A,
        S: S,
        Z: Z,
        pow2523: pow2523,
        add: add,
        set25519: set25519,
        modL: modL,
        scalarmult: scalarmult,
        scalarbase: scalarbase
    };
    /* High-level API */ function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
        for(var i = 0; i < arguments.length; i++){
            if (!(arguments[i] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
        }
    }
    function cleanup(arr) {
        for(var i = 0; i < arr.length; i++)arr[i] = 0;
    }
    nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
    };
    nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for(var i = 0; i < msg.length; i++)m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for(var i = 0; i < box.length; i++)c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
    };
    nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
    };
    nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return {
            publicKey: pk,
            secretKey: sk
        };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return {
            publicKey: pk,
            secretKey: new Uint8Array(secretKey)
        };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for(var i = 0; i < m.length; i++)m[i] = tmp[i];
        return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for(var i = 0; i < sig.length; i++)sig[i] = signedMsg[i];
        return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES) throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for(i = 0; i < crypto_sign_BYTES; i++)sm[i] = sig[i];
        for(i = 0; i < msg.length; i++)sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return {
            publicKey: pk,
            secretKey: sk
        };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for(var i = 0; i < pk.length; i++)pk[i] = secretKey[32 + i];
        return {
            publicKey: pk,
            secretKey: new Uint8Array(secretKey)
        };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES) throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for(var i = 0; i < 32; i++)sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return {
            publicKey: pk,
            secretKey: sk
        };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        // Zero length arguments are considered not equal.
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
        randombytes = fn;
    };
    (function() {
        // Initialize PRNG if environment provides CSPRNG.
        // If not, methods calling randombytes will throw.
        var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
            // Browsers.
            var QUOTA = 65536;
            nacl.setPRNG(function(x, n) {
                var i, v = new Uint8Array(n);
                for(i = 0; i < n; i += QUOTA)crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
                for(i = 0; i < n; i++)x[i] = v[i];
                cleanup(v);
            });
        } else {
            // Node.js.
            crypto = require("crypto");
            if (crypto && crypto.randomBytes) nacl.setPRNG(function(x, n) {
                var i, v = crypto.randomBytes(n);
                for(i = 0; i < n; i++)x[i] = v[i];
                cleanup(v);
            });
        }
    })();
})(module.exports ? module.exports : self.nacl = self.nacl || {});

},{"crypto":"jhUEF"}],"4zYlX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ed25519DeriveHard", ()=>ed25519DeriveHard);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _asU8AJs = require("../blake2/asU8a.js");
const HDKD = (0, _util.compactAddLength)((0, _util.stringToU8a)("Ed25519HDKD"));
function ed25519DeriveHard(seed, chainCode) {
    if (!(0, _util.isU8a)(chainCode) || chainCode.length !== 32) throw new Error("Invalid chainCode passed to derive");
    return (0, _asU8AJs.blake2AsU8a)((0, _util.u8aConcat)(HDKD, seed, chainCode));
}

},{"@polkadot/util":"3HnHw","../blake2/asU8a.js":"3rNsT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2EaW5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name ed25519PairFromRandom
 * @summary Creates a new public/secret keypair.
 * @description
 * Returns a new generate object containing a `publicKey` & `secretKey`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { ed25519PairFromRandom } from '@polkadot/util-crypto';
 *
 * ed25519PairFromRandom(); // => { secretKey: [...], publicKey: [...] }
 * ```
 */ parcelHelpers.export(exports, "ed25519PairFromRandom", ()=>ed25519PairFromRandom);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../../random/index.js");
var _fromSeedJs = require("./fromSeed.js");
function ed25519PairFromRandom() {
    return (0, _fromSeedJs.ed25519PairFromSeed)((0, _indexJs.randomAsU8a)());
}

},{"../../random/index.js":"63e69","./fromSeed.js":"d6ZVh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"63e69":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Returns a sequence of secure random bytes in a variety of formats
 */ parcelHelpers.export(exports, "randomAsNumber", ()=>(0, _asNumberJs.randomAsNumber));
parcelHelpers.export(exports, "randomAsHex", ()=>(0, _asU8AJs.randomAsHex));
parcelHelpers.export(exports, "randomAsU8a", ()=>(0, _asU8AJs.randomAsU8a));
var _asNumberJs = require("./asNumber.js");
var _asU8AJs = require("./asU8a.js");

},{"./asNumber.js":"cW4o9","./asU8a.js":"jPZeF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cW4o9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name randomAsNumber
 * @summary Creates a random number from random bytes.
 * @description
 * Returns a random number generated from the secure bytes.
 * @example
 * <BR>
 *
 * ```javascript
 * import { randomAsNumber } from '@polkadot/util-crypto';
 *
 * randomAsNumber(); // => <random number>
 * ```
 */ parcelHelpers.export(exports, "randomAsNumber", ()=>randomAsNumber);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _asU8AJs = require("./asU8a.js");
const BN_53 = new (0, _util.BN)(9007199254740991);
function randomAsNumber() {
    return (0, _util.hexToBn)((0, _asU8AJs.randomAsHex)(8)).and(BN_53).toNumber();
}

},{"@polkadot/util":"3HnHw","./asU8a.js":"jPZeF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jPZeF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name randomAsU8a
 * @summary Creates a Uint8Array filled with random bytes.
 * @description
 * Returns a `Uint8Array` with the specified (optional) length filled with random bytes.
 * @example
 * <BR>
 *
 * ```javascript
 * import { randomAsU8a } from '@polkadot/util-crypto';
 *
 * randomAsU8a(); // => Uint8Array([...])
 * ```
 */ parcelHelpers.export(exports, "randomAsU8a", ()=>randomAsU8a);
parcelHelpers.export(exports, "randomAsHex", ()=>randomAsHex);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _xRandomvalues = require("@polkadot/x-randomvalues");
var _helpersJs = require("../helpers.js");
function randomAsU8a(length = 32) {
    return (0, _xRandomvalues.getRandomValues)(new Uint8Array(length));
}
const randomAsHex = (0, _helpersJs.createAsHex)(randomAsU8a);

},{"@polkadot/x-randomvalues":"jhlDT","../helpers.js":"by01j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d6ZVh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name ed25519PairFromSeed
 * @summary Creates a new public/secret keypair from a seed.
 * @description
 * Returns a object containing a `publicKey` & `secretKey` generated from the supplied seed.
 * @example
 * <BR>
 *
 * ```javascript
 * import { ed25519PairFromSeed } from '@polkadot/util-crypto';
 *
 * ed25519PairFromSeed(...); // => { secretKey: [...], publicKey: [...] }
 * ```
 */ parcelHelpers.export(exports, "ed25519PairFromSeed", ()=>ed25519PairFromSeed);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _tweetnacl = require("tweetnacl");
var _tweetnaclDefault = parcelHelpers.interopDefault(_tweetnacl);
var _wasmCrypto = require("@polkadot/wasm-crypto");
function ed25519PairFromSeed(seed, onlyJs) {
    if (!onlyJs && (0, _wasmCrypto.isReady)()) {
        const full = (0, _wasmCrypto.ed25519KeypairFromSeed)(seed);
        return {
            publicKey: full.slice(32),
            secretKey: full.slice(0, 64)
        };
    }
    return (0, _tweetnaclDefault.default).sign.keyPair.fromSeed(seed);
}

},{"tweetnacl":"3J9rh","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h6CY8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name ed25519PairFromSecret
 * @summary Creates a new public/secret keypair from a secret.
 * @description
 * Returns a object containing a `publicKey` & `secretKey` generated from the supplied secret.
 * @example
 * <BR>
 *
 * ```javascript
 * import { ed25519PairFromSecret } from '@polkadot/util-crypto';
 *
 * ed25519PairFromSecret(...); // => { secretKey: [...], publicKey: [...] }
 * ```
 */ parcelHelpers.export(exports, "ed25519PairFromSecret", ()=>ed25519PairFromSecret);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _tweetnacl = require("tweetnacl");
var _tweetnaclDefault = parcelHelpers.interopDefault(_tweetnacl);
function ed25519PairFromSecret(secret) {
    return (0, _tweetnaclDefault.default).sign.keyPair.fromSecretKey(secret);
}

},{"tweetnacl":"3J9rh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2880J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name ed25519PairFromString
 * @summary Creates a new public/secret keypair from a string.
 * @description
 * Returns a object containing a `publicKey` & `secretKey` generated from the supplied string. The string is hashed and the value used as the input seed.
 * @example
 * <BR>
 *
 * ```javascript
 * import { ed25519PairFromString } from '@polkadot/util-crypto';
 *
 * ed25519PairFromString('test'); // => { secretKey: [...], publicKey: [...] }
 * ```
 */ parcelHelpers.export(exports, "ed25519PairFromString", ()=>ed25519PairFromString);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _asU8AJs = require("../../blake2/asU8a.js");
var _fromSeedJs = require("./fromSeed.js");
function ed25519PairFromString(value) {
    return (0, _fromSeedJs.ed25519PairFromSeed)((0, _asU8AJs.blake2AsU8a)((0, _util.stringToU8a)(value)));
}

},{"@polkadot/util":"3HnHw","../../blake2/asU8a.js":"3rNsT","./fromSeed.js":"d6ZVh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eiljI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name ed25519Sign
 * @summary Signs a message using the supplied secretKey
 * @description
 * Returns message signature of `message`, using the `secretKey`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { ed25519Sign } from '@polkadot/util-crypto';
 *
 * ed25519Sign([...], [...]); // => [...]
 * ```
 */ parcelHelpers.export(exports, "ed25519Sign", ()=>ed25519Sign);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _tweetnacl = require("tweetnacl");
var _tweetnaclDefault = parcelHelpers.interopDefault(_tweetnacl);
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
function ed25519Sign(message, { publicKey , secretKey  }, onlyJs) {
    if (!secretKey) throw new Error("Expected a valid secretKey");
    const messageU8a = (0, _util.u8aToU8a)(message);
    return !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.ed25519Sign)(publicKey, secretKey.subarray(0, 32), messageU8a) : (0, _tweetnaclDefault.default).sign.detached(messageU8a, secretKey);
}

},{"tweetnacl":"3J9rh","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eizeP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name ed25519Sign
 * @summary Verifies the signature on the supplied message.
 * @description
 * Verifies the `signature` on `message` with the supplied `publicKey`. Returns `true` on sucess, `false` otherwise.
 * @example
 * <BR>
 *
 * ```javascript
 * import { ed25519Verify } from '@polkadot/util-crypto';
 *
 * ed25519Verify([...], [...], [...]); // => true/false
 * ```
 */ parcelHelpers.export(exports, "ed25519Verify", ()=>ed25519Verify);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _tweetnacl = require("tweetnacl");
var _tweetnaclDefault = parcelHelpers.interopDefault(_tweetnacl);
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
function ed25519Verify(message, signature, publicKey, onlyJs) {
    const messageU8a = (0, _util.u8aToU8a)(message);
    const publicKeyU8a = (0, _util.u8aToU8a)(publicKey);
    const signatureU8a = (0, _util.u8aToU8a)(signature);
    if (publicKeyU8a.length !== 32) throw new Error(`Invalid publicKey, received ${publicKeyU8a.length}, expected 32`);
    else if (signatureU8a.length !== 64) throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
    return !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.ed25519Verify)(signatureU8a, messageU8a, publicKeyU8a) : (0, _tweetnaclDefault.default).sign.detached.verify(messageU8a, signatureU8a, publicKeyU8a);
}

},{"tweetnacl":"3J9rh","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1C8I0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keyHdkdSr25519", ()=>keyHdkdSr25519);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _deriveHardJs = require("../sr25519/deriveHard.js");
var _deriveSoftJs = require("../sr25519/deriveSoft.js");
function keyHdkdSr25519(keypair, { chainCode , isSoft  }) {
    return isSoft ? (0, _deriveSoftJs.sr25519DeriveSoft)(keypair, chainCode) : (0, _deriveHardJs.sr25519DeriveHard)(keypair, chainCode);
}

},{"../sr25519/deriveHard.js":"dcQYM","../sr25519/deriveSoft.js":"35sby","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dcQYM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sr25519DeriveHard", ()=>sr25519DeriveHard);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _deriveJs = require("./derive.js");
const sr25519DeriveHard = (0, _deriveJs.createDeriveFn)((0, _wasmCrypto.sr25519DeriveKeypairHard));

},{"@polkadot/wasm-crypto":"19VJZ","./derive.js":"fd4E9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fd4E9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createDeriveFn", ()=>createDeriveFn);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _fromU8AJs = require("./pair/fromU8a.js");
var _toU8AJs = require("./pair/toU8a.js");
function createDeriveFn(derive) {
    return (keypair, chainCode)=>{
        if (!(0, _util.isU8a)(chainCode) || chainCode.length !== 32) throw new Error("Invalid chainCode passed to derive");
        return (0, _fromU8AJs.sr25519PairFromU8a)(derive((0, _toU8AJs.sr25519KeypairToU8a)(keypair), chainCode));
    };
}

},{"@polkadot/util":"3HnHw","./pair/fromU8a.js":"fbo6u","./pair/toU8a.js":"jfewJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fbo6u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sr25519PairFromU8a", ()=>sr25519PairFromU8a);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const SEC_LEN = 64;
const PUB_LEN = 32;
const TOT_LEN = SEC_LEN + PUB_LEN;
function sr25519PairFromU8a(full) {
    const fullU8a = (0, _util.u8aToU8a)(full);
    if (fullU8a.length !== TOT_LEN) throw new Error(`Expected keypair with ${TOT_LEN} bytes, found ${fullU8a.length}`);
    return {
        publicKey: fullU8a.slice(SEC_LEN, TOT_LEN),
        secretKey: fullU8a.slice(0, SEC_LEN)
    };
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jfewJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sr25519KeypairToU8a", ()=>sr25519KeypairToU8a);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function sr25519KeypairToU8a({ publicKey , secretKey  }) {
    return (0, _util.u8aConcat)(secretKey, publicKey).slice();
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"35sby":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sr25519DeriveSoft", ()=>sr25519DeriveSoft);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _deriveJs = require("./derive.js");
const sr25519DeriveSoft = (0, _deriveJs.createDeriveFn)((0, _wasmCrypto.sr25519DeriveKeypairSoft));

},{"@polkadot/wasm-crypto":"19VJZ","./derive.js":"fd4E9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2JBt4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "sr25519Agreement", ()=>(0, _agreementJs.sr25519Agreement));
parcelHelpers.export(exports, "sr25519DeriveHard", ()=>(0, _deriveHardJs.sr25519DeriveHard));
parcelHelpers.export(exports, "sr25519DerivePublic", ()=>(0, _derivePublicJs.sr25519DerivePublic));
parcelHelpers.export(exports, "sr25519DeriveSoft", ()=>(0, _deriveSoftJs.sr25519DeriveSoft));
parcelHelpers.export(exports, "sr25519PairFromSeed", ()=>(0, _fromSeedJs.sr25519PairFromSeed));
parcelHelpers.export(exports, "sr25519Sign", ()=>(0, _signJs.sr25519Sign));
parcelHelpers.export(exports, "sr25519Verify", ()=>(0, _verifyJs.sr25519Verify));
parcelHelpers.export(exports, "sr25519VrfSign", ()=>(0, _vrfSignJs.sr25519VrfSign));
parcelHelpers.export(exports, "sr25519VrfVerify", ()=>(0, _vrfVerifyJs.sr25519VrfVerify));
var _agreementJs = require("./agreement.js");
var _deriveHardJs = require("./deriveHard.js");
var _derivePublicJs = require("./derivePublic.js");
var _deriveSoftJs = require("./deriveSoft.js");
var _fromSeedJs = require("./pair/fromSeed.js");
var _signJs = require("./sign.js");
var _verifyJs = require("./verify.js");
var _vrfSignJs = require("./vrfSign.js");
var _vrfVerifyJs = require("./vrfVerify.js");

},{"./agreement.js":"95CpC","./deriveHard.js":"dcQYM","./derivePublic.js":"gridv","./deriveSoft.js":"35sby","./pair/fromSeed.js":"ggYif","./sign.js":"dESsd","./verify.js":"5QxDh","./vrfSign.js":"H8GkX","./vrfVerify.js":"kEZOz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"95CpC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name sr25519Agreement
 * @description Key agreement between other's public key and self secret key
 */ parcelHelpers.export(exports, "sr25519Agreement", ()=>sr25519Agreement);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
function sr25519Agreement(secretKey, publicKey) {
    const secretKeyU8a = (0, _util.u8aToU8a)(secretKey);
    const publicKeyU8a = (0, _util.u8aToU8a)(publicKey);
    if (publicKeyU8a.length !== 32) throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
    else if (secretKeyU8a.length !== 64) throw new Error(`Invalid secretKey, received ${secretKeyU8a.length} bytes, expected 64`);
    return (0, _wasmCrypto.sr25519Agree)(publicKeyU8a, secretKeyU8a);
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gridv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sr25519DerivePublic", ()=>sr25519DerivePublic);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
function sr25519DerivePublic(publicKey, chainCode) {
    const publicKeyU8a = (0, _util.u8aToU8a)(publicKey);
    if (!(0, _util.isU8a)(chainCode) || chainCode.length !== 32) throw new Error("Invalid chainCode passed to derive");
    else if (publicKeyU8a.length !== 32) throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
    return (0, _wasmCrypto.sr25519DerivePublicSoft)(publicKeyU8a, chainCode);
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ggYif":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name sr25519PairFromSeed
 * @description Returns a object containing a `publicKey` & `secretKey` generated from the supplied seed.
 */ parcelHelpers.export(exports, "sr25519PairFromSeed", ()=>sr25519PairFromSeed);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _fromU8AJs = require("./fromU8a.js");
function sr25519PairFromSeed(seed) {
    const seedU8a = (0, _util.u8aToU8a)(seed);
    if (seedU8a.length !== 32) throw new Error(`Expected a seed matching 32 bytes, found ${seedU8a.length}`);
    return (0, _fromU8AJs.sr25519PairFromU8a)((0, _wasmCrypto.sr25519KeypairFromSeed)(seedU8a));
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","./fromU8a.js":"fbo6u","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dESsd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name sr25519Sign
 * @description Returns message signature of `message`, using the supplied pair
 */ parcelHelpers.export(exports, "sr25519Sign", ()=>sr25519Sign);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
function sr25519Sign(message, { publicKey , secretKey  }) {
    if ((publicKey === null || publicKey === void 0 ? void 0 : publicKey.length) !== 32) throw new Error("Expected a valid publicKey, 32-bytes");
    else if ((secretKey === null || secretKey === void 0 ? void 0 : secretKey.length) !== 64) throw new Error("Expected a valid secretKey, 64-bytes");
    return (0, _wasmCrypto.sr25519Sign)(publicKey, secretKey, (0, _util.u8aToU8a)(message));
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5QxDh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name sr25519Verify
 * @description Verifies the signature of `message`, using the supplied pair
 */ parcelHelpers.export(exports, "sr25519Verify", ()=>sr25519Verify);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
function sr25519Verify(message, signature, publicKey) {
    const publicKeyU8a = (0, _util.u8aToU8a)(publicKey);
    const signatureU8a = (0, _util.u8aToU8a)(signature);
    if (publicKeyU8a.length !== 32) throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
    else if (signatureU8a.length !== 64) throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
    return (0, _wasmCrypto.sr25519Verify)(signatureU8a, (0, _util.u8aToU8a)(message), publicKeyU8a);
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"H8GkX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name sr25519VrfSign
 * @description Sign with sr25519 vrf signing (deterministic)
 */ parcelHelpers.export(exports, "sr25519VrfSign", ()=>sr25519VrfSign);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
const EMPTY_U8A = new Uint8Array();
function sr25519VrfSign(message, { secretKey  }, context = EMPTY_U8A, extra = EMPTY_U8A) {
    if ((secretKey === null || secretKey === void 0 ? void 0 : secretKey.length) !== 64) throw new Error("Invalid secretKey, expected 64-bytes");
    return (0, _wasmCrypto.vrfSign)(secretKey, (0, _util.u8aToU8a)(context), (0, _util.u8aToU8a)(message), (0, _util.u8aToU8a)(extra));
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kEZOz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name sr25519VrfVerify
 * @description Verify with sr25519 vrf verification
 */ parcelHelpers.export(exports, "sr25519VrfVerify", ()=>sr25519VrfVerify);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
const EMPTY_U8A = new Uint8Array();
function sr25519VrfVerify(message, signOutput, publicKey, context = EMPTY_U8A, extra = EMPTY_U8A) {
    const publicKeyU8a = (0, _util.u8aToU8a)(publicKey);
    const proofU8a = (0, _util.u8aToU8a)(signOutput);
    if (publicKeyU8a.length !== 32) throw new Error("Invalid publicKey, expected 32-bytes");
    else if (proofU8a.length !== 96) throw new Error("Invalid vrfSign output, expected 96 bytes");
    return (0, _wasmCrypto.vrfVerify)(publicKeyU8a, (0, _util.u8aToU8a)(context), (0, _util.u8aToU8a)(message), (0, _util.u8aToU8a)(extra), proofU8a);
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkF5r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeAddress", ()=>encodeAddress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L34
var _util = require("@polkadot/util");
var _indexJs = require("../base58/index.js");
var _decodeJs = require("./decode.js");
var _defaultsJs = require("./defaults.js");
var _sshashJs = require("./sshash.js");
function encodeAddress(key, ss58Format = (0, _defaultsJs.defaults).prefix) {
    // decode it, this means we can re-encode an address
    const u8a = (0, _decodeJs.decodeAddress)(key);
    if (ss58Format < 0 || ss58Format > 16383 || [
        46,
        47
    ].includes(ss58Format)) throw new Error("Out of range ss58Format specified");
    else if (!(0, _defaultsJs.defaults).allowedDecodedLengths.includes(u8a.length)) throw new Error(`Expected a valid key to convert, with length ${(0, _defaultsJs.defaults).allowedDecodedLengths.join(", ")}`);
    const input = (0, _util.u8aConcat)(ss58Format < 64 ? [
        ss58Format
    ] : [
        (ss58Format & 252) >> 2 | 64,
        ss58Format >> 8 | (ss58Format & 3) << 6
    ], u8a);
    return (0, _indexJs.base58Encode)((0, _util.u8aConcat)(input, (0, _sshashJs.sshash)(input).subarray(0, [
        32,
        33
    ].includes(u8a.length) ? 2 : 1)));
}

},{"@polkadot/util":"3HnHw","../base58/index.js":"kXPnW","./decode.js":"1wUOF","./defaults.js":"cxlL5","./sshash.js":"4NFl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gX3uS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name encodeDerivedAddress
 * @summary Creates a derived address as used in Substrate utility.
 * @description
 * Creates a Substrate derived address based on the input address/publicKey and the index supplied.
 */ parcelHelpers.export(exports, "encodeDerivedAddress", ()=>encodeDerivedAddress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _decodeJs = require("./decode.js");
var _encodeJs = require("./encode.js");
var _keyDerivedJs = require("./keyDerived.js");
function encodeDerivedAddress(who, index, ss58Format) {
    return (0, _encodeJs.encodeAddress)((0, _keyDerivedJs.createKeyDerived)((0, _decodeJs.decodeAddress)(who), index), ss58Format);
}

},{"./decode.js":"1wUOF","./encode.js":"gkF5r","./keyDerived.js":"jAPQm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l3WPi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name encodeMultiAddress
 * @summary Creates a multisig address.
 * @description
 * Creates a Substrate multisig address based on the input address and the required threshold.
 */ parcelHelpers.export(exports, "encodeMultiAddress", ()=>encodeMultiAddress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _encodeJs = require("./encode.js");
var _keyMultiJs = require("./keyMulti.js");
function encodeMultiAddress(who, threshold, ss58Format) {
    return (0, _encodeJs.encodeAddress)((0, _keyMultiJs.createKeyMulti)(who, threshold), ss58Format);
}

},{"./encode.js":"gkF5r","./keyMulti.js":"gJriE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"egedG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name evmToAddress
 * @summary Converts an EVM address to its corresponding SS58 address.
 */ parcelHelpers.export(exports, "evmToAddress", ()=>evmToAddress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _hasherJs = require("../secp256k1/hasher.js");
var _encodeJs = require("./encode.js");
function evmToAddress(evmAddress, ss58Format, hashType = "blake2") {
    const message = (0, _util.u8aConcat)("evm:", evmAddress);
    if (message.length !== 24) throw new Error(`Converting ${evmAddress}: Invalid evm address length`);
    return (0, _encodeJs.encodeAddress)((0, _hasherJs.hasher)(hashType, message), ss58Format);
}

},{"@polkadot/util":"3HnHw","../secp256k1/hasher.js":"iqTSh","./encode.js":"gkF5r","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iqTSh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasher", ()=>hasher);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../blake2/index.js");
var _indexJs1 = require("../keccak/index.js");
function hasher(hashType, data, onlyJs) {
    return hashType === "keccak" ? (0, _indexJs1.keccakAsU8a)(data, undefined, onlyJs) : (0, _indexJs.blake2AsU8a)(data, undefined, undefined, onlyJs);
}

},{"../blake2/index.js":"fBtmb","../keccak/index.js":"6zB64","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fBtmb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Create blake2b values with specified bitlengths
 */ parcelHelpers.export(exports, "blake2AsHex", ()=>(0, _asU8AJs.blake2AsHex));
parcelHelpers.export(exports, "blake2AsU8a", ()=>(0, _asU8AJs.blake2AsU8a));
var _asU8AJs = require("./asU8a.js");

},{"./asU8a.js":"3rNsT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6zB64":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Create Keccak256/512 values as hex & Uint8Array output
 */ parcelHelpers.export(exports, "keccakAsHex", ()=>(0, _asU8AJs.keccakAsHex));
parcelHelpers.export(exports, "keccakAsU8a", ()=>(0, _asU8AJs.keccakAsU8a));
parcelHelpers.export(exports, "keccak256AsU8a", ()=>(0, _asU8AJs.keccak256AsU8a));
parcelHelpers.export(exports, "keccak512AsU8a", ()=>(0, _asU8AJs.keccak512AsU8a));
var _asU8AJs = require("./asU8a.js");

},{"./asU8a.js":"9I4NF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9I4NF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keccakAsU8a", ()=>keccakAsU8a);
parcelHelpers.export(exports, "keccak256AsU8a", ()=>keccak256AsU8a);
parcelHelpers.export(exports, "keccak512AsU8a", ()=>keccak512AsU8a);
parcelHelpers.export(exports, "keccakAsHex", ()=>keccakAsHex);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _sha3 = require("@noble/hashes/sha3");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _helpersJs = require("../helpers.js");
const keccakAsU8a = (0, _helpersJs.createDualHasher)({
    256: (0, _wasmCrypto.keccak256),
    512: (0, _wasmCrypto.keccak512)
}, {
    256: (0, _sha3.keccak_256),
    512: (0, _sha3.keccak_512)
});
const keccak256AsU8a = (0, _helpersJs.createBitHasher)(256, keccakAsU8a);
const keccak512AsU8a = (0, _helpersJs.createBitHasher)(512, keccakAsU8a);
const keccakAsHex = (0, _helpersJs.createAsHex)(keccakAsU8a);

},{"@noble/hashes/sha3":"7YJSg","@polkadot/wasm-crypto":"19VJZ","../helpers.js":"by01j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7YJSg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = require("./_assert.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [
    [],
    [],
    []
];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    [x, y] = [
        y,
        (2 * x + 3 * y) % 5
    ];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    let t = _0n;
    for(let j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s)=>s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
const rotlL = (h, l, s)=>s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(10);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(let round = 24 - rounds; round < 24; round++){
        // Theta Œ∏
        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(let x1 = 0; x1 < 10; x1 += 2){
            const idx1 = (x1 + 8) % 10;
            const idx0 = (x1 + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(let y = 0; y < 50; y += 10){
                s[x1 + y] ^= Th;
                s[x1 + y + 1] ^= Tl;
            }
        }
        // Rho (œÅ) and Pi (œÄ)
        let curH = s[2];
        let curL = s[3];
        for(let t = 0; t < 24; t++){
            const shift = SHA3_ROTL[t];
            const Th1 = rotlH(curH, curL, shift);
            const Tl1 = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th1;
            s[PI + 1] = Tl1;
        }
        // Chi (œá)
        for(let y1 = 0; y1 < 50; y1 += 10){
            for(let x2 = 0; x2 < 10; x2++)B[x2] = s[y1 + x2];
            for(let x3 = 0; x3 < 10; x3++)s[y1 + x3] ^= ~B[(x3 + 2) % 10] & B[(x3 + 4) % 10];
        }
        // Iota (Œπ)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        _assert_js_1.default.number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen , state  } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = true;
        const { state , suffix , pos , blockLen  } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen  } = this;
        for(let pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
    }
    xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished) throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen , suffix , outputLen , rounds , enableXOF  } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 28);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */ exports.sha3_256 = gen(0x06, 136, 32);
exports.sha3_384 = gen(0x06, 104, 48);
exports.sha3_512 = gen(0x06, 72, 64);
exports.keccak_224 = gen(0x01, 144, 28);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */ exports.keccak_256 = gen(0x01, 136, 32);
exports.keccak_384 = gen(0x01, 104, 48);
exports.keccak_512 = gen(0x01, 72, 64);
const genShake = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 16);
exports.shake256 = genShake(0x1f, 136, 32);

},{"./_assert.js":"BFdql","./_u64.js":"8TbxJ","./utils.js":"2ehgp"}],"4yq86":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name addressEq
 * @summary Compares two addresses, either in ss58, Uint8Array or hex format.
 * @description
 * For the input values, return true is the underlying public keys do match.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aEq } from '@polkadot/util';
 *
 * u8aEq(new Uint8Array([0x68, 0x65]), new Uint8Array([0x68, 0x65])); // true
 * ```
 */ parcelHelpers.export(exports, "addressEq", ()=>addressEq);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _decodeJs = require("./decode.js");
function addressEq(a, b) {
    return (0, _util.u8aEq)((0, _decodeJs.decodeAddress)(a), (0, _decodeJs.decodeAddress)(b));
}

},{"@polkadot/util":"3HnHw","./decode.js":"1wUOF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2z18S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isAddress", ()=>isAddress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _validateJs = require("./validate.js");
function isAddress(address, ignoreChecksum, ss58Format) {
    try {
        return (0, _validateJs.validateAddress)(address, ignoreChecksum, ss58Format);
    } catch (error) {
        return false;
    }
}

},{"./validate.js":"9kCMO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9kCMO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "validateAddress", ()=>validateAddress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _decodeJs = require("./decode.js");
function validateAddress(encoded, ignoreChecksum, ss58Format) {
    return !!(0, _decodeJs.decodeAddress)(encoded, ignoreChecksum, ss58Format);
}

},{"./decode.js":"1wUOF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fB8TL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Sets the global SS58 format to use for address encoding
 * @deprecated Use keyring.setSS58Format
 */ parcelHelpers.export(exports, "setSS58Format", ()=>setSS58Format);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _defaultsJs = require("./defaults.js");
const l = (0, _util.logger)("setSS58Format");
function setSS58Format(prefix) {
    l.warn("Global setting of the ss58Format is deprecated and not recommended. Set format on the keyring (if used) or as part of the address encode function");
    (0, _defaultsJs.defaults).prefix = prefix;
}

},{"@polkadot/util":"3HnHw","./defaults.js":"cxlL5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f2kEP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sortAddresses", ()=>sortAddresses);
// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _encodeJs = require("./encode.js");
var _utilJs = require("./util.js");
function sortAddresses(addresses, ss58Format) {
    const u8aToAddress = (u8a)=>(0, _encodeJs.encodeAddress)(u8a, ss58Format);
    return (0, _util.u8aSorted)(addresses.map((0, _utilJs.addressToU8a))).map(u8aToAddress);
}

},{"@polkadot/util":"3HnHw","./encode.js":"gkF5r","./util.js":"96saF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4vQZG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Encode and decode base32 values
 */ parcelHelpers.export(exports, "base32Decode", ()=>(0, _bs32Js.base32Decode));
parcelHelpers.export(exports, "base32Encode", ()=>(0, _bs32Js.base32Encode));
parcelHelpers.export(exports, "base32Validate", ()=>(0, _bs32Js.base32Validate));
parcelHelpers.export(exports, "isBase32", ()=>(0, _bs32Js.isBase32));
var _bs32Js = require("./bs32.js");

},{"./bs32.js":"42MIc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"42MIc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base32Validate", ()=>base32Validate);
parcelHelpers.export(exports, "isBase32", ()=>isBase32);
parcelHelpers.export(exports, "base32Decode", ()=>base32Decode);
parcelHelpers.export(exports, "base32Encode", ()=>base32Encode);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _base = require("@scure/base");
var _helpersJs = require("./helpers.js");
const chars = "abcdefghijklmnopqrstuvwxyz234567";
const config = {
    chars,
    coder: (0, _base.utils).chain((0, _base.utils).radix2(5), (0, _base.utils).alphabet(chars), {
        decode: (input)=>input.split(""),
        encode: (input)=>input.join("")
    }),
    ipfs: "b",
    type: "base32"
};
const base32Validate = (0, _helpersJs.createValidate)(config);
const isBase32 = (0, _helpersJs.createIs)(base32Validate);
const base32Decode = (0, _helpersJs.createDecode)(config, base32Validate);
const base32Encode = (0, _helpersJs.createEncode)(config);

},{"@scure/base":"cvmUK","./helpers.js":"azXie","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dCLyq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Encode and decode base64 values
 */ parcelHelpers.export(exports, "base64Decode", ()=>(0, _bs64Js.base64Decode));
parcelHelpers.export(exports, "base64Encode", ()=>(0, _bs64Js.base64Encode));
parcelHelpers.export(exports, "base64Validate", ()=>(0, _bs64Js.base64Validate));
parcelHelpers.export(exports, "isBase64", ()=>(0, _bs64Js.isBase64));
parcelHelpers.export(exports, "base64Pad", ()=>(0, _padJs.base64Pad));
parcelHelpers.export(exports, "base64Trim", ()=>(0, _trimJs.base64Trim));
var _bs64Js = require("./bs64.js");
var _padJs = require("./pad.js");
var _trimJs = require("./trim.js");

},{"./bs64.js":"hdCCc","./pad.js":"gFiYU","./trim.js":"ksExk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hdCCc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base64Validate", ()=>base64Validate);
parcelHelpers.export(exports, "isBase64", ()=>isBase64);
parcelHelpers.export(exports, "base64Decode", ()=>base64Decode);
parcelHelpers.export(exports, "base64Encode", ()=>base64Encode);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _base = require("@scure/base");
var _helpersJs = require("../base32/helpers.js");
const config = {
    chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    coder: (0, _base.base64),
    type: "base64"
};
const base64Validate = (0, _helpersJs.createValidate)(config);
const isBase64 = (0, _helpersJs.createIs)(base64Validate);
const base64Decode = (0, _helpersJs.createDecode)(config, base64Validate);
const base64Encode = (0, _helpersJs.createEncode)(config);

},{"@scure/base":"cvmUK","../base32/helpers.js":"azXie","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gFiYU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name base64Pad
 * @description Adds padding characters for correct length
 */ parcelHelpers.export(exports, "base64Pad", ()=>base64Pad);
function base64Pad(value) {
    return value.padEnd(value.length + value.length % 4, "=");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ksExk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name base64Trim
 * @description Trims padding characters
 */ parcelHelpers.export(exports, "base64Trim", ()=>base64Trim);
function base64Trim(value) {
    while(value.length && value[value.length - 1] === "=")value = value.slice(0, -1);
    return value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"huQFg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "ethereumEncode", ()=>(0, _encodeJs.ethereumEncode));
parcelHelpers.export(exports, "isEthereumAddress", ()=>(0, _isAddressJs.isEthereumAddress));
parcelHelpers.export(exports, "isEthereumChecksum", ()=>(0, _isChecksumJs.isEthereumChecksum));
var _encodeJs = require("./encode.js");
var _isAddressJs = require("./isAddress.js");
var _isChecksumJs = require("./isChecksum.js");

},{"./encode.js":"323SV","./isAddress.js":"iNBtl","./isChecksum.js":"jJwHG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"323SV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ethereumEncode", ()=>ethereumEncode);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../keccak/index.js");
var _indexJs1 = require("../secp256k1/index.js");
function getH160(u8a) {
    if ([
        33,
        65
    ].includes(u8a.length)) u8a = (0, _indexJs.keccakAsU8a)((0, _indexJs1.secp256k1Expand)(u8a));
    return u8a.slice(-20);
}
function ethereumEncode(addressOrPublic) {
    if (!addressOrPublic) return "0x";
    const u8aAddress = (0, _util.u8aToU8a)(addressOrPublic);
    if (![
        20,
        32,
        33,
        65
    ].includes(u8aAddress.length)) throw new Error("Invalid address or publicKey passed");
    const address = (0, _util.u8aToHex)(getH160(u8aAddress), -1, false);
    const hash = (0, _util.u8aToHex)((0, _indexJs.keccakAsU8a)(address), -1, false);
    let result = "";
    for(let i = 0; i < 40; i++)result = `${result}${parseInt(hash[i], 16) > 7 ? address[i].toUpperCase() : address[i]}`;
    return `0x${result}`;
}

},{"@polkadot/util":"3HnHw","../keccak/index.js":"6zB64","../secp256k1/index.js":"iZGLu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iZGLu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "secp256k1Compress", ()=>(0, _compressJs.secp256k1Compress));
parcelHelpers.export(exports, "secp256k1Expand", ()=>(0, _expandJs.secp256k1Expand));
parcelHelpers.export(exports, "secp256k1PairFromSeed", ()=>(0, _fromSeedJs.secp256k1PairFromSeed));
parcelHelpers.export(exports, "secp256k1Recover", ()=>(0, _recoverJs.secp256k1Recover));
parcelHelpers.export(exports, "secp256k1Sign", ()=>(0, _signJs.secp256k1Sign));
parcelHelpers.export(exports, "secp256k1PrivateKeyTweakAdd", ()=>(0, _tweakAddJs.secp256k1PrivateKeyTweakAdd));
parcelHelpers.export(exports, "secp256k1Verify", ()=>(0, _verifyJs.secp256k1Verify));
var _compressJs = require("./compress.js");
var _expandJs = require("./expand.js");
var _fromSeedJs = require("./pair/fromSeed.js");
var _recoverJs = require("./recover.js");
var _signJs = require("./sign.js");
var _tweakAddJs = require("./tweakAdd.js");
var _verifyJs = require("./verify.js");

},{"./compress.js":"eF7qg","./expand.js":"dAmfU","./pair/fromSeed.js":"6vhYg","./recover.js":"eW5a8","./sign.js":"a8Zd9","./tweakAdd.js":"e1fDJ","./verify.js":"hxRMC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eF7qg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "secp256k1Compress", ()=>secp256k1Compress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _secp256K1 = require("@noble/secp256k1");
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
function secp256k1Compress(publicKey, onlyJs) {
    if (publicKey.length === 33) return publicKey;
    if (publicKey.length !== 65) throw new Error("Invalid publicKey provided");
    return !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.secp256k1Compress)(publicKey) : (0, _secp256K1.Point).fromHex(publicKey).toRawBytes(true);
}

},{"@noble/secp256k1":"eyYsH","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dAmfU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "secp256k1Expand", ()=>secp256k1Expand);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _secp256K1 = require("@noble/secp256k1");
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _bnJs = require("../bn.js");
function secp256k1Expand(publicKey, onlyJs) {
    if (publicKey.length === 65) return publicKey.subarray(1);
    if (publicKey.length !== 33) throw new Error("Invalid publicKey provided");
    if (!(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)()) return (0, _wasmCrypto.secp256k1Expand)(publicKey).subarray(1);
    const { x , y  } = (0, _secp256K1.Point).fromHex(publicKey);
    return (0, _util.u8aConcat)((0, _util.bnToU8a)(x, (0, _bnJs.BN_BE_256_OPTS)), (0, _util.bnToU8a)(y, (0, _bnJs.BN_BE_256_OPTS)));
}

},{"@noble/secp256k1":"eyYsH","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","../bn.js":"h6UHx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eW5a8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name secp256k1Recover
 * @description Recovers a publicKey from the supplied signature
 */ parcelHelpers.export(exports, "secp256k1Recover", ()=>secp256k1Recover);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _secp256K1 = require("@noble/secp256k1");
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _compressJs = require("./compress.js");
var _expandJs = require("./expand.js");
function secp256k1Recover(msgHash, signature, recovery, hashType = "blake2", onlyJs) {
    const sig = (0, _util.u8aToU8a)(signature).subarray(0, 64);
    const msg = (0, _util.u8aToU8a)(msgHash);
    const publicKey = !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.secp256k1Recover)(msg, sig, recovery) : (0, _secp256K1.recoverPublicKey)(msg, (0, _secp256K1.Signature).fromCompact(sig).toRawBytes(), recovery);
    if (!publicKey) throw new Error("Unable to recover publicKey from signature");
    return hashType === "keccak" ? (0, _expandJs.secp256k1Expand)(publicKey, onlyJs) : (0, _compressJs.secp256k1Compress)(publicKey, onlyJs);
}

},{"@noble/secp256k1":"eyYsH","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","./compress.js":"eF7qg","./expand.js":"dAmfU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a8Zd9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name secp256k1Sign
 * @description Returns message signature of `message`, using the supplied pair
 */ parcelHelpers.export(exports, "secp256k1Sign", ()=>secp256k1Sign);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _secp256K1 = require("@noble/secp256k1");
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _bnJs = require("../bn.js");
var _hasherJs = require("./hasher.js");
function secp256k1Sign(message, { secretKey  }, hashType = "blake2", onlyJs) {
    if ((secretKey === null || secretKey === void 0 ? void 0 : secretKey.length) !== 32) throw new Error("Expected valid secp256k1 secretKey, 32-bytes");
    const data = (0, _hasherJs.hasher)(hashType, message, onlyJs);
    if (!(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)()) return (0, _wasmCrypto.secp256k1Sign)(data, secretKey);
    const [sigBytes, recoveryParam] = (0, _secp256K1.signSync)(data, secretKey, {
        canonical: true,
        recovered: true
    });
    const { r , s  } = (0, _secp256K1.Signature).fromHex(sigBytes);
    return (0, _util.u8aConcat)((0, _util.bnToU8a)(r, (0, _bnJs.BN_BE_256_OPTS)), (0, _util.bnToU8a)(s, (0, _bnJs.BN_BE_256_OPTS)), new Uint8Array([
        recoveryParam || 0
    ]));
}

},{"@noble/secp256k1":"eyYsH","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","../bn.js":"h6UHx","./hasher.js":"iqTSh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e1fDJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "secp256k1PrivateKeyTweakAdd", ()=>secp256k1PrivateKeyTweakAdd);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _xBigint = require("@polkadot/x-bigint");
var _bnJs = require("../bn.js"); // pre-defined curve param as lifted form elliptic
// https://github.com/indutny/elliptic/blob/e71b2d9359c5fe9437fbf46f1f05096de447de57/lib/elliptic/curves.js#L182
const N = "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141".replace(/ /g, "");
const N_BI = (0, _xBigint.BigInt)(`0x${N}`);
const N_BN = new (0, _util.BN)(N, "hex");
function addBi(seckey, tweak) {
    let res = (0, _util.u8aToBigInt)(tweak, (0, _bnJs.BN_BE_OPTS));
    if (res >= N_BI) throw new Error("Tweak parameter is out of range");
    res += (0, _util.u8aToBigInt)(seckey, (0, _bnJs.BN_BE_OPTS));
    if (res >= N_BI) res -= N_BI;
    if (res === (0, _util._0n)) throw new Error("Invalid resulting private key");
    return (0, _util.nToU8a)(res, (0, _bnJs.BN_BE_256_OPTS));
}
function addBn(seckey, tweak) {
    const res = new (0, _util.BN)(tweak);
    if (res.cmp(N_BN) >= 0) throw new Error("Tweak parameter is out of range");
    res.iadd(new (0, _util.BN)(seckey));
    if (res.cmp(N_BN) >= 0) res.isub(N_BN);
    if (res.isZero()) throw new Error("Invalid resulting private key");
    return (0, _util.bnToU8a)(res, (0, _bnJs.BN_BE_256_OPTS));
}
function secp256k1PrivateKeyTweakAdd(seckey, tweak, onlyBn) {
    if (!(0, _util.isU8a)(seckey) || seckey.length !== 32) throw new Error("Expected seckey to be an Uint8Array with length 32");
    else if (!(0, _util.isU8a)(tweak) || tweak.length !== 32) throw new Error("Expected tweak to be an Uint8Array with length 32");
    return !(0, _util.hasBigInt) || onlyBn ? addBn(seckey, tweak) : addBi(seckey, tweak);
}

},{"@polkadot/util":"3HnHw","@polkadot/x-bigint":"6Blk3","../bn.js":"h6UHx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hxRMC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name secp256k1Verify
 * @description Verifies the signature of `message`, using the supplied pair
 */ parcelHelpers.export(exports, "secp256k1Verify", ()=>secp256k1Verify);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _hasherJs = require("./hasher.js");
var _recoverJs = require("./recover.js");
function secp256k1Verify(msgHash, signature, address, hashType = "blake2", onlyJs) {
    const sig = (0, _util.u8aToU8a)(signature);
    if (sig.length !== 65) throw new Error(`Expected signature with 65 bytes, ${sig.length} found instead`);
    const publicKey = (0, _recoverJs.secp256k1Recover)((0, _hasherJs.hasher)(hashType, msgHash), sig, sig[64], hashType, onlyJs);
    const signerAddr = (0, _hasherJs.hasher)(hashType, publicKey, onlyJs);
    const inputAddr = (0, _util.u8aToU8a)(address); // for Ethereum (keccak) the last 20 bytes is the address
    return (0, _util.u8aEq)(publicKey, inputAddr) || (hashType === "keccak" ? (0, _util.u8aEq)(signerAddr.slice(-20), inputAddr.slice(-20)) : (0, _util.u8aEq)(signerAddr, inputAddr));
}

},{"@polkadot/util":"3HnHw","./hasher.js":"iqTSh","./recover.js":"eW5a8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iNBtl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isEthereumAddress", ()=>isEthereumAddress);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _isChecksumJs = require("./isChecksum.js");
function isEthereumAddress(address) {
    if (!address || address.length !== 42 || !(0, _util.isHex)(address)) return false;
    else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) return true;
    return (0, _isChecksumJs.isEthereumChecksum)(address);
}

},{"@polkadot/util":"3HnHw","./isChecksum.js":"jJwHG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jJwHG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isEthereumChecksum", ()=>isEthereumChecksum);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../keccak/index.js");
function isInvalidChar(char, byte) {
    return char !== (byte > 7 ? char.toUpperCase() : char.toLowerCase());
}
function isEthereumChecksum(_address) {
    const address = _address.replace("0x", "");
    const hash = (0, _util.u8aToHex)((0, _indexJs.keccakAsU8a)(address.toLowerCase()), -1, false);
    for(let i = 0; i < 40; i++){
        if (isInvalidChar(address[i], parseInt(hash[i], 16))) return false;
    }
    return true;
}

},{"@polkadot/util":"3HnHw","../keccak/index.js":"6zB64","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"51OaL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "hdEthereum", ()=>(0, _indexJs.hdEthereum));
parcelHelpers.export(exports, "hdLedger", ()=>(0, _indexJs1.hdLedger));
parcelHelpers.export(exports, "hdValidatePath", ()=>(0, _validatePathJs.hdValidatePath));
var _indexJs = require("./ethereum/index.js");
var _indexJs1 = require("./ledger/index.js");
var _validatePathJs = require("./validatePath.js");

},{"./ethereum/index.js":"kb5h6","./ledger/index.js":"4ogUS","./validatePath.js":"a1FHm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kb5h6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hdEthereum", ()=>hdEthereum);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _bnJs = require("../../bn.js");
var _indexJs = require("../../hmac/index.js");
var _indexJs1 = require("../../secp256k1/index.js");
var _validatePathJs = require("../validatePath.js");
const MASTER_SECRET = (0, _util.stringToU8a)("Bitcoin seed");
function createCoded(secretKey, chainCode) {
    return {
        chainCode,
        publicKey: (0, _indexJs1.secp256k1PairFromSeed)(secretKey).publicKey,
        secretKey
    };
}
function deriveChild(hd, index) {
    const indexBuffer = (0, _util.bnToU8a)(index, (0, _bnJs.BN_BE_32_OPTS));
    const data = index >= (0, _validatePathJs.HARDENED) ? (0, _util.u8aConcat)(new Uint8Array(1), hd.secretKey, indexBuffer) : (0, _util.u8aConcat)(hd.publicKey, indexBuffer);
    try {
        const I = (0, _indexJs.hmacShaAsU8a)(hd.chainCode, data, 512);
        return createCoded((0, _indexJs1.secp256k1PrivateKeyTweakAdd)(hd.secretKey, I.slice(0, 32)), I.slice(32));
    } catch (err) {
        // In case parse256(IL) >= n or ki == 0, proceed with the next value for i
        return deriveChild(hd, index + 1);
    }
}
function hdEthereum(seed, path = "") {
    const I = (0, _indexJs.hmacShaAsU8a)(MASTER_SECRET, seed, 512);
    let hd = createCoded(I.slice(0, 32), I.slice(32));
    if (!path || path === "m" || path === "M" || path === "m'" || path === "M'") return hd;
    if (!(0, _validatePathJs.hdValidatePath)(path)) throw new Error("Invalid derivation path");
    const parts = path.split("/").slice(1);
    for (const p of parts)hd = deriveChild(hd, parseInt(p, 10) + (p.length > 1 && p.endsWith("'") ? (0, _validatePathJs.HARDENED) : 0));
    return hd;
}

},{"@polkadot/util":"3HnHw","../../bn.js":"h6UHx","../../hmac/index.js":"6zSTS","../../secp256k1/index.js":"iZGLu","../validatePath.js":"a1FHm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a1FHm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HARDENED", ()=>HARDENED);
parcelHelpers.export(exports, "hdValidatePath", ()=>hdValidatePath);
const HARDENED = 0x80000000;
function hdValidatePath(path) {
    if (!path.startsWith("m/")) return false;
    const parts = path.split("/").slice(1);
    for (const p of parts){
        const n = /^\d+'?$/.test(p) ? parseInt(p.replace(/'$/, ""), 10) : Number.NaN;
        if (isNaN(n) || n >= HARDENED || n < 0) return false;
    }
    return true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ogUS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hdLedger", ()=>hdLedger);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../../ed25519/index.js");
var _indexJs1 = require("../../mnemonic/index.js");
var _validatePathJs = require("../validatePath.js");
var _derivePrivateJs = require("./derivePrivate.js");
var _masterJs = require("./master.js");
function hdLedger(_mnemonic, path) {
    const words = _mnemonic.split(" ").map((s)=>s.trim()).filter((s)=>s);
    if (![
        12,
        24,
        25
    ].includes(words.length)) throw new Error("Expected a mnemonic with 24 words (or 25 including a password)");
    const [mnemonic, password] = words.length === 25 ? [
        words.slice(0, 24).join(" "),
        words[24]
    ] : [
        words.join(" "),
        ""
    ];
    if (!(0, _indexJs1.mnemonicValidate)(mnemonic)) throw new Error("Invalid mnemonic passed to ledger derivation");
    else if (!(0, _validatePathJs.hdValidatePath)(path)) throw new Error("Invalid derivation path");
    const parts = path.split("/").slice(1);
    let seed = (0, _masterJs.ledgerMaster)(mnemonic, password);
    for (const p of parts){
        const n = parseInt(p.replace(/'$/, ""), 10);
        seed = (0, _derivePrivateJs.ledgerDerivePrivate)(seed, n < (0, _validatePathJs.HARDENED) ? n + (0, _validatePathJs.HARDENED) : n);
    }
    return (0, _indexJs.ed25519PairFromSeed)(seed.slice(0, 32));
}

},{"../../ed25519/index.js":"k5xh0","../../mnemonic/index.js":"7079C","../validatePath.js":"a1FHm","./derivePrivate.js":"gZRYm","./master.js":"5ihzZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7079C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Create valid mnemonic strings, validate them using BIP39, and convert them to valid seeds
 */ parcelHelpers.export(exports, "mnemonicGenerate", ()=>(0, _generateJs.mnemonicGenerate));
parcelHelpers.export(exports, "mnemonicToEntropy", ()=>(0, _toEntropyJs.mnemonicToEntropy));
parcelHelpers.export(exports, "mnemonicToLegacySeed", ()=>(0, _toLegacySeedJs.mnemonicToLegacySeed));
parcelHelpers.export(exports, "mnemonicToMiniSecret", ()=>(0, _toMiniSecretJs.mnemonicToMiniSecret));
parcelHelpers.export(exports, "mnemonicValidate", ()=>(0, _validateJs.mnemonicValidate));
var _generateJs = require("./generate.js");
var _toEntropyJs = require("./toEntropy.js");
var _toLegacySeedJs = require("./toLegacySeed.js");
var _toMiniSecretJs = require("./toMiniSecret.js");
var _validateJs = require("./validate.js");

},{"./generate.js":"5pRww","./toEntropy.js":"j7hqA","./toLegacySeed.js":"5sIIx","./toMiniSecret.js":"kGixy","./validate.js":"fXiLr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5pRww":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name mnemonicGenerate
 * @summary Creates a valid mnemonic string using using [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).
 * @example
 * <BR>
 *
 * ```javascript
 * import { mnemonicGenerate } from '@polkadot/util-crypto';
 *
 * const mnemonic = mnemonicGenerate(); // => string
 * ```
 */ parcelHelpers.export(exports, "mnemonicGenerate", ()=>mnemonicGenerate);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _bip39Js = require("./bip39.js");
function mnemonicGenerate(numWords = 12, onlyJs) {
    return !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.bip39Generate)(numWords) : (0, _bip39Js.generateMnemonic)(numWords);
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","./bip39.js":"4hvu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4hvu7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mnemonicToSeedSync", ()=>mnemonicToSeedSync);
parcelHelpers.export(exports, "mnemonicToEntropy", ()=>mnemonicToEntropy);
parcelHelpers.export(exports, "entropyToMnemonic", ()=>entropyToMnemonic);
parcelHelpers.export(exports, "generateMnemonic", ()=>generateMnemonic);
parcelHelpers.export(exports, "validateMnemonic", ()=>validateMnemonic);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Adapted from the bitcoinjs/bip39 source
// https://github.com/bitcoinjs/bip39/blob/1d063b6a6aee4145b34d701037cd3e67f5446ff9/ts_src/index.ts
// Copyright (c) 2014, Wei Lu <luwei.here@gmail.com> and Daniel Cousens <email@dcousens.com>
// ISC Licence
//
// Change made in this version -
//   - Adjust formatting (just eslint differences)
//   - Only English wordlist (this aligns with the wasm-crypto implementation)
//   - Use util-crypto randomAsU8a (instead of randombytes)
//   - Remove setting of wordlist passing of wordlist in functions
//   - Remove mnemonicToSeed (we only use the sync variant)
//   - generateMnemonic takes number of words (instead of strength)
var _util = require("@polkadot/util");
var _indexJs = require("../pbkdf2/index.js");
var _indexJs1 = require("../random/index.js");
var _indexJs2 = require("../sha/index.js");
var _bip39EnJs = require("./bip39-en.js");
var _bip39EnJsDefault = parcelHelpers.interopDefault(_bip39EnJs);
const INVALID_MNEMONIC = "Invalid mnemonic";
const INVALID_ENTROPY = "Invalid entropy";
const INVALID_CHECKSUM = "Invalid mnemonic checksum";
function normalize(str) {
    return (str || "").normalize("NFKD");
}
function binaryToByte(bin) {
    return parseInt(bin, 2);
}
function bytesToBinary(bytes) {
    return bytes.map((x)=>x.toString(2).padStart(8, "0")).join("");
}
function deriveChecksumBits(entropyBuffer) {
    return bytesToBinary(Array.from((0, _indexJs2.sha256AsU8a)(entropyBuffer))).slice(0, entropyBuffer.length * 8 / 32);
}
function mnemonicToSeedSync(mnemonic, password) {
    return (0, _indexJs.pbkdf2Encode)((0, _util.stringToU8a)(normalize(mnemonic)), (0, _util.stringToU8a)(`mnemonic${normalize(password)}`)).password;
}
function mnemonicToEntropy(mnemonic) {
    const words = normalize(mnemonic).split(" ");
    if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC);
     // convert word indices to 11 bit binary strings
    const bits = words.map((word)=>{
        const index = (0, _bip39EnJsDefault.default).indexOf(word);
        if (index === -1) throw new Error(INVALID_MNEMONIC);
        return index.toString(2).padStart(11, "0");
    }).join(""); // split the binary string into ENT/CS
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare
    const matched = entropyBits.match(/(.{1,8})/g);
    const entropyBytes = matched && matched.map(binaryToByte);
    if (!entropyBytes || entropyBytes.length % 4 !== 0 || entropyBytes.length < 16 || entropyBytes.length > 32) throw new Error(INVALID_ENTROPY);
    const entropy = (0, _util.u8aToU8a)(entropyBytes);
    if (deriveChecksumBits(entropy) !== checksumBits) throw new Error(INVALID_CHECKSUM);
    return entropy;
}
function entropyToMnemonic(entropy) {
    // 128 <= ENT <= 256
    if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) throw new Error(INVALID_ENTROPY);
    const matched = `${bytesToBinary(Array.from(entropy))}${deriveChecksumBits(entropy)}`.match(/(.{1,11})/g);
    const mapped = matched && matched.map((binary)=>(0, _bip39EnJsDefault.default)[binaryToByte(binary)]);
    if (!mapped || mapped.length < 12) throw new Error("Unable to map entropy to mnemonic");
    return mapped.join(" ");
}
function generateMnemonic(numWords) {
    return entropyToMnemonic((0, _indexJs1.randomAsU8a)(numWords / 3 * 4));
}
function validateMnemonic(mnemonic) {
    try {
        mnemonicToEntropy(mnemonic);
    } catch (e) {
        return false;
    }
    return true;
}

},{"@polkadot/util":"3HnHw","../pbkdf2/index.js":"7ynC4","../random/index.js":"63e69","../sha/index.js":"erzH4","./bip39-en.js":"OWSRa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7ynC4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "pbkdf2Encode", ()=>(0, _encodeJs.pbkdf2Encode));
var _encodeJs = require("./encode.js");

},{"./encode.js":"1ixaQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1ixaQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pbkdf2Encode", ()=>pbkdf2Encode);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _pbkdf2 = require("@noble/hashes/pbkdf2");
var _sha512 = require("@noble/hashes/sha512");
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _asU8AJs = require("../random/asU8a.js");
function pbkdf2Encode(passphrase, salt = (0, _asU8AJs.randomAsU8a)(), rounds = 2048, onlyJs) {
    const u8aPass = (0, _util.u8aToU8a)(passphrase);
    const u8aSalt = (0, _util.u8aToU8a)(salt);
    return {
        password: !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.pbkdf2)(u8aPass, u8aSalt, rounds) : (0, _pbkdf2.pbkdf2)((0, _sha512.sha512), u8aPass, u8aSalt, {
            c: rounds,
            dkLen: 64
        }),
        rounds,
        salt
    };
}

},{"@noble/hashes/pbkdf2":"c4hz5","@noble/hashes/sha512":"jlH7E","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","../random/asU8a.js":"jPZeF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c4hz5":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pbkdf2Async = exports.pbkdf2 = void 0;
const _assert_js_1 = require("./_assert.js");
const hmac_js_1 = require("./hmac.js");
const utils_js_1 = require("./utils.js");
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    _assert_js_1.default.hash(hash);
    const opts = (0, utils_js_1.checkOpts)({
        dkLen: 32,
        asyncTick: 10
    }, _opts);
    const { c , dkLen , asyncTick  } = opts;
    _assert_js_1.default.number(c);
    _assert_js_1.default.number(dkLen);
    _assert_js_1.default.number(asyncTick);
    if (c < 1) throw new Error("PBKDF2: iterations (c) should be >= 1");
    const password = (0, utils_js_1.toBytes)(_password);
    const salt = (0, utils_js_1.toBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_js_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return {
        c,
        dkLen,
        asyncTick,
        DK,
        PRF,
        PRFSalt
    };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW) prfW.destroy();
    u.fill(0);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */ function pbkdf2(hash, password, salt, opts) {
    const { c , dkLen , DK , PRF , PRFSalt  } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ‚ãØ + Tdklen/hlen
    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ‚ãØ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for(let ui = 1; ui < c; ui++){
            // Uc = PRF(Password, Uc‚àí1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2 = pbkdf2;
async function pbkdf2Async(hash, password, salt, opts) {
    const { c , dkLen , asyncTick , DK , PRF , PRFSalt  } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ‚ãØ + Tdklen/hlen
    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ‚ãØ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, (i)=>{
            // Uc = PRF(Password, Uc‚àí1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for(let i1 = 0; i1 < Ti.length; i1++)Ti[i1] ^= u[i1];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2Async = pbkdf2Async;

},{"./_assert.js":"BFdql","./hmac.js":"3IfCc","./utils.js":"2ehgp"}],"erzH4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Implements Sha-256/512 hashing functions for a variety of input and outputs
 */ parcelHelpers.export(exports, "shaAsU8a", ()=>(0, _asU8AJs.shaAsU8a));
parcelHelpers.export(exports, "sha256AsU8a", ()=>(0, _asU8AJs.sha256AsU8a));
parcelHelpers.export(exports, "sha512AsU8a", ()=>(0, _asU8AJs.sha512AsU8a));
var _asU8AJs = require("./asU8a.js");

},{"./asU8a.js":"hGvn3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hGvn3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shaAsU8a", ()=>shaAsU8a);
parcelHelpers.export(exports, "sha256AsU8a", ()=>sha256AsU8a);
parcelHelpers.export(exports, "sha512AsU8a", ()=>sha512AsU8a);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _sha256 = require("@noble/hashes/sha256");
var _sha512 = require("@noble/hashes/sha512");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _helpersJs = require("../helpers.js");
const shaAsU8a = (0, _helpersJs.createDualHasher)({
    256: (0, _wasmCrypto.sha256),
    512: (0, _wasmCrypto.sha512)
}, {
    256: (0, _sha256.sha256),
    512: (0, _sha512.sha512)
});
const sha256AsU8a = (0, _helpersJs.createBitHasher)(256, shaAsU8a);
const sha512AsU8a = (0, _helpersJs.createBitHasher)(512, shaAsU8a);

},{"@noble/hashes/sha256":"JjjO8","@noble/hashes/sha512":"jlH7E","@polkadot/wasm-crypto":"19VJZ","../helpers.js":"by01j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"OWSRa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Adapted from the bitcoinjs/bip39 source
// https://github.com/bitcoinjs/bip39/blob/1d063b6a6aee4145b34d701037cd3e67f5446ff9/ts_src/
exports.default = "abandon|ability|able|about|above|absent|absorb|abstract|absurd|abuse|access|accident|account|accuse|achieve|acid|acoustic|acquire|across|act|action|actor|actress|actual|adapt|add|addict|address|adjust|admit|adult|advance|advice|aerobic|affair|afford|afraid|again|age|agent|agree|ahead|aim|air|airport|aisle|alarm|album|alcohol|alert|alien|all|alley|allow|almost|alone|alpha|already|also|alter|always|amateur|amazing|among|amount|amused|analyst|anchor|ancient|anger|angle|angry|animal|ankle|announce|annual|another|answer|antenna|antique|anxiety|any|apart|apology|appear|apple|approve|april|arch|arctic|area|arena|argue|arm|armed|armor|army|around|arrange|arrest|arrive|arrow|art|artefact|artist|artwork|ask|aspect|assault|asset|assist|assume|asthma|athlete|atom|attack|attend|attitude|attract|auction|audit|august|aunt|author|auto|autumn|average|avocado|avoid|awake|aware|away|awesome|awful|awkward|axis|baby|bachelor|bacon|badge|bag|balance|balcony|ball|bamboo|banana|banner|bar|barely|bargain|barrel|base|basic|basket|battle|beach|bean|beauty|because|become|beef|before|begin|behave|behind|believe|below|belt|bench|benefit|best|betray|better|between|beyond|bicycle|bid|bike|bind|biology|bird|birth|bitter|black|blade|blame|blanket|blast|bleak|bless|blind|blood|blossom|blouse|blue|blur|blush|board|boat|body|boil|bomb|bone|bonus|book|boost|border|boring|borrow|boss|bottom|bounce|box|boy|bracket|brain|brand|brass|brave|bread|breeze|brick|bridge|brief|bright|bring|brisk|broccoli|broken|bronze|broom|brother|brown|brush|bubble|buddy|budget|buffalo|build|bulb|bulk|bullet|bundle|bunker|burden|burger|burst|bus|business|busy|butter|buyer|buzz|cabbage|cabin|cable|cactus|cage|cake|call|calm|camera|camp|can|canal|cancel|candy|cannon|canoe|canvas|canyon|capable|capital|captain|car|carbon|card|cargo|carpet|carry|cart|case|cash|casino|castle|casual|cat|catalog|catch|category|cattle|caught|cause|caution|cave|ceiling|celery|cement|census|century|cereal|certain|chair|chalk|champion|change|chaos|chapter|charge|chase|chat|cheap|check|cheese|chef|cherry|chest|chicken|chief|child|chimney|choice|choose|chronic|chuckle|chunk|churn|cigar|cinnamon|circle|citizen|city|civil|claim|clap|clarify|claw|clay|clean|clerk|clever|click|client|cliff|climb|clinic|clip|clock|clog|close|cloth|cloud|clown|club|clump|cluster|clutch|coach|coast|coconut|code|coffee|coil|coin|collect|color|column|combine|come|comfort|comic|common|company|concert|conduct|confirm|congress|connect|consider|control|convince|cook|cool|copper|copy|coral|core|corn|correct|cost|cotton|couch|country|couple|course|cousin|cover|coyote|crack|cradle|craft|cram|crane|crash|crater|crawl|crazy|cream|credit|creek|crew|cricket|crime|crisp|critic|crop|cross|crouch|crowd|crucial|cruel|cruise|crumble|crunch|crush|cry|crystal|cube|culture|cup|cupboard|curious|current|curtain|curve|cushion|custom|cute|cycle|dad|damage|damp|dance|danger|daring|dash|daughter|dawn|day|deal|debate|debris|decade|december|decide|decline|decorate|decrease|deer|defense|define|defy|degree|delay|deliver|demand|demise|denial|dentist|deny|depart|depend|deposit|depth|deputy|derive|describe|desert|design|desk|despair|destroy|detail|detect|develop|device|devote|diagram|dial|diamond|diary|dice|diesel|diet|differ|digital|dignity|dilemma|dinner|dinosaur|direct|dirt|disagree|discover|disease|dish|dismiss|disorder|display|distance|divert|divide|divorce|dizzy|doctor|document|dog|doll|dolphin|domain|donate|donkey|donor|door|dose|double|dove|draft|dragon|drama|drastic|draw|dream|dress|drift|drill|drink|drip|drive|drop|drum|dry|duck|dumb|dune|during|dust|dutch|duty|dwarf|dynamic|eager|eagle|early|earn|earth|easily|east|easy|echo|ecology|economy|edge|edit|educate|effort|egg|eight|either|elbow|elder|electric|elegant|element|elephant|elevator|elite|else|embark|embody|embrace|emerge|emotion|employ|empower|empty|enable|enact|end|endless|endorse|enemy|energy|enforce|engage|engine|enhance|enjoy|enlist|enough|enrich|enroll|ensure|enter|entire|entry|envelope|episode|equal|equip|era|erase|erode|erosion|error|erupt|escape|essay|essence|estate|eternal|ethics|evidence|evil|evoke|evolve|exact|example|excess|exchange|excite|exclude|excuse|execute|exercise|exhaust|exhibit|exile|exist|exit|exotic|expand|expect|expire|explain|expose|express|extend|extra|eye|eyebrow|fabric|face|faculty|fade|faint|faith|fall|false|fame|family|famous|fan|fancy|fantasy|farm|fashion|fat|fatal|father|fatigue|fault|favorite|feature|february|federal|fee|feed|feel|female|fence|festival|fetch|fever|few|fiber|fiction|field|figure|file|film|filter|final|find|fine|finger|finish|fire|firm|first|fiscal|fish|fit|fitness|fix|flag|flame|flash|flat|flavor|flee|flight|flip|float|flock|floor|flower|fluid|flush|fly|foam|focus|fog|foil|fold|follow|food|foot|force|forest|forget|fork|fortune|forum|forward|fossil|foster|found|fox|fragile|frame|frequent|fresh|friend|fringe|frog|front|frost|frown|frozen|fruit|fuel|fun|funny|furnace|fury|future|gadget|gain|galaxy|gallery|game|gap|garage|garbage|garden|garlic|garment|gas|gasp|gate|gather|gauge|gaze|general|genius|genre|gentle|genuine|gesture|ghost|giant|gift|giggle|ginger|giraffe|girl|give|glad|glance|glare|glass|glide|glimpse|globe|gloom|glory|glove|glow|glue|goat|goddess|gold|good|goose|gorilla|gospel|gossip|govern|gown|grab|grace|grain|grant|grape|grass|gravity|great|green|grid|grief|grit|grocery|group|grow|grunt|guard|guess|guide|guilt|guitar|gun|gym|habit|hair|half|hammer|hamster|hand|happy|harbor|hard|harsh|harvest|hat|have|hawk|hazard|head|health|heart|heavy|hedgehog|height|hello|helmet|help|hen|hero|hidden|high|hill|hint|hip|hire|history|hobby|hockey|hold|hole|holiday|hollow|home|honey|hood|hope|horn|horror|horse|hospital|host|hotel|hour|hover|hub|huge|human|humble|humor|hundred|hungry|hunt|hurdle|hurry|hurt|husband|hybrid|ice|icon|idea|identify|idle|ignore|ill|illegal|illness|image|imitate|immense|immune|impact|impose|improve|impulse|inch|include|income|increase|index|indicate|indoor|industry|infant|inflict|inform|inhale|inherit|initial|inject|injury|inmate|inner|innocent|input|inquiry|insane|insect|inside|inspire|install|intact|interest|into|invest|invite|involve|iron|island|isolate|issue|item|ivory|jacket|jaguar|jar|jazz|jealous|jeans|jelly|jewel|job|join|joke|journey|joy|judge|juice|jump|jungle|junior|junk|just|kangaroo|keen|keep|ketchup|key|kick|kid|kidney|kind|kingdom|kiss|kit|kitchen|kite|kitten|kiwi|knee|knife|knock|know|lab|label|labor|ladder|lady|lake|lamp|language|laptop|large|later|latin|laugh|laundry|lava|law|lawn|lawsuit|layer|lazy|leader|leaf|learn|leave|lecture|left|leg|legal|legend|leisure|lemon|lend|length|lens|leopard|lesson|letter|level|liar|liberty|library|license|life|lift|light|like|limb|limit|link|lion|liquid|list|little|live|lizard|load|loan|lobster|local|lock|logic|lonely|long|loop|lottery|loud|lounge|love|loyal|lucky|luggage|lumber|lunar|lunch|luxury|lyrics|machine|mad|magic|magnet|maid|mail|main|major|make|mammal|man|manage|mandate|mango|mansion|manual|maple|marble|march|margin|marine|market|marriage|mask|mass|master|match|material|math|matrix|matter|maximum|maze|meadow|mean|measure|meat|mechanic|medal|media|melody|melt|member|memory|mention|menu|mercy|merge|merit|merry|mesh|message|metal|method|middle|midnight|milk|million|mimic|mind|minimum|minor|minute|miracle|mirror|misery|miss|mistake|mix|mixed|mixture|mobile|model|modify|mom|moment|monitor|monkey|monster|month|moon|moral|more|morning|mosquito|mother|motion|motor|mountain|mouse|move|movie|much|muffin|mule|multiply|muscle|museum|mushroom|music|must|mutual|myself|mystery|myth|naive|name|napkin|narrow|nasty|nation|nature|near|neck|need|negative|neglect|neither|nephew|nerve|nest|net|network|neutral|never|news|next|nice|night|noble|noise|nominee|noodle|normal|north|nose|notable|note|nothing|notice|novel|now|nuclear|number|nurse|nut|oak|obey|object|oblige|obscure|observe|obtain|obvious|occur|ocean|october|odor|off|offer|office|often|oil|okay|old|olive|olympic|omit|once|one|onion|online|only|open|opera|opinion|oppose|option|orange|orbit|orchard|order|ordinary|organ|orient|original|orphan|ostrich|other|outdoor|outer|output|outside|oval|oven|over|own|owner|oxygen|oyster|ozone|pact|paddle|page|pair|palace|palm|panda|panel|panic|panther|paper|parade|parent|park|parrot|party|pass|patch|path|patient|patrol|pattern|pause|pave|payment|peace|peanut|pear|peasant|pelican|pen|penalty|pencil|people|pepper|perfect|permit|person|pet|phone|photo|phrase|physical|piano|picnic|picture|piece|pig|pigeon|pill|pilot|pink|pioneer|pipe|pistol|pitch|pizza|place|planet|plastic|plate|play|please|pledge|pluck|plug|plunge|poem|poet|point|polar|pole|police|pond|pony|pool|popular|portion|position|possible|post|potato|pottery|poverty|powder|power|practice|praise|predict|prefer|prepare|present|pretty|prevent|price|pride|primary|print|priority|prison|private|prize|problem|process|produce|profit|program|project|promote|proof|property|prosper|protect|proud|provide|public|pudding|pull|pulp|pulse|pumpkin|punch|pupil|puppy|purchase|purity|purpose|purse|push|put|puzzle|pyramid|quality|quantum|quarter|question|quick|quit|quiz|quote|rabbit|raccoon|race|rack|radar|radio|rail|rain|raise|rally|ramp|ranch|random|range|rapid|rare|rate|rather|raven|raw|razor|ready|real|reason|rebel|rebuild|recall|receive|recipe|record|recycle|reduce|reflect|reform|refuse|region|regret|regular|reject|relax|release|relief|rely|remain|remember|remind|remove|render|renew|rent|reopen|repair|repeat|replace|report|require|rescue|resemble|resist|resource|response|result|retire|retreat|return|reunion|reveal|review|reward|rhythm|rib|ribbon|rice|rich|ride|ridge|rifle|right|rigid|ring|riot|ripple|risk|ritual|rival|river|road|roast|robot|robust|rocket|romance|roof|rookie|room|rose|rotate|rough|round|route|royal|rubber|rude|rug|rule|run|runway|rural|sad|saddle|sadness|safe|sail|salad|salmon|salon|salt|salute|same|sample|sand|satisfy|satoshi|sauce|sausage|save|say|scale|scan|scare|scatter|scene|scheme|school|science|scissors|scorpion|scout|scrap|screen|script|scrub|sea|search|season|seat|second|secret|section|security|seed|seek|segment|select|sell|seminar|senior|sense|sentence|series|service|session|settle|setup|seven|shadow|shaft|shallow|share|shed|shell|sheriff|shield|shift|shine|ship|shiver|shock|shoe|shoot|shop|short|shoulder|shove|shrimp|shrug|shuffle|shy|sibling|sick|side|siege|sight|sign|silent|silk|silly|silver|similar|simple|since|sing|siren|sister|situate|six|size|skate|sketch|ski|skill|skin|skirt|skull|slab|slam|sleep|slender|slice|slide|slight|slim|slogan|slot|slow|slush|small|smart|smile|smoke|smooth|snack|snake|snap|sniff|snow|soap|soccer|social|sock|soda|soft|solar|soldier|solid|solution|solve|someone|song|soon|sorry|sort|soul|sound|soup|source|south|space|spare|spatial|spawn|speak|special|speed|spell|spend|sphere|spice|spider|spike|spin|spirit|split|spoil|sponsor|spoon|sport|spot|spray|spread|spring|spy|square|squeeze|squirrel|stable|stadium|staff|stage|stairs|stamp|stand|start|state|stay|steak|steel|stem|step|stereo|stick|still|sting|stock|stomach|stone|stool|story|stove|strategy|street|strike|strong|struggle|student|stuff|stumble|style|subject|submit|subway|success|such|sudden|suffer|sugar|suggest|suit|summer|sun|sunny|sunset|super|supply|supreme|sure|surface|surge|surprise|surround|survey|suspect|sustain|swallow|swamp|swap|swarm|swear|sweet|swift|swim|swing|switch|sword|symbol|symptom|syrup|system|table|tackle|tag|tail|talent|talk|tank|tape|target|task|taste|tattoo|taxi|teach|team|tell|ten|tenant|tennis|tent|term|test|text|thank|that|theme|then|theory|there|they|thing|this|thought|three|thrive|throw|thumb|thunder|ticket|tide|tiger|tilt|timber|time|tiny|tip|tired|tissue|title|toast|tobacco|today|toddler|toe|together|toilet|token|tomato|tomorrow|tone|tongue|tonight|tool|tooth|top|topic|topple|torch|tornado|tortoise|toss|total|tourist|toward|tower|town|toy|track|trade|traffic|tragic|train|transfer|trap|trash|travel|tray|treat|tree|trend|trial|tribe|trick|trigger|trim|trip|trophy|trouble|truck|true|truly|trumpet|trust|truth|try|tube|tuition|tumble|tuna|tunnel|turkey|turn|turtle|twelve|twenty|twice|twin|twist|two|type|typical|ugly|umbrella|unable|unaware|uncle|uncover|under|undo|unfair|unfold|unhappy|uniform|unique|unit|universe|unknown|unlock|until|unusual|unveil|update|upgrade|uphold|upon|upper|upset|urban|urge|usage|use|used|useful|useless|usual|utility|vacant|vacuum|vague|valid|valley|valve|van|vanish|vapor|various|vast|vault|vehicle|velvet|vendor|venture|venue|verb|verify|version|very|vessel|veteran|viable|vibrant|vicious|victory|video|view|village|vintage|violin|virtual|virus|visa|visit|visual|vital|vivid|vocal|voice|void|volcano|volume|vote|voyage|wage|wagon|wait|walk|wall|walnut|want|warfare|warm|warrior|wash|wasp|waste|water|wave|way|wealth|weapon|wear|weasel|weather|web|wedding|weekend|weird|welcome|west|wet|whale|what|wheat|wheel|when|where|whip|whisper|wide|width|wife|wild|will|win|window|wine|wing|wink|winner|winter|wire|wisdom|wise|wish|witness|wolf|woman|wonder|wood|wool|word|work|world|worry|worth|wrap|wreck|wrestle|wrist|write|wrong|yard|year|yellow|you|young|youth|zebra|zero|zone|zoo".split("|");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j7hqA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mnemonicToEntropy", ()=>mnemonicToEntropy);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _bip39Js = require("./bip39.js");
function mnemonicToEntropy(mnemonic, onlyJs) {
    return !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.bip39ToEntropy)(mnemonic) : (0, _bip39Js.mnemonicToEntropy)(mnemonic);
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","./bip39.js":"4hvu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5sIIx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name mnemonicToLegacySeed
 * @summary Creates a valid Ethereum/Bitcoin-compatible seed from a mnemonic input
 * @example
 * <BR>
 *
 * ```javascript
 * import { mnemonicGenerate, mnemonicToLegacySeed, mnemonicValidate } from '@polkadot/util-crypto';
 *
 * const mnemonic = mnemonicGenerate(); // => string
 * const isValidMnemonic = mnemonicValidate(mnemonic); // => boolean
 *
 * if (isValidMnemonic) {
 *   console.log(`Seed generated from mnemonic: ${mnemonicToLegacySeed(mnemonic)}`); => u8a
 * }
 * ```
 */ parcelHelpers.export(exports, "mnemonicToLegacySeed", ()=>mnemonicToLegacySeed);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _bip39Js = require("./bip39.js");
var _validateJs = require("./validate.js");
function mnemonicToLegacySeed(mnemonic, password = "", onlyJs, byteLength = 32) {
    if (!(0, _validateJs.mnemonicValidate)(mnemonic)) throw new Error("Invalid bip39 mnemonic specified");
    else if (![
        32,
        64
    ].includes(byteLength)) throw new Error(`Invalid seed length ${byteLength}, expected 32 or 64`);
    return byteLength === 32 ? !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.bip39ToSeed)(mnemonic, password) : (0, _bip39Js.mnemonicToSeedSync)(mnemonic, password).subarray(0, 32) : (0, _bip39Js.mnemonicToSeedSync)(mnemonic, password);
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","./bip39.js":"4hvu7","./validate.js":"fXiLr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fXiLr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name mnemonicValidate
 * @summary Validates a mnemonic input using [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).
 * @example
 * <BR>
 *
 * ```javascript
 * import { mnemonicGenerate, mnemonicValidate } from '@polkadot/util-crypto';
 *
 * const mnemonic = mnemonicGenerate(); // => string
 * const isValidMnemonic = mnemonicValidate(mnemonic); // => boolean
 * ```
 */ parcelHelpers.export(exports, "mnemonicValidate", ()=>mnemonicValidate);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _bip39Js = require("./bip39.js");
function mnemonicValidate(mnemonic, onlyJs) {
    return !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.bip39Validate)(mnemonic) : (0, _bip39Js.validateMnemonic)(mnemonic);
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","./bip39.js":"4hvu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kGixy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mnemonicToMiniSecret", ()=>mnemonicToMiniSecret);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _indexJs = require("../pbkdf2/index.js");
var _toEntropyJs = require("./toEntropy.js");
var _validateJs = require("./validate.js");
function mnemonicToMiniSecret(mnemonic, password = "", onlyJs) {
    if (!(0, _validateJs.mnemonicValidate)(mnemonic)) throw new Error("Invalid bip39 mnemonic specified");
    if (!onlyJs && (0, _wasmCrypto.isReady)()) return (0, _wasmCrypto.bip39ToMiniSecret)(mnemonic, password);
    const entropy = (0, _toEntropyJs.mnemonicToEntropy)(mnemonic);
    const salt = (0, _util.stringToU8a)(`mnemonic${password}`); // return the first 32 bytes as the seed
    return (0, _indexJs.pbkdf2Encode)(entropy, salt).password.slice(0, 32);
}

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","../pbkdf2/index.js":"7ynC4","./toEntropy.js":"j7hqA","./validate.js":"fXiLr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gZRYm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ledgerDerivePrivate", ()=>ledgerDerivePrivate);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _bnJs = require("../../bn.js");
var _indexJs = require("../../hmac/index.js"); // performs hard-only derivation on the xprv
function ledgerDerivePrivate(xprv, index) {
    const kl = xprv.subarray(0, 32);
    const kr = xprv.subarray(32, 64);
    const cc = xprv.subarray(64, 96);
    const data = (0, _util.u8aConcat)([
        0
    ], kl, kr, (0, _util.bnToU8a)(index, (0, _bnJs.BN_LE_32_OPTS)));
    const z = (0, _indexJs.hmacShaAsU8a)(cc, data, 512);
    data[0] = 0x01;
    return (0, _util.u8aConcat)((0, _util.bnToU8a)((0, _util.u8aToBn)(kl, (0, _bnJs.BN_LE_OPTS)).iadd((0, _util.u8aToBn)(z.subarray(0, 28), (0, _bnJs.BN_LE_OPTS)).imul((0, _util.BN_EIGHT))), (0, _bnJs.BN_LE_512_OPTS)).subarray(0, 32), (0, _util.bnToU8a)((0, _util.u8aToBn)(kr, (0, _bnJs.BN_LE_OPTS)).iadd((0, _util.u8aToBn)(z.subarray(32, 64), (0, _bnJs.BN_LE_OPTS))), (0, _bnJs.BN_LE_512_OPTS)).subarray(0, 32), (0, _indexJs.hmacShaAsU8a)(cc, data, 512).subarray(32, 64));
}

},{"@polkadot/util":"3HnHw","../../bn.js":"h6UHx","../../hmac/index.js":"6zSTS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5ihzZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ledgerMaster", ()=>ledgerMaster);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../../hmac/index.js");
var _bip39Js = require("../../mnemonic/bip39.js");
const ED25519_CRYPTO = "ed25519 seed"; // gets an xprv from a mnemonic
function ledgerMaster(mnemonic, password) {
    const seed = (0, _bip39Js.mnemonicToSeedSync)(mnemonic, password);
    const chainCode = (0, _indexJs.hmacShaAsU8a)(ED25519_CRYPTO, new Uint8Array([
        1,
        ...seed
    ]), 256);
    let priv;
    while(!priv || priv[31] & 32)priv = (0, _indexJs.hmacShaAsU8a)(ED25519_CRYPTO, priv || seed, 512);
    priv[0] &= 248;
    priv[31] &= 127;
    priv[31] |= 64;
    return (0, _util.u8aConcat)(priv, chainCode);
}

},{"@polkadot/util":"3HnHw","../../hmac/index.js":"6zSTS","../../mnemonic/bip39.js":"4hvu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8mFM3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "jsonDecrypt", ()=>(0, _decryptJs.jsonDecrypt));
parcelHelpers.export(exports, "jsonDecryptData", ()=>(0, _decryptDataJs.jsonDecryptData));
parcelHelpers.export(exports, "jsonEncrypt", ()=>(0, _encryptJs.jsonEncrypt));
parcelHelpers.export(exports, "jsonEncryptFormat", ()=>(0, _encryptFormatJs.jsonEncryptFormat));
var _decryptJs = require("./decrypt.js");
var _decryptDataJs = require("./decryptData.js");
var _encryptJs = require("./encrypt.js");
var _encryptFormatJs = require("./encryptFormat.js");

},{"./decrypt.js":"9yOe7","./decryptData.js":"hpjWK","./encrypt.js":"7bUzG","./encryptFormat.js":"2fEiZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9yOe7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jsonDecrypt", ()=>jsonDecrypt);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../base64/index.js");
var _decryptDataJs = require("./decryptData.js");
function jsonDecrypt({ encoded , encoding  }, passphrase) {
    if (!encoded) throw new Error("No encrypted data available to decode");
    return (0, _decryptDataJs.jsonDecryptData)((0, _util.isHex)(encoded) ? (0, _util.hexToU8a)(encoded) : (0, _indexJs.base64Decode)(encoded), passphrase, Array.isArray(encoding.type) ? encoding.type : [
        encoding.type
    ]);
}

},{"@polkadot/util":"3HnHw","../base64/index.js":"dCLyq","./decryptData.js":"hpjWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hpjWK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jsonDecryptData", ()=>jsonDecryptData);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../nacl/index.js");
var _indexJs1 = require("../scrypt/index.js");
var _constantsJs = require("./constants.js");
function jsonDecryptData(encrypted, passphrase, encType = (0, _constantsJs.ENCODING)) {
    if (!encrypted) throw new Error("No encrypted data available to decode");
    else if (encType.includes("xsalsa20-poly1305") && !passphrase) throw new Error("Password required to decode encrypted data");
    let encoded = encrypted;
    if (passphrase) {
        let password;
        if (encType.includes("scrypt")) {
            const { params , salt  } = (0, _indexJs1.scryptFromU8a)(encrypted);
            password = (0, _indexJs1.scryptEncode)(passphrase, salt, params).password;
            encrypted = encrypted.subarray((0, _constantsJs.SCRYPT_LENGTH));
        } else password = (0, _util.stringToU8a)(passphrase);
        encoded = (0, _indexJs.naclDecrypt)(encrypted.subarray((0, _constantsJs.NONCE_LENGTH)), encrypted.subarray(0, (0, _constantsJs.NONCE_LENGTH)), (0, _util.u8aFixLength)(password, 256, true));
    }
    if (!encoded) throw new Error("Unable to decode using the supplied passphrase");
    return encoded;
}

},{"@polkadot/util":"3HnHw","../nacl/index.js":"cX2uo","../scrypt/index.js":"lhRfY","./constants.js":"89SR2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cX2uo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Implements [NaCl](http://nacl.cr.yp.to/) secret-key authenticated encryption, public-key authenticated encryption
 */ parcelHelpers.export(exports, "naclDecrypt", ()=>(0, _decryptJs.naclDecrypt));
parcelHelpers.export(exports, "naclEncrypt", ()=>(0, _encryptJs.naclEncrypt));
parcelHelpers.export(exports, "naclBoxPairFromSecret", ()=>(0, _fromSecretJs.naclBoxPairFromSecret));
parcelHelpers.export(exports, "naclOpen", ()=>(0, _openJs.naclOpen));
parcelHelpers.export(exports, "naclSeal", ()=>(0, _sealJs.naclSeal));
var _decryptJs = require("./decrypt.js");
var _encryptJs = require("./encrypt.js");
var _fromSecretJs = require("./box/fromSecret.js");
var _openJs = require("./open.js");
var _sealJs = require("./seal.js");

},{"./decrypt.js":"fCEf9","./encrypt.js":"acK8O","./box/fromSecret.js":"3ZsKB","./open.js":"6oEDK","./seal.js":"igz33","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCEf9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name naclDecrypt
 * @summary Decrypts a message using the supplied secretKey and nonce
 * @description
 * Returns an decrypted message, using the `secret` and `nonce`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { naclDecrypt } from '@polkadot/util-crypto';
 *
 * naclDecrypt([...], [...], [...]); // => [...]
 * ```
 */ parcelHelpers.export(exports, "naclDecrypt", ()=>naclDecrypt);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _tweetnacl = require("tweetnacl");
var _tweetnaclDefault = parcelHelpers.interopDefault(_tweetnacl);
function naclDecrypt(encrypted, nonce, secret) {
    return (0, _tweetnaclDefault.default).secretbox.open(encrypted, nonce, secret) || null;
}

},{"tweetnacl":"3J9rh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"acK8O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name naclEncrypt
 * @summary Encrypts a message using the supplied secretKey and nonce
 * @description
 * Returns an encrypted message, using the `secretKey` and `nonce`. If the `nonce` was not supplied, a random value is generated.
 * @example
 * <BR>
 *
 * ```javascript
 * import { naclEncrypt } from '@polkadot/util-crypto';
 *
 * naclEncrypt([...], [...]); // => [...]
 * ```
 */ parcelHelpers.export(exports, "naclEncrypt", ()=>naclEncrypt);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _tweetnacl = require("tweetnacl");
var _tweetnaclDefault = parcelHelpers.interopDefault(_tweetnacl);
var _asU8AJs = require("../random/asU8a.js");
function naclEncrypt(message, secret, nonce = (0, _asU8AJs.randomAsU8a)(24)) {
    return {
        encrypted: (0, _tweetnaclDefault.default).secretbox(message, nonce, secret),
        nonce
    };
}

},{"tweetnacl":"3J9rh","../random/asU8a.js":"jPZeF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ZsKB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name naclBoxPairFromSecret
 * @summary Creates a new public/secret box keypair from a secret.
 * @description
 * Returns a object containing a box `publicKey` & `secretKey` generated from the supplied secret.
 * @example
 * <BR>
 *
 * ```javascript
 * import { naclBoxPairFromSecret } from '@polkadot/util-crypto';
 *
 * naclBoxPairFromSecret(...); // => { secretKey: [...], publicKey: [...] }
 * ```
 */ parcelHelpers.export(exports, "naclBoxPairFromSecret", ()=>naclBoxPairFromSecret);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _tweetnacl = require("tweetnacl");
var _tweetnaclDefault = parcelHelpers.interopDefault(_tweetnacl);
function naclBoxPairFromSecret(secret) {
    return (0, _tweetnaclDefault.default).box.keyPair.fromSecretKey(secret.slice(0, 32));
}

},{"tweetnacl":"3J9rh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6oEDK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name naclOpen
 * @summary Opens a message using the receiver's secretKey and nonce
 * @description
 * Returns a message sealed by the sender, using the receiver's `secret` and `nonce`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { naclOpen } from '@polkadot/util-crypto';
 *
 * naclOpen([...], [...], [...]); // => [...]
 * ```
 */ parcelHelpers.export(exports, "naclOpen", ()=>naclOpen);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _tweetnacl = require("tweetnacl");
var _tweetnaclDefault = parcelHelpers.interopDefault(_tweetnacl);
function naclOpen(sealed, nonce, senderBoxPublic, receiverBoxSecret) {
    return (0, _tweetnaclDefault.default).box.open(sealed, nonce, senderBoxPublic, receiverBoxSecret) || null;
}

},{"tweetnacl":"3J9rh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"igz33":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name naclSeal
 * @summary Seals a message using the sender's encrypting secretKey, receiver's public key, and nonce
 * @description
 * Returns an encrypted message which can be open only by receiver's secretKey. If the `nonce` was not supplied, a random value is generated.
 * @example
 * <BR>
 *
 * ```javascript
 * import { naclSeal } from '@polkadot/util-crypto';
 *
 * naclSeal([...], [...], [...], [...]); // => [...]
 * ```
 */ parcelHelpers.export(exports, "naclSeal", ()=>naclSeal);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _tweetnacl = require("tweetnacl");
var _tweetnaclDefault = parcelHelpers.interopDefault(_tweetnacl);
var _asU8AJs = require("../random/asU8a.js");
function naclSeal(message, senderBoxSecret, receiverBoxPublic, nonce = (0, _asU8AJs.randomAsU8a)(24)) {
    return {
        nonce,
        sealed: (0, _tweetnaclDefault.default).box(message, nonce, receiverBoxPublic, senderBoxSecret)
    };
}

},{"tweetnacl":"3J9rh","../random/asU8a.js":"jPZeF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lhRfY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "scryptEncode", ()=>(0, _encodeJs.scryptEncode));
parcelHelpers.export(exports, "scryptFromU8a", ()=>(0, _fromU8AJs.scryptFromU8a));
parcelHelpers.export(exports, "scryptToU8a", ()=>(0, _toU8AJs.scryptToU8a));
var _encodeJs = require("./encode.js");
var _fromU8AJs = require("./fromU8a.js");
var _toU8AJs = require("./toU8a.js");

},{"./encode.js":"jqxdk","./fromU8a.js":"9RZI4","./toU8a.js":"iuqOE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jqxdk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scryptEncode", ()=>scryptEncode);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _scrypt = require("@noble/hashes/scrypt");
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _asU8AJs = require("../random/asU8a.js");
var _defaultsJs = require("./defaults.js");
function scryptEncode(passphrase, salt = (0, _asU8AJs.randomAsU8a)(), params = (0, _defaultsJs.DEFAULT_PARAMS), onlyJs) {
    const u8a = (0, _util.u8aToU8a)(passphrase);
    return {
        params,
        password: !(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)() ? (0, _wasmCrypto.scrypt)(u8a, salt, Math.log2(params.N), params.r, params.p) : (0, _scrypt.scrypt)(u8a, salt, (0, _util.objectSpread)({
            dkLen: 64
        }, params)),
        salt
    };
}

},{"@noble/hashes/scrypt":"aamGB","@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","../random/asU8a.js":"jPZeF","./defaults.js":"2q5Gy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aamGB":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.scryptAsync = exports.scrypt = void 0;
const _assert_js_1 = require("./_assert.js");
const sha256_js_1 = require("./sha256.js");
const pbkdf2_js_1 = require("./pbkdf2.js");
const utils_js_1 = require("./utils.js");
// RFC 7914 Scrypt KDF
// Left rotate for uint32
const rotl = (a, b)=>a << b | a >>> 32 - b;
// The main Scrypt loop: uses Salsa extensively.
// Six versions of the function were tried, this is the fastest one.
// prettier-ignore
function XorAndSalsa(prev, pi, input, ii, out, oi) {
    // Based on https://cr.yp.to/salsa20.html
    // Xor blocks
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    // Save state to temporary variables (salsa)
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    // Main loop (salsa)
    for(let i = 0; i < 8; i += 2){
        x04 ^= rotl(x00 + x12 | 0, 7);
        x08 ^= rotl(x04 + x00 | 0, 9);
        x12 ^= rotl(x08 + x04 | 0, 13);
        x00 ^= rotl(x12 + x08 | 0, 18);
        x09 ^= rotl(x05 + x01 | 0, 7);
        x13 ^= rotl(x09 + x05 | 0, 9);
        x01 ^= rotl(x13 + x09 | 0, 13);
        x05 ^= rotl(x01 + x13 | 0, 18);
        x14 ^= rotl(x10 + x06 | 0, 7);
        x02 ^= rotl(x14 + x10 | 0, 9);
        x06 ^= rotl(x02 + x14 | 0, 13);
        x10 ^= rotl(x06 + x02 | 0, 18);
        x03 ^= rotl(x15 + x11 | 0, 7);
        x07 ^= rotl(x03 + x15 | 0, 9);
        x11 ^= rotl(x07 + x03 | 0, 13);
        x15 ^= rotl(x11 + x07 | 0, 18);
        x01 ^= rotl(x00 + x03 | 0, 7);
        x02 ^= rotl(x01 + x00 | 0, 9);
        x03 ^= rotl(x02 + x01 | 0, 13);
        x00 ^= rotl(x03 + x02 | 0, 18);
        x06 ^= rotl(x05 + x04 | 0, 7);
        x07 ^= rotl(x06 + x05 | 0, 9);
        x04 ^= rotl(x07 + x06 | 0, 13);
        x05 ^= rotl(x04 + x07 | 0, 18);
        x11 ^= rotl(x10 + x09 | 0, 7);
        x08 ^= rotl(x11 + x10 | 0, 9);
        x09 ^= rotl(x08 + x11 | 0, 13);
        x10 ^= rotl(x09 + x08 | 0, 18);
        x12 ^= rotl(x15 + x14 | 0, 7);
        x13 ^= rotl(x12 + x15 | 0, 9);
        x14 ^= rotl(x13 + x12 | 0, 13);
        x15 ^= rotl(x14 + x13 | 0, 18);
    }
    // Write output (salsa)
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)
    let head = oi + 0;
    let tail = oi + 16 * r;
    for(let i = 0; i < 16; i++)out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X ‚Üê B[2r‚àí1]
    for(let i1 = 0; i1 < r; i1++, head += 16, ii += 16){
        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1
        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])
        if (i1 > 0) tail += 16; // First iteration overwrites tmp value in tail
        XorAndSalsa(out, head, input, ii += 16, out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])
    }
}
// Common prologue and epilogue for sync/async functions
function scryptInit(password, salt, _opts) {
    // Maxmem - 1GB+1KB by default
    const opts = (0, utils_js_1.checkOpts)({
        dkLen: 32,
        asyncTick: 10,
        maxmem: 1024 ** 3 + 1024
    }, _opts);
    const { N , r , p , dkLen , asyncTick , maxmem , onProgress  } = opts;
    _assert_js_1.default.number(N);
    _assert_js_1.default.number(r);
    _assert_js_1.default.number(p);
    _assert_js_1.default.number(dkLen);
    _assert_js_1.default.number(asyncTick);
    _assert_js_1.default.number(maxmem);
    if (onProgress !== undefined && typeof onProgress !== "function") throw new Error("progressCb should be function");
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function
    // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
    if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem) throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
    // [B0...Bp‚àí1] ‚Üê PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)
    // Since it has only one iteration there is no reason to use async variant
    const B = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, salt, {
        c: 1,
        dkLen: blockSize * p
    });
    const B32 = (0, utils_js_1.u32)(B);
    // Re-used between parallel iterations. Array(iterations) of B
    const V = (0, utils_js_1.u32)(new Uint8Array(blockSize * N));
    const tmp = (0, utils_js_1.u32)(new Uint8Array(blockSize));
    let blockMixCb = ()=>{};
    if (onProgress) {
        const totalBlockMix = 2 * N * p;
        // Invoke callback if progress changes from 10.01 to 10.02
        // Allows to draw smooth progress bar on up to 8K screen
        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
        let blockMixCnt = 0;
        blockMixCb = ()=>{
            blockMixCnt++;
            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix)) onProgress(blockMixCnt / totalBlockMix);
        };
    }
    return {
        N,
        r,
        p,
        dkLen,
        blockSize32,
        V,
        B32,
        B,
        tmp,
        blockMixCb,
        asyncTick
    };
}
function scryptOutput(password, dkLen, B, V, tmp) {
    const res = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, B, {
        c: 1,
        dkLen
    });
    B.fill(0);
    V.fill(0);
    tmp.fill(0);
    return res;
}
/**
 * Scrypt KDF from RFC 7914.
 * @param password - pass
 * @param salt - salt
 * @param opts - parameters
 * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)
 * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance
 * - `p` is parallelization factor (1 is common)
 * - `dkLen` is output key length in bytes e.g. 32.
 * - `asyncTick` - (default: 10) max time in ms for which async function can block execution
 * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt
 * - `onProgress` - callback function that would be executed for progress report
 * @returns Derived key
 */ function scrypt(password, salt, opts) {
    const { N , r , p , dkLen , blockSize32 , V , B32 , B , tmp , blockMixCb  } = scryptInit(password, salt, opts);
    for(let pi = 0; pi < p; pi++){
        const Pi = blockSize32 * pi;
        for(let i = 0; i < blockSize32; i++)V[i] = B32[Pi + i]; // V[0] = B[i]
        for(let i1 = 0, pos = 0; i1 < N - 1; i1++){
            BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);
            blockMixCb();
        }
        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
        blockMixCb();
        for(let i2 = 0; i2 < N; i2++){
            // First u32 of the last 64-byte block (u32 is LE)
            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
            for(let k = 0; k < blockSize32; k++)tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
            blockMixCb();
        }
    }
    return scryptOutput(password, dkLen, B, V, tmp);
}
exports.scrypt = scrypt;
/**
 * Scrypt KDF from RFC 7914.
 */ async function scryptAsync(password, salt, opts) {
    const { N , r , p , dkLen , blockSize32 , V , B32 , B , tmp , blockMixCb , asyncTick  } = scryptInit(password, salt, opts);
    for(let pi = 0; pi < p; pi++){
        const Pi = blockSize32 * pi;
        for(let i = 0; i < blockSize32; i++)V[i] = B32[Pi + i]; // V[0] = B[i]
        let pos = 0;
        await (0, utils_js_1.asyncLoop)(N - 1, asyncTick, (i)=>{
            BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);
            blockMixCb();
        });
        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
        blockMixCb();
        await (0, utils_js_1.asyncLoop)(N, asyncTick, (i)=>{
            // First u32 of the last 64-byte block (u32 is LE)
            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
            for(let k = 0; k < blockSize32; k++)tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
            blockMixCb();
        });
    }
    return scryptOutput(password, dkLen, B, V, tmp);
}
exports.scryptAsync = scryptAsync;

},{"./_assert.js":"BFdql","./sha256.js":"JjjO8","./pbkdf2.js":"c4hz5","./utils.js":"2ehgp"}],"2q5Gy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_PARAMS", ()=>DEFAULT_PARAMS);
const DEFAULT_PARAMS = {
    N: 32768,
    p: 1,
    r: 8
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9RZI4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scryptFromU8a", ()=>scryptFromU8a);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _bnJs = require("../bn.js");
var _defaultsJs = require("./defaults.js");
function scryptFromU8a(data) {
    const salt = data.subarray(0, 32);
    const N = (0, _util.u8aToBn)(data.subarray(32, 36), (0, _bnJs.BN_LE_OPTS)).toNumber();
    const p = (0, _util.u8aToBn)(data.subarray(36, 40), (0, _bnJs.BN_LE_OPTS)).toNumber();
    const r = (0, _util.u8aToBn)(data.subarray(40, 44), (0, _bnJs.BN_LE_OPTS)).toNumber(); // FIXME At this moment we assume these to be fixed params, this is not a great idea since we lose flexibility
    // and updates for greater security. However we need some protection against carefully-crafted params that can
    // eat up CPU since these are user inputs. So we need to get very clever here, but atm we only allow the defaults
    // and if no match, bail out
    if (N !== (0, _defaultsJs.DEFAULT_PARAMS).N || p !== (0, _defaultsJs.DEFAULT_PARAMS).p || r !== (0, _defaultsJs.DEFAULT_PARAMS).r) throw new Error("Invalid injected scrypt params found");
    return {
        params: {
            N,
            p,
            r
        },
        salt
    };
}

},{"@polkadot/util":"3HnHw","../bn.js":"h6UHx","./defaults.js":"2q5Gy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iuqOE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scryptToU8a", ()=>scryptToU8a);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _bnJs = require("../bn.js");
function scryptToU8a(salt, { N , p , r  }) {
    return (0, _util.u8aConcat)(salt, (0, _util.bnToU8a)(N, (0, _bnJs.BN_LE_32_OPTS)), (0, _util.bnToU8a)(p, (0, _bnJs.BN_LE_32_OPTS)), (0, _util.bnToU8a)(r, (0, _bnJs.BN_LE_32_OPTS)));
}

},{"@polkadot/util":"3HnHw","../bn.js":"h6UHx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"89SR2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ENCODING", ()=>ENCODING);
parcelHelpers.export(exports, "ENCODING_NONE", ()=>ENCODING_NONE);
parcelHelpers.export(exports, "ENCODING_VERSION", ()=>ENCODING_VERSION);
parcelHelpers.export(exports, "NONCE_LENGTH", ()=>NONCE_LENGTH);
parcelHelpers.export(exports, "SCRYPT_LENGTH", ()=>SCRYPT_LENGTH);
const ENCODING = [
    "scrypt",
    "xsalsa20-poly1305"
];
const ENCODING_NONE = [
    "none"
];
const ENCODING_VERSION = "3";
const NONCE_LENGTH = 24;
const SCRYPT_LENGTH = 44;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7bUzG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jsonEncrypt", ()=>jsonEncrypt);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../nacl/index.js");
var _indexJs1 = require("../scrypt/index.js");
var _encryptFormatJs = require("./encryptFormat.js");
function jsonEncrypt(data, contentType, passphrase) {
    let isEncrypted = false;
    let encoded = data;
    if (passphrase) {
        const { params , password , salt  } = (0, _indexJs1.scryptEncode)(passphrase);
        const { encrypted , nonce  } = (0, _indexJs.naclEncrypt)(encoded, password.subarray(0, 32));
        isEncrypted = true;
        encoded = (0, _util.u8aConcat)((0, _indexJs1.scryptToU8a)(salt, params), nonce, encrypted);
    }
    return (0, _encryptFormatJs.jsonEncryptFormat)(encoded, contentType, isEncrypted);
}

},{"@polkadot/util":"3HnHw","../nacl/index.js":"cX2uo","../scrypt/index.js":"lhRfY","./encryptFormat.js":"2fEiZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2fEiZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jsonEncryptFormat", ()=>jsonEncryptFormat);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../base64/index.js");
var _constantsJs = require("./constants.js");
function jsonEncryptFormat(encoded, contentType, isEncrypted) {
    return {
        encoded: (0, _indexJs.base64Encode)(encoded),
        encoding: {
            content: contentType,
            type: isEncrypted ? (0, _constantsJs.ENCODING) : (0, _constantsJs.ENCODING_NONE),
            version: (0, _constantsJs.ENCODING_VERSION)
        }
    };
}

},{"../base64/index.js":"dCLyq","./constants.js":"89SR2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dyqtj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Utilities for working with signatures
 */ parcelHelpers.export(exports, "signatureVerify", ()=>(0, _verifyJs.signatureVerify));
var _verifyJs = require("./verify.js");

},{"./verify.js":"Zr2H0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Zr2H0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signatureVerify", ()=>signatureVerify);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _decodeJs = require("../address/decode.js");
var _verifyJs = require("../ed25519/verify.js");
var _verifyJs1 = require("../secp256k1/verify.js");
var _verifyJs2 = require("../sr25519/verify.js");
const secp256k1VerifyHasher = (hashType)=>(message, signature, publicKey)=>(0, _verifyJs1.secp256k1Verify)(message, signature, publicKey, hashType);
const VERIFIERS_ECDSA = [
    [
        "ecdsa",
        secp256k1VerifyHasher("blake2")
    ],
    [
        "ethereum",
        secp256k1VerifyHasher("keccak")
    ]
];
const VERIFIERS = [
    [
        "ed25519",
        (0, _verifyJs.ed25519Verify)
    ],
    [
        "sr25519",
        (0, _verifyJs2.sr25519Verify)
    ],
    ...VERIFIERS_ECDSA
];
const CRYPTO_TYPES = [
    "ed25519",
    "sr25519",
    "ecdsa"
];
function verifyDetect(result, { message , publicKey , signature  }, verifiers = VERIFIERS) {
    result.isValid = verifiers.some(([crypto, verify])=>{
        try {
            if (verify(message, signature, publicKey)) {
                result.crypto = crypto;
                return true;
            }
        } catch (error) {}
        return false;
    });
    return result;
}
function verifyMultisig(result, { message , publicKey , signature  }) {
    if (![
        0,
        1,
        2
    ].includes(signature[0])) throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);
    const type = CRYPTO_TYPES[signature[0]] || "none";
    result.crypto = type;
    try {
        result.isValid = ({
            ecdsa: ()=>verifyDetect(result, {
                    message,
                    publicKey,
                    signature: signature.subarray(1)
                }, VERIFIERS_ECDSA).isValid,
            ed25519: ()=>(0, _verifyJs.ed25519Verify)(message, signature.subarray(1), publicKey),
            none: ()=>{
                throw Error("no verify for `none` crypto type");
            },
            sr25519: ()=>(0, _verifyJs2.sr25519Verify)(message, signature.subarray(1), publicKey)
        })[type]();
    } catch (error) {}
    return result;
}
function getVerifyFn(signature) {
    return [
        0,
        1,
        2
    ].includes(signature[0]) && [
        65,
        66
    ].includes(signature.length) ? verifyMultisig : verifyDetect;
}
function signatureVerify(message, signature, addressOrPublicKey) {
    const signatureU8a = (0, _util.u8aToU8a)(signature);
    if (![
        64,
        65,
        66
    ].includes(signatureU8a.length)) throw new Error(`Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);
    const publicKey = (0, _decodeJs.decodeAddress)(addressOrPublicKey);
    const input = {
        message: (0, _util.u8aToU8a)(message),
        publicKey,
        signature: signatureU8a
    };
    const result = {
        crypto: "none",
        isValid: false,
        isWrapped: (0, _util.u8aIsWrapped)(input.message, true),
        publicKey
    };
    const isWrappedBytes = (0, _util.u8aIsWrapped)(input.message, false);
    const verifyFn = getVerifyFn(signatureU8a);
    verifyFn(result, input);
    if (result.crypto !== "none" || result.isWrapped && !isWrappedBytes) return result;
    input.message = isWrappedBytes ? (0, _util.u8aUnwrapBytes)(input.message) : (0, _util.u8aWrapBytes)(input.message);
    return verifyFn(result, input);
}

},{"@polkadot/util":"3HnHw","../address/decode.js":"1wUOF","../ed25519/verify.js":"eizeP","../secp256k1/verify.js":"hxRMC","../sr25519/verify.js":"5QxDh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9J4uy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Create xxhash64 values with specified bitlengths
 */ parcelHelpers.export(exports, "xxhashAsHex", ()=>(0, _asU8AJs.xxhashAsHex));
parcelHelpers.export(exports, "xxhashAsU8a", ()=>(0, _asU8AJs.xxhashAsU8a));
var _asU8AJs = require("./asU8a.js");

},{"./asU8a.js":"eMfkb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eMfkb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name xxhashAsU8a
 * @summary Creates a xxhash64 u8a from the input.
 * @description
 * From either a `string`, `Uint8Array` or a `Buffer` input, create the xxhash64 and return the result as a `Uint8Array` with the specified `bitLength`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { xxhashAsU8a } from '@polkadot/util-crypto';
 *
 * xxhashAsU8a('abc'); // => 0x44bc2cf5ad770999
 * ```
 */ parcelHelpers.export(exports, "xxhashAsU8a", ()=>xxhashAsU8a);
parcelHelpers.export(exports, "xxhashAsHex", ()=>xxhashAsHex);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _wasmCrypto = require("@polkadot/wasm-crypto");
var _helpersJs = require("../helpers.js");
var _xxhash64Js = require("./xxhash64.js");
function xxhashAsU8a(data, bitLength = 64, onlyJs) {
    const rounds = Math.ceil(bitLength / 64);
    const u8a = (0, _util.u8aToU8a)(data);
    if (!(0, _util.hasBigInt) || !onlyJs && (0, _wasmCrypto.isReady)()) return (0, _wasmCrypto.twox)(u8a, rounds);
    const result = new Uint8Array(rounds * 8);
    for(let seed = 0; seed < rounds; seed++)result.set((0, _xxhash64Js.xxhash64)(u8a, seed).reverse(), seed * 8);
    return result;
}
const xxhashAsHex = (0, _helpersJs.createAsHex)(xxhashAsU8a);

},{"@polkadot/util":"3HnHw","@polkadot/wasm-crypto":"19VJZ","../helpers.js":"by01j","./xxhash64.js":"gmAbl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gmAbl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "xxhash64", ()=>xxhash64);
// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _xBigint = require("@polkadot/x-bigint"); // Adapted from https://github.com/pierrec/js-xxhash/blob/0504e76f3d31a21ae8528a7f590c7289c9e431d2/lib/xxhash64.js
//
// xxHash64 implementation in pure Javascript
// Copyright (C) 2016, Pierre Curto
// MIT license
//
// Changes made:
//   - converted to TypeScript
//   - uses native JS BigInt (no external dependencies)
//   - support only for Uint8Array inputs
//   - no constructor function, straight fill & digest
//   - update code removed, only called once, no streams
const P64_1 = (0, _xBigint.BigInt)("11400714785074694791");
const P64_2 = (0, _xBigint.BigInt)("14029467366897019727");
const P64_3 = (0, _xBigint.BigInt)("1609587929392839161");
const P64_4 = (0, _xBigint.BigInt)("9650029242287828579");
const P64_5 = (0, _xBigint.BigInt)("2870177450012600261"); // mask for a u64, all bits set
const U64 = (0, _xBigint.BigInt)("0xffffffffffffffff"); // various constants
const _7n = (0, _xBigint.BigInt)(7);
const _11n = (0, _xBigint.BigInt)(11);
const _12n = (0, _xBigint.BigInt)(12);
const _16n = (0, _xBigint.BigInt)(16);
const _18n = (0, _xBigint.BigInt)(18);
const _23n = (0, _xBigint.BigInt)(23);
const _27n = (0, _xBigint.BigInt)(27);
const _29n = (0, _xBigint.BigInt)(29);
const _31n = (0, _xBigint.BigInt)(31);
const _32n = (0, _xBigint.BigInt)(32);
const _33n = (0, _xBigint.BigInt)(33);
const _64n = (0, _xBigint.BigInt)(64);
const _256n = (0, _xBigint.BigInt)(256);
function rotl(a, b) {
    const c = a & U64;
    return (c << b | c >> _64n - b) & U64;
}
function fromU8a(u8a, p, count) {
    const bigints = new Array(count);
    let offset = 0;
    for(let i = 0; i < count; i++, offset += 2)bigints[i] = (0, _xBigint.BigInt)(u8a[p + offset] | u8a[p + 1 + offset] << 8);
    let result = (0, _util._0n);
    for(let i1 = count - 1; i1 >= 0; i1--)result = (result << _16n) + bigints[i1];
    return result;
}
function toU8a(h64) {
    const result = new Uint8Array(8);
    for(let i = 7; i >= 0; i--){
        result[i] = Number(h64 % _256n);
        h64 = h64 / _256n;
    }
    return result;
}
function state(initSeed) {
    const seed = (0, _xBigint.BigInt)(initSeed);
    return {
        seed,
        u8a: new Uint8Array(32),
        u8asize: 0,
        v1: seed + P64_1 + P64_2,
        v2: seed + P64_2,
        v3: seed,
        v4: seed - P64_1
    };
}
function init(state, input) {
    if (input.length < 32) {
        state.u8a.set(input);
        state.u8asize = input.length;
        return state;
    }
    const limit = input.length - 32;
    let p = 0;
    if (limit >= 0) {
        const adjustV = (v)=>P64_1 * rotl(v + P64_2 * fromU8a(input, p, 4), _31n);
        do {
            state.v1 = adjustV(state.v1);
            p += 8;
            state.v2 = adjustV(state.v2);
            p += 8;
            state.v3 = adjustV(state.v3);
            p += 8;
            state.v4 = adjustV(state.v4);
            p += 8;
        }while (p <= limit);
    }
    if (p < input.length) {
        state.u8a.set(input.subarray(p, input.length));
        state.u8asize = input.length - p;
    }
    return state;
}
function xxhash64(input, initSeed) {
    const { seed , u8a , u8asize , v1 , v2 , v3 , v4  } = init(state(initSeed), input);
    let p = 0;
    let h64 = U64 & (0, _xBigint.BigInt)(input.length) + (input.length >= 32 ? ((((rotl(v1, (0, _util._1n)) + rotl(v2, _7n) + rotl(v3, _12n) + rotl(v4, _18n) ^ P64_1 * rotl(v1 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v2 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v3 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v4 * P64_2, _31n)) * P64_1 + P64_4 : seed + P64_5);
    while(p <= u8asize - 8){
        h64 = U64 & P64_4 + P64_1 * rotl(h64 ^ P64_1 * rotl(P64_2 * fromU8a(u8a, p, 4), _31n), _27n);
        p += 8;
    }
    if (p + 4 <= u8asize) {
        h64 = U64 & P64_3 + P64_2 * rotl(h64 ^ P64_1 * fromU8a(u8a, p, 2), _23n);
        p += 4;
    }
    while(p < u8asize)h64 = U64 & P64_1 * rotl(h64 ^ P64_5 * (0, _xBigint.BigInt)(u8a[p++]), _11n);
    h64 = U64 & P64_2 * (h64 ^ h64 >> _33n);
    h64 = U64 & P64_3 * (h64 ^ h64 >> _29n);
    return toU8a(U64 & (h64 ^ h64 >> _32n));
}

},{"@polkadot/util":"3HnHw","@polkadot/x-bigint":"6Blk3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8GAT6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEV_PHRASE", ()=>DEV_PHRASE);
parcelHelpers.export(exports, "DEV_SEED", ()=>DEV_SEED);
const DEV_PHRASE = "bottom drive obey lake curtain smoke basket hold race lonely fit walk"; // seed from the above phrase
const DEV_SEED = "0xfac7959dbfe72f052e5a0c3c8d6530f202b02fd8f9f5ca3580ec8deb7797479e";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4L1Q8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name createPair
 * @summary Creates a keyring pair object
 * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.
 * The keyring pair stores the account state including the encoded address and associated metadata.
 *
 * It has properties whose values are functions that may be called to perform account actions:
 *
 * - `address` function retrieves the address associated with the account.
 * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.
 * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key
 * and associated secret key that are then available in memory, and changes the account address stored in the
 * state of the pair to correspond to the address of the decoded public key.
 * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair
 * and when the secret key is in memory (when the account pair is not locked) it returns an encoded
 * public key of the account.
 * - `meta` is the metadata that is stored in the state of the pair, either when it was originally
 * created or set via `setMeta`.
 * - `publicKey` returns the public key stored in memory for the pair.
 * - `sign` may be used to return a signature by signing a provided message with the secret
 * key (if it is in memory) using Nacl.
 * - `toJson` calls another `toJson` function and provides the state of the pair,
 * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account
 * that it generates using the secret key from memory (if it has been made available in memory)
 * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`
 * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).
 * The `toJson` function that it calls returns a JSON object with properties including the `address`
 * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,
 * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`
 * property that indicates whether the public key value of the `encoded` property is encoded or not.
 */ parcelHelpers.export(exports, "createPair", ()=>createPair);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _decodeJs = require("./decode.js");
var _encodeJs = require("./encode.js");
var _toJsonJs = require("./toJson.js");
const SIG_TYPE_NONE = new Uint8Array();
const TYPE_FROM_SEED = {
    ecdsa: (0, _utilCrypto.secp256k1PairFromSeed),
    ed25519: (0, _utilCrypto.ed25519PairFromSeed),
    ethereum: (0, _utilCrypto.secp256k1PairFromSeed),
    sr25519: (0, _utilCrypto.sr25519PairFromSeed)
};
const TYPE_PREFIX = {
    ecdsa: new Uint8Array([
        2
    ]),
    ed25519: new Uint8Array([
        0
    ]),
    ethereum: new Uint8Array([
        2
    ]),
    sr25519: new Uint8Array([
        1
    ])
};
const TYPE_SIGNATURE = {
    ecdsa: (m, p)=>(0, _utilCrypto.secp256k1Sign)(m, p, "blake2"),
    ed25519: (0, _utilCrypto.ed25519Sign),
    ethereum: (m, p)=>(0, _utilCrypto.secp256k1Sign)(m, p, "keccak"),
    sr25519: (0, _utilCrypto.sr25519Sign)
};
const TYPE_ADDRESS = {
    ecdsa: (p)=>p.length > 32 ? (0, _utilCrypto.blake2AsU8a)(p) : p,
    ed25519: (p)=>p,
    ethereum: (p)=>p.length === 20 ? p : (0, _utilCrypto.keccakAsU8a)((0, _utilCrypto.secp256k1Expand)(p)),
    sr25519: (p)=>p
};
function isLocked(secretKey) {
    return !secretKey || (0, _util.u8aEmpty)(secretKey);
}
function vrfHash(proof, context, extra) {
    return (0, _utilCrypto.blake2AsU8a)((0, _util.u8aConcat)(context || "", extra || "", proof));
}
function createPair({ toSS58 , type  }, { publicKey , secretKey  }, meta = {}, encoded = null, encTypes) {
    const decodePkcs8 = (passphrase, userEncoded)=>{
        const decoded = (0, _decodeJs.decodePair)(passphrase, userEncoded || encoded, encTypes);
        if (decoded.secretKey.length === 64) {
            publicKey = decoded.publicKey;
            secretKey = decoded.secretKey;
        } else {
            const pair = TYPE_FROM_SEED[type](decoded.secretKey);
            publicKey = pair.publicKey;
            secretKey = pair.secretKey;
        }
    };
    const recode = (passphrase)=>{
        isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);
        encoded = (0, _encodeJs.encodePair)({
            publicKey,
            secretKey
        }, passphrase); // re-encode, latest version
        encTypes = undefined; // swap to defaults, latest version follows
        return encoded;
    };
    const encodeAddress = ()=>{
        const raw = TYPE_ADDRESS[type](publicKey);
        return type === "ethereum" ? (0, _utilCrypto.ethereumEncode)(raw) : toSS58(raw);
    };
    return {
        get address () {
            return encodeAddress();
        },
        get addressRaw () {
            const raw = TYPE_ADDRESS[type](publicKey);
            return type === "ethereum" ? raw.slice(-20) : raw;
        },
        get isLocked () {
            return isLocked(secretKey);
        },
        get meta () {
            return meta;
        },
        get publicKey () {
            return publicKey;
        },
        get type () {
            return type;
        },
        // eslint-disable-next-line sort-keys
        decodePkcs8,
        decryptMessage: (encryptedMessageWithNonce, senderPublicKey)=>{
            if (isLocked(secretKey)) throw new Error("Cannot encrypt with a locked key pair");
            else if ([
                "ecdsa",
                "ethereum"
            ].includes(type)) throw new Error("Secp256k1 not supported yet");
            const messageU8a = (0, _util.u8aToU8a)(encryptedMessageWithNonce);
            return (0, _utilCrypto.naclOpen)(messageU8a.slice(24, messageU8a.length), messageU8a.slice(0, 24), (0, _utilCrypto.convertPublicKeyToCurve25519)((0, _util.u8aToU8a)(senderPublicKey)), (0, _utilCrypto.convertSecretKeyToCurve25519)(secretKey));
        },
        derive: (suri, meta)=>{
            if (type === "ethereum") throw new Error("Unable to derive on this keypair");
            else if (isLocked(secretKey)) throw new Error("Cannot derive on a locked keypair");
            const { path  } = (0, _utilCrypto.keyExtractPath)(suri);
            const derived = (0, _utilCrypto.keyFromPath)({
                publicKey,
                secretKey
            }, path, type);
            return createPair({
                toSS58,
                type
            }, derived, meta, null);
        },
        encodePkcs8: (passphrase)=>{
            return recode(passphrase);
        },
        encryptMessage: (message, recipientPublicKey, nonceIn)=>{
            if (isLocked(secretKey)) throw new Error("Cannot encrypt with a locked key pair");
            else if ([
                "ecdsa",
                "ethereum"
            ].includes(type)) throw new Error("Secp256k1 not supported yet");
            const { nonce , sealed  } = (0, _utilCrypto.naclSeal)((0, _util.u8aToU8a)(message), (0, _utilCrypto.convertSecretKeyToCurve25519)(secretKey), (0, _utilCrypto.convertPublicKeyToCurve25519)((0, _util.u8aToU8a)(recipientPublicKey)), nonceIn);
            return (0, _util.u8aConcat)(nonce, sealed);
        },
        lock: ()=>{
            secretKey = new Uint8Array();
        },
        setMeta: (additional)=>{
            meta = (0, _util.objectSpread)({}, meta, additional);
        },
        sign: (message, options = {})=>{
            if (isLocked(secretKey)) throw new Error("Cannot sign with a locked key pair");
            return (0, _util.u8aConcat)(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type]((0, _util.u8aToU8a)(message), {
                publicKey,
                secretKey
            }));
        },
        toJson: (passphrase)=>{
            // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these
            // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)
            // unless the publicKey is already an address
            const address = [
                "ecdsa",
                "ethereum"
            ].includes(type) ? publicKey.length === 20 ? (0, _util.u8aToHex)(publicKey) : (0, _util.u8aToHex)((0, _utilCrypto.secp256k1Compress)(publicKey)) : encodeAddress();
            return (0, _toJsonJs.pairToJson)(type, {
                address,
                meta
            }, recode(passphrase), !!passphrase);
        },
        unlock: (passphrase)=>{
            return decodePkcs8(passphrase);
        },
        verify: (message, signature, signerPublic)=>{
            return (0, _utilCrypto.signatureVerify)(message, signature, TYPE_ADDRESS[type]((0, _util.u8aToU8a)(signerPublic))).isValid;
        },
        vrfSign: (message, context, extra)=>{
            if (isLocked(secretKey)) throw new Error("Cannot sign with a locked key pair");
            if (type === "sr25519") return (0, _utilCrypto.sr25519VrfSign)(message, {
                secretKey
            }, context, extra);
            const proof = TYPE_SIGNATURE[type]((0, _util.u8aToU8a)(message), {
                publicKey,
                secretKey
            });
            return (0, _util.u8aConcat)(vrfHash(proof, context, extra), proof);
        },
        vrfVerify: (message, vrfResult, signerPublic, context, extra)=>{
            if (type === "sr25519") return (0, _utilCrypto.sr25519VrfVerify)(message, vrfResult, publicKey, context, extra);
            const result = (0, _utilCrypto.signatureVerify)(message, (0, _util.u8aConcat)(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type]((0, _util.u8aToU8a)(signerPublic)));
            return result.isValid && (0, _util.u8aEq)(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));
        }
    };
}

},{"@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","./decode.js":"fqE7T","./encode.js":"7xS5T","./toJson.js":"gnMte","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fqE7T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodePair", ()=>decodePair);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _defaultsJs = require("./defaults.js");
const SEED_OFFSET = (0, _defaultsJs.PKCS8_HEADER).length;
function decodePair(passphrase, encrypted, _encType) {
    const encType = Array.isArray(_encType) || _encType === undefined ? _encType : [
        _encType
    ];
    const decrypted = (0, _utilCrypto.jsonDecryptData)(encrypted, passphrase, encType);
    const header = decrypted.subarray(0, (0, _defaultsJs.PKCS8_HEADER).length);
    if (!(0, _util.u8aEq)(header, (0, _defaultsJs.PKCS8_HEADER))) throw new Error("Invalid Pkcs8 header found in body");
    let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + (0, _defaultsJs.SEC_LENGTH));
    let divOffset = SEED_OFFSET + (0, _defaultsJs.SEC_LENGTH);
    let divider = decrypted.subarray(divOffset, divOffset + (0, _defaultsJs.PKCS8_DIVIDER).length); // old-style, we have the seed here
    if (!(0, _util.u8aEq)(divider, (0, _defaultsJs.PKCS8_DIVIDER))) {
        divOffset = SEED_OFFSET + (0, _defaultsJs.SEED_LENGTH);
        secretKey = decrypted.subarray(SEED_OFFSET, divOffset);
        divider = decrypted.subarray(divOffset, divOffset + (0, _defaultsJs.PKCS8_DIVIDER).length);
        if (!(0, _util.u8aEq)(divider, (0, _defaultsJs.PKCS8_DIVIDER))) throw new Error("Invalid Pkcs8 divider found in body");
    }
    const pubOffset = divOffset + (0, _defaultsJs.PKCS8_DIVIDER).length;
    const publicKey = decrypted.subarray(pubOffset, pubOffset + (0, _defaultsJs.PUB_LENGTH));
    return {
        publicKey,
        secretKey
    };
}

},{"@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","./defaults.js":"h9tTI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h9tTI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PKCS8_DIVIDER", ()=>PKCS8_DIVIDER);
parcelHelpers.export(exports, "PKCS8_HEADER", ()=>PKCS8_HEADER);
parcelHelpers.export(exports, "PUB_LENGTH", ()=>PUB_LENGTH);
parcelHelpers.export(exports, "SALT_LENGTH", ()=>SALT_LENGTH);
parcelHelpers.export(exports, "SEC_LENGTH", ()=>SEC_LENGTH);
parcelHelpers.export(exports, "SEED_LENGTH", ()=>SEED_LENGTH);
const PKCS8_DIVIDER = new Uint8Array([
    161,
    35,
    3,
    33,
    0
]);
const PKCS8_HEADER = new Uint8Array([
    48,
    83,
    2,
    1,
    1,
    48,
    5,
    6,
    3,
    43,
    101,
    112,
    4,
    34,
    4,
    32
]);
const PUB_LENGTH = 32;
const SALT_LENGTH = 32;
const SEC_LENGTH = 64;
const SEED_LENGTH = 32;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7xS5T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodePair", ()=>encodePair);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _defaultsJs = require("./defaults.js");
function encodePair({ publicKey , secretKey  }, passphrase) {
    if (!secretKey) throw new Error("Expected a valid secretKey to be passed to encode");
    const encoded = (0, _util.u8aConcat)((0, _defaultsJs.PKCS8_HEADER), secretKey, (0, _defaultsJs.PKCS8_DIVIDER), publicKey);
    if (!passphrase) return encoded;
    const { params , password , salt  } = (0, _utilCrypto.scryptEncode)(passphrase);
    const { encrypted , nonce  } = (0, _utilCrypto.naclEncrypt)(encoded, password.subarray(0, 32));
    return (0, _util.u8aConcat)((0, _utilCrypto.scryptToU8a)(salt, params), nonce, encrypted);
}

},{"@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","./defaults.js":"h9tTI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gnMte":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pairToJson", ()=>pairToJson);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
function pairToJson(type, { address , meta  }, encoded, isEncrypted) {
    return (0, _util.objectSpread)((0, _utilCrypto.jsonEncryptFormat)(encoded, [
        "pkcs8",
        type
    ], isEncrypted), {
        address,
        meta
    });
}

},{"@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dmmGz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Pairs", ()=>Pairs);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
class Pairs {
    #map = {};
    add(pair) {
        this.#map[(0, _utilCrypto.decodeAddress)(pair.address).toString()] = pair;
        return pair;
    }
    all() {
        return Object.values(this.#map);
    }
    get(address) {
        const pair = this.#map[(0, _utilCrypto.decodeAddress)(address).toString()];
        if (!pair) throw new Error(`Unable to retrieve keypair '${(0, _util.isU8a)(address) || (0, _util.isHex)(address) ? (0, _util.u8aToHex)((0, _util.u8aToU8a)(address)) : address}'`);
        return pair;
    }
    remove(address) {
        delete this.#map[(0, _utilCrypto.decodeAddress)(address).toString()];
    }
}

},{"@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cppCo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PAIRSSR25519", ()=>PAIRSSR25519);
parcelHelpers.export(exports, "PAIRSETHEREUM", ()=>PAIRSETHEREUM);
/**
 * @name testKeyring
 * @summary Create an instance of Keyring pre-populated with locked test accounts
 * @description The test accounts (i.e. alice, bob, dave, eve, ferdie)
 * are available on the dev chain and each test account is initialized with DOT funds.
 */ parcelHelpers.export(exports, "createTestKeyring", ()=>createTestKeyring);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _keyringJs = require("./keyring.js");
var _indexJs = require("./pair/index.js");
const PAIRSSR25519 = [
    {
        p: "0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d",
        s: "0x98319d4ff8a9508c4bb0cf0b5a78d760a0b2082c02775e6e82370816fedfff48925a225d97aa00682d6a59b95b18780c10d7032336e88f3442b42361f4a66011",
        // nosemgrep
        seed: "Alice",
        type: "sr25519"
    },
    {
        p: "0xbe5ddb1579b72e84524fc29e78609e3caf42e85aa118ebfe0b0ad404b5bdd25f",
        s: "0xe8da6c9d810e020f5e3c7f5af2dea314cbeaa0d72bc6421e92c0808a0c584a6046ab28e97c3ffc77fe12b5a4d37e8cd4afbfebbf2391ffc7cb07c0f38c023efd",
        // nosemgrep
        seed: "Alice//stash",
        type: "sr25519"
    },
    {
        p: "0x8eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48",
        s: "0x081ff694633e255136bdb456c20a5fc8fed21f8b964c11bb17ff534ce80ebd5941ae88f85d0c1bfc37be41c904e1dfc01de8c8067b0d6d5df25dd1ac0894a325",
        // nosemgrep
        seed: "Bob",
        type: "sr25519"
    },
    {
        p: "0xfe65717dad0447d715f660a0a58411de509b42e6efb8375f562f58a554d5860e",
        s: "0xc006507cdfc267a21532394c49ca9b754ca71de21e15a1cdf807c7ceab6d0b6c3ed408d9d35311540dcd54931933e67cf1ea10d46f75408f82b789d9bd212fde",
        // nosemgrep
        seed: "Bob//stash",
        type: "sr25519"
    },
    {
        p: "0x90b5ab205c6974c9ea841be688864633dc9ca8a357843eeacf2314649965fe22",
        s: "0xa8f2d83016052e5d6d77b2f6fd5d59418922a09024cda701b3c34369ec43a7668faf12ff39cd4e5d92bb773972f41a7a5279ebc2ed92264bed8f47d344f8f18c",
        // nosemgrep
        seed: "Charlie",
        type: "sr25519"
    },
    {
        p: "0x306721211d5404bd9da88e0204360a1a9ab8b87c66c1bc2fcdd37f3c2222cc20",
        s: "0x20e05482ca4677e0edbc58ae9a3a59f6ed3b1a9484ba17e64d6fe8688b2b7b5d108c4487b9323b98b11fe36cb301b084e920f7b7895536809a6d62a451b25568",
        // nosemgrep
        seed: "Dave",
        type: "sr25519"
    },
    {
        p: "0xe659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df4e",
        s: "0x683576abfd5dc35273e4264c23095a1bf21c14517bece57c7f0cc5c0ed4ce06a3dbf386b7828f348abe15d76973a72009e6ef86a5c91db2990cb36bb657c6587",
        // nosemgrep
        seed: "Eve",
        type: "sr25519"
    },
    {
        p: "0x1cbd2d43530a44705ad088af313e18f80b53ef16b36177cd4b77b846f2a5f07c",
        s: "0xb835c20f450079cf4f513900ae9faf8df06ad86c681884122c752a4b2bf74d4303e4f21bc6cc62bb4eeed5a9cce642c25e2d2ac1464093b50f6196d78e3a7426",
        // nosemgrep
        seed: "Ferdie",
        type: "sr25519"
    }
];
const PAIRSETHEREUM = [
    {
        name: "Alith",
        p: "0x02509540919faacf9ab52146c9aa40db68172d83777250b28e4679176e49ccdd9f",
        s: "0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133",
        // nosemgrep
        type: "ethereum"
    },
    {
        name: "Baltathar",
        p: "0x033bc19e36ff1673910575b6727a974a9abd80c9a875d41ab3e2648dbfb9e4b518",
        s: "0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b",
        // nosemgrep
        type: "ethereum"
    },
    {
        name: "Charleth",
        p: "0x0234637bdc0e89b5d46543bcbf8edff329d2702bc995e27e9af4b1ba009a3c2a5e",
        s: "0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b",
        // nosemgrep
        type: "ethereum"
    },
    {
        name: "Dorothy",
        p: "0x02a00d60b2b408c2a14c5d70cdd2c205db8985ef737a7e55ad20ea32cc9e7c417c",
        s: "0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68",
        // nosemgrep
        type: "ethereum"
    },
    {
        name: "Ethan",
        p: "0x025cdc005b752651cd3f728fb9192182acb3a9c89e19072cbd5b03f3ee1f1b3ffa",
        s: "0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4",
        // nosemgrep
        type: "ethereum"
    },
    {
        name: "Faith",
        p: "0x037964b6c9d546da4646ada28a99e34acaa1d14e7aba861a9055f9bd200c8abf74",
        s: "0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df",
        // nosemgrep
        type: "ethereum"
    }
];
function createMeta(name, seed) {
    if (!name && !seed) throw new Error("Testing pair should have either a name or a seed");
    return {
        isTesting: true,
        name: name || seed && seed.replace("//", "_").toLowerCase()
    };
}
function createTestKeyring(options = {}, isDerived = true) {
    const keyring = new (0, _keyringJs.Keyring)(options);
    const pairs = options.type === "ethereum" ? PAIRSETHEREUM : PAIRSSR25519;
    for (const { name , p , s , seed , type  } of pairs){
        const meta = createMeta(name, seed);
        const pair = !isDerived && !name && seed ? keyring.addFromUri(seed, meta, options.type) : keyring.addPair((0, _indexJs.createPair)({
            toSS58: keyring.encodeAddress,
            type
        }, {
            publicKey: (0, _util.hexToU8a)(p),
            secretKey: (0, _util.hexToU8a)(s)
        }, meta));
        pair.lock = ()=>{};
    }
    return keyring;
}

},{"@polkadot/util":"3HnHw","./keyring.js":"bVuzx","./pair/index.js":"4L1Q8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"crdQq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createTestPairs", ()=>createTestPairs);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _nobodyJs = require("./pair/nobody.js");
var _testingJs = require("./testing.js");
function createTestPairs(options, isDerived = true) {
    const keyring = (0, _testingJs.createTestKeyring)(options, isDerived);
    const pairs = keyring.getPairs();
    const map = {
        nobody: (0, _nobodyJs.nobody)()
    };
    for (const p of pairs)map[p.meta.name] = p;
    return map;
}

},{"./pair/nobody.js":"n33hd","./testing.js":"cppCo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"n33hd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nobody", ()=>nobody);
// Copyright 2017-2022 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
// empty publicKey
const publicKey = new Uint8Array(32); // pre-computed via encodeAddress(publicKey)
const address = "5C4hrfjw9DjXZTzV3MwzrrAr9P1MJhSrvWGWqi1eSuyUpnhM";
const meta = {
    isTesting: true,
    name: "nobody"
};
const json = {
    address,
    encoded: "",
    encoding: {
        content: [
            "pkcs8",
            "ed25519"
        ],
        type: "none",
        version: "0"
    },
    meta
};
const pair = {
    address,
    addressRaw: publicKey,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    decodePkcs8: (passphrase, encoded)=>undefined,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    decryptMessage: (encryptedMessageWithNonce, senderPublicKey)=>null,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    derive: (suri, meta)=>pair,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    encodePkcs8: (passphrase)=>new Uint8Array(0),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    encryptMessage: (message, recipientPublicKey, _nonce)=>new Uint8Array(),
    isLocked: true,
    lock: ()=>{},
    meta,
    publicKey,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setMeta: (meta)=>undefined,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sign: (message)=>new Uint8Array(64),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toJson: (passphrase)=>json,
    type: "ed25519",
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unlock: (passphrase)=>undefined,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    verify: (message, signature)=>false,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    vrfSign: (message, context, extra)=>new Uint8Array(96),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    vrfVerify: (message, vrfResult, context, extra)=>false
};
function nobody() {
    return pair;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bvUtj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"iJssI","./bundle.js":"g7SDL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iJssI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"a8QCt","./packageInfo.js":"bkNCg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a8QCt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/types/packageInfo");
exports.default = [
    (0, _packageInfo.packageInfo)
];

},{"@polkadot/types/packageInfo":"cIucp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g7SDL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "HttpProvider", ()=>(0, _indexJs.HttpProvider));
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
parcelHelpers.export(exports, "WsProvider", ()=>(0, _indexJs1.WsProvider));
parcelHelpers.export(exports, "ScProvider", ()=>(0, _indexJs2.ScProvider));
var _indexJs = require("./http/index.js");
var _packageInfoJs = require("./packageInfo.js");
var _indexJs1 = require("./ws/index.js");
var _indexJs2 = require("./substrate-connect/index.js");

},{"./http/index.js":"bxgeP","./packageInfo.js":"bkNCg","./ws/index.js":"kGnGj","./substrate-connect/index.js":"jyuF7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bxgeP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HttpProvider", ()=>HttpProvider);
var _classPrivateFieldLooseBase = require("@babel/runtime/helpers/esm/classPrivateFieldLooseBase");
var _classPrivateFieldLooseBaseDefault = parcelHelpers.interopDefault(_classPrivateFieldLooseBase);
var _classPrivateFieldLooseKey = require("@babel/runtime/helpers/esm/classPrivateFieldLooseKey");
var _classPrivateFieldLooseKeyDefault = parcelHelpers.interopDefault(_classPrivateFieldLooseKey);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _xFetch = require("@polkadot/x-fetch");
var _indexJs = require("../coder/index.js");
var _defaultsJs = require("../defaults.js");
var _defaultsJsDefault = parcelHelpers.interopDefault(_defaultsJs);
var _lruJs = require("../lru.js");
const ERROR_SUBSCRIBE = "HTTP Provider does not have subscriptions, use WebSockets instead";
const l = (0, _util.logger)("api-http");
/**
 * # @polkadot/rpc-provider
 *
 * @name HttpProvider
 *
 * @description The HTTP Provider allows sending requests using HTTP to a HTTP RPC server TCP port. It does not support subscriptions so you won't be able to listen to events such as new blocks or balance changes. It is usually preferable using the [[WsProvider]].
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Api from '@polkadot/api/promise';
 * import { HttpProvider } from '@polkadot/rpc-provider';
 *
 * const provider = new HttpProvider('http://127.0.0.1:9933');
 * const api = new Api(provider);
 * ```
 *
 * @see [[WsProvider]]
 */ var _callCache = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("callCache");
var _coder = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("coder");
var _endpoint = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("endpoint");
var _headers = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("headers");
var _stats = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("stats");
var _send = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("send");
class HttpProvider {
    /**
   * @param {string} endpoint The endpoint url starting with http://
   */ constructor(endpoint = (0, _defaultsJsDefault.default).HTTP_URL, headers = {}){
        Object.defineProperty(this, _send, {
            value: _send2
        });
        Object.defineProperty(this, _callCache, {
            writable: true,
            value: new (0, _lruJs.LRUCache)()
        });
        Object.defineProperty(this, _coder, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _endpoint, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _headers, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _stats, {
            writable: true,
            value: void 0
        });
        if (!/^(https|http):\/\//.test(endpoint)) throw new Error(`Endpoint should start with 'http://' or 'https://', received '${endpoint}'`);
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _coder)[_coder] = new (0, _indexJs.RpcCoder)();
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _endpoint)[_endpoint] = endpoint;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _headers)[_headers] = headers;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats] = {
            active: {
                requests: 0,
                subscriptions: 0
            },
            total: {
                bytesRecv: 0,
                bytesSent: 0,
                cached: 0,
                errors: 0,
                requests: 0,
                subscriptions: 0,
                timeout: 0
            }
        };
    }
    /**
   * @summary `true` when this provider supports subscriptions
   */ get hasSubscriptions() {
        return false;
    }
    /**
   * @description Returns a clone of the object
   */ clone() {
        return new HttpProvider((0, _classPrivateFieldLooseBaseDefault.default)(this, _endpoint)[_endpoint], (0, _classPrivateFieldLooseBaseDefault.default)(this, _headers)[_headers]);
    }
    /**
   * @description Manually connect from the connection
   */ async connect() {}
    /**
   * @description Manually disconnect from the connection
   */ async disconnect() {}
    /**
   * @description Returns the connection stats
   */ get stats() {
        return (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats];
    }
    /**
   * @summary Whether the node is connected or not.
   * @return {boolean} true if connected
   */ get isConnected() {
        return true;
    }
    /**
   * @summary Events are not supported with the HttpProvider, see [[WsProvider]].
   * @description HTTP Provider does not have 'on' emitters. WebSockets should be used instead.
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    on(type, sub) {
        l.error("HTTP Provider does not have 'on' emitters, use WebSockets instead");
        return ()=>{};
    }
    /**
   * @summary Send HTTP POST Request with Body to configured HTTP Endpoint.
   */ async send(method, params, isCacheable) {
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.requests++;
        const [, body] = (0, _classPrivateFieldLooseBaseDefault.default)(this, _coder)[_coder].encodeJson(method, params);
        let resultPromise = isCacheable ? (0, _classPrivateFieldLooseBaseDefault.default)(this, _callCache)[_callCache].get(body) : null;
        if (!resultPromise) {
            resultPromise = (0, _classPrivateFieldLooseBaseDefault.default)(this, _send)[_send](body);
            if (isCacheable) (0, _classPrivateFieldLooseBaseDefault.default)(this, _callCache)[_callCache].set(body, resultPromise);
        } else (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.cached++;
        return resultPromise;
    }
    /**
   * @summary Subscriptions are not supported with the HttpProvider, see [[WsProvider]].
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/require-await
    async subscribe(types, method, params, cb) {
        l.error(ERROR_SUBSCRIBE);
        throw new Error(ERROR_SUBSCRIBE);
    }
    /**
   * @summary Subscriptions are not supported with the HttpProvider, see [[WsProvider]].
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/require-await
    async unsubscribe(type, method, id) {
        l.error(ERROR_SUBSCRIBE);
        throw new Error(ERROR_SUBSCRIBE);
    }
}
async function _send2(body) {
    (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].active.requests++;
    (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.bytesSent += body.length;
    try {
        const response = await (0, _xFetch.fetch)((0, _classPrivateFieldLooseBaseDefault.default)(this, _endpoint)[_endpoint], {
            body,
            headers: {
                Accept: "application/json",
                "Content-Length": `${body.length}`,
                "Content-Type": "application/json",
                ...(0, _classPrivateFieldLooseBaseDefault.default)(this, _headers)[_headers]
            },
            method: "POST"
        });
        if (!response.ok) throw new Error(`[${response.status}]: ${response.statusText}`);
        const result = await response.text();
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.bytesRecv += result.length;
        const decoded = (0, _classPrivateFieldLooseBaseDefault.default)(this, _coder)[_coder].decodeResponse(JSON.parse(result));
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].active.requests--;
        return decoded;
    } catch (e) {
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].active.requests--;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.errors++;
        throw e;
    }
}

},{"@babel/runtime/helpers/esm/classPrivateFieldLooseBase":"gHEjb","@babel/runtime/helpers/esm/classPrivateFieldLooseKey":"90V54","@polkadot/util":"3HnHw","@polkadot/x-fetch":"5UXbg","../coder/index.js":"hnZK5","../defaults.js":"384nS","../lru.js":"33o4q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gHEjb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
    return receiver;
}
exports.default = _classPrivateFieldBase;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"90V54":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var id = 0;
function _classPrivateFieldKey(name) {
    return "__private_" + id++ + "_" + name;
}
exports.default = _classPrivateFieldKey;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5UXbg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetch = void 0;
Object.defineProperty(exports, "packageInfo", {
    enumerable: true,
    get: function() {
        return _packageInfo.packageInfo;
    }
});
var _xGlobal = require("@polkadot/x-global");
var _packageInfo = require("./packageInfo");
// Copyright 2017-2022 @polkadot/x-fetch authors & contributors
// SPDX-License-Identifier: Apache-2.0
const fetch = _xGlobal.xglobal.fetch;
exports.fetch = fetch;

},{"@polkadot/x-global":"k9Iwp","./packageInfo":"9RvoJ"}],"9RvoJ":[function(require,module,exports) {
"use strict";
var __dirname = "node_modules/@polkadot/x-fetch/cjs";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.packageInfo = void 0;
// Copyright 2017-2022 @polkadot/x-fetch authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
const packageInfo = {
    name: "@polkadot/x-fetch",
    path: typeof __dirname === "string" ? __dirname : "auto",
    type: "cjs",
    version: "10.1.6"
};
exports.packageInfo = packageInfo;

},{}],"hnZK5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "RpcCoder", ()=>RpcCoder);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _errorJs = require("./error.js");
var _errorJsDefault = parcelHelpers.interopDefault(_errorJs);
function formatErrorData(data) {
    if ((0, _util.isUndefined)(data)) return "";
    const formatted = `: ${(0, _util.isString)(data) ? data.replace(/Error\("/g, "").replace(/\("/g, "(").replace(/"\)/g, ")").replace(/\(/g, ", ").replace(/\)/g, "") : (0, _util.stringify)(data)}`; // We need some sort of cut-off here since these can be very large and
    // very nested, pick a number and trim the result display to it
    return formatted.length <= 256 ? formatted : `${formatted.substring(0, 255)}‚Ä¶`;
}
function checkError(error) {
    if (error) {
        const { code , data , message  } = error;
        throw new (0, _errorJsDefault.default)(`${code}: ${message}${formatErrorData(data)}`, code, data);
    }
}
class RpcCoder {
    #id = 0;
    decodeResponse(response) {
        if (!response || response.jsonrpc !== "2.0") throw new Error("Invalid jsonrpc field in decoded object");
        const isSubscription = !(0, _util.isUndefined)(response.params) && !(0, _util.isUndefined)(response.method);
        if (!(0, _util.isNumber)(response.id) && (!isSubscription || !(0, _util.isNumber)(response.params.subscription) && !(0, _util.isString)(response.params.subscription))) throw new Error("Invalid id field in decoded object");
        checkError(response.error);
        if (response.result === undefined && !isSubscription) throw new Error("No result found in jsonrpc response");
        if (isSubscription) {
            checkError(response.params.error);
            return response.params.result;
        }
        return response.result;
    }
    encodeJson(method, params) {
        const [id, data] = this.encodeObject(method, params);
        return [
            id,
            (0, _util.stringify)(data)
        ];
    }
    encodeObject(method, params) {
        const id = ++this.#id;
        return [
            id,
            {
                id,
                jsonrpc: "2.0",
                method,
                params
            }
        ];
    }
}

},{"@polkadot/util":"3HnHw","./error.js":"25oT1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"25oT1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _function = require("@polkadot/util/is/function");
const UNKNOWN = -99999;
function extend(that, name, value) {
    Object.defineProperty(that, name, {
        configurable: true,
        enumerable: false,
        value
    });
}
class RpcError extends Error {
    constructor(message = "", code = UNKNOWN, data){
        super();
        extend(this, "message", String(message));
        extend(this, "name", this.constructor.name);
        extend(this, "data", data);
        extend(this, "code", code);
        if ((0, _function.isFunction)(Error.captureStackTrace)) Error.captureStackTrace(this, this.constructor);
        else {
            const { stack  } = new Error(message);
            stack && extend(this, "stack", stack);
        }
    }
    static CODES = {
        ASSERT: -90009,
        INVALID_JSONRPC: -99998,
        METHOD_NOT_FOUND: -32601,
        // Rust client
        UNKNOWN
    };
}
exports.default = RpcError;

},{"@polkadot/util/is/function":"3nYod","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"384nS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
const HTTP_URL = "http://127.0.0.1:9933";
const WS_URL = "ws://127.0.0.1:9944";
exports.default = {
    HTTP_URL,
    WS_URL
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"33o4q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LRUCache", ()=>LRUCache);
var _classPrivateFieldLooseBase = require("@babel/runtime/helpers/esm/classPrivateFieldLooseBase");
var _classPrivateFieldLooseBaseDefault = parcelHelpers.interopDefault(_classPrivateFieldLooseBase);
var _classPrivateFieldLooseKey = require("@babel/runtime/helpers/esm/classPrivateFieldLooseKey");
var _classPrivateFieldLooseKeyDefault = parcelHelpers.interopDefault(_classPrivateFieldLooseKey);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Assuming all 1.5MB responses, we apply a default allowing for 192MB
// cache space (depending on the historic queries this would vary, metadata
// for Kusama/Polkadot/Substrate falls between 600-750K, 2x for estimate)
const DEFAULT_CAPACITY = 128;
class LRUNode {
    constructor(key){
        this.key = key;
        this.next = this.prev = this;
    }
} // https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
var _data = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("data");
var _refs = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("refs");
var _length = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("length");
var _head = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("head");
var _tail = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("tail");
var _toHead = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("toHead");
class LRUCache {
    constructor(capacity = DEFAULT_CAPACITY){
        Object.defineProperty(this, _toHead, {
            value: _toHead2
        });
        this.capacity = void 0;
        Object.defineProperty(this, _data, {
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, _refs, {
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, _length, {
            writable: true,
            value: 0
        });
        Object.defineProperty(this, _head, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _tail, {
            writable: true,
            value: void 0
        });
        this.capacity = capacity;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head] = (0, _classPrivateFieldLooseBaseDefault.default)(this, _tail)[_tail] = new LRUNode("<empty>");
    }
    get length() {
        return (0, _classPrivateFieldLooseBaseDefault.default)(this, _length)[_length];
    }
    get lengthData() {
        return (0, _classPrivateFieldLooseBaseDefault.default)(this, _data)[_data].size;
    }
    get lengthRefs() {
        return (0, _classPrivateFieldLooseBaseDefault.default)(this, _refs)[_refs].size;
    }
    entries() {
        const keys = this.keys();
        const entries = new Array(keys.length);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            entries[i] = [
                key,
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _data)[_data].get(key)
            ];
        }
        return entries;
    }
    keys() {
        const keys = [];
        if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _length)[_length]) {
            let curr = (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head];
            while(curr !== (0, _classPrivateFieldLooseBaseDefault.default)(this, _tail)[_tail]){
                keys.push(curr.key);
                curr = curr.next;
            }
            keys.push(curr.key);
        }
        return keys;
    }
    get(key) {
        const data = (0, _classPrivateFieldLooseBaseDefault.default)(this, _data)[_data].get(key);
        if (data) {
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _toHead)[_toHead](key);
            return data;
        }
        return null;
    }
    set(key, value) {
        if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _data)[_data].has(key)) (0, _classPrivateFieldLooseBaseDefault.default)(this, _toHead)[_toHead](key);
        else {
            const node = new LRUNode(key);
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _refs)[_refs].set(node.key, node);
            if (this.length === 0) (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head] = (0, _classPrivateFieldLooseBaseDefault.default)(this, _tail)[_tail] = node;
            else {
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head].prev = node;
                node.next = (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head];
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head] = node;
            }
            if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _length)[_length] === this.capacity) {
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _data)[_data].delete((0, _classPrivateFieldLooseBaseDefault.default)(this, _tail)[_tail].key);
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _refs)[_refs].delete((0, _classPrivateFieldLooseBaseDefault.default)(this, _tail)[_tail].key);
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _tail)[_tail] = (0, _classPrivateFieldLooseBaseDefault.default)(this, _tail)[_tail].prev;
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _tail)[_tail].next = (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head];
            } else (0, _classPrivateFieldLooseBaseDefault.default)(this, _length)[_length] += 1;
        }
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _data)[_data].set(key, value);
    }
}
function _toHead2(key) {
    const ref = (0, _classPrivateFieldLooseBaseDefault.default)(this, _refs)[_refs].get(key);
    if (ref && ref !== (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head]) {
        ref.prev.next = ref.next;
        ref.next.prev = ref.prev;
        ref.next = (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head];
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head].prev = ref;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _head)[_head] = ref;
    }
}

},{"@babel/runtime/helpers/esm/classPrivateFieldLooseBase":"gHEjb","@babel/runtime/helpers/esm/classPrivateFieldLooseKey":"90V54","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kGnGj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WsProvider", ()=>WsProvider);
var _classPrivateFieldLooseBase = require("@babel/runtime/helpers/esm/classPrivateFieldLooseBase");
var _classPrivateFieldLooseBaseDefault = parcelHelpers.interopDefault(_classPrivateFieldLooseBase);
var _classPrivateFieldLooseKey = require("@babel/runtime/helpers/esm/classPrivateFieldLooseKey");
var _classPrivateFieldLooseKeyDefault = parcelHelpers.interopDefault(_classPrivateFieldLooseKey);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable camelcase */ var _eventemitter3 = require("eventemitter3");
var _eventemitter3Default = parcelHelpers.interopDefault(_eventemitter3);
var _util = require("@polkadot/util");
var _xGlobal = require("@polkadot/x-global");
var _xWs = require("@polkadot/x-ws");
var _indexJs = require("../coder/index.js");
var _defaultsJs = require("../defaults.js");
var _defaultsJsDefault = parcelHelpers.interopDefault(_defaultsJs);
var _lruJs = require("../lru.js");
var _errorsJs = require("./errors.js");
const ALIASES = {
    chain_finalisedHead: "chain_finalizedHead",
    chain_subscribeFinalisedHeads: "chain_subscribeFinalizedHeads",
    chain_unsubscribeFinalisedHeads: "chain_unsubscribeFinalizedHeads"
};
const RETRY_DELAY = 2500;
const DEFAULT_TIMEOUT_MS = 60000;
const TIMEOUT_INTERVAL = 5000;
const MEGABYTE = 1048576;
const l = (0, _util.logger)("api-ws");
function eraseRecord(record, cb) {
    Object.keys(record).forEach((key)=>{
        if (cb) cb(record[key]);
        delete record[key];
    });
}
/**
 * # @polkadot/rpc-provider/ws
 *
 * @name WsProvider
 *
 * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Api from '@polkadot/api/promise';
 * import { WsProvider } from '@polkadot/rpc-provider/ws';
 *
 * const provider = new WsProvider('ws://127.0.0.1:9944');
 * const api = new Api(provider);
 * ```
 *
 * @see [[HttpProvider]]
 */ var _callCache = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("callCache");
var _coder = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("coder");
var _endpoints = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("endpoints");
var _headers = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("headers");
var _eventemitter = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("eventemitter");
var _handlers = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("handlers");
var _isReadyPromise = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("isReadyPromise");
var _stats = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("stats");
var _waitingForId = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("waitingForId");
var _autoConnectMs = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("autoConnectMs");
var _endpointIndex = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("endpointIndex");
var _isConnected = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("isConnected");
var _subscriptions = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("subscriptions");
var _timeoutId = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("timeoutId");
var _websocket = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("websocket");
var _timeout = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("timeout");
var _send = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("send");
var _emit = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("emit");
var _onSocketClose = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("onSocketClose");
var _onSocketError = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("onSocketError");
var _onSocketMessage = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("onSocketMessage");
var _onSocketMessageResult = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("onSocketMessageResult");
var _onSocketMessageSubscribe = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("onSocketMessageSubscribe");
var _onSocketOpen = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("onSocketOpen");
var _resubscribe = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("resubscribe");
var _timeoutHandlers = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("timeoutHandlers");
class WsProvider {
    /**
   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.
   * @param {boolean} autoConnect Whether to connect automatically or not.
   * @param {number} [timeout] Custom timeout value
   */ constructor(endpoint = (0, _defaultsJsDefault.default).WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout){
        Object.defineProperty(this, _send, {
            value: _send2
        });
        Object.defineProperty(this, _callCache, {
            writable: true,
            value: new (0, _lruJs.LRUCache)()
        });
        Object.defineProperty(this, _coder, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _endpoints, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _headers, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _eventemitter, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _handlers, {
            writable: true,
            value: {}
        });
        Object.defineProperty(this, _isReadyPromise, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _stats, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _waitingForId, {
            writable: true,
            value: {}
        });
        Object.defineProperty(this, _autoConnectMs, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _endpointIndex, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _isConnected, {
            writable: true,
            value: false
        });
        Object.defineProperty(this, _subscriptions, {
            writable: true,
            value: {}
        });
        Object.defineProperty(this, _timeoutId, {
            writable: true,
            value: null
        });
        Object.defineProperty(this, _websocket, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _timeout, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _emit, {
            writable: true,
            value: (type, ...args)=>{
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _eventemitter)[_eventemitter].emit(type, ...args);
            }
        });
        Object.defineProperty(this, _onSocketClose, {
            writable: true,
            value: (event)=>{
                const error = new Error(`disconnected from ${(0, _classPrivateFieldLooseBaseDefault.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBaseDefault.default)(this, _endpointIndex)[_endpointIndex]]}: ${event.code}:: ${event.reason || (0, _errorsJs.getWSErrorString)(event.code)}`);
                if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _autoConnectMs)[_autoConnectMs] > 0) l.error(error.message);
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _isConnected)[_isConnected] = false;
                if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket]) {
                    (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket].onclose = null;
                    (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket].onerror = null;
                    (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket].onmessage = null;
                    (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket].onopen = null;
                    (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket] = null;
                }
                if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _timeoutId)[_timeoutId]) {
                    clearInterval((0, _classPrivateFieldLooseBaseDefault.default)(this, _timeoutId)[_timeoutId]);
                    (0, _classPrivateFieldLooseBaseDefault.default)(this, _timeoutId)[_timeoutId] = null;
                }
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _emit)[_emit]("disconnected"); // reject all hanging requests
                eraseRecord((0, _classPrivateFieldLooseBaseDefault.default)(this, _handlers)[_handlers], (h)=>{
                    try {
                        h.callback(error, undefined);
                    } catch (err) {
                        // does not throw
                        l.error(err);
                    }
                });
                eraseRecord((0, _classPrivateFieldLooseBaseDefault.default)(this, _waitingForId)[_waitingForId]);
                if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _autoConnectMs)[_autoConnectMs] > 0) setTimeout(()=>{
                    this.connectWithRetry().catch(()=>{});
                }, (0, _classPrivateFieldLooseBaseDefault.default)(this, _autoConnectMs)[_autoConnectMs]);
            }
        });
        Object.defineProperty(this, _onSocketError, {
            writable: true,
            value: (error)=>{
                l.debug(()=>[
                        "socket error",
                        error
                    ]);
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _emit)[_emit]("error", error);
            }
        });
        Object.defineProperty(this, _onSocketMessage, {
            writable: true,
            value: (message)=>{
                l.debug(()=>[
                        "received",
                        message.data
                    ]);
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.bytesRecv += message.data.length;
                const response = JSON.parse(message.data);
                return (0, _util.isUndefined)(response.method) ? (0, _classPrivateFieldLooseBaseDefault.default)(this, _onSocketMessageResult)[_onSocketMessageResult](response) : (0, _classPrivateFieldLooseBaseDefault.default)(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](response);
            }
        });
        Object.defineProperty(this, _onSocketMessageResult, {
            writable: true,
            value: (response)=>{
                const handler = (0, _classPrivateFieldLooseBaseDefault.default)(this, _handlers)[_handlers][response.id];
                if (!handler) {
                    l.debug(()=>`Unable to find handler for id=${response.id}`);
                    return;
                }
                try {
                    const { method , params , subscription  } = handler;
                    const result = (0, _classPrivateFieldLooseBaseDefault.default)(this, _coder)[_coder].decodeResponse(response); // first send the result - in case of subs, we may have an update
                    // immediately if we have some queued results already
                    handler.callback(null, result);
                    if (subscription) {
                        const subId = `${subscription.type}::${result}`;
                        (0, _classPrivateFieldLooseBaseDefault.default)(this, _subscriptions)[_subscriptions][subId] = (0, _util.objectSpread)({}, subscription, {
                            method,
                            params
                        }); // if we have a result waiting for this subscription already
                        if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _waitingForId)[_waitingForId][subId]) (0, _classPrivateFieldLooseBaseDefault.default)(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe]((0, _classPrivateFieldLooseBaseDefault.default)(this, _waitingForId)[_waitingForId][subId]);
                    }
                } catch (error) {
                    (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.errors++;
                    handler.callback(error, undefined);
                }
                delete (0, _classPrivateFieldLooseBaseDefault.default)(this, _handlers)[_handlers][response.id];
            }
        });
        Object.defineProperty(this, _onSocketMessageSubscribe, {
            writable: true,
            value: (response)=>{
                const method = ALIASES[response.method] || response.method || "invalid";
                const subId = `${method}::${response.params.subscription}`;
                const handler = (0, _classPrivateFieldLooseBaseDefault.default)(this, _subscriptions)[_subscriptions][subId];
                if (!handler) {
                    // store the JSON, we could have out-of-order subid coming in
                    (0, _classPrivateFieldLooseBaseDefault.default)(this, _waitingForId)[_waitingForId][subId] = response;
                    l.debug(()=>`Unable to find handler for subscription=${subId}`);
                    return;
                } // housekeeping
                delete (0, _classPrivateFieldLooseBaseDefault.default)(this, _waitingForId)[_waitingForId][subId];
                try {
                    const result = (0, _classPrivateFieldLooseBaseDefault.default)(this, _coder)[_coder].decodeResponse(response);
                    handler.callback(null, result);
                } catch (error) {
                    (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.errors++;
                    handler.callback(error, undefined);
                }
            }
        });
        Object.defineProperty(this, _onSocketOpen, {
            writable: true,
            value: ()=>{
                if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket] === null) throw new Error("WebSocket cannot be null in onOpen");
                l.debug(()=>[
                        "connected to",
                        (0, _classPrivateFieldLooseBaseDefault.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBaseDefault.default)(this, _endpointIndex)[_endpointIndex]]
                    ]);
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _isConnected)[_isConnected] = true;
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _emit)[_emit]("connected");
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _resubscribe)[_resubscribe]();
                return true;
            }
        });
        Object.defineProperty(this, _resubscribe, {
            writable: true,
            value: ()=>{
                const subscriptions = (0, _classPrivateFieldLooseBaseDefault.default)(this, _subscriptions)[_subscriptions];
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _subscriptions)[_subscriptions] = {};
                Promise.all(Object.keys(subscriptions).map(async (id)=>{
                    const { callback , method , params , type  } = subscriptions[id]; // only re-create subscriptions which are not in author (only area where
                    // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'
                    // are not included (and will not be re-broadcast)
                    if (type.startsWith("author_")) return;
                    try {
                        await this.subscribe(type, method, params, callback);
                    } catch (error) {
                        l.error(error);
                    }
                })).catch(l.error);
            }
        });
        Object.defineProperty(this, _timeoutHandlers, {
            writable: true,
            value: ()=>{
                const now = Date.now();
                const ids = Object.keys((0, _classPrivateFieldLooseBaseDefault.default)(this, _handlers)[_handlers]);
                for(let i = 0; i < ids.length; i++){
                    const handler = (0, _classPrivateFieldLooseBaseDefault.default)(this, _handlers)[_handlers][ids[i]];
                    if (now - handler.start > (0, _classPrivateFieldLooseBaseDefault.default)(this, _timeout)[_timeout]) {
                        try {
                            handler.callback(new Error(`No response received from RPC endpoint in ${(0, _classPrivateFieldLooseBaseDefault.default)(this, _timeout)[_timeout] / 1000}s`), undefined);
                        } catch  {}
                        (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.timeout++;
                        delete (0, _classPrivateFieldLooseBaseDefault.default)(this, _handlers)[_handlers][ids[i]];
                    }
                }
            }
        });
        const endpoints = Array.isArray(endpoint) ? endpoint : [
            endpoint
        ];
        if (endpoints.length === 0) throw new Error("WsProvider requires at least one Endpoint");
        endpoints.forEach((endpoint)=>{
            if (!/^(wss|ws):\/\//.test(endpoint)) throw new Error(`Endpoint should start with 'ws://', received '${endpoint}'`);
        });
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _eventemitter)[_eventemitter] = new (0, _eventemitter3Default.default)();
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _autoConnectMs)[_autoConnectMs] = autoConnectMs || 0;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _coder)[_coder] = new (0, _indexJs.RpcCoder)();
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _endpointIndex)[_endpointIndex] = -1;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _endpoints)[_endpoints] = endpoints;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _headers)[_headers] = headers;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket] = null;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats] = {
            active: {
                requests: 0,
                subscriptions: 0
            },
            total: {
                bytesRecv: 0,
                bytesSent: 0,
                cached: 0,
                errors: 0,
                requests: 0,
                subscriptions: 0,
                timeout: 0
            }
        };
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _timeout)[_timeout] = timeout || DEFAULT_TIMEOUT_MS;
        if (autoConnectMs > 0) this.connectWithRetry().catch(()=>{});
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _isReadyPromise)[_isReadyPromise] = new Promise((resolve)=>{
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _eventemitter)[_eventemitter].once("connected", ()=>{
                resolve(this);
            });
        });
    }
    /**
   * @summary `true` when this provider supports subscriptions
   */ get hasSubscriptions() {
        return true;
    }
    /**
   * @summary Whether the node is connected or not.
   * @return {boolean} true if connected
   */ get isConnected() {
        return (0, _classPrivateFieldLooseBaseDefault.default)(this, _isConnected)[_isConnected];
    }
    /**
   * @description Promise that resolves the first time we are connected and loaded
   */ get isReady() {
        return (0, _classPrivateFieldLooseBaseDefault.default)(this, _isReadyPromise)[_isReadyPromise];
    }
    /**
   * @description Returns a clone of the object
   */ clone() {
        return new WsProvider((0, _classPrivateFieldLooseBaseDefault.default)(this, _endpoints)[_endpoints]);
    }
    /**
   * @summary Manually connect
   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may
   * connect manually using this method.
   */ // eslint-disable-next-line @typescript-eslint/require-await
    async connect() {
        try {
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _endpointIndex)[_endpointIndex] = ((0, _classPrivateFieldLooseBaseDefault.default)(this, _endpointIndex)[_endpointIndex] + 1) % (0, _classPrivateFieldLooseBaseDefault.default)(this, _endpoints)[_endpoints].length; // the as typeof WebSocket here is Deno-specific - not available on the globalThis
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket] = typeof (0, _xGlobal.xglobal).WebSocket !== "undefined" && (0, _util.isChildClass)((0, _xGlobal.xglobal).WebSocket, (0, _xWs.WebSocket)) ? new (0, _xWs.WebSocket)((0, _classPrivateFieldLooseBaseDefault.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBaseDefault.default)(this, _endpointIndex)[_endpointIndex]]) // eslint-disable-next-line @typescript-eslint/ban-ts-comment
             : new (0, _xWs.WebSocket)((0, _classPrivateFieldLooseBaseDefault.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBaseDefault.default)(this, _endpointIndex)[_endpointIndex]], undefined, undefined, (0, _classPrivateFieldLooseBaseDefault.default)(this, _headers)[_headers], undefined, {
                // default: true
                fragmentOutgoingMessages: true,
                // default: 16K (bump, the Node has issues with too many fragments, e.g. on setCode)
                fragmentationThreshold: 1 * MEGABYTE,
                // default: 1MiB (also align with maxReceivedMessageSize)
                maxReceivedFrameSize: 24 * MEGABYTE,
                // default: 8MB (however Polkadot api.query.staking.erasStakers.entries(356) is over that, 16M is ok there)
                maxReceivedMessageSize: 24 * MEGABYTE
            });
            if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket]) {
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket].onclose = (0, _classPrivateFieldLooseBaseDefault.default)(this, _onSocketClose)[_onSocketClose];
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket].onerror = (0, _classPrivateFieldLooseBaseDefault.default)(this, _onSocketError)[_onSocketError];
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket].onmessage = (0, _classPrivateFieldLooseBaseDefault.default)(this, _onSocketMessage)[_onSocketMessage];
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket].onopen = (0, _classPrivateFieldLooseBaseDefault.default)(this, _onSocketOpen)[_onSocketOpen];
            } // timeout any handlers that have not had a response
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _timeoutId)[_timeoutId] = setInterval(()=>(0, _classPrivateFieldLooseBaseDefault.default)(this, _timeoutHandlers)[_timeoutHandlers](), TIMEOUT_INTERVAL);
        } catch (error) {
            l.error(error);
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _emit)[_emit]("error", error);
            throw error;
        }
    }
    /**
   * @description Connect, never throwing an error, but rather forcing a retry
   */ async connectWithRetry() {
        if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _autoConnectMs)[_autoConnectMs] > 0) try {
            await this.connect();
        } catch (error) {
            setTimeout(()=>{
                this.connectWithRetry().catch(()=>{});
            }, (0, _classPrivateFieldLooseBaseDefault.default)(this, _autoConnectMs)[_autoConnectMs]);
        }
    }
    /**
   * @description Manually disconnect from the connection, clearing auto-connect logic
   */ // eslint-disable-next-line @typescript-eslint/require-await
    async disconnect() {
        // switch off autoConnect, we are in manual mode now
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _autoConnectMs)[_autoConnectMs] = 0;
        try {
            if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket]) // 1000 - Normal closure; the connection successfully completed
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket].close(1000);
        } catch (error) {
            l.error(error);
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _emit)[_emit]("error", error);
            throw error;
        }
    }
    /**
   * @description Returns the connection stats
   */ get stats() {
        return {
            active: {
                requests: Object.keys((0, _classPrivateFieldLooseBaseDefault.default)(this, _handlers)[_handlers]).length,
                subscriptions: Object.keys((0, _classPrivateFieldLooseBaseDefault.default)(this, _subscriptions)[_subscriptions]).length
            },
            total: (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total
        };
    }
    /**
   * @summary Listens on events after having subscribed using the [[subscribe]] function.
   * @param  {ProviderInterfaceEmitted} type Event
   * @param  {ProviderInterfaceEmitCb}  sub  Callback
   * @return unsubscribe function
   */ on(type, sub) {
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _eventemitter)[_eventemitter].on(type, sub);
        return ()=>{
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _eventemitter)[_eventemitter].removeListener(type, sub);
        };
    }
    /**
   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.
   * @param method The RPC methods to execute
   * @param params Encoded parameters as applicable for the method
   * @param subscription Subscription details (internally used)
   */ send(method, params, isCacheable, subscription) {
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.requests++;
        const [id, body] = (0, _classPrivateFieldLooseBaseDefault.default)(this, _coder)[_coder].encodeJson(method, params);
        let resultPromise = isCacheable ? (0, _classPrivateFieldLooseBaseDefault.default)(this, _callCache)[_callCache].get(body) : null;
        if (!resultPromise) {
            resultPromise = (0, _classPrivateFieldLooseBaseDefault.default)(this, _send)[_send](id, body, method, params, subscription);
            if (isCacheable) (0, _classPrivateFieldLooseBaseDefault.default)(this, _callCache)[_callCache].set(body, resultPromise);
        } else (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.cached++;
        return resultPromise;
    }
    /**
   * @name subscribe
   * @summary Allows subscribing to a specific event.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const provider = new WsProvider('ws://127.0.0.1:9944');
   * const rpc = new Rpc(provider);
   *
   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {
   *   console.log(values)
   * }).then((subscriptionId) => {
   *   console.log('balance changes subscription id: ', subscriptionId)
   * })
   * ```
   */ subscribe(type, method, params, callback) {
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.subscriptions++; // subscriptions are not cached, LRU applies to .at(<blockHash>) only
        return this.send(method, params, false, {
            callback,
            type
        });
    }
    /**
   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].
   */ async unsubscribe(type, method, id) {
        const subscription = `${type}::${id}`; // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub
        // the assigned id now does not match what the API user originally received. It has
        // a slight complication in solving - since we cannot rely on the send id, but rather
        // need to find the actual subscription id to map it
        if ((0, _util.isUndefined)((0, _classPrivateFieldLooseBaseDefault.default)(this, _subscriptions)[_subscriptions][subscription])) {
            l.debug(()=>`Unable to find active subscription=${subscription}`);
            return false;
        }
        delete (0, _classPrivateFieldLooseBaseDefault.default)(this, _subscriptions)[_subscriptions][subscription];
        try {
            return this.isConnected && !(0, _util.isNull)((0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket]) ? this.send(method, [
                id
            ]) : true;
        } catch (error) {
            return false;
        }
    }
}
async function _send2(id, body, method, params, subscription) {
    return new Promise((resolve, reject)=>{
        try {
            if (!this.isConnected || (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket] === null) throw new Error("WebSocket is not connected");
            const callback = (error, result)=>{
                error ? reject(error) : resolve(result);
            };
            l.debug(()=>[
                    "calling",
                    method,
                    body
                ]);
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _handlers)[_handlers][id] = {
                callback,
                method,
                params,
                start: Date.now(),
                subscription
            };
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.bytesSent += body.length;
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _websocket)[_websocket].send(body);
        } catch (error) {
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _stats)[_stats].total.errors++;
            reject(error);
        }
    });
}

},{"@babel/runtime/helpers/esm/classPrivateFieldLooseBase":"gHEjb","@babel/runtime/helpers/esm/classPrivateFieldLooseKey":"90V54","eventemitter3":"3fnfh","@polkadot/util":"3HnHw","@polkadot/x-global":"k9Iwp","@polkadot/x-ws":"fGsOX","../coder/index.js":"hnZK5","../defaults.js":"384nS","../lru.js":"33o4q","./errors.js":"7XO2X","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3fnfh":[function(require,module,exports) {
"use strict";
var has = Object.prototype.hasOwnProperty, prefix = "~";
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */ function Events() {}
//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
    Events.prototype = Object.create(null);
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */ function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */ function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") throw new TypeError("The listener must be a function");
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [
        emitter._events[evt],
        listener
    ];
    return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */ function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */ function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */ EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for(name in events = this._events)if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
    return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */ EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [
        handlers.fn
    ];
    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;
    return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */ EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch(len){
            case 1:
                return listeners.fn.call(listeners.context), true;
            case 2:
                return listeners.fn.call(listeners.context, a1), true;
            case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];
        listeners.fn.apply(listeners.context, args);
    } else {
        var length = listeners.length, j;
        for(i = 0; i < length; i++){
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
            switch(len){
                case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                default:
                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];
                    listeners[i].fn.apply(listeners[i].context, args);
            }
        }
    }
    return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
        clearEvent(this, evt);
        return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
    } else {
        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
    }
    return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
    } else {
        this._events = new Events();
        this._eventsCount = 0;
    }
    return this;
};
//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;
//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;
module.exports = EventEmitter;

},{}],"fGsOX":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebSocket = void 0;
Object.defineProperty(exports, "packageInfo", {
    enumerable: true,
    get: function() {
        return _packageInfo.packageInfo;
    }
});
var _xGlobal = require("@polkadot/x-global");
var _packageInfo = require("./packageInfo");
// Copyright 2017-2022 @polkadot/x-ws authors & contributors
// SPDX-License-Identifier: Apache-2.0
const WebSocket = _xGlobal.xglobal.WebSocket;
exports.WebSocket = WebSocket;

},{"@polkadot/x-global":"k9Iwp","./packageInfo":"dhtOZ"}],"dhtOZ":[function(require,module,exports) {
"use strict";
var __dirname = "node_modules/@polkadot/x-ws/cjs";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.packageInfo = void 0;
// Copyright 2017-2022 @polkadot/x-ws authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
const packageInfo = {
    name: "@polkadot/x-ws",
    path: typeof __dirname === "string" ? __dirname : "auto",
    type: "cjs",
    version: "10.1.6"
};
exports.packageInfo = packageInfo;

},{}],"7XO2X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getWSErrorString", ()=>getWSErrorString);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
// from https://stackoverflow.com/questions/19304157/getting-the-reason-why-websockets-closed-with-close-code-1006
const known = {
    1000: "Normal Closure",
    1001: "Going Away",
    1002: "Protocol Error",
    1003: "Unsupported Data",
    1004: "(For future)",
    1005: "No Status Received",
    1006: "Abnormal Closure",
    1007: "Invalid frame payload data",
    1008: "Policy Violation",
    1009: "Message too big",
    1010: "Missing Extension",
    1011: "Internal Error",
    1012: "Service Restart",
    1013: "Try Again Later",
    1014: "Bad Gateway",
    1015: "TLS Handshake"
};
function getUnmapped(code) {
    if (code <= 1999) return "(For WebSocket standard)";
    else if (code <= 2999) return "(For WebSocket extensions)";
    else if (code <= 3999) return "(For libraries and frameworks)";
    else if (code <= 4999) return "(For applications)";
}
function getWSErrorString(code) {
    if (code >= 0 && code <= 999) return "(Unused)";
    return known[code] || getUnmapped(code) || "(Unknown)";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jyuF7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _scProviderJs = require("./ScProvider.js");
parcelHelpers.exportAll(_scProviderJs, exports);

},{"./ScProvider.js":"7oxVY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7oxVY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WellKnownChain", ()=>(0, _connect.WellKnownChain));
parcelHelpers.export(exports, "ScProvider", ()=>ScProvider);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _connect = require("@substrate/connect");
var _eventemitter3 = require("eventemitter3");
var _eventemitter3Default = parcelHelpers.interopDefault(_eventemitter3);
var _util = require("@polkadot/util");
var _indexJs = require("../coder/index.js");
var _healthJs = require("./Health.js");
// These methods have been taken from:
// https://github.com/paritytech/smoldot/blob/17425040ddda47d539556eeaf62b88c4240d1d42/src/json_rpc/methods.rs#L338-L462
// It's important to take into account that smoldot is adding support to the new
// json-rpc-interface https://paritytech.github.io/json-rpc-interface-spec/
// However, at the moment this list only includes methods that belong to the "old" API
const subscriptionUnsubscriptionMethods = new Map([
    [
        "author_submitAndWatchExtrinsic",
        "author_unwatchExtrinsic"
    ],
    [
        "chain_subscribeAllHeads",
        "chain_unsubscribeAllHeads"
    ],
    [
        "chain_subscribeFinalizedHeads",
        "chain_unsubscribeFinalizedHeads"
    ],
    [
        "chain_subscribeFinalisedHeads",
        "chain_subscribeFinalisedHeads"
    ],
    [
        "chain_subscribeNewHeads",
        "chain_unsubscribeNewHeads"
    ],
    [
        "chain_subscribeNewHead",
        "chain_unsubscribeNewHead"
    ],
    [
        "chain_subscribeRuntimeVersion",
        "chain_unsubscribeRuntimeVersion"
    ],
    [
        "subscribe_newHead",
        "unsubscribe_newHead"
    ],
    [
        "state_subscribeRuntimeVersion",
        "state_unsubscribeRuntimeVersion"
    ],
    [
        "state_subscribeStorage",
        "state_unsubscribeStorage"
    ]
]);
const wellKnownChains = new Set(Object.values((0, _connect.WellKnownChain)));
const scClients = new WeakMap();
class ScProvider {
    #coder = new (0, _indexJs.RpcCoder)();
    #spec;
    #sharedSandbox;
    #subscriptions = new Map();
    #requests = new Map();
    #eventemitter = new (0, _eventemitter3Default.default)();
    #chain = null;
    #isChainReady = false;
    constructor(spec, sharedSandbox){
        this.#spec = spec;
        this.#sharedSandbox = sharedSandbox;
    }
    get hasSubscriptions() {
        // Indicates that subscriptions are supported
        return true;
    }
    get isConnected() {
        return !!this.#chain && this.#isChainReady;
    }
    clone() {
        throw new Error("clone() is not supported.");
    }
    // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts
    async connect(config, checkerFactory = (0, _healthJs.healthChecker)) {
        if (this.isConnected) throw new Error("Already connected!");
         // it could happen that after emitting `disconnected` due to the fact taht
        // smoldot is syncing, the consumer tries to reconnect after a certain amount
        // of time... In which case we want to make sure that we don't create a new
        // chain.
        if (this.#chain) {
            await this.#chain;
            return;
        }
        if (this.#sharedSandbox && !this.#sharedSandbox.isConnected) await this.#sharedSandbox.connect();
        const client = this.#sharedSandbox ? scClients.get(this.#sharedSandbox) : (0, _connect.createScClient)(config);
        if (!client) throw new Error("Unkown ScProvider!");
        scClients.set(this, client);
        const hc = checkerFactory();
        const onResponse = (res)=>{
            var _response$params, _this$subscriptions$g;
            const hcRes = hc.responsePassThrough(res);
            if (!hcRes) return;
            const response = JSON.parse(hcRes);
            let decodedResponse;
            try {
                decodedResponse = this.#coder.decodeResponse(response);
            } catch (e) {
                decodedResponse = e;
            } // It's not a subscription message, but rather a standar RPC response
            if (((_response$params = response.params) === null || _response$params === void 0 ? void 0 : _response$params.subscription) === undefined || !response.method) {
                var _this$requests$get;
                return (_this$requests$get = this.#requests.get(response.id)) === null || _this$requests$get === void 0 ? void 0 : _this$requests$get(decodedResponse);
            } // We are dealing with a subscription message
            const subscriptionId = `${response.method}::${response.params.subscription}`;
            const callback = (_this$subscriptions$g = this.#subscriptions.get(subscriptionId)) === null || _this$subscriptions$g === void 0 ? void 0 : _this$subscriptions$g[0];
            callback === null || callback === void 0 || callback(decodedResponse);
        };
        const addChain = wellKnownChains.has(this.#spec) ? client.addWellKnownChain : client.addChain;
        this.#chain = addChain(this.#spec, onResponse).then((chain)=>{
            hc.setSendJsonRpc(chain.sendJsonRpc);
            this.#isChainReady = false;
            const cleanup = ()=>{
                // If there are any callbacks left, we have to reject/error them.
                // Otherwise, that would cause a memory leak.
                const disconnectionError = new Error("Disconnected");
                this.#requests.forEach((cb)=>cb(disconnectionError));
                this.#subscriptions.forEach(([cb])=>cb(disconnectionError));
                this.#subscriptions.clear();
            };
            const staleSubscriptions = [];
            const killStaleSubscriptions = ()=>{
                if (staleSubscriptions.length === 0) return;
                const stale = staleSubscriptions.pop();
                if (!stale) throw new Error("Unable to get stale subscription");
                const { id , unsubscribeMethod  } = stale;
                Promise.race([
                    this.send(unsubscribeMethod, [
                        id
                    ]).catch(()=>undefined),
                    new Promise((resolve)=>setTimeout(resolve, 500))
                ]).then(killStaleSubscriptions).catch(()=>undefined);
            };
            hc.start((health)=>{
                const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers); // if it's the same as before, then nothing has changed and we are done
                if (this.#isChainReady === isReady) return;
                this.#isChainReady = isReady;
                if (!isReady) {
                    // If we've reached this point, that means that the chain used to be "ready"
                    // and now we are about to emit `disconnected`.
                    //
                    // This will cause the PolkadotJs API think that the connection is
                    // actually dead. In reality the smoldot chain is not dead, of course.
                    // However, we have to cleanup all the existing callbacks because when
                    // the smoldot chain stops syncing, then we will emit `connected` and
                    // the PolkadotJs API will try to re-create the previous
                    // subscriptions and requests. Although, now is not a good moment
                    // to be sending unsubscription messages to the smoldot chain, we
                    // should wait until is no longer syncing to send the unsubscription
                    // messages from the stale subscriptions of the previous connection.
                    //
                    // That's why -before we perform the cleanup of `this.#subscriptions`-
                    // we keep the necessary information that we will need later on to
                    // kill the stale subscriptions.
                    [
                        ...this.#subscriptions.values()
                    ].forEach((s)=>{
                        staleSubscriptions.push(s[1]);
                    });
                    cleanup();
                } else killStaleSubscriptions();
                this.#eventemitter.emit(isReady ? "connected" : "disconnected");
            });
            return {
                ...chain,
                remove: ()=>{
                    hc.stop();
                    chain.remove();
                    cleanup();
                },
                sendJsonRpc: hc.sendJsonRpc.bind(hc)
            };
        });
        try {
            await this.#chain;
        } catch (e) {
            this.#chain = null;
            this.#eventemitter.emit("error", e);
            throw e;
        }
    }
    async disconnect() {
        if (!this.#chain) return;
        const chain = await this.#chain;
        this.#chain = null;
        this.#isChainReady = false;
        try {
            chain.remove();
        } catch (_) {}
        this.#eventemitter.emit("disconnected");
    }
    on(type, sub) {
        // It's possible. Although, quite unlikely, that by the time that polkadot
        // subscribes to the `connected` event, the Provider is already connected.
        // In that case, we must emit to let the consumer know that we are connected.
        if (type === "connected" && this.isConnected) sub();
        this.#eventemitter.on(type, sub);
        return ()=>{
            this.#eventemitter.removeListener(type, sub);
        };
    }
    async send(method, params) {
        if (!this.isConnected || !this.#chain) throw new Error("Provider is not connected");
        const chain = await this.#chain;
        const [id, json] = this.#coder.encodeJson(method, params);
        const result = new Promise((resolve, reject)=>{
            this.#requests.set(id, (response)=>{
                ((0, _util.isError)(response) ? reject : resolve)(response);
            });
            try {
                chain.sendJsonRpc(json);
            } catch (e) {
                this.#chain = null;
                try {
                    chain.remove();
                } catch (_) {}
                this.#eventemitter.emit("error", e);
            }
        });
        try {
            return await result;
        } finally{
            // let's ensure that once the Promise is resolved/rejected, then we remove
            // remove its entry from the internal #requests
            this.#requests.delete(id);
        }
    }
    async subscribe(type, method, params, callback) {
        if (!subscriptionUnsubscriptionMethods.has(method)) throw new Error(`Unsupported subscribe method: ${method}`);
        const id = await this.send(method, params);
        const subscriptionId = `${type}::${id}`;
        const cb = (response)=>{
            if (response instanceof Error) callback(response, undefined);
            else callback(null, response);
        };
        const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);
        if (!unsubscribeMethod) throw new Error("Invalid unsubscribe method found");
        this.#subscriptions.set(subscriptionId, [
            cb,
            {
                id,
                unsubscribeMethod
            }
        ]);
        return id;
    }
    unsubscribe(type, method, id) {
        if (!this.isConnected) throw new Error("Provider is not connected");
        const subscriptionId = `${type}::${id}`;
        if (!this.#subscriptions.has(subscriptionId)) return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));
        this.#subscriptions.delete(subscriptionId);
        return this.send(method, [
            id
        ]);
    }
}

},{"@substrate/connect":"5VIDT","eventemitter3":"3fnfh","@polkadot/util":"3HnHw","../coder/index.js":"hnZK5","./Health.js":"9748M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5VIDT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The substrate-connect package makes it possible to connect to Substrate-compatible blockchains with a light client.
 *
 * Connecting to a chain is done in two steps:
 *
 * 1. Call {@link createScClient}, which gives you a so-called *client*.
 * 2. Call {@link addChain} or {@link addWellKnownChain} on this client.
 *
 * Note that this library is a low-level library where you directly send JSON-RPC requests and
 * receive responses.
 * For a high-level library build on top of `substrate-connect` you can use
 * {@link https://github.com/polkadot-js/api/tree/master/packages/rpc-provider | polkadot/rpc-provider/substrate-connect}
 *
 * # Adding parachains
 *
 * Connecting to a parachain is done the same way as connecting to a standalone chain: obtaining
 * a client then calling {@link addChain}.
 *
 * However, if you call {@link addChain} with a parachain chain specification, you **must** have
 * connected to its corresponding relay chain beforehand (using {@link addChain} or {@link addWellKnownChain}).
 * Failing to do so will lead to an error at the initialization of the parachain.
 *
 * Furthermore, the parachain must be added to the same client object as the one the relay chain
 * was added to.
 *
 * In other words, this will work:
 *
 * ```js
 * const client = createScClient();
 * await client.addChain(relayChain);
 * await client.addChain(parachain);
 * ```
 *
 * While this will **not** work, and an exception will be thrown when adding the parachain:
 *
 * ```js
 * await createScClient().addChain(relayChain);
 * await createScClient().addChain(parachain);
 * ```
 *
 * # Resources sharing
 *
 * While calling {@link createScClient} multiple times leads to a different observable behaviour
 * when it comes to parachains (see previous section), internally resources are shared
 * between all the clients.
 *
 * In order words, it is not a problem to do this:
 *
 * ```js
 * const relayChain = ...;
 * const chain1 = await createScClient().addChain(relayChain);
 * const chain2 = await createScClient().addChain(relayChain);
 * ```
 *
 * From an API perspective, `chain1` and `chain2` should be treated as two completely separate
 * connections to the same chain. Internally, however, only one "actual" connection to that chain
 * will exist.
 *
 * This means that there is no problem in calling {@link createScClient} from within a library for
 * example.
 *
 * # Well-known chains
 *
 * This package contains a list of so-called {@link WellKnownChain}s. This is a list of popular chains
 * that users are likely to connect to. Instead of calling `addChain` with a chain specification,
 * one can call `addWellKnownChain`, passing only the name of a well-known chain as parameter.
 *
 * Using {@link WellKnownChain}s doesn't provide any benefit when the substrate-connect extension is not
 * installed.
 *
 * If, however, the substrate-connect extension is installed, using {@link addWellKnownChain} has several
 * benefits:
 *
 * - The web page that uses substrate-connect doesn't need to download the chain specification of
 * a well-known chain from the web server, as this chain specification is already known by the
 * extension.
 * - The extension starts connect to well-known chains when the browser initializes, meaning that
 * when {@link addWellKnownChain} is called, it is likely that the chain in question has already been
 * fully synchronized.
 * - Furthermore, the extension stores the state of all the well-known chains in the browser's
 * local storage. This leads to a very quick initialization time.
 *
 * @packageDocumentation
 */ parcelHelpers.export(exports, "WellKnownChain", ()=>(0, _wellKnownChainJs.WellKnownChain));
var _wellKnownChainJs = require("./WellKnownChain.js");
var _indexJs = require("./connector/index.js");
parcelHelpers.exportAll(_indexJs, exports);

},{"./WellKnownChain.js":"fngsF","./connector/index.js":"3Z3Ip","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fngsF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WellKnownChain", ()=>WellKnownChain);
var WellKnownChain;
(function(WellKnownChain) {
    WellKnownChain["polkadot"] = "polkadot";
    WellKnownChain["ksmcc3"] = "ksmcc3";
    WellKnownChain["rococo_v2_2"] = "rococo_v2_2";
    WellKnownChain["westend2"] = "westend2";
})(WellKnownChain || (WellKnownChain = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Z3Ip":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isExtensionPresent", ()=>isExtensionPresent);
/**
 * Returns a {@link ScClient} that connects to chains, either through the substrate-connect
 * extension or by executing a light client directly from JavaScript, depending on whether the
 * extension is installed and available.
 */ parcelHelpers.export(exports, "createScClient", ()=>createScClient);
var _smoldotLightJs = require("./smoldot-light.js");
var _extensionJs = require("./extension.js");
var _connectExtensionProtocol = require("@substrate/connect-extension-protocol");
var _typesJs = require("./types.js");
parcelHelpers.exportAll(_typesJs, exports);
const isExtensionPresent = typeof document === "object" && typeof document.getElementById === "function" && !!document.getElementById((0, _connectExtensionProtocol.DOM_ELEMENT_ID));
function createScClient(config) {
    const forceEmbedded = config === null || config === void 0 ? void 0 : config.forceEmbeddedNode;
    if (!forceEmbedded && isExtensionPresent) return (0, _extensionJs.createScClient)();
    return (0, _smoldotLightJs.createScClient)(config === null || config === void 0 ? void 0 : config.embeddedNodeConfig);
}

},{"./smoldot-light.js":"XQAbc","./extension.js":"5jVO6","@substrate/connect-extension-protocol":"8eKwl","./types.js":"lQiKh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"XQAbc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createScClient", ()=>createScClient);
var _indexJs = require("./specs/index.js");
var _typesJs = require("./types.js");
let startPromise = null;
const getStart = ()=>{
    if (startPromise) return startPromise;
    startPromise = require("e7b6ba636d148ccb").then((sm)=>sm.start);
    return startPromise;
};
const clientReferences = []; // Note that this can't be a set, as the same config is added/removed multiple times
let clientPromise = null;
let clientReferencesMaxLogLevel = 3;
const getClientAndIncRef = (config)=>{
    if (config.maxLogLevel && config.maxLogLevel > clientReferencesMaxLogLevel) clientReferencesMaxLogLevel = config.maxLogLevel;
    if (clientPromise) {
        clientReferences.push(config);
        if (clientPromise instanceof Promise) return clientPromise;
        else return Promise.resolve(clientPromise);
    }
    const newClientPromise = getStart().then((start)=>start({
            forbidTcp: true,
            forbidNonLocalWs: true,
            maxLogLevel: 9999999,
            cpuRateLimit: 0.5,
            logCallback: (level, target, message)=>{
                if (level > clientReferencesMaxLogLevel) return;
                // The first parameter of the methods of `console` has some printf-like substitution
                // capabilities. We don't really need to use this, but not using it means that the logs
                // might not get printed correctly if they contain `%`.
                if (level <= 1) console.error("[%s] %s", target, message);
                else if (level === 2) console.warn("[%s] %s", target, message);
                else if (level === 3) console.info("[%s] %s", target, message);
                else if (level === 4) console.debug("[%s] %s", target, message);
                else console.trace("[%s] %s", target, message);
            }
        }));
    clientPromise = newClientPromise;
    newClientPromise.then((client)=>{
        // Make sure that the client we have just created is still desired
        if (clientPromise === newClientPromise) clientPromise = client;
        else client.terminate();
        // Note that if clientPromise != newClientPromise we know for sure that the client that we
        // return isn't going to be used. We would rather not return a terminated client, but this
        // isn't possible for type check reasons.
        return client;
    });
    clientReferences.push(config);
    return clientPromise;
};
// Must be passed the exact same object as was passed to {getClientAndIncRef}
const decRef = (config)=>{
    const idx = clientReferences.indexOf(config);
    if (idx === -1) throw new Error("Internal error within smoldot-light");
    clientReferences.splice(idx, 1);
    // Update `clientReferencesMaxLogLevel`
    // Note how it is set back to 3 if there is no reference anymore
    clientReferencesMaxLogLevel = 3;
    for (const cfg of clientReferences.values())if (cfg.maxLogLevel && cfg.maxLogLevel > clientReferencesMaxLogLevel) clientReferencesMaxLogLevel = cfg.maxLogLevel;
    if (clientReferences.length === 0) {
        if (clientPromise && !(clientPromise instanceof Promise)) clientPromise.terminate();
        clientPromise = null;
    }
};
const transformErrors = (thunk)=>{
    try {
        thunk();
    } catch (e) {
        const error = e;
        if ((error === null || error === void 0 ? void 0 : error.name) === "JsonRpcDisabledError") throw new (0, _typesJs.JsonRpcDisabledError)();
        if ((error === null || error === void 0 ? void 0 : error.name) === "CrashError") throw new (0, _typesJs.CrashError)(error.message);
        if ((error === null || error === void 0 ? void 0 : error.name) === "AlreadyDestroyedError") throw new (0, _typesJs.AlreadyDestroyedError)();
        throw new (0, _typesJs.CrashError)(e instanceof Error ? e.message : `Unexpected error ${e}`);
    }
};
const createScClient = (config)=>{
    const configOrDefault = config || {
        maxLogLevel: 3
    };
    const chains = new Map();
    const addChain = async (chainSpec, jsonRpcCallback)=>{
        const client = await getClientAndIncRef(configOrDefault);
        try {
            const internalChain = await client.addChain({
                chainSpec,
                potentialRelayChains: [
                    ...chains.values()
                ],
                jsonRpcCallback
            });
            const chain = {
                sendJsonRpc: (rpc)=>{
                    transformErrors(()=>{
                        internalChain.sendJsonRpc(rpc);
                    });
                },
                remove: ()=>{
                    try {
                        transformErrors(()=>{
                            internalChain.remove();
                        });
                    } finally{
                        chains.delete(chain);
                        decRef(configOrDefault);
                    }
                }
            };
            chains.set(chain, internalChain);
            return chain;
        } catch (error) {
            decRef(configOrDefault);
            throw error;
        }
    };
    const addWellKnownChain = async (supposedChain, jsonRpcCallback)=>{
        // the following line ensures that the http request for the dynamic import
        // of smoldot-light and the request for the dynamic import of the spec
        // happen in parallel
        getClientAndIncRef(configOrDefault);
        try {
            const spec = await (0, _indexJs.getSpec)(supposedChain);
            return await addChain(spec, jsonRpcCallback);
        } finally{
            decRef(configOrDefault);
        }
    };
    return {
        addChain,
        addWellKnownChain
    };
};

},{"./specs/index.js":"4fARU","./types.js":"lQiKh","e7b6ba636d148ccb":"iyuNM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4fARU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSpec", ()=>getSpec);
async function getSpec(chain) {
    // We don't want API users to be able to `import` a file outside of the `generated` directory.
    // While it is probably harmless, better be safe than sorry.
    // This is done by make sure that the name doesn't contain `..`. This also means that we can't
    // support well-known chain whose name contains `..`, but that seems unlikely to ever be
    // problematic.
    if (chain.indexOf("..") !== -1) throw new Error("Invalid chain name");
    try {
        const specRaw = await require("./generated/" + chain + ".js");
        return typeof specRaw === "string" ? specRaw : specRaw.default;
    } catch (error) {
        throw new Error("Invalid chain name");
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lQiKh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlreadyDestroyedError", ()=>AlreadyDestroyedError);
parcelHelpers.export(exports, "CrashError", ()=>CrashError);
parcelHelpers.export(exports, "JsonRpcDisabledError", ()=>JsonRpcDisabledError);
class AlreadyDestroyedError extends Error {
    constructor(){
        super();
        this.name = "AlreadyDestroyedError";
    }
}
class CrashError extends Error {
    constructor(message){
        super(message);
        this.name = "CrashError";
    }
}
class JsonRpcDisabledError extends Error {
    constructor(){
        super();
        this.name = "JsonRpcDisabledError";
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iyuNM":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require("./helpers/bundle-url").getBundleURL("lPpKD") + "index-browser.a565ff14.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("2h6MY"));

},{"./helpers/browser/js-loader":"61B45","./helpers/bundle-url":"lgJ39"}],"61B45":[function(require,module,exports) {
"use strict";
var cacheLoader = require("../cacheLoader");
module.exports = cacheLoader(function(bundle) {
    return new Promise(function(resolve, reject) {
        // Don't insert the same script twice (e.g. if it was already in the HTML)
        var existingScripts = document.getElementsByTagName("script");
        if ([].concat(existingScripts).some(function isCurrentBundle(script) {
            return script.src === bundle;
        })) {
            resolve();
            return;
        }
        var preloadLink = document.createElement("link");
        preloadLink.href = bundle;
        preloadLink.rel = "preload";
        preloadLink.as = "script";
        document.head.appendChild(preloadLink);
        var script = document.createElement("script");
        script.async = true;
        script.type = "text/javascript";
        script.src = bundle;
        script.onerror = function(e) {
            var error = new TypeError("Failed to fetch dynamically imported module: ".concat(bundle, ". Error: ").concat(e.message));
            script.onerror = script.onload = null;
            script.remove();
            reject(error);
        };
        script.onload = function() {
            script.onerror = script.onload = null;
            resolve();
        };
        document.getElementsByTagName("head")[0].appendChild(script);
    });
});

},{"../cacheLoader":"j49pS"}],"j49pS":[function(require,module,exports) {
"use strict";
var cachedBundles = {};
var cachedPreloads = {};
var cachedPrefetches = {};
function getCache(type) {
    switch(type){
        case "preload":
            return cachedPreloads;
        case "prefetch":
            return cachedPrefetches;
        default:
            return cachedBundles;
    }
}
module.exports = function(loader, type) {
    return function(bundle) {
        var cache = getCache(type);
        if (cache[bundle]) return cache[bundle];
        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {
            delete cache[bundle];
            throw e;
        });
    };
};

},{}],"lgJ39":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"5jVO6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createScClient", ()=>createScClient);
var _typesJs = require("./types.js");
var _indexJs = require("./specs/index.js");
const listeners = new Map();
if (typeof window === "object") window.addEventListener("message", ({ data  })=>{
    var _a;
    if ((data === null || data === void 0 ? void 0 : data.origin) !== "substrate-connect-extension") return;
    (_a = listeners.get(data.chainId)) === null || _a === void 0 || _a(data);
});
function getRandomChainId() {
    const arr = new BigUint64Array(2);
    // It can only be used from the browser, so this is fine.
    crypto.getRandomValues(arr);
    const result = arr[1] << BigInt(64) | arr[0];
    return result.toString(36);
}
const createScClient = ()=>{
    const chains = new Map();
    const internalAddChain = async (isWellKnown, chainSpecOrWellKnownName, jsonRpcCallback, potentialRelayChainIds = [])=>{
        let resolve;
        const initFinished = new Promise((res)=>{
            resolve = ()=>res(null);
        });
        const chainState = {
            id: getRandomChainId(),
            state: {
                state: "pending",
                waitFinished: resolve
            }
        };
        if (listeners.has(chainState.id)) throw new Error("Unexpectedly randomly generated the same chain ID twice despite 64bits of entropy");
        // Setup the listener for this chain.
        // This listener should never be removed until we are no longer interested in this chain.
        // Removing then re-adding the listener could cause messages to be missed.
        listeners.set(chainState.id, (msg)=>{
            switch(chainState.state.state){
                case "pending":
                    {
                        const waitFinished = chainState.state.waitFinished;
                        switch(msg.type){
                            case "chain-ready":
                                chainState.state = {
                                    state: "ok"
                                };
                                break;
                            case "error":
                                chainState.state = {
                                    state: "dead",
                                    error: new (0, _typesJs.CrashError)("Error while creating the chain: " + msg.errorMessage)
                                };
                                break;
                            default:
                                // Unexpected message. We ignore it.
                                // While it could be tempting to switch the chain to `dead`, the extension might
                                // think that the chain is still alive, and the state mismatch could have
                                // unpredictable and confusing consequences.
                                console.warn("Unexpected message of type `msg.type` received from substrate-connect extension");
                        }
                        waitFinished();
                        break;
                    }
                case "ok":
                    switch(msg.type){
                        case "error":
                            chainState.state = {
                                state: "dead",
                                error: new (0, _typesJs.CrashError)("Extension has killed the chain: " + msg.errorMessage)
                            };
                            break;
                        case "rpc":
                            if (jsonRpcCallback) jsonRpcCallback(msg.jsonRpcMessage);
                            else console.warn("Unexpected message of type `msg.type` received from substrate-connect extension");
                            break;
                        default:
                            // Unexpected message. We ignore it.
                            // While it could be tempting to switch the chain to `dead`, the extension might
                            // think that the chain is still alive, and the state mismatch could have
                            // unpredictable and confusing consequences.
                            console.warn("Unexpected message of type `msg.type` received from substrate-connect extension");
                    }
                    break;
                case "dead":
                    break;
            }
        });
        // Now that everything is ready to receive messages back from the extension, send the
        // add-chain message.
        if (isWellKnown) postToExtension({
            origin: "substrate-connect-client",
            chainId: chainState.id,
            type: "add-well-known-chain",
            chainName: chainSpecOrWellKnownName
        });
        else postToExtension({
            origin: "substrate-connect-client",
            chainId: chainState.id,
            type: "add-chain",
            chainSpec: chainSpecOrWellKnownName,
            potentialRelayChainIds
        });
        // Wait for the extension to send back either a confirmation or an error.
        // Note that `initFinished` becomes ready when `chainState` has been modified. The outcome
        // can be known by looking into `chainState`.
        await initFinished;
        // In the situation where we tried to create a well-known chain, the extension isn't supposed
        // to ever return an error. There is however one situation where errors can happen: if the
        // extension doesn't recognize the desired well-known chain because it uses a different list
        // of well-known chains than this code. To handle this, we download the chain spec of the
        // desired well-known chain and try again but this time as a non-well-known chain.
        if (isWellKnown && chainState.state.state === "dead") {
            // Note that we keep the same id for the chain for convenience.
            let resolve1;
            const initFinished1 = new Promise((res)=>{
                resolve1 = ()=>res(null);
            });
            chainState.state = {
                state: "pending",
                waitFinished: resolve1
            };
            postToExtension({
                origin: "substrate-connect-client",
                chainId: chainState.id,
                type: "add-chain",
                chainSpec: await (0, _indexJs.getSpec)(chainSpecOrWellKnownName),
                potentialRelayChainIds: []
            });
            await initFinished1;
        }
        // Now check the `chainState` to know if things have succeeded.
        if (chainState.state.state === "dead") throw chainState.state.error;
        // Everything is successful.
        const chain = {
            sendJsonRpc: (jsonRpcMessage)=>{
                if (chainState.state.state === "dead") throw chainState.state.error;
                if (!jsonRpcCallback) throw new (0, _typesJs.JsonRpcDisabledError)();
                postToExtension({
                    origin: "substrate-connect-client",
                    chainId: chainState.id,
                    type: "rpc",
                    jsonRpcMessage
                });
            },
            remove: ()=>{
                if (chainState.state.state === "dead") throw chainState.state.error;
                chainState.state = {
                    state: "dead",
                    error: new (0, _typesJs.AlreadyDestroyedError)()
                };
                listeners.delete(chainState.id);
                chains.delete(chain);
                postToExtension({
                    origin: "substrate-connect-client",
                    chainId: chainState.id,
                    type: "remove-chain"
                });
            }
        };
        // This mapping of chains is kept just for the `potentialRelayChainIds` field.
        chains.set(chain, chainState.id);
        return chain;
    };
    return {
        addChain: (chainSpec, jsonRpcCallback)=>internalAddChain(false, chainSpec, jsonRpcCallback, [
                ...chains.values()
            ]),
        addWellKnownChain: (name, jsonRpcCallback)=>internalAddChain(true, name, jsonRpcCallback)
    };
};
// Sends a message to the extension. This function primarly exists in order to provide strong
// typing for the message.
function postToExtension(msg) {
    window.postMessage(msg, "*");
}

},{"./types.js":"lQiKh","./specs/index.js":"4fARU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8eKwl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DOM_ELEMENT_ID", ()=>DOM_ELEMENT_ID);
const DOM_ELEMENT_ID = "substrateConnectExtensionAvailable";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9748M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
/*
 * Creates a new health checker.
 *
 * The role of the health checker is to report to the user the health of a smoldot chain.
 *
 * In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the
 * way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use
 * `start()` in order to start the health checks. The `start()` function must be passed a callback called
 * when an update to the health of the node is available.
 *
 * In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function
 * of the health checker. The health checker rewrites the `id` of the requests it receives.
 *
 * When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This
 * function intercepts the responses destined to the requests that have been emitted by the health
 * checker and returns `null`. If the response doesn't concern the health checker, the response is
 * simply returned by the function.
 *
 * # How it works
 *
 * The health checker periodically calls the `system_health` JSON-RPC call in order to determine
 * the health of the chain.
 *
 * In addition to this, as long as the health check reports that `isSyncing` is `true`, the
 * health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.
 * Whenever a new block is notified, a health check is performed immediately in order to determine
 * whether `isSyncing` has changed to `false`.
 *
 * Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to
 * `isSyncing: false` is very low.
 *
 */ parcelHelpers.export(exports, "healthChecker", ()=>healthChecker);
parcelHelpers.export(exports, "HealthCheckError", ()=>HealthCheckError);
function healthChecker() {
    // `null` if health checker is not started.
    let checker = null;
    let sendJsonRpc = null;
    return {
        responsePassThrough: (jsonRpcResponse)=>{
            if (checker === null) return jsonRpcResponse;
            return checker.responsePassThrough(jsonRpcResponse);
        },
        sendJsonRpc: (request)=>{
            if (!sendJsonRpc) throw new Error("setSendJsonRpc must be called before sending requests");
            if (checker === null) sendJsonRpc(request);
            else checker.sendJsonRpc(request);
        },
        setSendJsonRpc: (cb)=>{
            sendJsonRpc = cb;
        },
        start: (healthCallback)=>{
            if (checker !== null) throw new Error("Can't start the health checker multiple times in parallel");
            else if (!sendJsonRpc) throw new Error("setSendJsonRpc must be called before starting the health checks");
            checker = new InnerChecker(healthCallback, sendJsonRpc);
            checker.update(true);
        },
        stop: ()=>{
            if (checker === null) return;
             // Already stopped.
            checker.destroy();
            checker = null;
        }
    };
}
class InnerChecker {
    #healthCallback;
    #currentHealthCheckId = null;
    #currentHealthTimeout = null;
    #currentSubunsubRequestId = null;
    #currentSubscriptionId = null;
    #requestToSmoldot;
    #isSyncing = false;
    #nextRequestId = 0;
    constructor(healthCallback, requestToSmoldot){
        this.#healthCallback = healthCallback;
        this.#requestToSmoldot = requestToSmoldot;
    }
    sendJsonRpc = (request)=>{
        // Replace the `id` in the request to prefix the request ID with `extern:`.
        let parsedRequest;
        try {
            parsedRequest = JSON.parse(request);
        } catch (err) {
            return;
        }
        if (parsedRequest.id) {
            const newId = "extern:" + JSON.stringify(parsedRequest.id);
            parsedRequest.id = newId;
        }
        this.#requestToSmoldot(JSON.stringify(parsedRequest));
    };
    responsePassThrough = (jsonRpcResponse)=>{
        let parsedResponse;
        try {
            parsedResponse = JSON.parse(jsonRpcResponse);
        } catch (err) {
            return jsonRpcResponse;
        } // Check whether response is a response to `system_health`.
        if (parsedResponse.id && this.#currentHealthCheckId === parsedResponse.id) {
            this.#currentHealthCheckId = null; // Check whether query was successful. It is possible for queries to fail for
            // various reasons, such as the client being overloaded.
            if (!parsedResponse.result) {
                this.update(false);
                return null;
            }
            this.#healthCallback(parsedResponse.result);
            this.#isSyncing = parsedResponse.result.isSyncing;
            this.update(false);
            return null;
        } // Check whether response is a response to the subscription or unsubscription.
        if (parsedResponse.id && this.#currentSubunsubRequestId === parsedResponse.id) {
            this.#currentSubunsubRequestId = null; // Check whether query was successful. It is possible for queries to fail for
            // various reasons, such as the client being overloaded.
            if (!parsedResponse.result) {
                this.update(false);
                return null;
            }
            if (this.#currentSubscriptionId) this.#currentSubscriptionId = null;
            else this.#currentSubscriptionId = parsedResponse.result;
            this.update(false);
            return null;
        } // Check whether response is a notification to a subscription.
        if (parsedResponse.params && this.#currentSubscriptionId && parsedResponse.params.subscription === this.#currentSubscriptionId) {
            // Note that after a successful subscription, a notification containing
            // the current best block is always returned. Considering that a
            // subscription is performed in response to a health check, calling
            // `startHealthCheck()` here will lead to a second health check.
            // It might seem redundant to perform two health checks in a quick
            // succession, but doing so doesn't lead to any problem, and it is
            // actually possible for the health to have changed in between as the
            // current best block might have been updated during the subscription
            // request.
            this.update(true);
            return null;
        } // Response doesn't concern us.
        if (parsedResponse.id) {
            const id = parsedResponse.id; // Need to remove the `extern:` prefix.
            if (!id.startsWith("extern:")) throw new Error("State inconsistency in health checker");
            const newId = JSON.parse(id.slice(7));
            parsedResponse.id = newId;
        }
        return JSON.stringify(parsedResponse);
    };
    update = (startNow)=>{
        // If `startNow`, clear `#currentHealthTimeout` so that it is set below.
        if (startNow && this.#currentHealthTimeout) {
            clearTimeout(this.#currentHealthTimeout);
            this.#currentHealthTimeout = null;
        }
        if (!this.#currentHealthTimeout) {
            const startHealthRequest = ()=>{
                this.#currentHealthTimeout = null; // No matter what, don't start a health request if there is already one in progress.
                // This is sane to do because receiving a response to a health request calls `update()`.
                if (this.#currentHealthCheckId) return;
                 // Actual request starting.
                this.#currentHealthCheckId = "health-checker:".concat(this.#nextRequestId.toString());
                this.#nextRequestId += 1;
                this.#requestToSmoldot(JSON.stringify({
                    id: this.#currentHealthCheckId,
                    jsonrpc: "2.0",
                    method: "system_health",
                    params: []
                }));
            };
            if (startNow) startHealthRequest();
            else this.#currentHealthTimeout = setTimeout(startHealthRequest, 1000);
        }
        if (this.#isSyncing && !this.#currentSubscriptionId && !this.#currentSubunsubRequestId) this.startSubscription();
        if (!this.#isSyncing && this.#currentSubscriptionId && !this.#currentSubunsubRequestId) this.endSubscription();
    };
    startSubscription = ()=>{
        if (this.#currentSubunsubRequestId || this.#currentSubscriptionId) throw new Error("Internal error in health checker");
        this.#currentSubunsubRequestId = "health-checker:".concat(this.#nextRequestId.toString());
        this.#nextRequestId += 1;
        this.#requestToSmoldot(JSON.stringify({
            id: this.#currentSubunsubRequestId,
            jsonrpc: "2.0",
            method: "chain_subscribeNewHeads",
            params: []
        }));
    };
    endSubscription = ()=>{
        if (this.#currentSubunsubRequestId || !this.#currentSubscriptionId) throw new Error("Internal error in health checker");
        this.#currentSubunsubRequestId = "health-checker:".concat(this.#nextRequestId.toString());
        this.#nextRequestId += 1;
        this.#requestToSmoldot(JSON.stringify({
            id: this.#currentSubunsubRequestId,
            jsonrpc: "2.0",
            method: "chain_unsubscribeNewHeads",
            params: [
                this.#currentSubscriptionId
            ]
        }));
    };
    destroy = ()=>{
        if (this.#currentHealthTimeout) {
            clearTimeout(this.#currentHealthTimeout);
            this.#currentHealthTimeout = null;
        }
    };
}
class HealthCheckError extends Error {
    #cause;
    getCause() {
        return this.#cause;
    }
    constructor(response, message = "Got error response asking for system health"){
        super(message);
        this.#cause = response;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"IVbyl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "createSubmittable", ()=>(0, _createSubmittableJs.createSubmittable));
parcelHelpers.export(exports, "SubmittableResult", ()=>(0, _resultJs.SubmittableResult));
var _createSubmittableJs = require("./createSubmittable.js");
var _resultJs = require("./Result.js");

},{"./createSubmittable.js":"8p2ZD","./Result.js":"aFTVd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8p2ZD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createSubmittable", ()=>createSubmittable);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _createClassJs = require("./createClass.js");
function createSubmittable(apiType, api, decorateMethod, registry, blockHash) {
    const Submittable = (0, _createClassJs.createClass)({
        api,
        apiType,
        blockHash,
        decorateMethod
    });
    return (extrinsic)=>new Submittable(registry || api.registry, extrinsic);
}

},{"./createClass.js":"e7PMG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e7PMG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createClass", ()=>createClass);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable no-dupe-class-members */ var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
var _resultJs = require("./Result.js");
const identity = (input)=>input;
function makeEraOptions(api, registry, partialOptions, { header , mortalLength , nonce  }) {
    if (!header) {
        if (partialOptions.era && !partialOptions.blockHash) throw new Error("Expected blockHash to be passed alongside non-immortal era options");
        if ((0, _util.isNumber)(partialOptions.era)) {
            // since we have no header, it is immortal, remove any option overrides
            // so we only supply the genesisHash and no era to the construction
            delete partialOptions.era;
            delete partialOptions.blockHash;
        }
        return makeSignOptions(api, partialOptions, {
            nonce
        });
    }
    return makeSignOptions(api, partialOptions, {
        blockHash: header.hash,
        era: registry.createTypeUnsafe("ExtrinsicEra", [
            {
                current: header.number,
                period: partialOptions.era || mortalLength
            }
        ]),
        nonce
    });
}
function makeSignAndSendOptions(partialOptions, statusCb) {
    let options = {};
    if ((0, _util.isFunction)(partialOptions)) statusCb = partialOptions;
    else options = (0, _util.objectSpread)({}, partialOptions);
    return [
        options,
        statusCb
    ];
}
function makeSignOptions(api, partialOptions, extras) {
    return (0, _util.objectSpread)({
        blockHash: api.genesisHash,
        genesisHash: api.genesisHash
    }, partialOptions, extras, {
        runtimeVersion: api.runtimeVersion,
        signedExtensions: api.registry.signedExtensions,
        version: api.extrinsicType
    });
}
function optionsOrNonce(partialOptions = {}) {
    return (0, _util.isBn)(partialOptions) || (0, _util.isNumber)(partialOptions) ? {
        nonce: partialOptions
    } : partialOptions;
}
function createClass({ api , apiType , blockHash , decorateMethod  }) {
    // an instance of the base extrinsic for us to extend
    const ExtrinsicBase = api.registry.createClass("Extrinsic");
    class Submittable extends ExtrinsicBase {
        #ignoreStatusCb;
        #transformResult = identity;
        constructor(registry, extrinsic){
            super(registry, extrinsic, {
                version: api.extrinsicType
            });
            this.#ignoreStatusCb = apiType === "rxjs";
        }
        dryRun(account, optionsOrHash) {
            if (blockHash || (0, _util.isString)(optionsOrHash) || (0, _util.isU8a)(optionsOrHash)) // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return decorateMethod(()=>api.rpc.system.dryRun(this.toHex(), blockHash || optionsOrHash));
             // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
            return decorateMethod(()=>this.#observeSign(account, optionsOrHash).pipe((0, _rxjs.switchMap)(()=>api.rpc.system.dryRun(this.toHex()))))();
        }
        paymentInfo(account, optionsOrHash) {
            if (blockHash || (0, _util.isString)(optionsOrHash) || (0, _util.isU8a)(optionsOrHash)) // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return decorateMethod(()=>api.rpc.payment.queryInfo(this.toHex(), blockHash || optionsOrHash));
            const [allOptions] = makeSignAndSendOptions(optionsOrHash);
            const address = (0, _indexJs.isKeyringPair)(account) ? account.address : account.toString(); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
            return decorateMethod(()=>api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe((0, _rxjs.first)(), (0, _rxjs.switchMap)((signingInfo)=>{
                    // setup our options (same way as in signAndSend)
                    const eraOptions = makeEraOptions(api, this.registry, allOptions, signingInfo);
                    const signOptions = makeSignOptions(api, eraOptions, {});
                    return api.rpc.payment.queryInfo(this.isSigned ? api.tx(this).signFake(address, signOptions).toHex() : this.signFake(address, signOptions).toHex());
                })))();
        }
        // send implementation for both immediate Hash and statusCb variants
        send(statusCb) {
            const isSubscription = api.hasSubscriptions && (this.#ignoreStatusCb || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
            return decorateMethod(isSubscription ? this.#observeSubscribe : this.#observeSend)(statusCb);
        }
        /**
     * @description Sign a transaction, returning the this to allow chaining, i.e. .sign(...).send(). When options, e.g. nonce/blockHash are not specified, it will be inferred. To retrieve eg. nonce use `signAsync` (the preferred interface, this is provided for backwards compatibility)
     * @deprecated
     */ sign(account, partialOptions) {
            super.sign(account, makeSignOptions(api, optionsOrNonce(partialOptions), {}));
            return this;
        }
        /**
     * @description Signs a transaction, returning `this` to allow chaining. E.g.: `sign(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.
     */ signAsync(account, partialOptions) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
            return decorateMethod(()=>this.#observeSign(account, partialOptions).pipe((0, _rxjs.mapTo)(this)))();
        }
        // signAndSend implementation for all 3 cases above
        signAndSend(account, partialOptions, optionalStatusCb) {
            const [options, statusCb] = makeSignAndSendOptions(partialOptions, optionalStatusCb);
            const isSubscription = api.hasSubscriptions && (this.#ignoreStatusCb || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
            return decorateMethod(()=>this.#observeSign(account, options).pipe((0, _rxjs.switchMap)((info)=>isSubscription ? this.#observeSubscribe(info) : this.#observeSend(info))) // FIXME This is wrong, SubmittableResult is _not_ a codec
            )(statusCb);
        }
        withResultTransform(transform) {
            this.#transformResult = transform;
            return this;
        }
        #observeSign = (account, partialOptions)=>{
            const address = (0, _indexJs.isKeyringPair)(account) ? account.address : account.toString();
            const options = optionsOrNonce(partialOptions);
            return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe((0, _rxjs.first)(), (0, _rxjs.mergeMap)(async (signingInfo)=>{
                const eraOptions = makeEraOptions(api, this.registry, options, signingInfo);
                let updateId = -1;
                if ((0, _indexJs.isKeyringPair)(account)) this.sign(account, eraOptions);
                else updateId = await this.#signViaSigner(address, eraOptions, signingInfo.header);
                return {
                    options: eraOptions,
                    updateId
                };
            }));
        };
        #observeStatus = (txHash, status)=>{
            if (!status.isFinalized && !status.isInBlock) return (0, _rxjs.of)(this.#transformResult(new (0, _resultJs.SubmittableResult)({
                status,
                txHash
            })));
            const blockHash = status.isInBlock ? status.asInBlock : status.asFinalized;
            return api.derive.tx.events(blockHash).pipe((0, _rxjs.map)(({ block , events  })=>this.#transformResult(new (0, _resultJs.SubmittableResult)({
                    ...(0, _indexJs.filterEvents)(txHash, block, events, status),
                    status,
                    txHash
                }))), (0, _rxjs.catchError)((internalError)=>(0, _rxjs.of)(this.#transformResult(new (0, _resultJs.SubmittableResult)({
                    internalError,
                    status,
                    txHash
                })))));
        };
        #observeSend = (info)=>{
            return api.rpc.author.submitExtrinsic(this).pipe((0, _rxjs.tap)((hash)=>{
                this.#updateSigner(hash, info);
            }));
        };
        #observeSubscribe = (info)=>{
            const txHash = this.hash;
            return api.rpc.author.submitAndWatchExtrinsic(this).pipe((0, _rxjs.switchMap)((status)=>this.#observeStatus(txHash, status)), (0, _rxjs.tap)((status)=>{
                this.#updateSigner(status, info);
            }));
        };
        #signViaSigner = async (address, options, header)=>{
            const signer = options.signer || api.signer;
            if (!signer) throw new Error("No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.");
            const payload = this.registry.createTypeUnsafe("SignerPayload", [
                (0, _util.objectSpread)({}, options, {
                    address,
                    blockNumber: header ? header.number : 0,
                    method: this.method
                })
            ]);
            let result;
            if ((0, _util.isFunction)(signer.signPayload)) result = await signer.signPayload(payload.toPayload());
            else if ((0, _util.isFunction)(signer.signRaw)) result = await signer.signRaw(payload.toRaw());
            else throw new Error("Invalid signer interface, it should implement either signPayload or signRaw (or both)");
             // Here we explicitly call `toPayload()` again instead of working with an object
            // (reference) as passed to the signer. This means that we are sure that the
            // payload data is not modified from our inputs, but the signer
            super.addSignature(address, result.signature, payload.toPayload());
            return result.id;
        };
        #updateSigner = (status, info)=>{
            if (info && info.updateId !== -1) {
                const { options , updateId  } = info;
                const signer = options.signer || api.signer;
                if (signer && (0, _util.isFunction)(signer.update)) signer.update(updateId, status);
            }
        };
    }
    return Submittable;
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"gnxBn","./Result.js":"aFTVd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lLy7s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Observable", ()=>(0, _observable.Observable));
parcelHelpers.export(exports, "ConnectableObservable", ()=>(0, _connectableObservable.ConnectableObservable));
parcelHelpers.export(exports, "observable", ()=>(0, _observable1.observable));
parcelHelpers.export(exports, "animationFrames", ()=>(0, _animationFrames.animationFrames));
parcelHelpers.export(exports, "Subject", ()=>(0, _subject.Subject));
parcelHelpers.export(exports, "BehaviorSubject", ()=>(0, _behaviorSubject.BehaviorSubject));
parcelHelpers.export(exports, "ReplaySubject", ()=>(0, _replaySubject.ReplaySubject));
parcelHelpers.export(exports, "AsyncSubject", ()=>(0, _asyncSubject.AsyncSubject));
parcelHelpers.export(exports, "asap", ()=>(0, _asap.asap));
parcelHelpers.export(exports, "asapScheduler", ()=>(0, _asap.asapScheduler));
parcelHelpers.export(exports, "async", ()=>(0, _async.async));
parcelHelpers.export(exports, "asyncScheduler", ()=>(0, _async.asyncScheduler));
parcelHelpers.export(exports, "queue", ()=>(0, _queue.queue));
parcelHelpers.export(exports, "queueScheduler", ()=>(0, _queue.queueScheduler));
parcelHelpers.export(exports, "animationFrame", ()=>(0, _animationFrame.animationFrame));
parcelHelpers.export(exports, "animationFrameScheduler", ()=>(0, _animationFrame.animationFrameScheduler));
parcelHelpers.export(exports, "VirtualTimeScheduler", ()=>(0, _virtualTimeScheduler.VirtualTimeScheduler));
parcelHelpers.export(exports, "VirtualAction", ()=>(0, _virtualTimeScheduler.VirtualAction));
parcelHelpers.export(exports, "Scheduler", ()=>(0, _scheduler.Scheduler));
parcelHelpers.export(exports, "Subscription", ()=>(0, _subscription.Subscription));
parcelHelpers.export(exports, "Subscriber", ()=>(0, _subscriber.Subscriber));
parcelHelpers.export(exports, "Notification", ()=>(0, _notification.Notification));
parcelHelpers.export(exports, "NotificationKind", ()=>(0, _notification.NotificationKind));
parcelHelpers.export(exports, "pipe", ()=>(0, _pipe.pipe));
parcelHelpers.export(exports, "noop", ()=>(0, _noop.noop));
parcelHelpers.export(exports, "identity", ()=>(0, _identity.identity));
parcelHelpers.export(exports, "isObservable", ()=>(0, _isObservable.isObservable));
parcelHelpers.export(exports, "lastValueFrom", ()=>(0, _lastValueFrom.lastValueFrom));
parcelHelpers.export(exports, "firstValueFrom", ()=>(0, _firstValueFrom.firstValueFrom));
parcelHelpers.export(exports, "ArgumentOutOfRangeError", ()=>(0, _argumentOutOfRangeError.ArgumentOutOfRangeError));
parcelHelpers.export(exports, "EmptyError", ()=>(0, _emptyError.EmptyError));
parcelHelpers.export(exports, "NotFoundError", ()=>(0, _notFoundError.NotFoundError));
parcelHelpers.export(exports, "ObjectUnsubscribedError", ()=>(0, _objectUnsubscribedError.ObjectUnsubscribedError));
parcelHelpers.export(exports, "SequenceError", ()=>(0, _sequenceError.SequenceError));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _timeout.TimeoutError));
parcelHelpers.export(exports, "UnsubscriptionError", ()=>(0, _unsubscriptionError.UnsubscriptionError));
parcelHelpers.export(exports, "bindCallback", ()=>(0, _bindCallback.bindCallback));
parcelHelpers.export(exports, "bindNodeCallback", ()=>(0, _bindNodeCallback.bindNodeCallback));
parcelHelpers.export(exports, "combineLatest", ()=>(0, _combineLatest.combineLatest));
parcelHelpers.export(exports, "concat", ()=>(0, _concat.concat));
parcelHelpers.export(exports, "connectable", ()=>(0, _connectable.connectable));
parcelHelpers.export(exports, "defer", ()=>(0, _defer.defer));
parcelHelpers.export(exports, "empty", ()=>(0, _empty.empty));
parcelHelpers.export(exports, "forkJoin", ()=>(0, _forkJoin.forkJoin));
parcelHelpers.export(exports, "from", ()=>(0, _from.from));
parcelHelpers.export(exports, "fromEvent", ()=>(0, _fromEvent.fromEvent));
parcelHelpers.export(exports, "fromEventPattern", ()=>(0, _fromEventPattern.fromEventPattern));
parcelHelpers.export(exports, "generate", ()=>(0, _generate.generate));
parcelHelpers.export(exports, "iif", ()=>(0, _iif.iif));
parcelHelpers.export(exports, "interval", ()=>(0, _interval.interval));
parcelHelpers.export(exports, "merge", ()=>(0, _merge.merge));
parcelHelpers.export(exports, "never", ()=>(0, _never.never));
parcelHelpers.export(exports, "of", ()=>(0, _of.of));
parcelHelpers.export(exports, "onErrorResumeNext", ()=>(0, _onErrorResumeNext.onErrorResumeNext));
parcelHelpers.export(exports, "pairs", ()=>(0, _pairs.pairs));
parcelHelpers.export(exports, "partition", ()=>(0, _partition.partition));
parcelHelpers.export(exports, "race", ()=>(0, _race.race));
parcelHelpers.export(exports, "range", ()=>(0, _range.range));
parcelHelpers.export(exports, "throwError", ()=>(0, _throwError.throwError));
parcelHelpers.export(exports, "timer", ()=>(0, _timer.timer));
parcelHelpers.export(exports, "using", ()=>(0, _using.using));
parcelHelpers.export(exports, "zip", ()=>(0, _zip.zip));
parcelHelpers.export(exports, "scheduled", ()=>(0, _scheduled.scheduled));
parcelHelpers.export(exports, "EMPTY", ()=>(0, _empty.EMPTY));
parcelHelpers.export(exports, "NEVER", ()=>(0, _never.NEVER));
parcelHelpers.export(exports, "config", ()=>(0, _config.config));
parcelHelpers.export(exports, "audit", ()=>(0, _audit.audit));
parcelHelpers.export(exports, "auditTime", ()=>(0, _auditTime.auditTime));
parcelHelpers.export(exports, "buffer", ()=>(0, _buffer.buffer));
parcelHelpers.export(exports, "bufferCount", ()=>(0, _bufferCount.bufferCount));
parcelHelpers.export(exports, "bufferTime", ()=>(0, _bufferTime.bufferTime));
parcelHelpers.export(exports, "bufferToggle", ()=>(0, _bufferToggle.bufferToggle));
parcelHelpers.export(exports, "bufferWhen", ()=>(0, _bufferWhen.bufferWhen));
parcelHelpers.export(exports, "catchError", ()=>(0, _catchError.catchError));
parcelHelpers.export(exports, "combineAll", ()=>(0, _combineAll.combineAll));
parcelHelpers.export(exports, "combineLatestAll", ()=>(0, _combineLatestAll.combineLatestAll));
parcelHelpers.export(exports, "combineLatestWith", ()=>(0, _combineLatestWith.combineLatestWith));
parcelHelpers.export(exports, "concatAll", ()=>(0, _concatAll.concatAll));
parcelHelpers.export(exports, "concatMap", ()=>(0, _concatMap.concatMap));
parcelHelpers.export(exports, "concatMapTo", ()=>(0, _concatMapTo.concatMapTo));
parcelHelpers.export(exports, "concatWith", ()=>(0, _concatWith.concatWith));
parcelHelpers.export(exports, "connect", ()=>(0, _connect.connect));
parcelHelpers.export(exports, "count", ()=>(0, _count.count));
parcelHelpers.export(exports, "debounce", ()=>(0, _debounce.debounce));
parcelHelpers.export(exports, "debounceTime", ()=>(0, _debounceTime.debounceTime));
parcelHelpers.export(exports, "defaultIfEmpty", ()=>(0, _defaultIfEmpty.defaultIfEmpty));
parcelHelpers.export(exports, "delay", ()=>(0, _delay.delay));
parcelHelpers.export(exports, "delayWhen", ()=>(0, _delayWhen.delayWhen));
parcelHelpers.export(exports, "dematerialize", ()=>(0, _dematerialize.dematerialize));
parcelHelpers.export(exports, "distinct", ()=>(0, _distinct.distinct));
parcelHelpers.export(exports, "distinctUntilChanged", ()=>(0, _distinctUntilChanged.distinctUntilChanged));
parcelHelpers.export(exports, "distinctUntilKeyChanged", ()=>(0, _distinctUntilKeyChanged.distinctUntilKeyChanged));
parcelHelpers.export(exports, "elementAt", ()=>(0, _elementAt.elementAt));
parcelHelpers.export(exports, "endWith", ()=>(0, _endWith.endWith));
parcelHelpers.export(exports, "every", ()=>(0, _every.every));
parcelHelpers.export(exports, "exhaust", ()=>(0, _exhaust.exhaust));
parcelHelpers.export(exports, "exhaustAll", ()=>(0, _exhaustAll.exhaustAll));
parcelHelpers.export(exports, "exhaustMap", ()=>(0, _exhaustMap.exhaustMap));
parcelHelpers.export(exports, "expand", ()=>(0, _expand.expand));
parcelHelpers.export(exports, "filter", ()=>(0, _filter.filter));
parcelHelpers.export(exports, "finalize", ()=>(0, _finalize.finalize));
parcelHelpers.export(exports, "find", ()=>(0, _find.find));
parcelHelpers.export(exports, "findIndex", ()=>(0, _findIndex.findIndex));
parcelHelpers.export(exports, "first", ()=>(0, _first.first));
parcelHelpers.export(exports, "groupBy", ()=>(0, _groupBy.groupBy));
parcelHelpers.export(exports, "ignoreElements", ()=>(0, _ignoreElements.ignoreElements));
parcelHelpers.export(exports, "isEmpty", ()=>(0, _isEmpty.isEmpty));
parcelHelpers.export(exports, "last", ()=>(0, _last.last));
parcelHelpers.export(exports, "map", ()=>(0, _map.map));
parcelHelpers.export(exports, "mapTo", ()=>(0, _mapTo.mapTo));
parcelHelpers.export(exports, "materialize", ()=>(0, _materialize.materialize));
parcelHelpers.export(exports, "max", ()=>(0, _max.max));
parcelHelpers.export(exports, "mergeAll", ()=>(0, _mergeAll.mergeAll));
parcelHelpers.export(exports, "flatMap", ()=>(0, _flatMap.flatMap));
parcelHelpers.export(exports, "mergeMap", ()=>(0, _mergeMap.mergeMap));
parcelHelpers.export(exports, "mergeMapTo", ()=>(0, _mergeMapTo.mergeMapTo));
parcelHelpers.export(exports, "mergeScan", ()=>(0, _mergeScan.mergeScan));
parcelHelpers.export(exports, "mergeWith", ()=>(0, _mergeWith.mergeWith));
parcelHelpers.export(exports, "min", ()=>(0, _min.min));
parcelHelpers.export(exports, "multicast", ()=>(0, _multicast.multicast));
parcelHelpers.export(exports, "observeOn", ()=>(0, _observeOn.observeOn));
parcelHelpers.export(exports, "pairwise", ()=>(0, _pairwise.pairwise));
parcelHelpers.export(exports, "pluck", ()=>(0, _pluck.pluck));
parcelHelpers.export(exports, "publish", ()=>(0, _publish.publish));
parcelHelpers.export(exports, "publishBehavior", ()=>(0, _publishBehavior.publishBehavior));
parcelHelpers.export(exports, "publishLast", ()=>(0, _publishLast.publishLast));
parcelHelpers.export(exports, "publishReplay", ()=>(0, _publishReplay.publishReplay));
parcelHelpers.export(exports, "raceWith", ()=>(0, _raceWith.raceWith));
parcelHelpers.export(exports, "reduce", ()=>(0, _reduce.reduce));
parcelHelpers.export(exports, "repeat", ()=>(0, _repeat.repeat));
parcelHelpers.export(exports, "repeatWhen", ()=>(0, _repeatWhen.repeatWhen));
parcelHelpers.export(exports, "retry", ()=>(0, _retry.retry));
parcelHelpers.export(exports, "retryWhen", ()=>(0, _retryWhen.retryWhen));
parcelHelpers.export(exports, "refCount", ()=>(0, _refCount.refCount));
parcelHelpers.export(exports, "sample", ()=>(0, _sample.sample));
parcelHelpers.export(exports, "sampleTime", ()=>(0, _sampleTime.sampleTime));
parcelHelpers.export(exports, "scan", ()=>(0, _scan.scan));
parcelHelpers.export(exports, "sequenceEqual", ()=>(0, _sequenceEqual.sequenceEqual));
parcelHelpers.export(exports, "share", ()=>(0, _share.share));
parcelHelpers.export(exports, "shareReplay", ()=>(0, _shareReplay.shareReplay));
parcelHelpers.export(exports, "single", ()=>(0, _single.single));
parcelHelpers.export(exports, "skip", ()=>(0, _skip.skip));
parcelHelpers.export(exports, "skipLast", ()=>(0, _skipLast.skipLast));
parcelHelpers.export(exports, "skipUntil", ()=>(0, _skipUntil.skipUntil));
parcelHelpers.export(exports, "skipWhile", ()=>(0, _skipWhile.skipWhile));
parcelHelpers.export(exports, "startWith", ()=>(0, _startWith.startWith));
parcelHelpers.export(exports, "subscribeOn", ()=>(0, _subscribeOn.subscribeOn));
parcelHelpers.export(exports, "switchAll", ()=>(0, _switchAll.switchAll));
parcelHelpers.export(exports, "switchMap", ()=>(0, _switchMap.switchMap));
parcelHelpers.export(exports, "switchMapTo", ()=>(0, _switchMapTo.switchMapTo));
parcelHelpers.export(exports, "switchScan", ()=>(0, _switchScan.switchScan));
parcelHelpers.export(exports, "take", ()=>(0, _take.take));
parcelHelpers.export(exports, "takeLast", ()=>(0, _takeLast.takeLast));
parcelHelpers.export(exports, "takeUntil", ()=>(0, _takeUntil.takeUntil));
parcelHelpers.export(exports, "takeWhile", ()=>(0, _takeWhile.takeWhile));
parcelHelpers.export(exports, "tap", ()=>(0, _tap.tap));
parcelHelpers.export(exports, "throttle", ()=>(0, _throttle.throttle));
parcelHelpers.export(exports, "throttleTime", ()=>(0, _throttleTime.throttleTime));
parcelHelpers.export(exports, "throwIfEmpty", ()=>(0, _throwIfEmpty.throwIfEmpty));
parcelHelpers.export(exports, "timeInterval", ()=>(0, _timeInterval.timeInterval));
parcelHelpers.export(exports, "timeout", ()=>(0, _timeout.timeout));
parcelHelpers.export(exports, "timeoutWith", ()=>(0, _timeoutWith.timeoutWith));
parcelHelpers.export(exports, "timestamp", ()=>(0, _timestamp.timestamp));
parcelHelpers.export(exports, "toArray", ()=>(0, _toArray.toArray));
parcelHelpers.export(exports, "window", ()=>(0, _window.window));
parcelHelpers.export(exports, "windowCount", ()=>(0, _windowCount.windowCount));
parcelHelpers.export(exports, "windowTime", ()=>(0, _windowTime.windowTime));
parcelHelpers.export(exports, "windowToggle", ()=>(0, _windowToggle.windowToggle));
parcelHelpers.export(exports, "windowWhen", ()=>(0, _windowWhen.windowWhen));
parcelHelpers.export(exports, "withLatestFrom", ()=>(0, _withLatestFrom.withLatestFrom));
parcelHelpers.export(exports, "zipAll", ()=>(0, _zipAll.zipAll));
parcelHelpers.export(exports, "zipWith", ()=>(0, _zipWith.zipWith));
var _observable = require("./internal/Observable");
var _connectableObservable = require("./internal/observable/ConnectableObservable");
var _observable1 = require("./internal/symbol/observable");
var _animationFrames = require("./internal/observable/dom/animationFrames");
var _subject = require("./internal/Subject");
var _behaviorSubject = require("./internal/BehaviorSubject");
var _replaySubject = require("./internal/ReplaySubject");
var _asyncSubject = require("./internal/AsyncSubject");
var _asap = require("./internal/scheduler/asap");
var _async = require("./internal/scheduler/async");
var _queue = require("./internal/scheduler/queue");
var _animationFrame = require("./internal/scheduler/animationFrame");
var _virtualTimeScheduler = require("./internal/scheduler/VirtualTimeScheduler");
var _scheduler = require("./internal/Scheduler");
var _subscription = require("./internal/Subscription");
var _subscriber = require("./internal/Subscriber");
var _notification = require("./internal/Notification");
var _pipe = require("./internal/util/pipe");
var _noop = require("./internal/util/noop");
var _identity = require("./internal/util/identity");
var _isObservable = require("./internal/util/isObservable");
var _lastValueFrom = require("./internal/lastValueFrom");
var _firstValueFrom = require("./internal/firstValueFrom");
var _argumentOutOfRangeError = require("./internal/util/ArgumentOutOfRangeError");
var _emptyError = require("./internal/util/EmptyError");
var _notFoundError = require("./internal/util/NotFoundError");
var _objectUnsubscribedError = require("./internal/util/ObjectUnsubscribedError");
var _sequenceError = require("./internal/util/SequenceError");
var _timeout = require("./internal/operators/timeout");
var _unsubscriptionError = require("./internal/util/UnsubscriptionError");
var _bindCallback = require("./internal/observable/bindCallback");
var _bindNodeCallback = require("./internal/observable/bindNodeCallback");
var _combineLatest = require("./internal/observable/combineLatest");
var _concat = require("./internal/observable/concat");
var _connectable = require("./internal/observable/connectable");
var _defer = require("./internal/observable/defer");
var _empty = require("./internal/observable/empty");
var _forkJoin = require("./internal/observable/forkJoin");
var _from = require("./internal/observable/from");
var _fromEvent = require("./internal/observable/fromEvent");
var _fromEventPattern = require("./internal/observable/fromEventPattern");
var _generate = require("./internal/observable/generate");
var _iif = require("./internal/observable/iif");
var _interval = require("./internal/observable/interval");
var _merge = require("./internal/observable/merge");
var _never = require("./internal/observable/never");
var _of = require("./internal/observable/of");
var _onErrorResumeNext = require("./internal/observable/onErrorResumeNext");
var _pairs = require("./internal/observable/pairs");
var _partition = require("./internal/observable/partition");
var _race = require("./internal/observable/race");
var _range = require("./internal/observable/range");
var _throwError = require("./internal/observable/throwError");
var _timer = require("./internal/observable/timer");
var _using = require("./internal/observable/using");
var _zip = require("./internal/observable/zip");
var _scheduled = require("./internal/scheduled/scheduled");
var _types = require("./internal/types");
parcelHelpers.exportAll(_types, exports);
var _config = require("./internal/config");
var _audit = require("./internal/operators/audit");
var _auditTime = require("./internal/operators/auditTime");
var _buffer = require("./internal/operators/buffer");
var _bufferCount = require("./internal/operators/bufferCount");
var _bufferTime = require("./internal/operators/bufferTime");
var _bufferToggle = require("./internal/operators/bufferToggle");
var _bufferWhen = require("./internal/operators/bufferWhen");
var _catchError = require("./internal/operators/catchError");
var _combineAll = require("./internal/operators/combineAll");
var _combineLatestAll = require("./internal/operators/combineLatestAll");
var _combineLatestWith = require("./internal/operators/combineLatestWith");
var _concatAll = require("./internal/operators/concatAll");
var _concatMap = require("./internal/operators/concatMap");
var _concatMapTo = require("./internal/operators/concatMapTo");
var _concatWith = require("./internal/operators/concatWith");
var _connect = require("./internal/operators/connect");
var _count = require("./internal/operators/count");
var _debounce = require("./internal/operators/debounce");
var _debounceTime = require("./internal/operators/debounceTime");
var _defaultIfEmpty = require("./internal/operators/defaultIfEmpty");
var _delay = require("./internal/operators/delay");
var _delayWhen = require("./internal/operators/delayWhen");
var _dematerialize = require("./internal/operators/dematerialize");
var _distinct = require("./internal/operators/distinct");
var _distinctUntilChanged = require("./internal/operators/distinctUntilChanged");
var _distinctUntilKeyChanged = require("./internal/operators/distinctUntilKeyChanged");
var _elementAt = require("./internal/operators/elementAt");
var _endWith = require("./internal/operators/endWith");
var _every = require("./internal/operators/every");
var _exhaust = require("./internal/operators/exhaust");
var _exhaustAll = require("./internal/operators/exhaustAll");
var _exhaustMap = require("./internal/operators/exhaustMap");
var _expand = require("./internal/operators/expand");
var _filter = require("./internal/operators/filter");
var _finalize = require("./internal/operators/finalize");
var _find = require("./internal/operators/find");
var _findIndex = require("./internal/operators/findIndex");
var _first = require("./internal/operators/first");
var _groupBy = require("./internal/operators/groupBy");
var _ignoreElements = require("./internal/operators/ignoreElements");
var _isEmpty = require("./internal/operators/isEmpty");
var _last = require("./internal/operators/last");
var _map = require("./internal/operators/map");
var _mapTo = require("./internal/operators/mapTo");
var _materialize = require("./internal/operators/materialize");
var _max = require("./internal/operators/max");
var _mergeAll = require("./internal/operators/mergeAll");
var _flatMap = require("./internal/operators/flatMap");
var _mergeMap = require("./internal/operators/mergeMap");
var _mergeMapTo = require("./internal/operators/mergeMapTo");
var _mergeScan = require("./internal/operators/mergeScan");
var _mergeWith = require("./internal/operators/mergeWith");
var _min = require("./internal/operators/min");
var _multicast = require("./internal/operators/multicast");
var _observeOn = require("./internal/operators/observeOn");
var _pairwise = require("./internal/operators/pairwise");
var _pluck = require("./internal/operators/pluck");
var _publish = require("./internal/operators/publish");
var _publishBehavior = require("./internal/operators/publishBehavior");
var _publishLast = require("./internal/operators/publishLast");
var _publishReplay = require("./internal/operators/publishReplay");
var _raceWith = require("./internal/operators/raceWith");
var _reduce = require("./internal/operators/reduce");
var _repeat = require("./internal/operators/repeat");
var _repeatWhen = require("./internal/operators/repeatWhen");
var _retry = require("./internal/operators/retry");
var _retryWhen = require("./internal/operators/retryWhen");
var _refCount = require("./internal/operators/refCount");
var _sample = require("./internal/operators/sample");
var _sampleTime = require("./internal/operators/sampleTime");
var _scan = require("./internal/operators/scan");
var _sequenceEqual = require("./internal/operators/sequenceEqual");
var _share = require("./internal/operators/share");
var _shareReplay = require("./internal/operators/shareReplay");
var _single = require("./internal/operators/single");
var _skip = require("./internal/operators/skip");
var _skipLast = require("./internal/operators/skipLast");
var _skipUntil = require("./internal/operators/skipUntil");
var _skipWhile = require("./internal/operators/skipWhile");
var _startWith = require("./internal/operators/startWith");
var _subscribeOn = require("./internal/operators/subscribeOn");
var _switchAll = require("./internal/operators/switchAll");
var _switchMap = require("./internal/operators/switchMap");
var _switchMapTo = require("./internal/operators/switchMapTo");
var _switchScan = require("./internal/operators/switchScan");
var _take = require("./internal/operators/take");
var _takeLast = require("./internal/operators/takeLast");
var _takeUntil = require("./internal/operators/takeUntil");
var _takeWhile = require("./internal/operators/takeWhile");
var _tap = require("./internal/operators/tap");
var _throttle = require("./internal/operators/throttle");
var _throttleTime = require("./internal/operators/throttleTime");
var _throwIfEmpty = require("./internal/operators/throwIfEmpty");
var _timeInterval = require("./internal/operators/timeInterval");
var _timeoutWith = require("./internal/operators/timeoutWith");
var _timestamp = require("./internal/operators/timestamp");
var _toArray = require("./internal/operators/toArray");
var _window = require("./internal/operators/window");
var _windowCount = require("./internal/operators/windowCount");
var _windowTime = require("./internal/operators/windowTime");
var _windowToggle = require("./internal/operators/windowToggle");
var _windowWhen = require("./internal/operators/windowWhen");
var _withLatestFrom = require("./internal/operators/withLatestFrom");
var _zipAll = require("./internal/operators/zipAll");
var _zipWith = require("./internal/operators/zipWith");

},{"./internal/Observable":"4Jvxr","./internal/observable/ConnectableObservable":"6Vb8A","./internal/symbol/observable":"byHtV","./internal/observable/dom/animationFrames":false,"./internal/Subject":"94RSe","./internal/BehaviorSubject":"4s6yS","./internal/ReplaySubject":"3RRP9","./internal/AsyncSubject":false,"./internal/scheduler/asap":"ercvV","./internal/scheduler/async":false,"./internal/scheduler/queue":false,"./internal/scheduler/animationFrame":false,"./internal/scheduler/VirtualTimeScheduler":false,"./internal/Scheduler":"90yvc","./internal/Subscription":"lFyhg","./internal/Subscriber":"1VFFQ","./internal/Notification":false,"./internal/util/pipe":"1GN6U","./internal/util/noop":"l8uEm","./internal/util/identity":"8Xfg6","./internal/util/isObservable":false,"./internal/lastValueFrom":false,"./internal/firstValueFrom":"6sMsY","./internal/util/ArgumentOutOfRangeError":false,"./internal/util/EmptyError":"6OnNQ","./internal/util/NotFoundError":false,"./internal/util/ObjectUnsubscribedError":"6Gcwa","./internal/util/SequenceError":false,"./internal/operators/timeout":false,"./internal/util/UnsubscriptionError":"GSF7Z","./internal/observable/bindCallback":false,"./internal/observable/bindNodeCallback":false,"./internal/observable/combineLatest":"klIwv","./internal/observable/concat":"5g0IT","./internal/observable/connectable":false,"./internal/observable/defer":false,"./internal/observable/empty":"dGHVG","./internal/observable/forkJoin":false,"./internal/observable/from":"dBWag","./internal/observable/fromEvent":false,"./internal/observable/fromEventPattern":false,"./internal/observable/generate":false,"./internal/observable/iif":false,"./internal/observable/interval":false,"./internal/observable/merge":false,"./internal/observable/never":false,"./internal/observable/of":"lnQPU","./internal/observable/onErrorResumeNext":false,"./internal/observable/pairs":false,"./internal/observable/partition":false,"./internal/observable/race":false,"./internal/observable/range":false,"./internal/observable/throwError":false,"./internal/observable/timer":false,"./internal/observable/using":false,"./internal/observable/zip":false,"./internal/scheduled/scheduled":"l8eo2","./internal/types":"c58fk","./internal/config":"fX0gC","./internal/operators/audit":false,"./internal/operators/auditTime":false,"./internal/operators/buffer":false,"./internal/operators/bufferCount":false,"./internal/operators/bufferTime":false,"./internal/operators/bufferToggle":false,"./internal/operators/bufferWhen":false,"./internal/operators/catchError":"jKP5Q","./internal/operators/combineAll":false,"./internal/operators/combineLatestAll":false,"./internal/operators/combineLatestWith":false,"./internal/operators/concatAll":"77QLf","./internal/operators/concatMap":false,"./internal/operators/concatMapTo":false,"./internal/operators/concatWith":false,"./internal/operators/connect":"2umbm","./internal/operators/count":false,"./internal/operators/debounce":false,"./internal/operators/debounceTime":false,"./internal/operators/defaultIfEmpty":"03Bwx","./internal/operators/delay":false,"./internal/operators/delayWhen":false,"./internal/operators/dematerialize":false,"./internal/operators/distinct":false,"./internal/operators/distinctUntilChanged":"knFKV","./internal/operators/distinctUntilKeyChanged":false,"./internal/operators/elementAt":false,"./internal/operators/endWith":false,"./internal/operators/every":false,"./internal/operators/exhaust":false,"./internal/operators/exhaustAll":false,"./internal/operators/exhaustMap":false,"./internal/operators/expand":false,"./internal/operators/filter":"gA0i5","./internal/operators/finalize":false,"./internal/operators/find":false,"./internal/operators/findIndex":false,"./internal/operators/first":"1Jl7y","./internal/operators/groupBy":false,"./internal/operators/ignoreElements":false,"./internal/operators/isEmpty":false,"./internal/operators/last":false,"./internal/operators/map":"25iUP","./internal/operators/mapTo":"8NiL4","./internal/operators/materialize":false,"./internal/operators/max":false,"./internal/operators/mergeAll":"iAqyw","./internal/operators/flatMap":false,"./internal/operators/mergeMap":"1Kzmb","./internal/operators/mergeMapTo":false,"./internal/operators/mergeScan":false,"./internal/operators/mergeWith":false,"./internal/operators/min":false,"./internal/operators/multicast":"bjWSV","./internal/operators/observeOn":"21OcU","./internal/operators/pairwise":false,"./internal/operators/pluck":false,"./internal/operators/publish":false,"./internal/operators/publishBehavior":false,"./internal/operators/publishLast":false,"./internal/operators/publishReplay":"6ioy7","./internal/operators/raceWith":false,"./internal/operators/reduce":"8K6iO","./internal/operators/repeat":false,"./internal/operators/repeatWhen":false,"./internal/operators/retry":false,"./internal/operators/retryWhen":false,"./internal/operators/refCount":"6LyQe","./internal/operators/sample":false,"./internal/operators/sampleTime":false,"./internal/operators/scan":false,"./internal/operators/sequenceEqual":false,"./internal/operators/share":false,"./internal/operators/shareReplay":false,"./internal/operators/single":false,"./internal/operators/skip":false,"./internal/operators/skipLast":false,"./internal/operators/skipUntil":false,"./internal/operators/skipWhile":false,"./internal/operators/startWith":"kMx2y","./internal/operators/subscribeOn":"3SFol","./internal/operators/switchAll":false,"./internal/operators/switchMap":"jbzg2","./internal/operators/switchMapTo":false,"./internal/operators/switchScan":false,"./internal/operators/take":"jxxom","./internal/operators/takeLast":false,"./internal/operators/takeUntil":false,"./internal/operators/takeWhile":false,"./internal/operators/tap":"dVdZH","./internal/operators/throttle":false,"./internal/operators/throttleTime":false,"./internal/operators/throwIfEmpty":"1CMQN","./internal/operators/timeInterval":false,"./internal/operators/timeoutWith":false,"./internal/operators/timestamp":false,"./internal/operators/toArray":"occyH","./internal/operators/window":false,"./internal/operators/windowCount":false,"./internal/operators/windowTime":false,"./internal/operators/windowToggle":false,"./internal/operators/windowWhen":false,"./internal/operators/withLatestFrom":false,"./internal/operators/zipAll":false,"./internal/operators/zipWith":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Jvxr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Observable", ()=>Observable);
var _subscriber = require("./Subscriber");
var _subscription = require("./Subscription");
var _observable = require("./symbol/observable");
var _pipe = require("./util/pipe");
var _config = require("./config");
var _isFunction = require("./util/isFunction");
var _errorContext = require("./util/errorContext");
var Observable = function() {
    function Observable(subscribe) {
        if (subscribe) this._subscribe = subscribe;
    }
    Observable.prototype.lift = function(operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new (0, _subscriber.SafeSubscriber)(observerOrNext, error, complete);
        (0, _errorContext.errorContext)(function() {
            var _a = _this, operator = _a.operator, source = _a.source;
            subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
    };
    Observable.prototype._trySubscribe = function(sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            sink.error(err);
        }
    };
    Observable.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
            var subscriber = new (0, _subscriber.SafeSubscriber)({
                next: function(value) {
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscriber.unsubscribe();
                    }
                },
                error: reject,
                complete: resolve
            });
            _this.subscribe(subscriber);
        });
    };
    Observable.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable.prototype[0, _observable.observable] = function() {
        return this;
    };
    Observable.prototype.pipe = function() {
        var operations = [];
        for(var _i = 0; _i < arguments.length; _i++)operations[_i] = arguments[_i];
        return (0, _pipe.pipeFromArray)(operations)(this);
    };
    Observable.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
            var value;
            _this.subscribe(function(x) {
                return value = x;
            }, function(err) {
                return reject(err);
            }, function() {
                return resolve(value);
            });
        });
    };
    Observable.create = function(subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : (0, _config.config).Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
    return value && (0, _isFunction.isFunction)(value.next) && (0, _isFunction.isFunction)(value.error) && (0, _isFunction.isFunction)(value.complete);
}
function isSubscriber(value) {
    return value && value instanceof (0, _subscriber.Subscriber) || isObserver(value) && (0, _subscription.isSubscription)(value);
}

},{"./Subscriber":"1VFFQ","./Subscription":"lFyhg","./symbol/observable":"byHtV","./util/pipe":"1GN6U","./config":"fX0gC","./util/isFunction":"dEyyK","./util/errorContext":"gU38l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1VFFQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subscriber", ()=>Subscriber);
parcelHelpers.export(exports, "SafeSubscriber", ()=>SafeSubscriber);
parcelHelpers.export(exports, "EMPTY_OBSERVER", ()=>EMPTY_OBSERVER);
var _tslib = require("tslib");
var _isFunction = require("./util/isFunction");
var _subscription = require("./Subscription");
var _config = require("./config");
var _reportUnhandledError = require("./util/reportUnhandledError");
var _noop = require("./util/noop");
var _notificationFactories = require("./NotificationFactories");
var _timeoutProvider = require("./scheduler/timeoutProvider");
var _errorContext = require("./util/errorContext");
var Subscriber = function(_super) {
    (0, _tslib.__extends)(Subscriber, _super);
    function Subscriber(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
            _this.destination = destination;
            if ((0, _subscription.isSubscription)(destination)) destination.add(_this);
        } else _this.destination = EMPTY_OBSERVER;
        return _this;
    }
    Subscriber.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
    };
    Subscriber.prototype.next = function(value) {
        if (this.isStopped) handleStoppedNotification((0, _notificationFactories.nextNotification)(value), this);
        else this._next(value);
    };
    Subscriber.prototype.error = function(err) {
        if (this.isStopped) handleStoppedNotification((0, _notificationFactories.errorNotification)(err), this);
        else {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function() {
        if (this.isStopped) handleStoppedNotification((0, _notificationFactories.COMPLETE_NOTIFICATION), this);
        else {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function() {
        if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
        }
    };
    Subscriber.prototype._next = function(value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function(err) {
        try {
            this.destination.error(err);
        } finally{
            this.unsubscribe();
        }
    };
    Subscriber.prototype._complete = function() {
        try {
            this.destination.complete();
        } finally{
            this.unsubscribe();
        }
    };
    return Subscriber;
}((0, _subscription.Subscription));
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
    function ConsumerObserver(partialObserver) {
        this.partialObserver = partialObserver;
    }
    ConsumerObserver.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) try {
            partialObserver.next(value);
        } catch (error) {
            handleUnhandledError(error);
        }
    };
    ConsumerObserver.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) try {
            partialObserver.error(err);
        } catch (error) {
            handleUnhandledError(error);
        }
        else handleUnhandledError(err);
    };
    ConsumerObserver.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) try {
            partialObserver.complete();
        } catch (error) {
            handleUnhandledError(error);
        }
    };
    return ConsumerObserver;
}();
var SafeSubscriber = function(_super) {
    (0, _tslib.__extends)(SafeSubscriber, _super);
    function SafeSubscriber(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if ((0, _isFunction.isFunction)(observerOrNext) || !observerOrNext) partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,
            error: error !== null && error !== void 0 ? error : undefined,
            complete: complete !== null && complete !== void 0 ? complete : undefined
        };
        else {
            var context_1;
            if (_this && (0, _config.config).useDeprecatedNextContext) {
                context_1 = Object.create(observerOrNext);
                context_1.unsubscribe = function() {
                    return _this.unsubscribe();
                };
                partialObserver = {
                    next: observerOrNext.next && bind(observerOrNext.next, context_1),
                    error: observerOrNext.error && bind(observerOrNext.error, context_1),
                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
                };
            } else partialObserver = observerOrNext;
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
    }
    return SafeSubscriber;
}(Subscriber);
function handleUnhandledError(error) {
    if ((0, _config.config).useDeprecatedSynchronousErrorHandling) (0, _errorContext.captureError)(error);
    else (0, _reportUnhandledError.reportUnhandledError)(error);
}
function defaultErrorHandler(err) {
    throw err;
}
function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = (0, _config.config).onStoppedNotification;
    onStoppedNotification && (0, _timeoutProvider.timeoutProvider).setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
    });
}
var EMPTY_OBSERVER = {
    closed: true,
    next: (0, _noop.noop),
    error: defaultErrorHandler,
    complete: (0, _noop.noop)
};

},{"tslib":"lRdW5","./util/isFunction":"dEyyK","./Subscription":"lFyhg","./config":"fX0gC","./util/reportUnhandledError":"aVM3K","./util/noop":"l8uEm","./NotificationFactories":"hwqFj","./scheduler/timeoutProvider":"1FR9J","./util/errorContext":"gU38l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lRdW5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__extends", ()=>__extends);
parcelHelpers.export(exports, "__assign", ()=>__assign);
parcelHelpers.export(exports, "__rest", ()=>__rest);
parcelHelpers.export(exports, "__decorate", ()=>__decorate);
parcelHelpers.export(exports, "__param", ()=>__param);
parcelHelpers.export(exports, "__metadata", ()=>__metadata);
parcelHelpers.export(exports, "__awaiter", ()=>__awaiter);
parcelHelpers.export(exports, "__generator", ()=>__generator);
parcelHelpers.export(exports, "__createBinding", ()=>__createBinding);
parcelHelpers.export(exports, "__exportStar", ()=>__exportStar);
parcelHelpers.export(exports, "__values", ()=>__values);
parcelHelpers.export(exports, "__read", ()=>__read);
/** @deprecated */ parcelHelpers.export(exports, "__spread", ()=>__spread);
/** @deprecated */ parcelHelpers.export(exports, "__spreadArrays", ()=>__spreadArrays);
parcelHelpers.export(exports, "__spreadArray", ()=>__spreadArray);
parcelHelpers.export(exports, "__await", ()=>__await);
parcelHelpers.export(exports, "__asyncGenerator", ()=>__asyncGenerator);
parcelHelpers.export(exports, "__asyncDelegator", ()=>__asyncDelegator);
parcelHelpers.export(exports, "__asyncValues", ()=>__asyncValues);
parcelHelpers.export(exports, "__makeTemplateObject", ()=>__makeTemplateObject);
parcelHelpers.export(exports, "__importStar", ()=>__importStar);
parcelHelpers.export(exports, "__importDefault", ()=>__importDefault);
parcelHelpers.export(exports, "__classPrivateFieldGet", ()=>__classPrivateFieldGet);
parcelHelpers.export(exports, "__classPrivateFieldSet", ()=>__classPrivateFieldSet);
parcelHelpers.export(exports, "__classPrivateFieldIn", ()=>__classPrivateFieldIn);
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: n === "return"
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) Object.defineProperty(cooked, "raw", {
        value: raw
    });
    else cooked.raw = raw;
    return cooked;
}
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dEyyK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
function isFunction(value) {
    return typeof value === "function";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lFyhg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subscription", ()=>Subscription);
parcelHelpers.export(exports, "EMPTY_SUBSCRIPTION", ()=>EMPTY_SUBSCRIPTION);
parcelHelpers.export(exports, "isSubscription", ()=>isSubscription);
var _tslib = require("tslib");
var _isFunction = require("./util/isFunction");
var _unsubscriptionError = require("./util/UnsubscriptionError");
var _arrRemove = require("./util/arrRemove");
var Subscription = function() {
    function Subscription(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
    }
    Subscription.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
                this._parentage = null;
                if (Array.isArray(_parentage)) try {
                    for(var _parentage_1 = (0, _tslib.__values)(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()){
                        var parent_1 = _parentage_1_1.value;
                        parent_1.remove(this);
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
                else _parentage.remove(this);
            }
            var initialFinalizer = this.initialTeardown;
            if ((0, _isFunction.isFunction)(initialFinalizer)) try {
                initialFinalizer();
            } catch (e) {
                errors = e instanceof (0, _unsubscriptionError.UnsubscriptionError) ? e.errors : [
                    e
                ];
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
                this._finalizers = null;
                try {
                    for(var _finalizers_1 = (0, _tslib.__values)(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()){
                        var finalizer = _finalizers_1_1.value;
                        try {
                            execFinalizer(finalizer);
                        } catch (err) {
                            errors = errors !== null && errors !== void 0 ? errors : [];
                            if (err instanceof (0, _unsubscriptionError.UnsubscriptionError)) errors = (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], (0, _tslib.__read)(errors)), (0, _tslib.__read)(err.errors));
                            else errors.push(err);
                        }
                    }
                } catch (e_2_1) {
                    e_2 = {
                        error: e_2_1
                    };
                } finally{
                    try {
                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                    } finally{
                        if (e_2) throw e_2.error;
                    }
                }
            }
            if (errors) throw new (0, _unsubscriptionError.UnsubscriptionError)(errors);
        }
    };
    Subscription.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
            if (this.closed) execFinalizer(teardown);
            else {
                if (teardown instanceof Subscription) {
                    if (teardown.closed || teardown._hasParent(this)) return;
                    teardown._addParent(this);
                }
                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
        }
    };
    Subscription.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [
            _parentage,
            parent
        ] : parent;
    };
    Subscription.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) this._parentage = null;
        else if (Array.isArray(_parentage)) (0, _arrRemove.arrRemove)(_parentage, parent);
    };
    Subscription.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && (0, _arrRemove.arrRemove)(_finalizers, teardown);
        if (teardown instanceof Subscription) teardown._removeParent(this);
    };
    Subscription.EMPTY = function() {
        var empty = new Subscription();
        empty.closed = true;
        return empty;
    }();
    return Subscription;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && (0, _isFunction.isFunction)(value.remove) && (0, _isFunction.isFunction)(value.add) && (0, _isFunction.isFunction)(value.unsubscribe);
}
function execFinalizer(finalizer) {
    if ((0, _isFunction.isFunction)(finalizer)) finalizer();
    else finalizer.unsubscribe();
}

},{"tslib":"lRdW5","./util/isFunction":"dEyyK","./util/UnsubscriptionError":"GSF7Z","./util/arrRemove":"dLHeW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"GSF7Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnsubscriptionError", ()=>UnsubscriptionError);
var _createErrorClass = require("./createErrorClass");
var UnsubscriptionError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
            return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
    };
});

},{"./createErrorClass":"i1v8Q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i1v8Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createErrorClass", ()=>createErrorClass);
function createErrorClass(createImpl) {
    var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dLHeW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrRemove", ()=>arrRemove);
function arrRemove(arr, item) {
    if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fX0gC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "config", ()=>config);
var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aVM3K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reportUnhandledError", ()=>reportUnhandledError);
var _config = require("../config");
var _timeoutProvider = require("../scheduler/timeoutProvider");
function reportUnhandledError(err) {
    (0, _timeoutProvider.timeoutProvider).setTimeout(function() {
        var onUnhandledError = (0, _config.config).onUnhandledError;
        if (onUnhandledError) onUnhandledError(err);
        else throw err;
    });
}

},{"../config":"fX0gC","../scheduler/timeoutProvider":"1FR9J","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1FR9J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeoutProvider", ()=>timeoutProvider);
var _tslib = require("tslib");
var timeoutProvider = {
    setTimeout: function(handler, timeout) {
        var args = [];
        for(var _i = 2; _i < arguments.length; _i++)args[_i - 2] = arguments[_i];
        var delegate = timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) return delegate.setTimeout.apply(delegate, (0, _tslib.__spreadArray)([
            handler,
            timeout
        ], (0, _tslib.__read)(args)));
        return setTimeout.apply(void 0, (0, _tslib.__spreadArray)([
            handler,
            timeout
        ], (0, _tslib.__read)(args)));
    },
    clearTimeout: function(handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined
};

},{"tslib":"lRdW5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l8uEm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noop", ()=>noop);
function noop() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwqFj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "COMPLETE_NOTIFICATION", ()=>COMPLETE_NOTIFICATION);
parcelHelpers.export(exports, "errorNotification", ()=>errorNotification);
parcelHelpers.export(exports, "nextNotification", ()=>nextNotification);
parcelHelpers.export(exports, "createNotification", ()=>createNotification);
var COMPLETE_NOTIFICATION = function() {
    return createNotification("C", undefined, undefined);
}();
function errorNotification(error) {
    return createNotification("E", undefined, error);
}
function nextNotification(value) {
    return createNotification("N", value, undefined);
}
function createNotification(kind, value, error) {
    return {
        kind: kind,
        value: value,
        error: error
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gU38l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errorContext", ()=>errorContext);
parcelHelpers.export(exports, "captureError", ()=>captureError);
var _config = require("../config");
var context = null;
function errorContext(cb) {
    if ((0, _config.config).useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) context = {
            errorThrown: false,
            error: null
        };
        cb();
        if (isRoot) {
            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
            context = null;
            if (errorThrown) throw error;
        }
    } else cb();
}
function captureError(err) {
    if ((0, _config.config).useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
    }
}

},{"../config":"fX0gC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"byHtV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "observable", ()=>observable);
var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1GN6U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pipe", ()=>pipe);
parcelHelpers.export(exports, "pipeFromArray", ()=>pipeFromArray);
var _identity = require("./identity");
function pipe() {
    var fns = [];
    for(var _i = 0; _i < arguments.length; _i++)fns[_i] = arguments[_i];
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (fns.length === 0) return 0, _identity.identity;
    if (fns.length === 1) return fns[0];
    return function piped(input) {
        return fns.reduce(function(prev, fn) {
            return fn(prev);
        }, input);
    };
}

},{"./identity":"8Xfg6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Xfg6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "identity", ()=>identity);
function identity(x) {
    return x;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Vb8A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConnectableObservable", ()=>ConnectableObservable);
var _tslib = require("tslib");
var _observable = require("../Observable");
var _subscription = require("../Subscription");
var _refCount = require("../operators/refCount");
var _operatorSubscriber = require("../operators/OperatorSubscriber");
var _lift = require("../util/lift");
var ConnectableObservable = function(_super) {
    (0, _tslib.__extends)(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if ((0, _lift.hasLift)(source)) _this.lift = source.lift;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) this._subject = this.subjectFactory();
        return this._subject;
    };
    ConnectableObservable.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 || _connection.unsubscribe();
    };
    ConnectableObservable.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
            connection = this._connection = new (0, _subscription.Subscription)();
            var subject_1 = this.getSubject();
            connection.add(this.source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subject_1, undefined, function() {
                _this._teardown();
                subject_1.complete();
            }, function(err) {
                _this._teardown();
                subject_1.error(err);
            }, function() {
                return _this._teardown();
            })));
            if (connection.closed) {
                this._connection = null;
                connection = (0, _subscription.Subscription).EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function() {
        return (0, _refCount.refCount)()(this);
    };
    return ConnectableObservable;
}((0, _observable.Observable));

},{"tslib":"lRdW5","../Observable":"4Jvxr","../Subscription":"lFyhg","../operators/refCount":"6LyQe","../operators/OperatorSubscriber":"96z9b","../util/lift":"7CiSs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6LyQe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "refCount", ()=>refCount);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function refCount() {
    return (0, _lift.operate)(function(source, subscriber) {
        var connection = null;
        source._refCount++;
        var refCounter = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, undefined, undefined, undefined, function() {
            if (!source || source._refCount <= 0 || 0 < --source._refCount) {
                connection = null;
                return;
            }
            var sharedConnection = source._connection;
            var conn = connection;
            connection = null;
            if (sharedConnection && (!conn || sharedConnection === conn)) sharedConnection.unsubscribe();
            subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) connection = source.connect();
    });
}

},{"../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CiSs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasLift", ()=>hasLift);
parcelHelpers.export(exports, "operate", ()=>operate);
var _isFunction = require("./isFunction");
function hasLift(source) {
    return (0, _isFunction.isFunction)(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
    return function(source) {
        if (hasLift(source)) return source.lift(function(liftedSource) {
            try {
                return init(liftedSource, this);
            } catch (err) {
                this.error(err);
            }
        });
        throw new TypeError("Unable to lift unknown Observable type");
    };
}

},{"./isFunction":"dEyyK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"96z9b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createOperatorSubscriber", ()=>createOperatorSubscriber);
parcelHelpers.export(exports, "OperatorSubscriber", ()=>OperatorSubscriber);
var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
    (0, _tslib.__extends)(OperatorSubscriber, _super);
    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
            try {
                onNext(value);
            } catch (err) {
                destination.error(err);
            }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
            try {
                onError(err);
            } catch (err1) {
                destination.error(err1);
            } finally{
                this.unsubscribe();
            }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
            try {
                onComplete();
            } catch (err) {
                destination.error(err);
            } finally{
                this.unsubscribe();
            }
        } : _super.prototype._complete;
        return _this;
    }
    OperatorSubscriber.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 || _a.call(this));
        }
    };
    return OperatorSubscriber;
}((0, _subscriber.Subscriber));

},{"tslib":"lRdW5","../Subscriber":"1VFFQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"94RSe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subject", ()=>Subject);
parcelHelpers.export(exports, "AnonymousSubject", ()=>AnonymousSubject);
var _tslib = require("tslib");
var _observable = require("./Observable");
var _subscription = require("./Subscription");
var _objectUnsubscribedError = require("./util/ObjectUnsubscribedError");
var _arrRemove = require("./util/arrRemove");
var _errorContext = require("./util/errorContext");
var Subject = function(_super) {
    (0, _tslib.__extends)(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype._throwIfClosed = function() {
        if (this.closed) throw new (0, _objectUnsubscribedError.ObjectUnsubscribedError)();
    };
    Subject.prototype.next = function(value) {
        var _this = this;
        (0, _errorContext.errorContext)(function() {
            var e_1, _a;
            _this._throwIfClosed();
            if (!_this.isStopped) {
                if (!_this.currentObservers) _this.currentObservers = Array.from(_this.observers);
                try {
                    for(var _b = (0, _tslib.__values)(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()){
                        var observer = _c.value;
                        observer.next(value);
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
            }
        });
    };
    Subject.prototype.error = function(err) {
        var _this = this;
        (0, _errorContext.errorContext)(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.hasError = _this.isStopped = true;
                _this.thrownError = err;
                var observers = _this.observers;
                while(observers.length)observers.shift().error(err);
            }
        });
    };
    Subject.prototype.complete = function() {
        var _this = this;
        (0, _errorContext.errorContext)(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.isStopped = true;
                var observers = _this.observers;
                while(observers.length)observers.shift().complete();
            }
        });
    };
    Subject.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject.prototype, "observed", {
        get: function() {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
    });
    Subject.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
    };
    Subject.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) return 0, _subscription.EMPTY_SUBSCRIPTION;
        this.currentObservers = null;
        observers.push(subscriber);
        return new (0, _subscription.Subscription)(function() {
            _this.currentObservers = null;
            (0, _arrRemove.arrRemove)(observers, subscriber);
        });
    };
    Subject.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) subscriber.error(thrownError);
        else if (isStopped) subscriber.complete();
    };
    Subject.prototype.asObservable = function() {
        var observable = new (0, _observable.Observable)();
        observable.source = this;
        return observable;
    };
    Subject.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}((0, _observable.Observable));
var AnonymousSubject = function(_super) {
    (0, _tslib.__extends)(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 || _b.call(_a, value);
    };
    AnonymousSubject.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 || _b.call(_a, err);
    };
    AnonymousSubject.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 || _b.call(_a);
    };
    AnonymousSubject.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : (0, _subscription.EMPTY_SUBSCRIPTION);
    };
    return AnonymousSubject;
}(Subject);

},{"tslib":"lRdW5","./Observable":"4Jvxr","./Subscription":"lFyhg","./util/ObjectUnsubscribedError":"6Gcwa","./util/arrRemove":"dLHeW","./util/errorContext":"gU38l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Gcwa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ObjectUnsubscribedError", ()=>ObjectUnsubscribedError);
var _createErrorClass = require("./createErrorClass");
var ObjectUnsubscribedError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
    };
});

},{"./createErrorClass":"i1v8Q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4s6yS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BehaviorSubject", ()=>BehaviorSubject);
var _tslib = require("tslib");
var _subject = require("./Subject");
var BehaviorSubject = function(_super) {
    (0, _tslib.__extends)(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function() {
            return this.getValue();
        },
        enumerable: false,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) throw thrownError;
        this._throwIfClosed();
        return _value;
    };
    BehaviorSubject.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}((0, _subject.Subject));

},{"tslib":"lRdW5","./Subject":"94RSe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3RRP9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ReplaySubject", ()=>ReplaySubject);
var _tslib = require("tslib");
var _subject = require("./Subject");
var _dateTimestampProvider = require("./scheduler/dateTimestampProvider");
var ReplaySubject = function(_super) {
    (0, _tslib.__extends)(ReplaySubject, _super);
    function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) _bufferSize = Infinity;
        if (_windowTime === void 0) _windowTime = Infinity;
        if (_timestampProvider === void 0) _timestampProvider = (0, _dateTimestampProvider.dateTimestampProvider);
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
    }
    ReplaySubject.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
            _buffer.push(value);
            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for(var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2)subscriber.next(copy[i]);
        this._checkFinalizedStatuses(subscriber);
        return subscription;
    };
    ReplaySubject.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
            var now = _timestampProvider.now();
            var last = 0;
            for(var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2)last = i;
            last && _buffer.splice(0, last + 1);
        }
    };
    return ReplaySubject;
}((0, _subject.Subject));

},{"tslib":"lRdW5","./Subject":"94RSe","./scheduler/dateTimestampProvider":"9VL6k","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9VL6k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dateTimestampProvider", ()=>dateTimestampProvider);
var dateTimestampProvider = {
    now: function() {
        return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ercvV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asapScheduler", ()=>asapScheduler);
parcelHelpers.export(exports, "asap", ()=>asap);
var _asapAction = require("./AsapAction");
var _asapScheduler = require("./AsapScheduler");
var asapScheduler = new (0, _asapScheduler.AsapScheduler)((0, _asapAction.AsapAction));
var asap = asapScheduler;

},{"./AsapAction":"b2ORt","./AsapScheduler":"bjk5t","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b2ORt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsapAction", ()=>AsapAction);
var _tslib = require("tslib");
var _asyncAction = require("./AsyncAction");
var _immediateProvider = require("./immediateProvider");
var AsapAction = function(_super) {
    (0, _tslib.__extends)(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay !== null && delay > 0) return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = (0, _immediateProvider.immediateProvider).setImmediate(scheduler.flush.bind(scheduler, undefined)));
    };
    AsapAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay != null && delay > 0 || delay == null && this.delay > 0) return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        if (!scheduler.actions.some(function(action) {
            return action.id === id;
        })) {
            (0, _immediateProvider.immediateProvider).clearImmediate(id);
            scheduler._scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}((0, _asyncAction.AsyncAction));

},{"tslib":"lRdW5","./AsyncAction":"26t3B","./immediateProvider":"b9A4P","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"26t3B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncAction", ()=>AsyncAction);
var _tslib = require("tslib");
var _action = require("./Action");
var _intervalProvider = require("./intervalProvider");
var _arrRemove = require("../util/arrRemove");
var AsyncAction = function(_super) {
    (0, _tslib.__extends)(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function(state, delay) {
        if (delay === void 0) delay = 0;
        if (this.closed) return this;
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) this.id = this.recycleAsyncId(scheduler, id, delay);
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function(scheduler, _id, delay) {
        if (delay === void 0) delay = 0;
        return (0, _intervalProvider.intervalProvider).setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function(_scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay != null && this.delay === delay && this.pending === false) return id;
        (0, _intervalProvider.intervalProvider).clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function(state, delay) {
        if (this.closed) return new Error("executing a cancelled action");
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) return error;
        else if (this.pending === false && this.id != null) this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    };
    AsyncAction.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype.unsubscribe = function() {
        if (!this.closed) {
            var _a = this, id = _a.id, scheduler = _a.scheduler;
            var actions = scheduler.actions;
            this.work = this.state = this.scheduler = null;
            this.pending = false;
            (0, _arrRemove.arrRemove)(actions, this);
            if (id != null) this.id = this.recycleAsyncId(scheduler, id, null);
            this.delay = null;
            _super.prototype.unsubscribe.call(this);
        }
    };
    return AsyncAction;
}((0, _action.Action));

},{"tslib":"lRdW5","./Action":"iPCnX","./intervalProvider":"1Kd8E","../util/arrRemove":"dLHeW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iPCnX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Action", ()=>Action);
var _tslib = require("tslib");
var _subscription = require("../Subscription");
var Action = function(_super) {
    (0, _tslib.__extends)(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function(state, delay) {
        if (delay === void 0) delay = 0;
        return this;
    };
    return Action;
}((0, _subscription.Subscription));

},{"tslib":"lRdW5","../Subscription":"lFyhg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Kd8E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "intervalProvider", ()=>intervalProvider);
var _tslib = require("tslib");
var intervalProvider = {
    setInterval: function(handler, timeout) {
        var args = [];
        for(var _i = 2; _i < arguments.length; _i++)args[_i - 2] = arguments[_i];
        var delegate = intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) return delegate.setInterval.apply(delegate, (0, _tslib.__spreadArray)([
            handler,
            timeout
        ], (0, _tslib.__read)(args)));
        return setInterval.apply(void 0, (0, _tslib.__spreadArray)([
            handler,
            timeout
        ], (0, _tslib.__read)(args)));
    },
    clearInterval: function(handle) {
        var delegate = intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined
};

},{"tslib":"lRdW5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b9A4P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "immediateProvider", ()=>immediateProvider);
var _tslib = require("tslib");
var _immediate = require("../util/Immediate");
var setImmediate = (0, _immediate.Immediate).setImmediate, clearImmediate = (0, _immediate.Immediate).clearImmediate;
var immediateProvider = {
    setImmediate: function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        var delegate = immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(args)));
    },
    clearImmediate: function(handle) {
        var delegate = immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
    },
    delegate: undefined
};

},{"tslib":"lRdW5","../util/Immediate":"jFxbC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jFxbC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Immediate", ()=>Immediate);
parcelHelpers.export(exports, "TestTools", ()=>TestTools);
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
var Immediate = {
    setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) resolved = Promise.resolve();
        resolved.then(function() {
            return findAndClearHandle(handle) && cb();
        });
        return handle;
    },
    clearImmediate: function(handle) {
        findAndClearHandle(handle);
    }
};
var TestTools = {
    pending: function() {
        return Object.keys(activeHandles).length;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bjk5t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsapScheduler", ()=>AsapScheduler);
var _tslib = require("tslib");
var _asyncScheduler = require("./AsyncScheduler");
var AsapScheduler = function(_super) {
    (0, _tslib.__extends)(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = undefined;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) break;
        }while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
            while((action = actions[0]) && action.id === flushId && actions.shift())action.unsubscribe();
            throw error;
        }
    };
    return AsapScheduler;
}((0, _asyncScheduler.AsyncScheduler));

},{"tslib":"lRdW5","./AsyncScheduler":"c1rfP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c1rfP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncScheduler", ()=>AsyncScheduler);
var _tslib = require("tslib");
var _scheduler = require("../Scheduler");
var AsyncScheduler = function(_super) {
    (0, _tslib.__extends)(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) now = (0, _scheduler.Scheduler).now;
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        _this._scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
            actions.push(action);
            return;
        }
        var error;
        this._active = true;
        do {
            if (error = action.execute(action.state, action.delay)) break;
        }while (action = actions.shift());
        this._active = false;
        if (error) {
            while(action = actions.shift())action.unsubscribe();
            throw error;
        }
    };
    return AsyncScheduler;
}((0, _scheduler.Scheduler));

},{"tslib":"lRdW5","../Scheduler":"90yvc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"90yvc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Scheduler", ()=>Scheduler);
var _dateTimestampProvider = require("./scheduler/dateTimestampProvider");
var Scheduler = function() {
    function Scheduler(schedulerActionCtor, now) {
        if (now === void 0) now = Scheduler.now;
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
    }
    Scheduler.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) delay = 0;
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler.now = (0, _dateTimestampProvider.dateTimestampProvider).now;
    return Scheduler;
}();

},{"./scheduler/dateTimestampProvider":"9VL6k","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6sMsY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "firstValueFrom", ()=>firstValueFrom);
var _emptyError = require("./util/EmptyError");
var _subscriber = require("./Subscriber");
function firstValueFrom(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
        var subscriber = new (0, _subscriber.SafeSubscriber)({
            next: function(value) {
                resolve(value);
                subscriber.unsubscribe();
            },
            error: reject,
            complete: function() {
                if (hasConfig) resolve(config.defaultValue);
                else reject(new (0, _emptyError.EmptyError)());
            }
        });
        source.subscribe(subscriber);
    });
}

},{"./util/EmptyError":"6OnNQ","./Subscriber":"1VFFQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6OnNQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmptyError", ()=>EmptyError);
var _createErrorClass = require("./createErrorClass");
var EmptyError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
    };
});

},{"./createErrorClass":"i1v8Q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klIwv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "combineLatest", ()=>combineLatest);
parcelHelpers.export(exports, "combineLatestInit", ()=>combineLatestInit);
var _observable = require("../Observable");
var _argsArgArrayOrObject = require("../util/argsArgArrayOrObject");
var _from = require("./from");
var _identity = require("../util/identity");
var _mapOneOrManyArgs = require("../util/mapOneOrManyArgs");
var _args = require("../util/args");
var _createObject = require("../util/createObject");
var _operatorSubscriber = require("../operators/OperatorSubscriber");
var _executeSchedule = require("../util/executeSchedule");
function combineLatest() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var scheduler = (0, _args.popScheduler)(args);
    var resultSelector = (0, _args.popResultSelector)(args);
    var _a = (0, _argsArgArrayOrObject.argsArgArrayOrObject)(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) return (0, _from.from)([], scheduler);
    var result = new (0, _observable.Observable)(combineLatestInit(observables, scheduler, keys ? function(values) {
        return (0, _createObject.createObject)(keys, values);
    } : (0, _identity.identity)));
    return resultSelector ? result.pipe((0, _mapOneOrManyArgs.mapOneOrManyArgs)(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) valueTransform = (0, _identity.identity);
    return function(subscriber) {
        maybeSchedule(scheduler, function() {
            var length = observables.length;
            var values = new Array(length);
            var active = length;
            var remainingFirstValues = length;
            var _loop_1 = function(i) {
                maybeSchedule(scheduler, function() {
                    var source = (0, _from.from)(observables[i], scheduler);
                    var hasFirstValue = false;
                    source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
                        values[i] = value;
                        if (!hasFirstValue) {
                            hasFirstValue = true;
                            remainingFirstValues--;
                        }
                        if (!remainingFirstValues) subscriber.next(valueTransform(values.slice()));
                    }, function() {
                        if (!--active) subscriber.complete();
                    }));
                }, subscriber);
            };
            for(var i = 0; i < length; i++)_loop_1(i);
        }, subscriber);
    };
}
function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) (0, _executeSchedule.executeSchedule)(subscription, scheduler, execute);
    else execute();
}

},{"../Observable":"4Jvxr","../util/argsArgArrayOrObject":"sN5w7","./from":"dBWag","../util/identity":"8Xfg6","../util/mapOneOrManyArgs":"hlLvg","../util/args":"i1opM","../util/createObject":"1ntWm","../operators/OperatorSubscriber":"96z9b","../util/executeSchedule":"lF0MM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"sN5w7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "argsArgArrayOrObject", ()=>argsArgArrayOrObject);
var isArray = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(args) {
    if (args.length === 1) {
        var first_1 = args[0];
        if (isArray(first_1)) return {
            args: first_1,
            keys: null
        };
        if (isPOJO(first_1)) {
            var keys = getKeys(first_1);
            return {
                args: keys.map(function(key) {
                    return first_1[key];
                }),
                keys: keys
            };
        }
    }
    return {
        args: args,
        keys: null
    };
}
function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dBWag":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "from", ()=>from);
var _scheduled = require("../scheduled/scheduled");
var _innerFrom = require("./innerFrom");
function from(input, scheduler) {
    return scheduler ? (0, _scheduled.scheduled)(input, scheduler) : (0, _innerFrom.innerFrom)(input);
}

},{"../scheduled/scheduled":"l8eo2","./innerFrom":"27e4p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l8eo2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduled", ()=>scheduled);
var _scheduleObservable = require("./scheduleObservable");
var _schedulePromise = require("./schedulePromise");
var _scheduleArray = require("./scheduleArray");
var _scheduleIterable = require("./scheduleIterable");
var _scheduleAsyncIterable = require("./scheduleAsyncIterable");
var _isInteropObservable = require("../util/isInteropObservable");
var _isPromise = require("../util/isPromise");
var _isArrayLike = require("../util/isArrayLike");
var _isIterable = require("../util/isIterable");
var _isAsyncIterable = require("../util/isAsyncIterable");
var _throwUnobservableError = require("../util/throwUnobservableError");
var _isReadableStreamLike = require("../util/isReadableStreamLike");
var _scheduleReadableStreamLike = require("./scheduleReadableStreamLike");
function scheduled(input, scheduler) {
    if (input != null) {
        if ((0, _isInteropObservable.isInteropObservable)(input)) return (0, _scheduleObservable.scheduleObservable)(input, scheduler);
        if ((0, _isArrayLike.isArrayLike)(input)) return (0, _scheduleArray.scheduleArray)(input, scheduler);
        if ((0, _isPromise.isPromise)(input)) return (0, _schedulePromise.schedulePromise)(input, scheduler);
        if ((0, _isAsyncIterable.isAsyncIterable)(input)) return (0, _scheduleAsyncIterable.scheduleAsyncIterable)(input, scheduler);
        if ((0, _isIterable.isIterable)(input)) return (0, _scheduleIterable.scheduleIterable)(input, scheduler);
        if ((0, _isReadableStreamLike.isReadableStreamLike)(input)) return (0, _scheduleReadableStreamLike.scheduleReadableStreamLike)(input, scheduler);
    }
    throw (0, _throwUnobservableError.createInvalidObservableTypeError)(input);
}

},{"./scheduleObservable":"g2JIf","./schedulePromise":"aQruY","./scheduleArray":"e4o4N","./scheduleIterable":"1884S","./scheduleAsyncIterable":"bCUem","../util/isInteropObservable":"7Yp6b","../util/isPromise":"aVkee","../util/isArrayLike":"i81jv","../util/isIterable":"cGlpL","../util/isAsyncIterable":"fuDY5","../util/throwUnobservableError":"Il45E","../util/isReadableStreamLike":"bnSKo","./scheduleReadableStreamLike":"6KcBM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g2JIf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleObservable", ()=>scheduleObservable);
var _innerFrom = require("../observable/innerFrom");
var _observeOn = require("../operators/observeOn");
var _subscribeOn = require("../operators/subscribeOn");
function scheduleObservable(input, scheduler) {
    return (0, _innerFrom.innerFrom)(input).pipe((0, _subscribeOn.subscribeOn)(scheduler), (0, _observeOn.observeOn)(scheduler));
}

},{"../observable/innerFrom":"27e4p","../operators/observeOn":"21OcU","../operators/subscribeOn":"3SFol","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"27e4p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "innerFrom", ()=>innerFrom);
parcelHelpers.export(exports, "fromInteropObservable", ()=>fromInteropObservable);
parcelHelpers.export(exports, "fromArrayLike", ()=>fromArrayLike);
parcelHelpers.export(exports, "fromPromise", ()=>fromPromise);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "fromAsyncIterable", ()=>fromAsyncIterable);
parcelHelpers.export(exports, "fromReadableStreamLike", ()=>fromReadableStreamLike);
var _tslib = require("tslib");
var _isArrayLike = require("../util/isArrayLike");
var _isPromise = require("../util/isPromise");
var _observable = require("../Observable");
var _isInteropObservable = require("../util/isInteropObservable");
var _isAsyncIterable = require("../util/isAsyncIterable");
var _throwUnobservableError = require("../util/throwUnobservableError");
var _isIterable = require("../util/isIterable");
var _isReadableStreamLike = require("../util/isReadableStreamLike");
var _isFunction = require("../util/isFunction");
var _reportUnhandledError = require("../util/reportUnhandledError");
var _observable1 = require("../symbol/observable");
function innerFrom(input) {
    if (input instanceof (0, _observable.Observable)) return input;
    if (input != null) {
        if ((0, _isInteropObservable.isInteropObservable)(input)) return fromInteropObservable(input);
        if ((0, _isArrayLike.isArrayLike)(input)) return fromArrayLike(input);
        if ((0, _isPromise.isPromise)(input)) return fromPromise(input);
        if ((0, _isAsyncIterable.isAsyncIterable)(input)) return fromAsyncIterable(input);
        if ((0, _isIterable.isIterable)(input)) return fromIterable(input);
        if ((0, _isReadableStreamLike.isReadableStreamLike)(input)) return fromReadableStreamLike(input);
    }
    throw (0, _throwUnobservableError.createInvalidObservableTypeError)(input);
}
function fromInteropObservable(obj) {
    return new (0, _observable.Observable)(function(subscriber) {
        var obs = obj[0, _observable1.observable]();
        if ((0, _isFunction.isFunction)(obs.subscribe)) return obs.subscribe(subscriber);
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
}
function fromArrayLike(array) {
    return new (0, _observable.Observable)(function(subscriber) {
        for(var i = 0; i < array.length && !subscriber.closed; i++)subscriber.next(array[i]);
        subscriber.complete();
    });
}
function fromPromise(promise) {
    return new (0, _observable.Observable)(function(subscriber) {
        promise.then(function(value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function(err) {
            return subscriber.error(err);
        }).then(null, (0, _reportUnhandledError.reportUnhandledError));
    });
}
function fromIterable(iterable) {
    return new (0, _observable.Observable)(function(subscriber) {
        var e_1, _a;
        try {
            for(var iterable_1 = (0, _tslib.__values)(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()){
                var value = iterable_1_1.value;
                subscriber.next(value);
                if (subscriber.closed) return;
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        subscriber.complete();
    });
}
function fromAsyncIterable(asyncIterable) {
    return new (0, _observable.Observable)(function(subscriber) {
        process(asyncIterable, subscriber).catch(function(err) {
            return subscriber.error(err);
        });
    });
}
function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable((0, _isReadableStreamLike.readableStreamLikeToAsyncGenerator)(readableStream));
}
function process(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
        var value, e_2_1;
        return (0, _tslib.__generator)(this, function(_b) {
            switch(_b.label){
                case 0:
                    _b.trys.push([
                        0,
                        5,
                        6,
                        11
                    ]);
                    asyncIterable_1 = (0, _tslib.__asyncValues)(asyncIterable);
                    _b.label = 1;
                case 1:
                    return [
                        4,
                        asyncIterable_1.next()
                    ];
                case 2:
                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [
                        3,
                        4
                    ];
                    value = asyncIterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) return [
                        2
                    ];
                    _b.label = 3;
                case 3:
                    return [
                        3,
                        1
                    ];
                case 4:
                    return [
                        3,
                        11
                    ];
                case 5:
                    e_2_1 = _b.sent();
                    e_2 = {
                        error: e_2_1
                    };
                    return [
                        3,
                        11
                    ];
                case 6:
                    _b.trys.push([
                        6,
                        ,
                        9,
                        10
                    ]);
                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [
                        3,
                        8
                    ];
                    return [
                        4,
                        _a.call(asyncIterable_1)
                    ];
                case 7:
                    _b.sent();
                    _b.label = 8;
                case 8:
                    return [
                        3,
                        10
                    ];
                case 9:
                    if (e_2) throw e_2.error;
                    return [
                        7
                    ];
                case 10:
                    return [
                        7
                    ];
                case 11:
                    subscriber.complete();
                    return [
                        2
                    ];
            }
        });
    });
}

},{"tslib":"lRdW5","../util/isArrayLike":"i81jv","../util/isPromise":"aVkee","../Observable":"4Jvxr","../util/isInteropObservable":"7Yp6b","../util/isAsyncIterable":"fuDY5","../util/throwUnobservableError":"Il45E","../util/isIterable":"cGlpL","../util/isReadableStreamLike":"bnSKo","../util/isFunction":"dEyyK","../util/reportUnhandledError":"aVM3K","../symbol/observable":"byHtV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i81jv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArrayLike", ()=>isArrayLike);
var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aVkee":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
var _isFunction = require("./isFunction");
function isPromise(value) {
    return (0, _isFunction.isFunction)(value === null || value === void 0 ? void 0 : value.then);
}

},{"./isFunction":"dEyyK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Yp6b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isInteropObservable", ()=>isInteropObservable);
var _observable = require("../symbol/observable");
var _isFunction = require("./isFunction");
function isInteropObservable(input) {
    return (0, _isFunction.isFunction)(input[0, _observable.observable]);
}

},{"../symbol/observable":"byHtV","./isFunction":"dEyyK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fuDY5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isAsyncIterable", ()=>isAsyncIterable);
var _isFunction = require("./isFunction");
function isAsyncIterable(obj) {
    return Symbol.asyncIterator && (0, _isFunction.isFunction)(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

},{"./isFunction":"dEyyK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Il45E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createInvalidObservableTypeError", ()=>createInvalidObservableTypeError);
function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cGlpL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isIterable", ()=>isIterable);
var _iterator = require("../symbol/iterator");
var _isFunction = require("./isFunction");
function isIterable(input) {
    return (0, _isFunction.isFunction)(input === null || input === void 0 ? void 0 : input[0, _iterator.iterator]);
}

},{"../symbol/iterator":"l85ff","./isFunction":"dEyyK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l85ff":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSymbolIterator", ()=>getSymbolIterator);
parcelHelpers.export(exports, "iterator", ()=>iterator);
function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) return "@@iterator";
    return Symbol.iterator;
}
var iterator = getSymbolIterator();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bnSKo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "readableStreamLikeToAsyncGenerator", ()=>readableStreamLikeToAsyncGenerator);
parcelHelpers.export(exports, "isReadableStreamLike", ()=>isReadableStreamLike);
var _tslib = require("tslib");
var _isFunction = require("./isFunction");
function readableStreamLikeToAsyncGenerator(readableStream) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return (0, _tslib.__generator)(this, function(_b) {
            switch(_b.label){
                case 0:
                    reader = readableStream.getReader();
                    _b.label = 1;
                case 1:
                    _b.trys.push([
                        1,
                        ,
                        9,
                        10
                    ]);
                    _b.label = 2;
                case 2:
                    return [
                        4,
                        (0, _tslib.__await)(reader.read())
                    ];
                case 3:
                    _a = _b.sent(), value = _a.value, done = _a.done;
                    if (!done) return [
                        3,
                        5
                    ];
                    return [
                        4,
                        (0, _tslib.__await)(void 0)
                    ];
                case 4:
                    return [
                        2,
                        _b.sent()
                    ];
                case 5:
                    return [
                        4,
                        (0, _tslib.__await)(value)
                    ];
                case 6:
                    return [
                        4,
                        _b.sent()
                    ];
                case 7:
                    _b.sent();
                    return [
                        3,
                        2
                    ];
                case 8:
                    return [
                        3,
                        10
                    ];
                case 9:
                    reader.releaseLock();
                    return [
                        7
                    ];
                case 10:
                    return [
                        2
                    ];
            }
        });
    });
}
function isReadableStreamLike(obj) {
    return (0, _isFunction.isFunction)(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

},{"tslib":"lRdW5","./isFunction":"dEyyK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"21OcU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "observeOn", ()=>observeOn);
var _executeSchedule = require("../util/executeSchedule");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function observeOn(scheduler, delay) {
    if (delay === void 0) delay = 0;
    return (0, _lift.operate)(function(source, subscriber) {
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            return (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                return subscriber.next(value);
            }, delay);
        }, function() {
            return (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                return subscriber.complete();
            }, delay);
        }, function(err) {
            return (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                return subscriber.error(err);
            }, delay);
        }));
    });
}

},{"../util/executeSchedule":"lF0MM","../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lF0MM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "executeSchedule", ()=>executeSchedule);
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) delay = 0;
    if (repeat === void 0) repeat = false;
    var scheduleSubscription = scheduler.schedule(function() {
        work();
        if (repeat) parentSubscription.add(this.schedule(null, delay));
        else this.unsubscribe();
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) return scheduleSubscription;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3SFol":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subscribeOn", ()=>subscribeOn);
var _lift = require("../util/lift");
function subscribeOn(scheduler, delay) {
    if (delay === void 0) delay = 0;
    return (0, _lift.operate)(function(source, subscriber) {
        subscriber.add(scheduler.schedule(function() {
            return source.subscribe(subscriber);
        }, delay));
    });
}

},{"../util/lift":"7CiSs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aQruY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "schedulePromise", ()=>schedulePromise);
var _innerFrom = require("../observable/innerFrom");
var _observeOn = require("../operators/observeOn");
var _subscribeOn = require("../operators/subscribeOn");
function schedulePromise(input, scheduler) {
    return (0, _innerFrom.innerFrom)(input).pipe((0, _subscribeOn.subscribeOn)(scheduler), (0, _observeOn.observeOn)(scheduler));
}

},{"../observable/innerFrom":"27e4p","../operators/observeOn":"21OcU","../operators/subscribeOn":"3SFol","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e4o4N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleArray", ()=>scheduleArray);
var _observable = require("../Observable");
function scheduleArray(input, scheduler) {
    return new (0, _observable.Observable)(function(subscriber) {
        var i = 0;
        return scheduler.schedule(function() {
            if (i === input.length) subscriber.complete();
            else {
                subscriber.next(input[i++]);
                if (!subscriber.closed) this.schedule();
            }
        });
    });
}

},{"../Observable":"4Jvxr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1884S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleIterable", ()=>scheduleIterable);
var _observable = require("../Observable");
var _iterator = require("../symbol/iterator");
var _isFunction = require("../util/isFunction");
var _executeSchedule = require("../util/executeSchedule");
function scheduleIterable(input, scheduler) {
    return new (0, _observable.Observable)(function(subscriber) {
        var iterator;
        (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
            iterator = input[0, _iterator.iterator]();
            (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                var _a;
                var value;
                var done;
                try {
                    _a = iterator.next(), value = _a.value, done = _a.done;
                } catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) subscriber.complete();
                else subscriber.next(value);
            }, 0, true);
        });
        return function() {
            return (0, _isFunction.isFunction)(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
        };
    });
}

},{"../Observable":"4Jvxr","../symbol/iterator":"l85ff","../util/isFunction":"dEyyK","../util/executeSchedule":"lF0MM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bCUem":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleAsyncIterable", ()=>scheduleAsyncIterable);
var _observable = require("../Observable");
var _executeSchedule = require("../util/executeSchedule");
function scheduleAsyncIterable(input, scheduler) {
    if (!input) throw new Error("Iterable cannot be null");
    return new (0, _observable.Observable)(function(subscriber) {
        (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
            var iterator = input[Symbol.asyncIterator]();
            (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                iterator.next().then(function(result) {
                    if (result.done) subscriber.complete();
                    else subscriber.next(result.value);
                });
            }, 0, true);
        });
    });
}

},{"../Observable":"4Jvxr","../util/executeSchedule":"lF0MM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6KcBM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleReadableStreamLike", ()=>scheduleReadableStreamLike);
var _scheduleAsyncIterable = require("./scheduleAsyncIterable");
var _isReadableStreamLike = require("../util/isReadableStreamLike");
function scheduleReadableStreamLike(input, scheduler) {
    return (0, _scheduleAsyncIterable.scheduleAsyncIterable)((0, _isReadableStreamLike.readableStreamLikeToAsyncGenerator)(input), scheduler);
}

},{"./scheduleAsyncIterable":"bCUem","../util/isReadableStreamLike":"bnSKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hlLvg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapOneOrManyArgs", ()=>mapOneOrManyArgs);
var _tslib = require("tslib");
var _map = require("../operators/map");
var isArray = Array.isArray;
function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
    return (0, _map.map)(function(args) {
        return callOrApply(fn, args);
    });
}

},{"tslib":"lRdW5","../operators/map":"25iUP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"25iUP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "map", ()=>map);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function map(project, thisArg) {
    return (0, _lift.operate)(function(source, subscriber) {
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            subscriber.next(project.call(thisArg, value, index++));
        }));
    });
}

},{"../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i1opM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popResultSelector", ()=>popResultSelector);
parcelHelpers.export(exports, "popScheduler", ()=>popScheduler);
parcelHelpers.export(exports, "popNumber", ()=>popNumber);
var _isFunction = require("./isFunction");
var _isScheduler = require("./isScheduler");
function last(arr) {
    return arr[arr.length - 1];
}
function popResultSelector(args) {
    return (0, _isFunction.isFunction)(last(args)) ? args.pop() : undefined;
}
function popScheduler(args) {
    return (0, _isScheduler.isScheduler)(last(args)) ? args.pop() : undefined;
}
function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
}

},{"./isFunction":"dEyyK","./isScheduler":"67Brk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"67Brk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isScheduler", ()=>isScheduler);
var _isFunction = require("./isFunction");
function isScheduler(value) {
    return value && (0, _isFunction.isFunction)(value.schedule);
}

},{"./isFunction":"dEyyK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1ntWm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createObject", ()=>createObject);
function createObject(keys, values) {
    return keys.reduce(function(result, key, i) {
        return result[key] = values[i], result;
    }, {});
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5g0IT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concat", ()=>concat);
var _concatAll = require("../operators/concatAll");
var _args = require("../util/args");
var _from = require("./from");
function concat() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    return (0, _concatAll.concatAll)()((0, _from.from)(args, (0, _args.popScheduler)(args)));
}

},{"../operators/concatAll":"77QLf","../util/args":"i1opM","./from":"dBWag","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"77QLf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concatAll", ()=>concatAll);
var _mergeAll = require("./mergeAll");
function concatAll() {
    return (0, _mergeAll.mergeAll)(1);
}

},{"./mergeAll":"iAqyw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iAqyw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeAll", ()=>mergeAll);
var _mergeMap = require("./mergeMap");
var _identity = require("../util/identity");
function mergeAll(concurrent) {
    if (concurrent === void 0) concurrent = Infinity;
    return (0, _mergeMap.mergeMap)((0, _identity.identity), concurrent);
}

},{"./mergeMap":"1Kzmb","../util/identity":"8Xfg6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Kzmb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeMap", ()=>mergeMap);
var _map = require("./map");
var _innerFrom = require("../observable/innerFrom");
var _lift = require("../util/lift");
var _mergeInternals = require("./mergeInternals");
var _isFunction = require("../util/isFunction");
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) concurrent = Infinity;
    if ((0, _isFunction.isFunction)(resultSelector)) return mergeMap(function(a, i) {
        return (0, _map.map)(function(b, ii) {
            return resultSelector(a, b, i, ii);
        })((0, _innerFrom.innerFrom)(project(a, i)));
    }, concurrent);
    else if (typeof resultSelector === "number") concurrent = resultSelector;
    return (0, _lift.operate)(function(source, subscriber) {
        return (0, _mergeInternals.mergeInternals)(source, subscriber, project, concurrent);
    });
}

},{"./map":"25iUP","../observable/innerFrom":"27e4p","../util/lift":"7CiSs","./mergeInternals":"izBBV","../util/isFunction":"dEyyK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"izBBV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeInternals", ()=>mergeInternals);
var _innerFrom = require("../observable/innerFrom");
var _executeSchedule = require("../util/executeSchedule");
var _operatorSubscriber = require("./OperatorSubscriber");
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
        if (isComplete && !buffer.length && !active) subscriber.complete();
    };
    var outerNext = function(value) {
        return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
        expand && subscriber.next(value);
        active++;
        var innerComplete = false;
        (0, _innerFrom.innerFrom)(project(value, index++)).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(innerValue) {
            onBeforeNext === null || onBeforeNext === void 0 || onBeforeNext(innerValue);
            if (expand) outerNext(innerValue);
            else subscriber.next(innerValue);
        }, function() {
            innerComplete = true;
        }, undefined, function() {
            if (innerComplete) try {
                active--;
                var _loop_1 = function() {
                    var bufferedValue = buffer.shift();
                    if (innerSubScheduler) (0, _executeSchedule.executeSchedule)(subscriber, innerSubScheduler, function() {
                        return doInnerSub(bufferedValue);
                    });
                    else doInnerSub(bufferedValue);
                };
                while(buffer.length && active < concurrent)_loop_1();
                checkComplete();
            } catch (err) {
                subscriber.error(err);
            }
        }));
    };
    source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, outerNext, function() {
        isComplete = true;
        checkComplete();
    }));
    return function() {
        additionalFinalizer === null || additionalFinalizer === void 0 || additionalFinalizer();
    };
}

},{"../observable/innerFrom":"27e4p","../util/executeSchedule":"lF0MM","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dGHVG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY", ()=>EMPTY);
parcelHelpers.export(exports, "empty", ()=>empty);
var _observable = require("../Observable");
var EMPTY = new (0, _observable.Observable)(function(subscriber) {
    return subscriber.complete();
});
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new (0, _observable.Observable)(function(subscriber) {
        return scheduler.schedule(function() {
            return subscriber.complete();
        });
    });
}

},{"../Observable":"4Jvxr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lnQPU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "of", ()=>of);
var _args = require("../util/args");
var _from = require("./from");
function of() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var scheduler = (0, _args.popScheduler)(args);
    return (0, _from.from)(args, scheduler);
}

},{"../util/args":"i1opM","./from":"dBWag","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c58fk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jKP5Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "catchError", ()=>catchError);
var _innerFrom = require("../observable/innerFrom");
var _operatorSubscriber = require("./OperatorSubscriber");
var _lift = require("../util/lift");
function catchError(selector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var innerSub = null;
        var syncUnsub = false;
        var handledResult;
        innerSub = source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, undefined, undefined, function(err) {
            handledResult = (0, _innerFrom.innerFrom)(selector(err, catchError(selector)(source)));
            if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                handledResult.subscribe(subscriber);
            } else syncUnsub = true;
        }));
        if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
        }
    });
}

},{"../observable/innerFrom":"27e4p","./OperatorSubscriber":"96z9b","../util/lift":"7CiSs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2umbm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "connect", ()=>connect);
var _subject = require("../Subject");
var _innerFrom = require("../observable/innerFrom");
var _lift = require("../util/lift");
var _fromSubscribable = require("../observable/fromSubscribable");
var DEFAULT_CONFIG = {
    connector: function() {
        return new (0, _subject.Subject)();
    }
};
function connect(selector, config) {
    if (config === void 0) config = DEFAULT_CONFIG;
    var connector = config.connector;
    return (0, _lift.operate)(function(source, subscriber) {
        var subject = connector();
        (0, _innerFrom.innerFrom)(selector((0, _fromSubscribable.fromSubscribable)(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
    });
}

},{"../Subject":"94RSe","../observable/innerFrom":"27e4p","../util/lift":"7CiSs","../observable/fromSubscribable":"bDY0K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bDY0K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromSubscribable", ()=>fromSubscribable);
var _observable = require("../Observable");
function fromSubscribable(subscribable) {
    return new (0, _observable.Observable)(function(subscriber) {
        return subscribable.subscribe(subscriber);
    });
}

},{"../Observable":"4Jvxr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"03Bwx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultIfEmpty", ()=>defaultIfEmpty);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function defaultIfEmpty(defaultValue) {
    return (0, _lift.operate)(function(source, subscriber) {
        var hasValue = false;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            hasValue = true;
            subscriber.next(value);
        }, function() {
            if (!hasValue) subscriber.next(defaultValue);
            subscriber.complete();
        }));
    });
}

},{"../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"knFKV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distinctUntilChanged", ()=>distinctUntilChanged);
var _identity = require("../util/identity");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === void 0) keySelector = (0, _identity.identity);
    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return (0, _lift.operate)(function(source, subscriber) {
        var previousKey;
        var first = true;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var currentKey = keySelector(value);
            if (first || !comparator(previousKey, currentKey)) {
                first = false;
                previousKey = currentKey;
                subscriber.next(value);
            }
        }));
    });
}
function defaultCompare(a, b) {
    return a === b;
}

},{"../util/identity":"8Xfg6","../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gA0i5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filter", ()=>filter);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function filter(predicate, thisArg) {
    return (0, _lift.operate)(function(source, subscriber) {
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            return predicate.call(thisArg, value, index++) && subscriber.next(value);
        }));
    });
}

},{"../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Jl7y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "first", ()=>first);
var _emptyError = require("../util/EmptyError");
var _filter = require("./filter");
var _take = require("./take");
var _defaultIfEmpty = require("./defaultIfEmpty");
var _throwIfEmpty = require("./throwIfEmpty");
var _identity = require("../util/identity");
function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
        return source.pipe(predicate ? (0, _filter.filter)(function(v, i) {
            return predicate(v, i, source);
        }) : (0, _identity.identity), (0, _take.take)(1), hasDefaultValue ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue) : (0, _throwIfEmpty.throwIfEmpty)(function() {
            return new (0, _emptyError.EmptyError)();
        }));
    };
}

},{"../util/EmptyError":"6OnNQ","./filter":"gA0i5","./take":"jxxom","./defaultIfEmpty":"03Bwx","./throwIfEmpty":"1CMQN","../util/identity":"8Xfg6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jxxom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "take", ()=>take);
var _empty = require("../observable/empty");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function take(count) {
    return count <= 0 ? function() {
        return 0, _empty.EMPTY;
    } : (0, _lift.operate)(function(source, subscriber) {
        var seen = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            if (++seen <= count) {
                subscriber.next(value);
                if (count <= seen) subscriber.complete();
            }
        }));
    });
}

},{"../observable/empty":"dGHVG","../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1CMQN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "throwIfEmpty", ()=>throwIfEmpty);
var _emptyError = require("../util/EmptyError");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) errorFactory = defaultErrorFactory;
    return (0, _lift.operate)(function(source, subscriber) {
        var hasValue = false;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            hasValue = true;
            subscriber.next(value);
        }, function() {
            return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
        }));
    });
}
function defaultErrorFactory() {
    return new (0, _emptyError.EmptyError)();
}

},{"../util/EmptyError":"6OnNQ","../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8NiL4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapTo", ()=>mapTo);
var _map = require("./map");
function mapTo(value) {
    return (0, _map.map)(function() {
        return value;
    });
}

},{"./map":"25iUP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bjWSV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "multicast", ()=>multicast);
var _connectableObservable = require("../observable/ConnectableObservable");
var _isFunction = require("../util/isFunction");
var _connect = require("./connect");
function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory = (0, _isFunction.isFunction)(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
        return subjectOrSubjectFactory;
    };
    if ((0, _isFunction.isFunction)(selector)) return (0, _connect.connect)(selector, {
        connector: subjectFactory
    });
    return function(source) {
        return new (0, _connectableObservable.ConnectableObservable)(source, subjectFactory);
    };
}

},{"../observable/ConnectableObservable":"6Vb8A","../util/isFunction":"dEyyK","./connect":"2umbm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6ioy7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "publishReplay", ()=>publishReplay);
var _replaySubject = require("../ReplaySubject");
var _multicast = require("./multicast");
var _isFunction = require("../util/isFunction");
function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
    if (selectorOrScheduler && !(0, _isFunction.isFunction)(selectorOrScheduler)) timestampProvider = selectorOrScheduler;
    var selector = (0, _isFunction.isFunction)(selectorOrScheduler) ? selectorOrScheduler : undefined;
    return function(source) {
        return (0, _multicast.multicast)(new (0, _replaySubject.ReplaySubject)(bufferSize, windowTime, timestampProvider), selector)(source);
    };
}

},{"../ReplaySubject":"3RRP9","./multicast":"bjWSV","../util/isFunction":"dEyyK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8K6iO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reduce", ()=>reduce);
var _scanInternals = require("./scanInternals");
var _lift = require("../util/lift");
function reduce(accumulator, seed) {
    return (0, _lift.operate)((0, _scanInternals.scanInternals)(accumulator, seed, arguments.length >= 2, false, true));
}

},{"./scanInternals":"7fn6o","../util/lift":"7CiSs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7fn6o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scanInternals", ()=>scanInternals);
var _operatorSubscriber = require("./OperatorSubscriber");
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
        var hasState = hasSeed;
        var state = seed;
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var i = index++;
            state = hasState ? accumulator(state, value, i) : (hasState = true, value);
            emitOnNext && subscriber.next(state);
        }, emitBeforeComplete && function() {
            hasState && subscriber.next(state);
            subscriber.complete();
        }));
    };
}

},{"./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kMx2y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "startWith", ()=>startWith);
var _concat = require("../observable/concat");
var _args = require("../util/args");
var _lift = require("../util/lift");
function startWith() {
    var values = [];
    for(var _i = 0; _i < arguments.length; _i++)values[_i] = arguments[_i];
    var scheduler = (0, _args.popScheduler)(values);
    return (0, _lift.operate)(function(source, subscriber) {
        (scheduler ? (0, _concat.concat)(values, source, scheduler) : (0, _concat.concat)(values, source)).subscribe(subscriber);
    });
}

},{"../observable/concat":"5g0IT","../util/args":"i1opM","../util/lift":"7CiSs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jbzg2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "switchMap", ()=>switchMap);
var _innerFrom = require("../observable/innerFrom");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function switchMap(project, resultSelector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
            return isComplete && !innerSubscriber && subscriber.complete();
        };
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            innerSubscriber === null || innerSubscriber === void 0 || innerSubscriber.unsubscribe();
            var innerIndex = 0;
            var outerIndex = index++;
            (0, _innerFrom.innerFrom)(project(value, outerIndex)).subscribe(innerSubscriber = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(innerValue) {
                return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
            }, function() {
                innerSubscriber = null;
                checkComplete();
            }));
        }, function() {
            isComplete = true;
            checkComplete();
        }));
    });
}

},{"../observable/innerFrom":"27e4p","../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dVdZH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tap", ()=>tap);
var _isFunction = require("../util/isFunction");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _identity = require("../util/identity");
function tap(observerOrNext, error, complete) {
    var tapObserver = (0, _isFunction.isFunction)(observerOrNext) || error || complete ? {
        next: observerOrNext,
        error: error,
        complete: complete
    } : observerOrNext;
    return tapObserver ? (0, _lift.operate)(function(source, subscriber) {
        var _a;
        (_a = tapObserver.subscribe) === null || _a === void 0 || _a.call(tapObserver);
        var isUnsub = true;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var _a;
            (_a = tapObserver.next) === null || _a === void 0 || _a.call(tapObserver, value);
            subscriber.next(value);
        }, function() {
            var _a;
            isUnsub = false;
            (_a = tapObserver.complete) === null || _a === void 0 || _a.call(tapObserver);
            subscriber.complete();
        }, function(err) {
            var _a;
            isUnsub = false;
            (_a = tapObserver.error) === null || _a === void 0 || _a.call(tapObserver, err);
            subscriber.error(err);
        }, function() {
            var _a, _b;
            if (isUnsub) (_a = tapObserver.unsubscribe) === null || _a === void 0 || _a.call(tapObserver);
            (_b = tapObserver.finalize) === null || _b === void 0 || _b.call(tapObserver);
        }));
    }) : (0, _identity.identity);
}

},{"../util/isFunction":"dEyyK","../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","../util/identity":"8Xfg6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"occyH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toArray", ()=>toArray);
var _reduce = require("./reduce");
var _lift = require("../util/lift");
var arrReducer = function(arr, value) {
    return arr.push(value), arr;
};
function toArray() {
    return (0, _lift.operate)(function(source, subscriber) {
        (0, _reduce.reduce)(arrReducer, [])(source).subscribe(subscriber);
    });
}

},{"./reduce":"8K6iO","../util/lift":"7CiSs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gnxBn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterEvents", ()=>(0, _filterEventsJs.filterEvents));
parcelHelpers.export(exports, "isKeyringPair", ()=>(0, _isKeyringPairJs.isKeyringPair));
parcelHelpers.export(exports, "l", ()=>(0, _loggingJs.l));
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _decorateJs = require("./decorate.js");
parcelHelpers.exportAll(_decorateJs, exports);
var _filterEventsJs = require("./filterEvents.js");
var _isKeyringPairJs = require("./isKeyringPair.js");
var _loggingJs = require("./logging.js");

},{"./decorate.js":"dOghB","./filterEvents.js":"a7ljv","./isKeyringPair.js":"zbWpQ","./logging.js":"fpxQ9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dOghB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This is a section decorator which keeps all type information.
 */ parcelHelpers.export(exports, "decorateDeriveSections", ()=>decorateDeriveSections);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _apiDerive = require("@polkadot/api-derive");
function decorateDeriveSections(decorateMethod, derives) {
    const getKeys = (s)=>Object.keys(derives[s]);
    const creator = (s, m)=>decorateMethod(derives[s][m]);
    const result = {};
    const names = Object.keys(derives);
    for(let i = 0; i < names.length; i++)(0, _apiDerive.lazyDeriveSection)(result, names[i], getKeys, creator);
    return result;
}

},{"@polkadot/api-derive":"5hNo3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5hNo3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"akTr1","./bundle.js":"etoDJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"akTr1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"gPb2C","./packageInfo.js":"bD5x4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gPb2C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Empty template, auto-generated by @polkadot/dev
exports.default = [];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"etoDJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lazyDeriveSection", ()=>(0, _indexJs.lazyDeriveSection)) // Enable derive only if some of these modules are available
;
// For now we just drop the custom derive typings
/** @internal */ parcelHelpers.export(exports, "getAvailableDerives", ()=>getAvailableDerives);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _deriveJs = require("./derive.js");
var _indexJs = require("./util/index.js");
parcelHelpers.exportAll(_deriveJs, exports);
var _indexJs1 = require("./type/index.js");
parcelHelpers.exportAll(_indexJs1, exports);
const checks = {
    bagsList: {
        instances: [
            "voterList",
            "bagsList"
        ],
        methods: [],
        withDetect: true
    },
    contracts: {
        instances: [
            "contracts"
        ],
        methods: []
    },
    council: {
        instances: [
            "council"
        ],
        methods: [],
        withDetect: true
    },
    crowdloan: {
        instances: [
            "crowdloan"
        ],
        methods: []
    },
    democracy: {
        instances: [
            "democracy"
        ],
        methods: []
    },
    elections: {
        instances: [
            "phragmenElection",
            "electionsPhragmen",
            "elections",
            "council"
        ],
        methods: [],
        withDetect: true
    },
    imOnline: {
        instances: [
            "imOnline"
        ],
        methods: []
    },
    membership: {
        instances: [
            "membership"
        ],
        methods: []
    },
    parachains: {
        instances: [
            "parachains",
            "registrar"
        ],
        methods: []
    },
    session: {
        instances: [
            "session"
        ],
        methods: []
    },
    society: {
        instances: [
            "society"
        ],
        methods: []
    },
    staking: {
        instances: [
            "staking"
        ],
        methods: [
            "erasRewardPoints"
        ]
    },
    technicalCommittee: {
        instances: [
            "technicalCommittee"
        ],
        methods: [],
        withDetect: true
    },
    treasury: {
        instances: [
            "treasury"
        ],
        methods: []
    }
};
function getModuleInstances(api, specName, moduleName) {
    return api.registry.getModuleInstances(specName, moduleName) || [];
}
/**
 * Returns an object that will inject `api` into all the functions inside
 * `allSections`, and keep the object architecture of `allSections`.
 */ /** @internal */ function injectFunctions(instanceId, api, derives) {
    const result = {};
    const names = Object.keys(derives);
    const keys = Object.keys(api.query);
    const specName = api.runtimeVersion.specName;
    const filterKeys = (q)=>keys.includes(q);
    const filterInstances = (q)=>getModuleInstances(api, specName, q).some(filterKeys);
    const filterMethods = (all)=>(m)=>all.some((q)=>keys.includes(q) && api.query[q][m]);
    const getKeys = (s)=>Object.keys(derives[s]);
    const creator = (s, m)=>derives[s][m](instanceId, api);
    const isIncluded = (c)=>!checks[c] || checks[c].instances.some(filterKeys) && (!checks[c].methods.length || checks[c].methods.every(filterMethods(checks[c].instances))) || checks[c].withDetect && checks[c].instances.some(filterInstances);
    for(let i = 0; i < names.length; i++){
        const name = names[i];
        isIncluded(name) && (0, _indexJs.lazyDeriveSection)(result, name, getKeys, creator);
    }
    return result;
} // FIXME The return type of this function should be {...ExactDerive, ...DeriveCustom}
function getAvailableDerives(instanceId, api, custom = {}) {
    return {
        ...injectFunctions(instanceId, api, (0, _deriveJs.derive)),
        ...injectFunctions(instanceId, api, custom)
    };
}

},{"./derive.js":"l831w","./util/index.js":"cN7tY","./type/index.js":"cd05H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l831w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "derive", ()=>derive);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("./accounts/index.js");
var _indexJs1 = require("./bagsList/index.js");
var _indexJs2 = require("./balances/index.js");
var _indexJs3 = require("./bounties/index.js");
var _indexJs4 = require("./chain/index.js");
var _indexJs5 = require("./contracts/index.js");
var _indexJs6 = require("./council/index.js");
var _indexJs7 = require("./crowdloan/index.js");
var _indexJs8 = require("./democracy/index.js");
var _indexJs9 = require("./elections/index.js");
var _indexJs10 = require("./imOnline/index.js");
var _indexJs11 = require("./membership/index.js");
var _indexJs12 = require("./parachains/index.js");
var _indexJs13 = require("./session/index.js");
var _indexJs14 = require("./society/index.js");
var _indexJs15 = require("./staking/index.js");
var _indexJs16 = require("./technicalCommittee/index.js");
var _indexJs17 = require("./treasury/index.js");
var _indexJs18 = require("./tx/index.js");
const derive = {
    accounts: _indexJs,
    bagsList: _indexJs1,
    balances: _indexJs2,
    bounties: _indexJs3,
    chain: _indexJs4,
    contracts: _indexJs5,
    council: _indexJs6,
    crowdloan: _indexJs7,
    democracy: _indexJs8,
    elections: _indexJs9,
    imOnline: _indexJs10,
    membership: _indexJs11,
    parachains: _indexJs12,
    session: _indexJs13,
    society: _indexJs14,
    staking: _indexJs15,
    technicalCommittee: _indexJs16,
    treasury: _indexJs17,
    tx: _indexJs18
};

},{"./accounts/index.js":"7W6rl","./bagsList/index.js":"57KV3","./balances/index.js":"jOGiw","./bounties/index.js":"6JcL5","./chain/index.js":"9gS3k","./contracts/index.js":"5txcW","./council/index.js":"foPeO","./crowdloan/index.js":"emHOx","./democracy/index.js":"859YG","./elections/index.js":"fNaCt","./imOnline/index.js":"kJWmI","./membership/index.js":"61FaC","./parachains/index.js":"bJVqc","./session/index.js":"9XXME","./society/index.js":"1Vl0X","./staking/index.js":"4ZPwx","./technicalCommittee/index.js":"1wdIE","./treasury/index.js":"d9FCT","./tx/index.js":"3OoHL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7W6rl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _accountIdJs = require("./accountId.js");
parcelHelpers.exportAll(_accountIdJs, exports);
var _flagsJs = require("./flags.js");
parcelHelpers.exportAll(_flagsJs, exports);
var _idAndIndexJs = require("./idAndIndex.js");
parcelHelpers.exportAll(_idAndIndexJs, exports);
var _idToIndexJs = require("./idToIndex.js");
parcelHelpers.exportAll(_idToIndexJs, exports);
var _identityJs = require("./identity.js");
parcelHelpers.exportAll(_identityJs, exports);
var _indexToIdJs = require("./indexToId.js");
parcelHelpers.exportAll(_indexToIdJs, exports);
var _indexesJs = require("./indexes.js");
parcelHelpers.exportAll(_indexesJs, exports);
var _infoJs = require("./info.js");
parcelHelpers.exportAll(_infoJs, exports);

},{"./accountId.js":"7KK8r","./flags.js":"7CqbO","./idAndIndex.js":"9dHsI","./idToIndex.js":"h6dAG","./identity.js":"15R4i","./indexToId.js":"17gC4","./indexes.js":"d1wmx","./info.js":"b0w4D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7KK8r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name accountId
 * @param {(Address | AccountId | AccountIndex | string | null)} address - An accounts address in various formats.
 * @description  An [[AccountId]]
 */ parcelHelpers.export(exports, "accountId", ()=>accountId);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _indexJs = require("../util/index.js");
function accountId(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (address)=>{
        const decoded = (0, _util.isU8a)(address) ? address : (0, _utilCrypto.decodeAddress)((address || "").toString());
        if (decoded.length > 8) return (0, _rxjs.of)(api.registry.createType("AccountId", decoded));
        const accountIndex = api.registry.createType("AccountIndex", decoded);
        return api.derive.accounts.indexToId(accountIndex.toString()).pipe((0, _rxjs.map)((a)=>(0, _util.assertReturn)(a, "Unable to retrieve accountId")));
    });
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cN7tY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "drr", ()=>(0, _rpcCore.drr));
parcelHelpers.export(exports, "memo", ()=>(0, _rpcCore.memo));
var _rpcCore = require("@polkadot/rpc-core");
var _approvalFlagsToBoolsJs = require("./approvalFlagsToBools.js");
parcelHelpers.exportAll(_approvalFlagsToBoolsJs, exports);
var _blockNumberJs = require("./blockNumber.js");
parcelHelpers.exportAll(_blockNumberJs, exports);
var _cacheJs = require("./cache.js");
parcelHelpers.exportAll(_cacheJs, exports);
var _cacheImplJs = require("./cacheImpl.js");
parcelHelpers.exportAll(_cacheImplJs, exports);
var _firstJs = require("./first.js");
parcelHelpers.exportAll(_firstJs, exports);
var _lazyJs = require("./lazy.js");
parcelHelpers.exportAll(_lazyJs, exports);

},{"@polkadot/rpc-core":"8DbiP","./approvalFlagsToBools.js":"3AZuH","./blockNumber.js":"40yRm","./cache.js":"71fW9","./cacheImpl.js":"8ec7w","./first.js":"xmW8w","./lazy.js":"jmKEw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8DbiP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"lMXp3","./bundle.js":"7rPNR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lMXp3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"l8Dv7","./packageInfo.js":"3xOtl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l8Dv7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/rpc-provider/packageInfo");
var _packageInfo1 = require("@polkadot/types/packageInfo");
exports.default = [
    (0, _packageInfo.packageInfo),
    (0, _packageInfo1.packageInfo)
];

},{"@polkadot/rpc-provider/packageInfo":"bkNCg","@polkadot/types/packageInfo":"cIucp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7rPNR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
/**
 * @name Rpc
 * @summary The API may use a HTTP or WebSockets provider.
 * @description It allows for querying a Polkadot Client Node.
 * WebSockets provider is recommended since HTTP provider only supports basic querying.
 *
 * ```mermaid
 * graph LR;
 *   A[Api] --> |WebSockets| B[WsProvider];
 *   B --> |endpoint| C[ws://127.0.0.1:9944]
 * ```
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Rpc from '@polkadot/rpc-core';
 * import { WsProvider } from '@polkadot/rpc-provider/ws';
 *
 * const provider = new WsProvider('ws://127.0.0.1:9944');
 * const rpc = new Rpc(provider);
 * ```
 */ parcelHelpers.export(exports, "RpcCore", ()=>RpcCore);
// Copyright 2017-2022 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _types = require("@polkadot/types");
var _util = require("@polkadot/util");
var _indexJs = require("./util/index.js");
var _packageInfoJs = require("./packageInfo.js");
parcelHelpers.exportAll(_indexJs, exports);
const l = (0, _util.logger)("rpc-core");
const EMPTY_META = {
    fallback: undefined,
    modifier: {
        isOptional: true
    },
    type: {
        asMap: {
            linked: {
                isTrue: false
            }
        },
        isMap: false
    }
}; // utility method to create a nicely-formatted error
/** @internal */ function logErrorMessage(method, { noErrorLog , params , type  }, error) {
    if (noErrorLog) return;
    const inputs = params.map(({ isOptional , name , type  })=>`${name}${isOptional ? "?" : ""}: ${type}`).join(", ");
    l.error(`${method}(${inputs}): ${type}:: ${error.message}`);
}
function isTreatAsHex(key) {
    // :code is problematic - it does not have the length attached, which is
    // unlike all other storage entries where it is indeed properly encoded
    return [
        "0x3a636f6465"
    ].includes(key.toHex());
}
class RpcCore {
    #instanceId;
    #registryDefault;
    #getBlockRegistry;
    #getBlockHash;
    #storageCache = new Map();
    mapping = new Map();
    sections = [];
    /**
   * @constructor
   * Default constructor for the Api Object
   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket
   */ constructor(instanceId, registry, provider, userRpc = {}){
        // eslint-disable-next-line @typescript-eslint/unbound-method
        if (!provider || !(0, _util.isFunction)(provider.send)) throw new Error("Expected Provider to API create");
        this.#instanceId = instanceId;
        this.#registryDefault = registry;
        this.provider = provider;
        const sectionNames = Object.keys((0, _types.rpcDefinitions)); // these are the base keys (i.e. part of jsonrpc)
        this.sections.push(...sectionNames); // decorate all interfaces, defined and user on this instance
        this.addUserInterfaces(userRpc);
    }
    /**
   * @description Returns the connected status of a provider
   */ get isConnected() {
        return this.provider.isConnected;
    }
    /**
   * @description Manually connect from the attached provider
   */ connect() {
        return this.provider.connect();
    }
    /**
   * @description Manually disconnect from the attached provider
   */ disconnect() {
        return this.provider.disconnect();
    }
    /**
   * @description Sets a registry swap (typically from Api)
   */ setRegistrySwap(registrySwap) {
        this.#getBlockRegistry = (0, _util.memoize)(registrySwap, {
            getInstanceId: ()=>this.#instanceId
        });
    }
    /**
   * @description Sets a function to resolve block hash from block number
   */ setResolveBlockHash(resolveBlockHash) {
        this.#getBlockHash = (0, _util.memoize)(resolveBlockHash, {
            getInstanceId: ()=>this.#instanceId
        });
    }
    addUserInterfaces(userRpc) {
        // add any extra user-defined sections
        this.sections.push(...Object.keys(userRpc).filter((k)=>!this.sections.includes(k)));
        for(let s = 0; s < this.sections.length; s++){
            const section = this.sections[s];
            const defs = (0, _util.objectSpread)({}, (0, _types.rpcDefinitions)[section], userRpc[section]);
            const methods = Object.keys(defs);
            for(let m = 0; m < methods.length; m++){
                const method = methods[m];
                const def = defs[method];
                const jsonrpc = def.endpoint || `${section}_${method}`;
                if (!this.mapping.has(jsonrpc)) {
                    const isSubscription = !!def.pubsub;
                    if (!this[section]) this[section] = {};
                    this.mapping.set(jsonrpc, (0, _util.objectSpread)({}, def, {
                        isSubscription,
                        jsonrpc,
                        method,
                        section
                    }));
                    (0, _util.lazyMethod)(this[section], method, ()=>isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def));
                }
            }
        }
    }
    _memomize(creator, def) {
        const memoOpts = {
            getInstanceId: ()=>this.#instanceId
        };
        const memoized = (0, _util.memoize)(creator(true), memoOpts);
        memoized.raw = (0, _util.memoize)(creator(false), memoOpts);
        memoized.meta = def;
        return memoized;
    }
    _formatResult(isScale, registry, blockHash, method, def, params, result) {
        return isScale ? this._formatOutput(registry, blockHash, method, def, params, result) : result;
    }
    _createMethodSend(section, method, def) {
        const rpcName = def.endpoint || `${section}_${method}`;
        const hashIndex = def.params.findIndex(({ isHistoric  })=>isHistoric);
        let memoized = null; // execute the RPC call, doing a registry swap for historic as applicable
        const callWithRegistry = async (isScale, values)=>{
            var _this$getBlockHash;
            const blockId = hashIndex === -1 ? null : values[hashIndex];
            const blockHash = blockId && def.params[hashIndex].type === "BlockNumber" ? await ((_this$getBlockHash = this.#getBlockHash) === null || _this$getBlockHash === void 0 ? void 0 : _this$getBlockHash.call(this, blockId)) : blockId;
            const { registry  } = isScale && blockHash && this.#getBlockRegistry ? await this.#getBlockRegistry((0, _util.u8aToU8a)(blockHash)) : {
                registry: this.#registryDefault
            };
            const params = this._formatInputs(registry, null, def, values); // only cache .at(<blockHash>) queries, e.g. where valid blockHash was supplied
            const result = await this.provider.send(rpcName, params.map((p)=>p.toJSON()), !!blockHash);
            return this._formatResult(isScale, registry, blockHash, method, def, params, result);
        };
        const creator = (isScale)=>(...values)=>{
                const isDelayed = isScale && hashIndex !== -1 && !!values[hashIndex];
                return new (0, _rxjs.Observable)((observer)=>{
                    callWithRegistry(isScale, values).then((value)=>{
                        observer.next(value);
                        observer.complete();
                    }).catch((error)=>{
                        logErrorMessage(method, def, error);
                        observer.error(error);
                        observer.complete();
                    });
                    return ()=>{
                        // delete old results from cache
                        if (isScale) {
                            var _memoized;
                            (_memoized = memoized) === null || _memoized === void 0 || _memoized.unmemoize(...values);
                        } else {
                            var _memoized2;
                            (_memoized2 = memoized) === null || _memoized2 === void 0 || _memoized2.raw.unmemoize(...values);
                        }
                    };
                }).pipe((0, _rxjs.publishReplay)(1), isDelayed ? (0, _indexJs.refCountDelay)() // Unsubscribe after delay
                 : (0, _rxjs.refCount)());
            };
        memoized = this._memomize(creator, def);
        return memoized;
    }
    _createSubscriber({ paramsJson , subName , subType , update  }, errorHandler) {
        return new Promise((resolve, reject)=>{
            this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch((error)=>{
                errorHandler(error);
                reject(error);
            });
        });
    }
    _createMethodSubscribe(section, method, def) {
        const [updateType, subMethod, unsubMethod] = def.pubsub;
        const subName = `${section}_${subMethod}`;
        const unsubName = `${section}_${unsubMethod}`;
        const subType = `${section}_${updateType}`;
        let memoized = null;
        const creator = (isScale)=>(...values)=>{
                return new (0, _rxjs.Observable)((observer)=>{
                    // Have at least an empty promise, as used in the unsubscribe
                    let subscriptionPromise = Promise.resolve(null);
                    const registry = this.#registryDefault;
                    const errorHandler = (error)=>{
                        logErrorMessage(method, def, error);
                        observer.error(error);
                    };
                    try {
                        const params = this._formatInputs(registry, null, def, values);
                        const paramsJson = params.map((p)=>p.toJSON());
                        const update = (error, result)=>{
                            if (error) {
                                logErrorMessage(method, def, error);
                                return;
                            }
                            try {
                                observer.next(this._formatResult(isScale, registry, null, method, def, params, result));
                            } catch (error1) {
                                observer.error(error1);
                            }
                        };
                        subscriptionPromise = this._createSubscriber({
                            paramsJson,
                            subName,
                            subType,
                            update
                        }, errorHandler);
                    } catch (error) {
                        errorHandler(error);
                    } // Teardown logic
                    return ()=>{
                        // Delete from cache, so old results don't hang around
                        if (isScale) {
                            var _memoized3;
                            (_memoized3 = memoized) === null || _memoized3 === void 0 || _memoized3.unmemoize(...values);
                        } else {
                            var _memoized4;
                            (_memoized4 = memoized) === null || _memoized4 === void 0 || _memoized4.raw.unmemoize(...values);
                        } // Unsubscribe from provider
                        subscriptionPromise.then((subscriptionId)=>(0, _util.isNull)(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch((error)=>logErrorMessage(method, def, error));
                    };
                }).pipe((0, _indexJs.drr)());
            };
        memoized = this._memomize(creator, def);
        return memoized;
    }
    _formatInputs(registry, blockHash, def, inputs) {
        const reqArgCount = def.params.filter(({ isOptional  })=>!isOptional).length;
        const optText = reqArgCount === def.params.length ? "" : ` (${def.params.length - reqArgCount} optional)`;
        if (inputs.length < reqArgCount || inputs.length > def.params.length) throw new Error(`Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);
        return inputs.map((input, index)=>registry.createTypeUnsafe(def.params[index].type, [
                input
            ], {
                blockHash
            }));
    }
    _formatOutput(registry, blockHash, method, rpc, params, result) {
        if (rpc.type === "StorageData") {
            const key = params[0];
            return this._formatStorageData(registry, blockHash, key, result);
        } else if (rpc.type === "StorageChangeSet") {
            const keys = params[0];
            return keys ? this._formatStorageSet(registry, result.block, keys, result.changes) : registry.createType("StorageChangeSet", result);
        } else if (rpc.type === "Vec<StorageChangeSet>") {
            const mapped = result.map(({ block , changes  })=>[
                    registry.createType("Hash", block),
                    this._formatStorageSet(registry, block, params[0], changes)
                ]); // we only query at a specific block, not a range - flatten
            return method === "queryStorageAt" ? mapped[0][1] : mapped;
        }
        return registry.createTypeUnsafe(rpc.type, [
            result
        ], {
            blockHash
        });
    }
    _formatStorageData(registry, blockHash, key, value) {
        const isEmpty = (0, _util.isNull)(value); // we convert to Uint8Array since it maps to the raw encoding, all
        // data will be correctly encoded (incl. numbers, excl. :code)
        const input = isEmpty ? null : isTreatAsHex(key) ? value : (0, _util.u8aToU8a)(value);
        return this._newType(registry, blockHash, key, input, isEmpty);
    }
    _formatStorageSet(registry, blockHash, keys, changes) {
        // For StorageChangeSet, the changes has the [key, value] mappings
        const withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values
        // one at a time, all based on the query types. Three values can be returned -
        //   - Codec - There is a valid value, non-empty
        //   - null - The storage key is empty
        return keys.reduce((results, key, index)=>{
            results.push(this._formatStorageSetEntry(registry, blockHash, key, changes, withCache, index));
            return results;
        }, []);
    }
    _formatStorageSetEntry(registry, blockHash, key, changes, withCache, entryIndex) {
        const hexKey = key.toHex();
        const found = changes.find(([key])=>key === hexKey);
        const isNotFound = (0, _util.isUndefined)(found); // if we don't find the value, this is our fallback
        //   - in the case of an array of values, fill the hole from the cache
        //   - if a single result value, don't fill - it is not an update hole
        //   - fallback to an empty option in all cases
        if (isNotFound && withCache) {
            const cached = this.#storageCache.get(hexKey);
            if (cached) return cached;
        }
        const value = isNotFound ? null : found[1];
        const isEmpty = (0, _util.isNull)(value);
        const input = isEmpty || isTreatAsHex(key) ? value : (0, _util.u8aToU8a)(value);
        const codec = this._newType(registry, blockHash, key, input, isEmpty, entryIndex); // store the retrieved result - the only issue with this cache is that there is no
        // clearing of it, so very long running processes (not just a couple of hours, longer)
        // will increase memory beyond what is allowed.
        this.#storageCache.set(hexKey, codec);
        return codec;
    }
    _newType(registry, blockHash, key, input, isEmpty, entryIndex = -1) {
        // single return value (via state.getStorage), decode the value based on the
        // outputType that we have specified. Fallback to Raw on nothing
        const type = key.outputType || "Raw";
        const meta = key.meta || EMPTY_META;
        const entryNum = entryIndex === -1 ? "" : ` entry ${entryIndex}:`;
        try {
            return registry.createTypeUnsafe(type, [
                isEmpty ? meta.fallback // For old-style Linkage, we add an empty linkage at the end
                 ? type.includes("Linkage<") ? (0, _util.u8aConcat)((0, _util.hexToU8a)(meta.fallback.toHex()), new Uint8Array(2)) : (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : meta.modifier.isOptional ? registry.createTypeUnsafe(type, [
                    input
                ], {
                    blockHash,
                    isPedantic: true
                }) : input
            ], {
                blockHash,
                isOptional: meta.modifier.isOptional,
                isPedantic: !meta.modifier.isOptional
            });
        } catch (error) {
            throw new Error(`Unable to decode storage ${key.section || "unknown"}.${key.method || "unknown"}:${entryNum}: ${error.message}`);
        }
    }
}

},{"rxjs":"lLy7s","@polkadot/types":"fnDGk","@polkadot/util":"3HnHw","./util/index.js":"6dxRh","./packageInfo.js":"3xOtl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fnDGk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"1v6yX","./bundle.js":"6NAac","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1v6yX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"gUxEK","./packageInfo.js":"cIucp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gUxEK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/types-codec/packageInfo");
var _packageInfo1 = require("@polkadot/types-create/packageInfo");
exports.default = [
    (0, _packageInfo.packageInfo),
    (0, _packageInfo1.packageInfo)
];

},{"@polkadot/types-codec/packageInfo":"2E3zV","@polkadot/types-create/packageInfo":"cUwPM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2E3zV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $1ed217d034207ea4$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/types-codec/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/types-codec",
    path: $1ed217d034207ea4$import_meta && "file:///node_modules/@polkadot/types-codec/packageInfo.js" ? new URL("file:///node_modules/@polkadot/types-codec/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/types-codec/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "8.14.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cUwPM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "packageInfo", ()=>packageInfo);
var $96642f2809a73f8a$import_meta = Object.assign(Object.create(null), {
    url: "file:///node_modules/@polkadot/types-create/packageInfo.js"
});
const packageInfo = {
    name: "@polkadot/types-create",
    path: $96642f2809a73f8a$import_meta && "file:///node_modules/@polkadot/types-create/packageInfo.js" ? new URL("file:///node_modules/@polkadot/types-create/packageInfo.js").pathname.substring(0, new URL("file:///node_modules/@polkadot/types-create/packageInfo.js").pathname.lastIndexOf("/") + 1) : "auto",
    type: "esm",
    version: "8.14.1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6NAac":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeDefInfo", ()=>(0, _typesCreate.TypeDefInfo));
parcelHelpers.export(exports, "convertSiV0toV1", ()=>(0, _indexJs3.convertSiV0toV1));
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
parcelHelpers.export(exports, "unwrapStorageType", ()=>(0, _storageKeyJs.unwrapStorageType));
parcelHelpers.export(exports, "typeDefinitions", ()=>_definitionsJs);
parcelHelpers.export(exports, "rpcDefinitions", ()=>(0, _jsonrpcJsDefault.default));
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _definitionsJs = require("./interfaces/definitions.js");
var _jsonrpcJs = require("./interfaces/jsonrpc.js");
var _jsonrpcJsDefault = parcelHelpers.interopDefault(_jsonrpcJs);
var _indexJs = require("./codec/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var _indexJs1 = require("./create/index.js");
parcelHelpers.exportAll(_indexJs1, exports);
var _indexTypesJs = require("./index.types.js");
parcelHelpers.exportAll(_indexTypesJs, exports);
var _indexJs2 = require("./metadata/index.js");
parcelHelpers.exportAll(_indexJs2, exports);
var _typesCreate = require("@polkadot/types-create");
var _indexJs3 = require("./metadata/PortableRegistry/index.js");
var _packageInfoJs = require("./packageInfo.js");
var _storageKeyJs = require("./primitive/StorageKey.js");

},{"./interfaces/definitions.js":"44OZI","./interfaces/jsonrpc.js":"WQpKM","./codec/index.js":"iQbAh","./create/index.js":"7qdxB","./index.types.js":"b4BtA","./metadata/index.js":"5EZrK","@polkadot/types-create":"cr6lO","./metadata/PortableRegistry/index.js":"9hFU1","./packageInfo.js":"cIucp","./primitive/StorageKey.js":"fD5Ag","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"44OZI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assets", ()=>(0, _definitionsJsDefault.default));
parcelHelpers.export(exports, "authorship", ()=>(0, _definitionsJsDefault1.default));
parcelHelpers.export(exports, "aura", ()=>(0, _definitionsJsDefault2.default));
parcelHelpers.export(exports, "babe", ()=>(0, _definitionsJsDefault3.default));
parcelHelpers.export(exports, "balances", ()=>(0, _definitionsJsDefault4.default));
parcelHelpers.export(exports, "beefy", ()=>(0, _definitionsJsDefault5.default));
parcelHelpers.export(exports, "benchmark", ()=>(0, _definitionsJsDefault6.default));
parcelHelpers.export(exports, "blockbuilder", ()=>(0, _definitionsJsDefault7.default));
parcelHelpers.export(exports, "collective", ()=>(0, _definitionsJsDefault8.default));
parcelHelpers.export(exports, "consensus", ()=>(0, _definitionsJsDefault9.default));
parcelHelpers.export(exports, "contracts", ()=>(0, _definitionsJsDefault10.default));
parcelHelpers.export(exports, "democracy", ()=>(0, _definitionsJsDefault11.default));
parcelHelpers.export(exports, "dev", ()=>(0, _definitionsJsDefault12.default));
parcelHelpers.export(exports, "discovery", ()=>(0, _definitionsJsDefault13.default));
parcelHelpers.export(exports, "elections", ()=>(0, _definitionsJsDefault14.default));
parcelHelpers.export(exports, "engine", ()=>(0, _definitionsJsDefault15.default));
parcelHelpers.export(exports, "evm", ()=>(0, _definitionsJsDefault16.default));
parcelHelpers.export(exports, "extrinsics", ()=>(0, _definitionsJsDefault17.default));
parcelHelpers.export(exports, "genericAsset", ()=>(0, _definitionsJsDefault18.default));
parcelHelpers.export(exports, "gilt", ()=>(0, _definitionsJsDefault19.default));
parcelHelpers.export(exports, "grandpa", ()=>(0, _definitionsJsDefault20.default));
parcelHelpers.export(exports, "identity", ()=>(0, _definitionsJsDefault21.default));
parcelHelpers.export(exports, "imOnline", ()=>(0, _definitionsJsDefault22.default));
parcelHelpers.export(exports, "lottery", ()=>(0, _definitionsJsDefault23.default));
parcelHelpers.export(exports, "mmr", ()=>(0, _definitionsJsDefault24.default));
parcelHelpers.export(exports, "nompools", ()=>(0, _definitionsJsDefault25.default));
parcelHelpers.export(exports, "offences", ()=>(0, _definitionsJsDefault26.default));
parcelHelpers.export(exports, "pow", ()=>(0, _definitionsJsDefault27.default));
parcelHelpers.export(exports, "proxy", ()=>(0, _definitionsJsDefault28.default));
parcelHelpers.export(exports, "recovery", ()=>(0, _definitionsJsDefault29.default));
parcelHelpers.export(exports, "scheduler", ()=>(0, _definitionsJsDefault30.default));
parcelHelpers.export(exports, "session", ()=>(0, _definitionsJsDefault31.default));
parcelHelpers.export(exports, "society", ()=>(0, _definitionsJsDefault32.default));
parcelHelpers.export(exports, "staking", ()=>(0, _definitionsJsDefault33.default));
parcelHelpers.export(exports, "support", ()=>(0, _definitionsJsDefault34.default));
parcelHelpers.export(exports, "syncstate", ()=>(0, _definitionsJsDefault35.default));
parcelHelpers.export(exports, "system", ()=>(0, _definitionsJsDefault36.default));
parcelHelpers.export(exports, "treasury", ()=>(0, _definitionsJsDefault37.default));
parcelHelpers.export(exports, "txpayment", ()=>(0, _definitionsJsDefault38.default));
parcelHelpers.export(exports, "txqueue", ()=>(0, _definitionsJsDefault39.default));
parcelHelpers.export(exports, "uniques", ()=>(0, _definitionsJsDefault40.default));
parcelHelpers.export(exports, "utility", ()=>(0, _definitionsJsDefault41.default));
parcelHelpers.export(exports, "vesting", ()=>(0, _definitionsJsDefault42.default)) // polkadot-specific types
;
parcelHelpers.export(exports, "attestations", ()=>(0, _definitionsJsDefault43.default));
parcelHelpers.export(exports, "bridges", ()=>(0, _definitionsJsDefault44.default));
parcelHelpers.export(exports, "claims", ()=>(0, _definitionsJsDefault45.default));
parcelHelpers.export(exports, "crowdloan", ()=>(0, _definitionsJsDefault46.default));
parcelHelpers.export(exports, "cumulus", ()=>(0, _definitionsJsDefault47.default));
parcelHelpers.export(exports, "finality", ()=>(0, _definitionsJsDefault48.default));
parcelHelpers.export(exports, "parachains", ()=>(0, _definitionsJsDefault49.default));
parcelHelpers.export(exports, "poll", ()=>(0, _definitionsJsDefault50.default));
parcelHelpers.export(exports, "purchase", ()=>(0, _definitionsJsDefault51.default));
parcelHelpers.export(exports, "xcm", ()=>(0, _definitionsJsDefault52.default)) // other useful types
;
parcelHelpers.export(exports, "contractsAbi", ()=>(0, _definitionsJsDefault53.default));
parcelHelpers.export(exports, "eth", ()=>(0, _definitionsJsDefault54.default)) // additional known/community definitions
;
parcelHelpers.export(exports, "nimbus", ()=>(0, _definitionsJsDefault55.default));
parcelHelpers.export(exports, "ormlOracle", ()=>(0, _definitionsJsDefault56.default));
parcelHelpers.export(exports, "ormlTokens", ()=>(0, _definitionsJsDefault57.default)) // pull in rpc last, assuming that is uses info from above
;
parcelHelpers.export(exports, "rpc", ()=>(0, _definitionsJsDefault58.default)) // rpc-only definitions
;
parcelHelpers.export(exports, "author", ()=>(0, _definitionsJsDefault59.default));
parcelHelpers.export(exports, "chain", ()=>(0, _definitionsJsDefault60.default));
parcelHelpers.export(exports, "childstate", ()=>(0, _definitionsJsDefault61.default));
parcelHelpers.export(exports, "offchain", ()=>(0, _definitionsJsDefault62.default));
parcelHelpers.export(exports, "payment", ()=>(0, _definitionsJsDefault63.default));
parcelHelpers.export(exports, "state", ()=>(0, _definitionsJsDefault64.default));
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _essentialsJs = require("./essentials.js"); // substrate types
parcelHelpers.exportAll(_essentialsJs, exports);
var _definitionsJs = require("./assets/definitions.js");
var _definitionsJsDefault = parcelHelpers.interopDefault(_definitionsJs);
var _definitionsJs1 = require("./authorship/definitions.js");
var _definitionsJsDefault1 = parcelHelpers.interopDefault(_definitionsJs1);
var _definitionsJs2 = require("./aura/definitions.js");
var _definitionsJsDefault2 = parcelHelpers.interopDefault(_definitionsJs2);
var _definitionsJs3 = require("./babe/definitions.js");
var _definitionsJsDefault3 = parcelHelpers.interopDefault(_definitionsJs3);
var _definitionsJs4 = require("./balances/definitions.js");
var _definitionsJsDefault4 = parcelHelpers.interopDefault(_definitionsJs4);
var _definitionsJs5 = require("./beefy/definitions.js");
var _definitionsJsDefault5 = parcelHelpers.interopDefault(_definitionsJs5);
var _definitionsJs6 = require("./benchmark/definitions.js");
var _definitionsJsDefault6 = parcelHelpers.interopDefault(_definitionsJs6);
var _definitionsJs7 = require("./blockbuilder/definitions.js");
var _definitionsJsDefault7 = parcelHelpers.interopDefault(_definitionsJs7);
var _definitionsJs8 = require("./collective/definitions.js");
var _definitionsJsDefault8 = parcelHelpers.interopDefault(_definitionsJs8);
var _definitionsJs9 = require("./consensus/definitions.js");
var _definitionsJsDefault9 = parcelHelpers.interopDefault(_definitionsJs9);
var _definitionsJs10 = require("./contracts/definitions.js");
var _definitionsJsDefault10 = parcelHelpers.interopDefault(_definitionsJs10);
var _definitionsJs11 = require("./democracy/definitions.js");
var _definitionsJsDefault11 = parcelHelpers.interopDefault(_definitionsJs11);
var _definitionsJs12 = require("./dev/definitions.js");
var _definitionsJsDefault12 = parcelHelpers.interopDefault(_definitionsJs12);
var _definitionsJs13 = require("./discovery/definitions.js");
var _definitionsJsDefault13 = parcelHelpers.interopDefault(_definitionsJs13);
var _definitionsJs14 = require("./elections/definitions.js");
var _definitionsJsDefault14 = parcelHelpers.interopDefault(_definitionsJs14);
var _definitionsJs15 = require("./engine/definitions.js");
var _definitionsJsDefault15 = parcelHelpers.interopDefault(_definitionsJs15);
var _definitionsJs16 = require("./evm/definitions.js");
var _definitionsJsDefault16 = parcelHelpers.interopDefault(_definitionsJs16);
var _definitionsJs17 = require("./extrinsics/definitions.js");
var _definitionsJsDefault17 = parcelHelpers.interopDefault(_definitionsJs17);
var _definitionsJs18 = require("./genericAsset/definitions.js");
var _definitionsJsDefault18 = parcelHelpers.interopDefault(_definitionsJs18);
var _definitionsJs19 = require("./gilt/definitions.js");
var _definitionsJsDefault19 = parcelHelpers.interopDefault(_definitionsJs19);
var _definitionsJs20 = require("./grandpa/definitions.js");
var _definitionsJsDefault20 = parcelHelpers.interopDefault(_definitionsJs20);
var _definitionsJs21 = require("./identity/definitions.js");
var _definitionsJsDefault21 = parcelHelpers.interopDefault(_definitionsJs21);
var _definitionsJs22 = require("./imOnline/definitions.js");
var _definitionsJsDefault22 = parcelHelpers.interopDefault(_definitionsJs22);
var _definitionsJs23 = require("./lottery/definitions.js");
var _definitionsJsDefault23 = parcelHelpers.interopDefault(_definitionsJs23);
var _definitionsJs24 = require("./mmr/definitions.js");
var _definitionsJsDefault24 = parcelHelpers.interopDefault(_definitionsJs24);
var _definitionsJs25 = require("./nompools/definitions.js");
var _definitionsJsDefault25 = parcelHelpers.interopDefault(_definitionsJs25);
var _definitionsJs26 = require("./offences/definitions.js");
var _definitionsJsDefault26 = parcelHelpers.interopDefault(_definitionsJs26);
var _definitionsJs27 = require("./pow/definitions.js");
var _definitionsJsDefault27 = parcelHelpers.interopDefault(_definitionsJs27);
var _definitionsJs28 = require("./proxy/definitions.js");
var _definitionsJsDefault28 = parcelHelpers.interopDefault(_definitionsJs28);
var _definitionsJs29 = require("./recovery/definitions.js");
var _definitionsJsDefault29 = parcelHelpers.interopDefault(_definitionsJs29);
var _definitionsJs30 = require("./scheduler/definitions.js");
var _definitionsJsDefault30 = parcelHelpers.interopDefault(_definitionsJs30);
var _definitionsJs31 = require("./session/definitions.js");
var _definitionsJsDefault31 = parcelHelpers.interopDefault(_definitionsJs31);
var _definitionsJs32 = require("./society/definitions.js");
var _definitionsJsDefault32 = parcelHelpers.interopDefault(_definitionsJs32);
var _definitionsJs33 = require("./staking/definitions.js");
var _definitionsJsDefault33 = parcelHelpers.interopDefault(_definitionsJs33);
var _definitionsJs34 = require("./support/definitions.js");
var _definitionsJsDefault34 = parcelHelpers.interopDefault(_definitionsJs34);
var _definitionsJs35 = require("./syncstate/definitions.js");
var _definitionsJsDefault35 = parcelHelpers.interopDefault(_definitionsJs35);
var _definitionsJs36 = require("./system/definitions.js");
var _definitionsJsDefault36 = parcelHelpers.interopDefault(_definitionsJs36);
var _definitionsJs37 = require("./treasury/definitions.js");
var _definitionsJsDefault37 = parcelHelpers.interopDefault(_definitionsJs37);
var _definitionsJs38 = require("./txpayment/definitions.js");
var _definitionsJsDefault38 = parcelHelpers.interopDefault(_definitionsJs38);
var _definitionsJs39 = require("./txqueue/definitions.js");
var _definitionsJsDefault39 = parcelHelpers.interopDefault(_definitionsJs39);
var _definitionsJs40 = require("./uniques/definitions.js");
var _definitionsJsDefault40 = parcelHelpers.interopDefault(_definitionsJs40);
var _definitionsJs41 = require("./utility/definitions.js");
var _definitionsJsDefault41 = parcelHelpers.interopDefault(_definitionsJs41);
var _definitionsJs42 = require("./vesting/definitions.js");
var _definitionsJsDefault42 = parcelHelpers.interopDefault(_definitionsJs42);
var _definitionsJs43 = require("./attestations/definitions.js");
var _definitionsJsDefault43 = parcelHelpers.interopDefault(_definitionsJs43);
var _definitionsJs44 = require("./bridges/definitions.js");
var _definitionsJsDefault44 = parcelHelpers.interopDefault(_definitionsJs44);
var _definitionsJs45 = require("./claims/definitions.js");
var _definitionsJsDefault45 = parcelHelpers.interopDefault(_definitionsJs45);
var _definitionsJs46 = require("./crowdloan/definitions.js");
var _definitionsJsDefault46 = parcelHelpers.interopDefault(_definitionsJs46);
var _definitionsJs47 = require("./cumulus/definitions.js");
var _definitionsJsDefault47 = parcelHelpers.interopDefault(_definitionsJs47);
var _definitionsJs48 = require("./finality/definitions.js");
var _definitionsJsDefault48 = parcelHelpers.interopDefault(_definitionsJs48);
var _definitionsJs49 = require("./parachains/definitions.js");
var _definitionsJsDefault49 = parcelHelpers.interopDefault(_definitionsJs49);
var _definitionsJs50 = require("./poll/definitions.js");
var _definitionsJsDefault50 = parcelHelpers.interopDefault(_definitionsJs50);
var _definitionsJs51 = require("./purchase/definitions.js");
var _definitionsJsDefault51 = parcelHelpers.interopDefault(_definitionsJs51);
var _definitionsJs52 = require("./xcm/definitions.js");
var _definitionsJsDefault52 = parcelHelpers.interopDefault(_definitionsJs52);
var _definitionsJs53 = require("./contractsAbi/definitions.js");
var _definitionsJsDefault53 = parcelHelpers.interopDefault(_definitionsJs53);
var _definitionsJs54 = require("./eth/definitions.js");
var _definitionsJsDefault54 = parcelHelpers.interopDefault(_definitionsJs54);
var _definitionsJs55 = require("./nimbus/definitions.js");
var _definitionsJsDefault55 = parcelHelpers.interopDefault(_definitionsJs55);
var _definitionsJs56 = require("./ormlOracle/definitions.js");
var _definitionsJsDefault56 = parcelHelpers.interopDefault(_definitionsJs56);
var _definitionsJs57 = require("./ormlTokens/definitions.js");
var _definitionsJsDefault57 = parcelHelpers.interopDefault(_definitionsJs57);
var _definitionsJs58 = require("./rpc/definitions.js");
var _definitionsJsDefault58 = parcelHelpers.interopDefault(_definitionsJs58);
var _definitionsJs59 = require("./author/definitions.js");
var _definitionsJsDefault59 = parcelHelpers.interopDefault(_definitionsJs59);
var _definitionsJs60 = require("./chain/definitions.js");
var _definitionsJsDefault60 = parcelHelpers.interopDefault(_definitionsJs60);
var _definitionsJs61 = require("./childstate/definitions.js");
var _definitionsJsDefault61 = parcelHelpers.interopDefault(_definitionsJs61);
var _definitionsJs62 = require("./offchain/definitions.js");
var _definitionsJsDefault62 = parcelHelpers.interopDefault(_definitionsJs62);
var _definitionsJs63 = require("./payment/definitions.js");
var _definitionsJsDefault63 = parcelHelpers.interopDefault(_definitionsJs63);
var _definitionsJs64 = require("./state/definitions.js");
var _definitionsJsDefault64 = parcelHelpers.interopDefault(_definitionsJs64);

},{"./essentials.js":"1etId","./assets/definitions.js":"6Jchk","./authorship/definitions.js":"e6dra","./aura/definitions.js":"7oRb1","./babe/definitions.js":"3SOFg","./balances/definitions.js":"hkwTy","./beefy/definitions.js":"3hA2R","./benchmark/definitions.js":"fdaW0","./blockbuilder/definitions.js":"kKaWs","./collective/definitions.js":"deutg","./consensus/definitions.js":"deoP9","./contracts/definitions.js":"jTpo2","./democracy/definitions.js":"lbBfn","./dev/definitions.js":"206dY","./discovery/definitions.js":"8l8G5","./elections/definitions.js":"7432Q","./engine/definitions.js":"8IgZM","./evm/definitions.js":"hshdN","./extrinsics/definitions.js":"3jfHp","./genericAsset/definitions.js":"03qFj","./gilt/definitions.js":"cghBp","./grandpa/definitions.js":"cVXOr","./identity/definitions.js":"1WVt1","./imOnline/definitions.js":"i0Bt2","./lottery/definitions.js":"acY4d","./mmr/definitions.js":"gutES","./nompools/definitions.js":"8BZbl","./offences/definitions.js":"hmPgW","./pow/definitions.js":"jrFKv","./proxy/definitions.js":"fKFwr","./recovery/definitions.js":"gtDUv","./scheduler/definitions.js":"dT5Rh","./session/definitions.js":"dWl4R","./society/definitions.js":"7KBk2","./staking/definitions.js":"6HHiX","./support/definitions.js":"lyZLt","./syncstate/definitions.js":"PEQ39","./system/definitions.js":"l4H65","./treasury/definitions.js":"3e69H","./txpayment/definitions.js":"iNbEd","./txqueue/definitions.js":"fCot4","./uniques/definitions.js":"lOumW","./utility/definitions.js":"buWug","./vesting/definitions.js":"ioJDd","./attestations/definitions.js":"bzheC","./bridges/definitions.js":"hWXsW","./claims/definitions.js":"iGvqz","./crowdloan/definitions.js":"aDOdR","./cumulus/definitions.js":"jSZGb","./finality/definitions.js":"41cWe","./parachains/definitions.js":"htNih","./poll/definitions.js":"8EFaw","./purchase/definitions.js":"1GK22","./xcm/definitions.js":"a37to","./contractsAbi/definitions.js":"5CyRS","./eth/definitions.js":"h4sbM","./nimbus/definitions.js":"eMBA0","./ormlOracle/definitions.js":"kTf8P","./ormlTokens/definitions.js":"grkrk","./rpc/definitions.js":"dIscT","./author/definitions.js":"hkDY6","./chain/definitions.js":"iLEm8","./childstate/definitions.js":"4gxGw","./offchain/definitions.js":"CTv6V","./payment/definitions.js":"5fFfa","./state/definitions.js":"8p1Cg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1etId":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "metadata", ()=>(0, _definitionsJsDefault.default));
parcelHelpers.export(exports, "runtime", ()=>(0, _definitionsJsDefault1.default));
parcelHelpers.export(exports, "scaleInfo", ()=>(0, _definitionsJsDefault2.default));
var _definitionsJs = require("./metadata/definitions.js");
var _definitionsJsDefault = parcelHelpers.interopDefault(_definitionsJs);
var _definitionsJs1 = require("./runtime/definitions.js");
var _definitionsJsDefault1 = parcelHelpers.interopDefault(_definitionsJs1);
var _definitionsJs2 = require("./scaleInfo/definitions.js");
var _definitionsJsDefault2 = parcelHelpers.interopDefault(_definitionsJs2);

},{"./metadata/definitions.js":"8EArQ","./runtime/definitions.js":"cRjlK","./scaleInfo/definitions.js":"f4f2A","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8EArQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AllHashers", ()=>(0, _hashersJs.AllHashers));
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _util = require("@polkadot/util");
var _hashersJs = require("./hashers.js");
var _runtimeJs = require("./runtime.js");
var _v9Js = require("./v9.js");
var _v10Js = require("./v10.js");
var _v11Js = require("./v11.js");
var _v12Js = require("./v12.js");
var _v13Js = require("./v13.js");
var _v14Js = require("./v14.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: (0, _util.objectSpread)({}, (0, _v9Js.v9), (0, _v10Js.v10), (0, _v11Js.v11), (0, _v12Js.v12), (0, _v13Js.v13), (0, _v14Js.v14), {
        // latest mappings
        ErrorMetadataLatest: "ErrorMetadataV14",
        EventMetadataLatest: "EventMetadataV14",
        ExtrinsicMetadataLatest: "ExtrinsicMetadataV14",
        FunctionArgumentMetadataLatest: "FunctionArgumentMetadataV14",
        FunctionMetadataLatest: "FunctionMetadataV14",
        MetadataLatest: "MetadataV14",
        PalletCallMetadataLatest: "PalletCallMetadataV14",
        PalletConstantMetadataLatest: "PalletConstantMetadataV14",
        PalletErrorMetadataLatest: "PalletErrorMetadataV14",
        PalletEventMetadataLatest: "PalletEventMetadataV14",
        PalletMetadataLatest: "PalletMetadataV14",
        PalletStorageMetadataLatest: "PalletStorageMetadataV14",
        PortableType: "PortableTypeV14",
        SignedExtensionMetadataLatest: "SignedExtensionMetadataV14",
        StorageEntryMetadataLatest: "StorageEntryMetadataV14",
        StorageEntryModifierLatest: "StorageEntryModifierV14",
        StorageEntryTypeLatest: "StorageEntryTypeV14",
        StorageHasher: "StorageHasherV14",
        // additional types
        OpaqueMetadata: "Opaque<Bytes>",
        // the enum containing all the mappings
        MetadataAll: {
            _enum: {
                V0: "DoNotConstruct<MetadataV0>",
                V1: "DoNotConstruct<MetadataV1>",
                V2: "DoNotConstruct<MetadataV2>",
                V3: "DoNotConstruct<MetadataV3>",
                V4: "DoNotConstruct<MetadataV4>",
                V5: "DoNotConstruct<MetadataV5>",
                V6: "DoNotConstruct<MetadataV6>",
                V7: "DoNotConstruct<MetadataV7>",
                V8: "DoNotConstruct<MetadataV8>",
                // First version on Kusama in V9, dropping will be problematic
                V9: "MetadataV9",
                V10: "MetadataV10",
                V11: "MetadataV11",
                V12: "MetadataV12",
                V13: "MetadataV13",
                V14: "MetadataV14"
            }
        }
    })
};

},{"@polkadot/util":"3HnHw","./hashers.js":"kav2J","./runtime.js":"eP8ul","./v9.js":"8vbmG","./v10.js":"86uC8","./v11.js":"eIvft","./v12.js":"2ZO5t","./v13.js":"kL6QY","./v14.js":"9P96S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kav2J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AllHashers", ()=>AllHashers);
const AllHashers = {
    Blake2_128: null,
    // eslint-disable-line camelcase
    Blake2_256: null,
    // eslint-disable-line camelcase
    Blake2_128Concat: null,
    // eslint-disable-line camelcase
    Twox128: null,
    Twox256: null,
    Twox64Concat: null,
    // new in v11
    Identity: null
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eP8ul":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    Metadata: [
        {
            methods: {
                metadata: {
                    description: "Returns the metadata of a runtime",
                    params: [],
                    type: "OpaqueMetadata"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8vbmG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v9", ()=>v9);
const v9 = {
    // v9
    ErrorMetadataV9: {
        name: "Text",
        docs: "Vec<Text>"
    },
    EventMetadataV9: {
        name: "Text",
        args: "Vec<Type>",
        docs: "Vec<Text>"
    },
    FunctionArgumentMetadataV9: {
        name: "Text",
        type: "Type"
    },
    FunctionMetadataV9: {
        name: "Text",
        args: "Vec<FunctionArgumentMetadataV9>",
        docs: "Vec<Text>"
    },
    MetadataV9: {
        modules: "Vec<ModuleMetadataV9>"
    },
    ModuleConstantMetadataV9: {
        name: "Text",
        type: "Type",
        value: "Bytes",
        docs: "Vec<Text>"
    },
    ModuleMetadataV9: {
        name: "Text",
        storage: "Option<StorageMetadataV9>",
        calls: "Option<Vec<FunctionMetadataV9>>",
        events: "Option<Vec<EventMetadataV9>>",
        constants: "Vec<ModuleConstantMetadataV9>",
        errors: "Vec<ErrorMetadataV9>"
    },
    StorageEntryMetadataV9: {
        name: "Text",
        modifier: "StorageEntryModifierV9",
        type: "StorageEntryTypeV9",
        fallback: "Bytes",
        docs: "Vec<Text>"
    },
    StorageEntryModifierV9: {
        _enum: [
            "Optional",
            "Default",
            "Required"
        ]
    },
    StorageEntryTypeV9: {
        _enum: {
            Plain: "Type",
            Map: {
                hasher: "StorageHasherV9",
                key: "Type",
                value: "Type",
                linked: "bool"
            },
            DoubleMap: {
                hasher: "StorageHasherV9",
                key1: "Type",
                key2: "Type",
                value: "Type",
                key2Hasher: "StorageHasherV9"
            }
        }
    },
    StorageHasherV9: {
        _enum: {
            Blake2_128: null,
            // eslint-disable-line camelcase
            Blake2_256: null,
            // eslint-disable-line camelcase
            Twox128: null,
            Twox256: null,
            Twox64Concat: null
        }
    },
    StorageMetadataV9: {
        prefix: "Text",
        items: "Vec<StorageEntryMetadataV9>"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"86uC8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v10", ()=>v10);
const v10 = {
    // v10
    ErrorMetadataV10: "ErrorMetadataV9",
    EventMetadataV10: "EventMetadataV9",
    FunctionArgumentMetadataV10: "FunctionArgumentMetadataV9",
    FunctionMetadataV10: "FunctionMetadataV9",
    MetadataV10: {
        modules: "Vec<ModuleMetadataV10>"
    },
    ModuleConstantMetadataV10: "ModuleConstantMetadataV9",
    ModuleMetadataV10: {
        name: "Text",
        storage: "Option<StorageMetadataV10>",
        calls: "Option<Vec<FunctionMetadataV10>>",
        events: "Option<Vec<EventMetadataV10>>",
        constants: "Vec<ModuleConstantMetadataV10>",
        errors: "Vec<ErrorMetadataV10>"
    },
    StorageEntryModifierV10: "StorageEntryModifierV9",
    StorageEntryMetadataV10: {
        name: "Text",
        modifier: "StorageEntryModifierV10",
        type: "StorageEntryTypeV10",
        fallback: "Bytes",
        docs: "Vec<Text>"
    },
    StorageEntryTypeV10: {
        _enum: {
            Plain: "Type",
            Map: {
                hasher: "StorageHasherV10",
                key: "Type",
                value: "Type",
                linked: "bool"
            },
            DoubleMap: {
                hasher: "StorageHasherV10",
                key1: "Type",
                key2: "Type",
                value: "Type",
                key2Hasher: "StorageHasherV10"
            }
        }
    },
    StorageMetadataV10: {
        prefix: "Text",
        items: "Vec<StorageEntryMetadataV10>"
    },
    StorageHasherV10: {
        _enum: {
            Blake2_128: null,
            // eslint-disable-line camelcase
            Blake2_256: null,
            // eslint-disable-line camelcase
            Blake2_128Concat: null,
            // eslint-disable-line camelcase
            Twox128: null,
            Twox256: null,
            Twox64Concat: null
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eIvft":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v11", ()=>v11);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _hashersJs = require("./hashers.js");
const v11 = {
    // v11
    ErrorMetadataV11: "ErrorMetadataV10",
    EventMetadataV11: "EventMetadataV10",
    ExtrinsicMetadataV11: {
        version: "u8",
        signedExtensions: "Vec<Text>"
    },
    FunctionArgumentMetadataV11: "FunctionArgumentMetadataV10",
    FunctionMetadataV11: "FunctionMetadataV10",
    MetadataV11: {
        modules: "Vec<ModuleMetadataV11>",
        extrinsic: "ExtrinsicMetadataV11"
    },
    ModuleConstantMetadataV11: "ModuleConstantMetadataV10",
    ModuleMetadataV11: {
        name: "Text",
        storage: "Option<StorageMetadataV11>",
        calls: "Option<Vec<FunctionMetadataV11>>",
        events: "Option<Vec<EventMetadataV11>>",
        constants: "Vec<ModuleConstantMetadataV11>",
        errors: "Vec<ErrorMetadataV11>"
    },
    StorageEntryModifierV11: "StorageEntryModifierV10",
    StorageEntryMetadataV11: {
        name: "Text",
        modifier: "StorageEntryModifierV11",
        type: "StorageEntryTypeV11",
        fallback: "Bytes",
        docs: "Vec<Text>"
    },
    StorageEntryTypeV11: {
        _enum: {
            Plain: "Type",
            Map: {
                hasher: "StorageHasherV11",
                key: "Type",
                value: "Type",
                linked: "bool"
            },
            DoubleMap: {
                hasher: "StorageHasherV11",
                key1: "Type",
                key2: "Type",
                value: "Type",
                key2Hasher: "StorageHasherV11"
            }
        }
    },
    StorageMetadataV11: {
        prefix: "Text",
        items: "Vec<StorageEntryMetadataV11>"
    },
    StorageHasherV11: {
        _enum: (0, _hashersJs.AllHashers)
    }
};

},{"./hashers.js":"kav2J","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ZO5t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v12", ()=>v12);
const v12 = {
    // v12
    ErrorMetadataV12: "ErrorMetadataV11",
    EventMetadataV12: "EventMetadataV11",
    ExtrinsicMetadataV12: "ExtrinsicMetadataV11",
    FunctionArgumentMetadataV12: "FunctionArgumentMetadataV11",
    FunctionMetadataV12: "FunctionMetadataV11",
    MetadataV12: {
        modules: "Vec<ModuleMetadataV12>",
        extrinsic: "ExtrinsicMetadataV12"
    },
    ModuleConstantMetadataV12: "ModuleConstantMetadataV11",
    ModuleMetadataV12: {
        name: "Text",
        storage: "Option<StorageMetadataV12>",
        calls: "Option<Vec<FunctionMetadataV12>>",
        events: "Option<Vec<EventMetadataV12>>",
        constants: "Vec<ModuleConstantMetadataV12>",
        errors: "Vec<ErrorMetadataV12>",
        index: "u8"
    },
    StorageEntryModifierV12: "StorageEntryModifierV11",
    StorageEntryMetadataV12: "StorageEntryMetadataV11",
    StorageEntryTypeV12: "StorageEntryTypeV11",
    StorageMetadataV12: "StorageMetadataV11",
    StorageHasherV12: "StorageHasherV11"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kL6QY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v13", ()=>v13);
const v13 = {
    // v13
    ErrorMetadataV13: "ErrorMetadataV12",
    EventMetadataV13: "EventMetadataV12",
    ExtrinsicMetadataV13: "ExtrinsicMetadataV12",
    FunctionArgumentMetadataV13: "FunctionArgumentMetadataV12",
    FunctionMetadataV13: "FunctionMetadataV12",
    MetadataV13: {
        modules: "Vec<ModuleMetadataV13>",
        extrinsic: "ExtrinsicMetadataV13"
    },
    ModuleConstantMetadataV13: "ModuleConstantMetadataV12",
    ModuleMetadataV13: {
        name: "Text",
        storage: "Option<StorageMetadataV13>",
        calls: "Option<Vec<FunctionMetadataV13>>",
        events: "Option<Vec<EventMetadataV13>>",
        constants: "Vec<ModuleConstantMetadataV13>",
        errors: "Vec<ErrorMetadataV13>",
        index: "u8"
    },
    StorageEntryModifierV13: "StorageEntryModifierV12",
    StorageEntryMetadataV13: {
        name: "Text",
        modifier: "StorageEntryModifierV13",
        type: "StorageEntryTypeV13",
        fallback: "Bytes",
        docs: "Vec<Text>"
    },
    StorageEntryTypeV13: {
        _enum: {
            Plain: "Type",
            Map: {
                hasher: "StorageHasherV13",
                key: "Type",
                value: "Type",
                linked: "bool"
            },
            DoubleMap: {
                hasher: "StorageHasherV13",
                key1: "Type",
                key2: "Type",
                value: "Type",
                key2Hasher: "StorageHasherV13"
            },
            NMap: {
                keyVec: "Vec<Type>",
                hashers: "Vec<StorageHasherV13>",
                value: "Type"
            }
        }
    },
    StorageMetadataV13: {
        prefix: "Text",
        items: "Vec<StorageEntryMetadataV13>"
    },
    StorageHasherV13: "StorageHasherV12"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9P96S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v14", ()=>v14);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _util = require("@polkadot/util");
var _v1Js = require("../scaleInfo/v1.js");
const v14 = {
    // registry
    PortableTypeV14: {
        id: "Si1LookupTypeId",
        type: "Si1Type"
    },
    // compatibility with earlier layouts, i.e. don't break previous users
    ErrorMetadataV14: (0, _util.objectSpread)({}, (0, _v1Js.Si1Variant), {
        args: "Vec<Type>"
    }),
    EventMetadataV14: (0, _util.objectSpread)({}, (0, _v1Js.Si1Variant), {
        args: "Vec<Type>"
    }),
    FunctionArgumentMetadataV14: {
        name: "Text",
        type: "Type",
        typeName: "Option<Type>"
    },
    FunctionMetadataV14: (0, _util.objectSpread)({}, (0, _v1Js.Si1Variant), {
        args: "Vec<FunctionArgumentMetadataV14>"
    }),
    // V14
    ExtrinsicMetadataV14: {
        type: "SiLookupTypeId",
        version: "u8",
        signedExtensions: "Vec<SignedExtensionMetadataV14>"
    },
    MetadataV14: {
        lookup: "PortableRegistry",
        pallets: "Vec<PalletMetadataV14>",
        extrinsic: "ExtrinsicMetadataV14",
        type: "SiLookupTypeId"
    },
    PalletCallMetadataV14: {
        type: "SiLookupTypeId"
    },
    PalletConstantMetadataV14: {
        name: "Text",
        type: "SiLookupTypeId",
        value: "Bytes",
        docs: "Vec<Text>"
    },
    PalletErrorMetadataV14: {
        type: "SiLookupTypeId"
    },
    PalletEventMetadataV14: {
        type: "SiLookupTypeId"
    },
    PalletMetadataV14: {
        name: "Text",
        storage: "Option<PalletStorageMetadataV14>",
        calls: "Option<PalletCallMetadataV14>",
        events: "Option<PalletEventMetadataV14>",
        constants: "Vec<PalletConstantMetadataV14>",
        errors: "Option<PalletErrorMetadataV14>",
        index: "u8"
    },
    PalletStorageMetadataV14: {
        prefix: "Text",
        // NOTE: Renamed from entries
        items: "Vec<StorageEntryMetadataV14>"
    },
    SignedExtensionMetadataV14: {
        identifier: "Text",
        type: "SiLookupTypeId",
        additionalSigned: "SiLookupTypeId"
    },
    StorageEntryMetadataV14: {
        name: "Text",
        modifier: "StorageEntryModifierV14",
        type: "StorageEntryTypeV14",
        fallback: "Bytes",
        docs: "Vec<Text>"
    },
    StorageEntryModifierV14: "StorageEntryModifierV13",
    StorageEntryTypeV14: {
        _enum: {
            Plain: "SiLookupTypeId",
            Map: {
                hashers: "Vec<StorageHasherV14>",
                key: "SiLookupTypeId",
                // NOTE: Renamed from "keys"
                value: "SiLookupTypeId"
            }
        }
    },
    StorageHasherV14: "StorageHasherV13"
};

},{"@polkadot/util":"3HnHw","../scaleInfo/v1.js":"c1dpM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c1dpM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Si1Variant", ()=>Si1Variant);
parcelHelpers.export(exports, "v1", ()=>v1);
const Si1Variant = {
    name: "Text",
    fields: "Vec<Si1Field>",
    index: "u8",
    docs: "Vec<Text>"
};
const v1 = {
    Si1Field: {
        name: "Option<Text>",
        type: "Si1LookupTypeId",
        typeName: "Option<Text>",
        docs: "Vec<Text>"
    },
    Si1LookupTypeId: "Compact<u32>",
    Si1Path: "Si0Path",
    Si1Type: {
        path: "Si1Path",
        params: "Vec<Si1TypeParameter>",
        def: "Si1TypeDef",
        docs: "Vec<Text>"
    },
    Si1TypeDef: {
        _enum: {
            Composite: "Si1TypeDefComposite",
            Variant: "Si1TypeDefVariant",
            Sequence: "Si1TypeDefSequence",
            Array: "Si1TypeDefArray",
            Tuple: "Si1TypeDefTuple",
            Primitive: "Si1TypeDefPrimitive",
            Compact: "Si1TypeDefCompact",
            BitSequence: "Si1TypeDefBitSequence",
            // NOTE: This is specific to the implementation for pre-v14 metadata
            // compatibility (always keep this as the last entry in the enum)
            HistoricMetaCompat: "Type"
        }
    },
    Si1TypeDefArray: {
        len: "u32",
        type: "Si1LookupTypeId"
    },
    Si1TypeDefBitSequence: {
        bitStoreType: "Si1LookupTypeId",
        bitOrderType: "Si1LookupTypeId"
    },
    Si1TypeDefCompact: {
        type: "Si1LookupTypeId"
    },
    Si1TypeDefComposite: {
        fields: "Vec<Si1Field>"
    },
    Si1TypeDefPrimitive: "Si0TypeDefPrimitive",
    Si1TypeDefSequence: {
        type: "Si1LookupTypeId"
    },
    Si1TypeDefTuple: "Vec<Si1LookupTypeId>",
    Si1TypeParameter: {
        name: "Text",
        type: "Option<Si1LookupTypeId>"
    },
    Si1TypeDefVariant: {
        variants: "Vec<Si1Variant>"
    },
    Si1Variant
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cRjlK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "knownOrigins", ()=>knownOrigins);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _util = require("@polkadot/util");
var _runtimeJs = require("./runtime.js");
const numberTypes = {
    Fixed64: "Int<64, Fixed64>",
    FixedI64: "Int<64, FixedI64>",
    FixedU64: "UInt<64, FixedU64>",
    Fixed128: "Int<128, Fixed128>",
    FixedI128: "Int<128, FixedI128>",
    FixedU128: "UInt<128, FixedU128>",
    I32F32: "Int<64, I32F32>",
    U32F32: "UInt<64, U32F32>",
    PerU16: "UInt<16, PerU16>",
    Perbill: "UInt<32, Perbill>",
    Percent: "UInt<8, Percent>",
    Permill: "UInt<32, Permill>",
    Perquintill: "UInt<64, Perquintill>"
}; // Since we don't have insight into the origin specification, we can only define what we know about
const knownOrigins = {
    //
    // (1) Defaults from Substrate
    //
    Council: "CollectiveOrigin",
    System: "SystemOrigin",
    TechnicalCommittee: "CollectiveOrigin",
    //
    // (2) Defaults from Polkadot
    //
    Xcm: "XcmOrigin",
    XcmPallet: "XcmOrigin",
    //
    // (3) Defaults from Acala
    //
    Authority: "AuthorityOrigin",
    GeneralCouncil: "CollectiveOrigin"
};
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: (0, _util.objectSpread)({}, numberTypes, {
        AccountId: "AccountId32",
        AccountId20: "GenericEthereumAccountId",
        AccountId32: "GenericAccountId",
        AccountIdOf: "AccountId",
        AccountIndex: "GenericAccountIndex",
        Address: "MultiAddress",
        AssetId: "u32",
        Balance: "UInt<128, Balance>",
        BalanceOf: "Balance",
        Block: "GenericBlock",
        BlockNumber: "u32",
        BlockNumberFor: "BlockNumber",
        BlockNumberOf: "BlockNumber",
        Call: "GenericCall",
        CallHash: "Hash",
        CallHashOf: "CallHash",
        ChangesTrieConfiguration: {
            digestInterval: "u32",
            digestLevels: "u32"
        },
        ChangesTrieSignal: {
            _enum: {
                NewConfiguration: "Option<ChangesTrieConfiguration>"
            }
        },
        ConsensusEngineId: "GenericConsensusEngineId",
        CodecHash: "Hash",
        CrateVersion: {
            major: "u16",
            minor: "u8",
            patch: "u8"
        },
        Digest: {
            logs: "Vec<DigestItem>"
        },
        DigestItem: {
            _enum: {
                Other: "Bytes",
                // 0
                AuthoritiesChange: "Vec<AuthorityId>",
                // 1
                ChangesTrieRoot: "Hash",
                // 2
                SealV0: "SealV0",
                // 3
                Consensus: "Consensus",
                // 4
                Seal: "Seal",
                // 5
                PreRuntime: "PreRuntime",
                // 6
                ChangesTrieSignal: "ChangesTrieSignal",
                // 7
                RuntimeEnvironmentUpdated: "Null" // 8
            }
        },
        ExtrinsicsWeight: {
            normal: "Weight",
            operational: "Weight"
        },
        H32: "[u8; 4; H32]",
        H64: "[u8; 8; H64]",
        H128: "[u8; 16; H128]",
        H160: "[u8; 20; H160]",
        H256: "[u8; 32; H256]",
        H512: "[u8; 64; H512]",
        H1024: "[u8; 128; H1024]",
        H2048: "[u8; 256; H2048]",
        Hash: "H256",
        Header: {
            parentHash: "Hash",
            number: "Compact<BlockNumber>",
            stateRoot: "Hash",
            extrinsicsRoot: "Hash",
            digest: "Digest"
        },
        HeaderPartial: {
            parentHash: "Hash",
            // since we only parse JSON with this, having non-compact works
            number: "BlockNumber"
        },
        IndicesLookupSource: "GenericLookupSource",
        Index: "u32",
        Justification: "(ConsensusEngineId, EncodedJustification)",
        EncodedJustification: "Bytes",
        Justifications: "Vec<Justification>",
        KeyValue: "(StorageKey, StorageData)",
        KeyTypeId: "u32",
        LockIdentifier: "[u8; 8]",
        LookupSource: "MultiAddress",
        LookupTarget: "AccountId",
        ModuleId: "LockIdentifier",
        MultiAddress: "GenericMultiAddress",
        MultiSigner: {
            _enum: {
                Ed25519: "[u8; 32]",
                Sr25519: "[u8; 32]",
                Ecdsa: "[u8; 33]"
            }
        },
        Moment: "UInt<64, Moment>",
        OpaqueCall: "Bytes",
        Origin: "DoNotConstruct<Origin>",
        OriginCaller: {
            _enum: {
                // this should be dynamically built from the actual modules, based on index
                System: "SystemOrigin"
            }
        },
        PalletId: "LockIdentifier",
        PalletsOrigin: "OriginCaller",
        PalletVersion: {
            major: "u16",
            minor: "u8",
            patch: "u8"
        },
        Pays: {
            _enum: [
                "Yes",
                "No"
            ]
        },
        Phantom: "Null",
        PhantomData: "Null",
        Releases: {
            _enum: [
                "V1",
                "V2",
                "V3",
                "V4",
                "V5",
                "V6",
                "V7",
                "V8",
                "V9",
                "V10"
            ]
        },
        RuntimeDbWeight: {
            read: "Weight",
            write: "Weight"
        },
        SignedBlock: "SignedBlockWithJustifications",
        SignedBlockWithJustification: {
            block: "Block",
            justification: "Option<EncodedJustification>"
        },
        SignedBlockWithJustifications: {
            block: "Block",
            justifications: "Option<Justifications>"
        },
        Slot: "u64",
        SlotDuration: "u64",
        StorageData: "Bytes",
        StorageInfo: {
            palletName: "Bytes",
            storage_name: "Bytes",
            prefix: "Bytes",
            maxValues: "Option<u32>",
            maxSize: "Option<u32>"
        },
        StorageProof: {
            trieNodes: "Vec<Bytes>"
        },
        TransactionPriority: "u64",
        TransactionLongevity: "u64",
        TransactionTag: "Bytes",
        TransactionInfo: {
            _alias: {
                dataSize: "size"
            },
            chunkRoot: "H256",
            contentHash: "H256",
            dataSize: "u32",
            blockChunks: "u32"
        },
        TransactionStorageProof: {
            chunk: "Vec<u8>",
            proof: "Vec<Vec<u8>>"
        },
        ValidatorId: "AccountId",
        ValidatorIdOf: "ValidatorId",
        Weight: "u64",
        WeightMultiplier: "Fixed64",
        // digest
        PreRuntime: "(ConsensusEngineId, Bytes)",
        SealV0: "(u64, Signature)",
        Seal: "(ConsensusEngineId, Bytes)",
        Consensus: "(ConsensusEngineId, Bytes)"
    })
};

},{"@polkadot/util":"3HnHw","./runtime.js":"fMO27","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fMO27":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const CORE_V1_TO_V4 = {
    execute_block: {
        description: "Execute the given block.",
        params: [
            {
                name: "block",
                type: "Block"
            }
        ],
        type: "Null"
    }
};
const CORE_V1_TO_V2 = {
    version: {
        description: "Returns the version of the runtime.",
        params: [],
        type: "RuntimeVersionPre3"
    }
};
const CORE_V2_TO_V4 = {
    initialize_block: {
        description: "Initialize a block with the given header.",
        params: [
            {
                name: "header",
                type: "Header"
            }
        ],
        type: "Null"
    }
};
const runtime = {
    Core: [
        {
            methods: (0, _util.objectSpread)({
                version: {
                    description: "Returns the version of the runtime.",
                    params: [],
                    type: "RuntimeVersion"
                }
            }, CORE_V1_TO_V4, CORE_V2_TO_V4),
            version: 4
        },
        {
            methods: (0, _util.objectSpread)({
                version: {
                    description: "Returns the version of the runtime.",
                    params: [],
                    type: "RuntimeVersionPre4"
                }
            }, CORE_V1_TO_V4, CORE_V2_TO_V4),
            version: 3
        },
        {
            methods: (0, _util.objectSpread)({}, CORE_V1_TO_V2, CORE_V1_TO_V4, CORE_V2_TO_V4),
            version: 2
        },
        {
            methods: (0, _util.objectSpread)({
                initialise_block: {
                    description: "Initialize a block with the given header.",
                    params: [
                        {
                            name: "header",
                            type: "Header"
                        }
                    ],
                    type: "Null"
                }
            }, CORE_V1_TO_V2, CORE_V1_TO_V4),
            version: 1
        }
    ],
    TryRuntime: [
        {
            methods: {
                execute_block_no_check: {
                    description: "Execute the given block, but don't check that its state root matches that of yours.",
                    params: [
                        {
                            name: "block",
                            type: "Block"
                        }
                    ],
                    type: "Weight"
                },
                on_runtime_upgrade: {
                    description: "dry-run runtime upgrades, returning the total weight consumed.",
                    params: [],
                    type: "(Weight, Weight)"
                }
            },
            version: 1
        }
    ]
};

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f4f2A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _v0Js = require("./v0.js");
var _v1Js = require("./v1.js"); // order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: (0, _util.objectSpread)({}, (0, _v0Js.v0), (0, _v1Js.v1), {
        // latest mappings
        SiField: "Si1Field",
        SiLookupTypeId: "Si1LookupTypeId",
        SiPath: "Si1Path",
        SiType: "Si1Type",
        SiTypeDef: "Si1TypeDef",
        SiTypeDefArray: "Si1TypeDefArray",
        SiTypeDefBitSequence: "Si1TypeDefBitSequence",
        SiTypeDefCompact: "Si1TypeDefCompact",
        SiTypeDefComposite: "Si1TypeDefComposite",
        SiTypeDefPrimitive: "Si1TypeDefPrimitive",
        SiTypeDefSequence: "Si1TypeDefSequence",
        SiTypeDefTuple: "Si1TypeDefTuple",
        SiTypeParameter: "Si1TypeParameter",
        SiTypeDefVariant: "Si1TypeDefVariant",
        SiVariant: "Si1Variant"
    })
};

},{"@polkadot/util":"3HnHw","./v0.js":"jHbzU","./v1.js":"c1dpM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jHbzU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v0", ()=>v0);
const v0 = {
    Si0Field: {
        name: "Option<Text>",
        type: "Si0LookupTypeId",
        typeName: "Option<Text>",
        docs: "Vec<Text>"
    },
    Si0LookupTypeId: "u32",
    Si0Path: "Vec<Text>",
    Si0Type: {
        path: "Si0Path",
        params: "Vec<Si0LookupTypeId>",
        def: "Si0TypeDef"
    },
    Si0TypeDef: {
        _enum: {
            Composite: "Si0TypeDefComposite",
            Variant: "Si0TypeDefVariant",
            Sequence: "Si0TypeDefSequence",
            Array: "Si0TypeDefArray",
            Tuple: "Si0TypeDefTuple",
            Primitive: "Si0TypeDefPrimitive",
            Compact: "Si0TypeDefCompact",
            Phantom: "Si0TypeDefPhantom",
            BitSequence: "Si0TypeDefBitSequence"
        }
    },
    Si0TypeDefArray: {
        len: "u32",
        type: "Si0LookupTypeId"
    },
    Si0TypeDefBitSequence: {
        bitStoreType: "Si0LookupTypeId",
        bitOrderType: "Si0LookupTypeId"
    },
    Si0TypeDefCompact: {
        type: "Si0LookupTypeId"
    },
    Si0TypeDefComposite: {
        fields: "Vec<Si0Field>"
    },
    Si0TypeDefPhantom: "Null",
    Si0TypeDefVariant: {
        variants: "Vec<Si0Variant>"
    },
    Si0TypeDefPrimitive: {
        _enum: [
            "Bool",
            "Char",
            "Str",
            "U8",
            "U16",
            "U32",
            "U64",
            "U128",
            "U256",
            "I8",
            "I16",
            "I32",
            "I64",
            "I128",
            "I256"
        ]
    },
    Si0TypeDefSequence: {
        type: "Si0LookupTypeId"
    },
    Si0TypeDefTuple: "Vec<Si0LookupTypeId>",
    Si0TypeParameter: {
        name: "Text",
        type: "Option<Si0LookupTypeId>"
    },
    Si0Variant: {
        name: "Text",
        fields: "Vec<Si0Field>",
        index: "Option<u8>",
        discriminant: "Option<u64>",
        docs: "Vec<Text>"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Jchk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        AssetApprovalKey: {
            owner: "AccountId",
            delegate: "AccountId"
        },
        AssetApproval: {
            amount: "TAssetBalance",
            deposit: "TAssetDepositBalance"
        },
        AssetBalance: {
            balance: "TAssetBalance",
            isFrozen: "bool",
            isSufficient: "bool"
        },
        AssetDestroyWitness: {
            accounts: "Compact<u32>",
            sufficients: "Compact<u32>",
            approvals: "Compact<u32>"
        },
        AssetDetails: {
            owner: "AccountId",
            issuer: "AccountId",
            admin: "AccountId",
            freezer: "AccountId",
            supply: "TAssetBalance",
            deposit: "TAssetDepositBalance",
            minBalance: "TAssetBalance",
            isSufficient: "bool",
            accounts: "u32",
            sufficients: "u32",
            approvals: "u32",
            isFrozen: "bool"
        },
        AssetMetadata: {
            deposit: "TAssetDepositBalance",
            name: "Vec<u8>",
            symbol: "Vec<u8>",
            decimals: "u8",
            isFrozen: "bool"
        },
        TAssetBalance: "u64",
        TAssetDepositBalance: "BalanceOf"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e6dra":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        UncleEntryItem: {
            _enum: {
                InclusionHeight: "BlockNumber",
                Uncle: "(Hash, Option<AccountId>)"
            }
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7oRb1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {
        RawAuraPreDigest: {
            slotNumber: "u64"
        }
    }
};

},{"./runtime.js":"95Cy1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"95Cy1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    AuraApi: [
        {
            methods: {
                authorities: {
                    description: "Return the current set of authorities.",
                    params: [],
                    type: "Vec<AuthorityId>"
                },
                slot_duration: {
                    description: "Returns the slot duration for Aura.",
                    params: [],
                    type: "SlotDuration"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3SOFg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    runtime: (0, _runtimeJs.runtime),
    types: {
        AllowedSlots: {
            _enum: [
                "PrimarySlots",
                "PrimaryAndSecondaryPlainSlots",
                "PrimaryAndSecondaryVRFSlots"
            ]
        },
        BabeAuthorityWeight: "u64",
        BabeEpochConfiguration: {
            c: "(u64, u64)",
            allowedSlots: "AllowedSlots"
        },
        BabeBlockWeight: "u32",
        BabeEquivocationProof: {
            offender: "AuthorityId",
            slotNumber: "SlotNumber",
            firstHeader: "Header",
            secondHeader: "Header"
        },
        BabeGenesisConfiguration: {
            slotDuration: "u64",
            epochLength: "u64",
            c: "(u64, u64)",
            genesisAuthorities: "Vec<(AuthorityId, BabeAuthorityWeight)>",
            randomness: "Randomness",
            allowedSlots: "AllowedSlots"
        },
        BabeGenesisConfigurationV1: {
            slotDuration: "u64",
            epochLength: "u64",
            c: "(u64, u64)",
            genesisAuthorities: "Vec<(AuthorityId, BabeAuthorityWeight)>",
            randomness: "Randomness",
            secondarySlots: "bool"
        },
        BabeWeight: "u64",
        MaybeRandomness: "Option<Randomness>",
        MaybeVrf: "Option<VrfData>",
        Epoch: {
            epochIndex: "u64",
            startSlot: "Slot",
            duration: "u64",
            authorities: "Vec<(AuthorityId, BabeAuthorityWeight)>",
            randomness: "Hash",
            // [u8; VRF_OUTPUT_LENGTH],
            config: "BabeEpochConfiguration"
        },
        EpochAuthorship: {
            primary: "Vec<u64>",
            secondary: "Vec<u64>",
            secondary_vrf: "Vec<u64>"
        },
        NextConfigDescriptor: {
            _enum: {
                V0: "Null",
                V1: "NextConfigDescriptorV1"
            }
        },
        NextConfigDescriptorV1: {
            c: "(u64, u64)",
            allowedSlots: "AllowedSlots"
        },
        OpaqueKeyOwnershipProof: "Bytes",
        Randomness: "Hash",
        // [u8; RANDOMNESS_LENGTH],
        RawBabePreDigest: {
            _enum: {
                Phantom: "Null",
                // index starts at 1... empty slot at 0
                Primary: "RawBabePreDigestPrimary",
                SecondaryPlain: "RawBabePreDigestSecondaryPlain",
                SecondaryVRF: "RawBabePreDigestSecondaryVRF"
            }
        },
        RawBabePreDigestPrimary: {
            authorityIndex: "u32",
            // AuthorityIndex (also in aura)
            slotNumber: "SlotNumber",
            vrfOutput: "VrfOutput",
            vrfProof: "VrfProof"
        },
        RawBabePreDigestSecondaryPlain: {
            authorityIndex: "u32",
            // AuthorityIndex (also in aura)
            slotNumber: "SlotNumber"
        },
        RawBabePreDigestSecondaryVRF: {
            authorityIndex: "u32",
            slotNumber: "SlotNumber",
            vrfOutput: "VrfOutput",
            vrfProof: "VrfProof"
        },
        RawBabePreDigestTo159: {
            _enum: {
                Primary: "RawBabePreDigestPrimaryTo159",
                Secondary: "RawBabePreDigestSecondaryTo159"
            }
        },
        RawBabePreDigestPrimaryTo159: {
            authorityIndex: "u32",
            slotNumber: "SlotNumber",
            weight: "BabeBlockWeight",
            vrfOutput: "VrfOutput",
            vrfProof: "VrfProof"
        },
        RawBabePreDigestSecondaryTo159: {
            authorityIndex: "u32",
            slotNumber: "SlotNumber",
            weight: "BabeBlockWeight"
        },
        // a cross old/new compatible version of the digest, that is _only_ useful
        // for partial parsing and extraction of the author. This assumes that all
        // entries has the authorityIndex in the first position - and that it is all
        // we are interested in
        RawBabePreDigestCompat: {
            _enum: {
                Zero: "u32",
                One: "u32",
                Two: "u32",
                Three: "u32"
            }
        },
        SlotNumber: "u64",
        VrfData: "[u8; 32]",
        VrfOutput: "[u8; 32]",
        VrfProof: "[u8; 64]"
    }
};

},{"./rpc.js":"9lMXz","./runtime.js":"8wQr4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9lMXz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    epochAuthorship: {
        description: "Returns data about which slots (primary or secondary) can be claimed in the current epoch with the keys in the keystore",
        params: [],
        type: "HashMap<AuthorityId, EpochAuthorship>"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8wQr4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const V1_V2_SHARED = {
    current_epoch: {
        description: "Returns information regarding the current epoch.",
        params: [],
        type: "Epoch"
    },
    current_epoch_start: {
        description: "Returns the slot that started the current epoch.",
        params: [],
        type: "Slot"
    },
    generate_key_ownership_proof: {
        description: "Generates a proof of key ownership for the given authority in the current epoch.",
        params: [
            {
                name: "slot",
                type: "Slot"
            },
            {
                name: "authorityId",
                type: "AuthorityId"
            }
        ],
        type: "Option<OpaqueKeyOwnershipProof>"
    },
    next_epoch: {
        description: "Returns information regarding the next epoch (which was already previously announced).",
        params: [],
        type: "Epoch"
    },
    submit_report_equivocation_unsigned_extrinsic: {
        description: "Submits an unsigned extrinsic to report an equivocation.",
        params: [
            {
                name: "equivocationProof",
                type: "BabeEquivocationProof"
            },
            {
                name: "keyOwnerProof",
                type: "OpaqueKeyOwnershipProof"
            }
        ],
        type: "Option<Null>"
    }
};
const runtime = {
    BabeApi: [
        {
            methods: (0, _util.objectSpread)({
                configuration: {
                    description: "Return the genesis configuration for BABE. The configuration is only read on genesis.",
                    params: [],
                    type: "BabeGenesisConfiguration"
                }
            }, V1_V2_SHARED),
            version: 2
        },
        {
            methods: (0, _util.objectSpread)({
                configuration: {
                    description: "Return the configuration for BABE. Version 1.",
                    params: [],
                    type: "BabeGenesisConfigurationV1"
                }
            }, V1_V2_SHARED),
            version: 1
        }
    ]
};

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hkwTy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        AccountData: {
            free: "Balance",
            reserved: "Balance",
            miscFrozen: "Balance",
            feeFrozen: "Balance"
        },
        BalanceLockTo212: {
            id: "LockIdentifier",
            amount: "Balance",
            until: "BlockNumber",
            reasons: "WithdrawReasons"
        },
        BalanceLock: {
            id: "LockIdentifier",
            amount: "Balance",
            reasons: "Reasons"
        },
        BalanceStatus: {
            _enum: [
                "Free",
                "Reserved"
            ]
        },
        Reasons: {
            _enum: [
                "Fee",
                "Misc",
                "All"
            ]
        },
        ReserveData: {
            id: "ReserveIdentifier",
            amount: "Balance"
        },
        ReserveIdentifier: "[u8; 8]",
        VestingSchedule: {
            offset: "Balance",
            perBlock: "Balance",
            startingBlock: "BlockNumber"
        },
        WithdrawReasons: {
            _set: {
                TransactionPayment: 1,
                Transfer: 2,
                Reserve: 4,
                Fee: 8,
                Tip: 16
            }
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3hA2R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    runtime: (0, _runtimeJs.runtime),
    types: {
        BeefyAuthoritySet: {
            id: "u64",
            len: "u32",
            root: "H256"
        },
        BeefyCommitment: {
            payload: "BeefyPayload",
            blockNumber: "BlockNumber",
            validatorSetId: "ValidatorSetId"
        },
        BeefyId: "[u8; 33]",
        BeefySignedCommitment: {
            commitment: "BeefyCommitment",
            signatures: "Vec<Option<EcdsaSignature>>"
        },
        BeefyNextAuthoritySet: {
            id: "u64",
            len: "u32",
            root: "H256"
        },
        BeefyPayload: "Vec<(BeefyPayloadId, Bytes)>",
        BeefyPayloadId: "[u8;2]",
        MmrRootHash: "H256",
        ValidatorSetId: "u64",
        ValidatorSet: {
            validators: "Vec<AuthorityId>",
            id: "ValidatorSetId"
        }
    }
};

},{"./rpc.js":"TSsQ1","./runtime.js":"6RXlq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"TSsQ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    getFinalizedHead: {
        description: "Returns hash of the latest BEEFY finalized block as seen by this client.",
        params: [],
        type: "H256"
    },
    subscribeJustifications: {
        description: "Returns the block most recently finalized by BEEFY, alongside side its justification.",
        params: [],
        pubsub: [
            "justifications",
            "subscribeJustifications",
            "unsubscribeJustifications"
        ],
        type: "BeefySignedCommitment"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6RXlq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    BeefyApi: [
        {
            methods: {
                validator_set: {
                    description: "Return the current active BEEFY validator set",
                    params: [],
                    type: "Option<ValidatorSet>"
                }
            },
            version: 1
        }
    ],
    BeefyMmrApi: [
        {
            methods: {
                authority_set_proof: {
                    description: "Return the currently active BEEFY authority set proof.",
                    params: [],
                    type: "BeefyAuthoritySet"
                },
                next_authority_set_proof: {
                    description: "Return the next/queued BEEFY authority set proof.",
                    params: [],
                    type: "BeefyNextAuthoritySet"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fdaW0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {
        BenchmarkConfig: {
            pallet: "Bytes",
            benchmark: "Bytes",
            selectedComponents: "Vec<(BenchmarkParameter, u32)>",
            verify: "bool",
            internalRepeats: "u32"
        },
        BenchmarkList: {
            pallet: "Bytes",
            instance: "Bytes",
            benchmarks: "Vec<BenchmarkMetadata>"
        },
        BenchmarkMetadata: {
            name: "Bytes",
            components: "Vec<(BenchmarkParameter, u32, u32)>"
        },
        BenchmarkParameter: {
            _enum: [
                "a",
                "b",
                "c",
                "d",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "p",
                "q",
                "r",
                "s",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "z"
            ]
        }
    }
};

},{"./runtime.js":"aSpJe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aSpJe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    Benchmark: [
        {
            methods: {
                benchmark_metadata: {
                    description: "Get the benchmark metadata available for this runtime.",
                    params: [
                        {
                            name: "extra",
                            type: "bool"
                        }
                    ],
                    type: "(Vec<BenchmarkList>, Vec<StorageInfo>)"
                },
                dispatch_benchmark: {
                    description: "Dispatch the given benchmark.",
                    params: [
                        {
                            name: "config",
                            type: "BenchmarkConfig"
                        }
                    ],
                    type: "Result<Vec<BenchmarkBatch>, Text>"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kKaWs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {
        CheckInherentsResult: {
            okay: "bool",
            fatalError: "bool",
            errors: "InherentData"
        },
        InherentData: {
            data: "BTreeMap<InherentIdentifier, Bytes>"
        },
        InherentIdentifier: "[u8; 8]"
    }
};

},{"./runtime.js":"12EEU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"12EEU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const BB_V2_TO_V4 = {
    // this was removed after V4
    random_seed: {
        description: "Generate a random seed.",
        params: [],
        type: "Hash"
    }
};
const BB_V2_TO_V5 = {
    apply_extrinsic: {
        description: "Apply the given extrinsic.",
        params: [
            {
                name: "extrinsic",
                type: "Extrinsic"
            }
        ],
        type: "ApplyExtrinsicResultPre6"
    }
};
const BB_V2_TO_V6 = {
    check_inherents: {
        description: "Check that the inherents are valid.",
        params: [
            {
                name: "block",
                type: "Block"
            },
            {
                name: "data",
                type: "InherentData"
            }
        ],
        type: "CheckInherentsResult"
    },
    inherent_extrinsics: {
        description: "Generate inherent extrinsics.",
        params: [
            {
                name: "inherent",
                type: "InherentData"
            }
        ],
        type: "Vec<Extrinsic>"
    }
};
const BB_V3_TO_V6 = {
    // renamed in v3 from finalize_block
    finalize_block: {
        description: "Finish the current block.",
        params: [],
        type: "Header"
    }
};
const runtime = {
    BlockBuilder: [
        {
            methods: (0, _util.objectSpread)({
                apply_extrinsic: {
                    description: "Apply the given extrinsic.",
                    params: [
                        {
                            name: "extrinsic",
                            type: "Extrinsic"
                        }
                    ],
                    type: "ApplyExtrinsicResult"
                }
            }, BB_V2_TO_V6, BB_V3_TO_V6),
            version: 6
        },
        {
            methods: (0, _util.objectSpread)({}, BB_V2_TO_V5, BB_V2_TO_V6, BB_V3_TO_V6),
            version: 5
        },
        {
            methods: (0, _util.objectSpread)({}, BB_V2_TO_V4, BB_V2_TO_V5, BB_V2_TO_V6, BB_V3_TO_V6),
            version: 4
        },
        {
            methods: (0, _util.objectSpread)({}, BB_V2_TO_V4, BB_V2_TO_V6, BB_V3_TO_V6),
            version: 3
        },
        {
            methods: (0, _util.objectSpread)({
                finalise_block: {
                    description: "Finish the current block.",
                    params: [],
                    type: "Header"
                }
            }, BB_V2_TO_V4, BB_V2_TO_V6),
            version: 2
        }
    ]
};

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"deutg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        CollectiveOrigin: {
            _enum: {
                Members: "(MemberCount, MemberCount)",
                Member: "AccountId"
            }
        },
        MemberCount: "u32",
        ProposalIndex: "u32",
        VotesTo230: {
            index: "ProposalIndex",
            threshold: "MemberCount",
            ayes: "Vec<AccountId>",
            nays: "Vec<AccountId>"
        },
        Votes: {
            index: "ProposalIndex",
            threshold: "MemberCount",
            ayes: "Vec<AccountId>",
            nays: "Vec<AccountId>",
            end: "BlockNumber"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"deoP9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        AuthorityId: "AccountId",
        RawVRFOutput: "[u8; 32]"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jTpo2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    runtime: (0, _runtimeJs.runtime),
    types: {
        AliveContractInfo: {
            trieId: "TrieId",
            storageSize: "u32",
            pairCount: "u32",
            codeHash: "CodeHash",
            rentAllowance: "Balance",
            rentPaid: "Balance",
            deductBlock: "BlockNumber",
            lastWrite: "Option<BlockNumber>",
            _reserved: "Option<Null>"
        },
        CodeHash: "Hash",
        CodeSource: {
            _enum: {
                Upload: "Bytes",
                Existing: "Hash"
            }
        },
        CodeUploadRequest: {
            origin: "AccountId",
            code: "Bytes",
            storageDepositLimit: "Option<Balance>"
        },
        CodeUploadResult: "Result<CodeUploadResultValue, DispatchError>",
        CodeUploadResultValue: {
            codeHash: "CodeHash",
            deposit: "Balance"
        },
        ContractCallRequest: {
            origin: "AccountId",
            dest: "AccountId",
            value: "Balance",
            gasLimit: "u64",
            storageDepositLimit: "Option<Balance>",
            inputData: "Bytes"
        },
        ContractExecResultSuccessTo255: {
            status: "u8",
            data: "Raw"
        },
        ContractExecResultTo255: {
            _enum: {
                Success: "ContractExecResultSuccessTo255",
                Error: "Null"
            }
        },
        ContractExecResultSuccessTo260: {
            flags: "ContractReturnFlags",
            data: "Bytes",
            gasConsumed: "u64"
        },
        ContractExecResultTo260: {
            _enum: {
                Success: "ContractExecResultSuccessTo260",
                Error: "Null"
            }
        },
        ContractExecResultOk: {
            flags: "ContractReturnFlags",
            data: "Bytes"
        },
        ContractExecResultResult: "Result<ContractExecResultOk, DispatchError>",
        ContractExecResultTo267: {
            gasConsumed: "u64",
            debugMessage: "Text",
            result: "ContractExecResultResult"
        },
        ContractExecResult: {
            gasConsumed: "u64",
            gasRequired: "u64",
            storageDeposit: "StorageDeposit",
            debugMessage: "Text",
            result: "ContractExecResultResult"
        },
        ContractInfo: {
            _enum: {
                Alive: "AliveContractInfo",
                Tombstone: "TombstoneContractInfo"
            }
        },
        ContractCallFlags: {
            _set: {
                _bitLength: 32,
                ForwardInput: 1,
                CloneInput: 2,
                TailCall: 4,
                AllowReentry: 8
            }
        },
        ContractReturnFlags: {
            _set: {
                _bitLength: 32,
                Revert: 0x00000001
            }
        },
        ContractStorageKey: "[u8; 32]",
        DeletedContract: {
            pairCount: "u32",
            trieId: "TrieId"
        },
        ExecReturnValue: {
            flags: "ContractReturnFlags",
            data: "Bytes"
        },
        Gas: "u64",
        HostFnWeightsTo264: {
            caller: "Weight",
            address: "Weight",
            gasLeft: "Weight",
            balance: "Weight",
            valueTransferred: "Weight",
            minimumBalance: "Weight",
            tombstoneDeposit: "Weight",
            rentAllowance: "Weight",
            blockNumber: "Weight",
            now: "Weight",
            weightToFee: "Weight",
            gas: "Weight",
            input: "Weight",
            inputPerByte: "Weight",
            return: "Weight",
            returnPerByte: "Weight",
            terminate: "Weight",
            restoreTo: "Weight",
            restoreToPerDelta: "Weight",
            random: "Weight",
            depositEvent: "Weight",
            depositEventPerTopic: "Weight",
            depositEventPerByte: "Weight",
            setRentAllowance: "Weight",
            setStorage: "Weight",
            setStoragePerByte: "Weight",
            clearStorage: "Weight",
            getStorage: "Weight",
            getStoragePerByte: "Weight",
            transfer: "Weight",
            call: "Weight",
            callTransferSurcharge: "Weight",
            callPerInputByte: "Weight",
            callPerOutputByte: "Weight",
            instantiate: "Weight",
            instantiatePerInputByte: "Weight",
            instantiatePerOutputByte: "Weight",
            hashSha2256: "Weight",
            hashSha2256PerByte: "Weight",
            hashKeccak256: "Weight",
            hashKeccak256PerByte: "Weight",
            hashBlake2256: "Weight",
            hashBlake2256PerByte: "Weight",
            hashBlake2128: "Weight",
            hashBlake2128PerByte: "Weight"
        },
        HostFnWeights: {
            caller: "Weight",
            address: "Weight",
            gasLeft: "Weight",
            balance: "Weight",
            valueTransferred: "Weight",
            minimumBalance: "Weight",
            tombstoneDeposit: "Weight",
            rentAllowance: "Weight",
            blockNumber: "Weight",
            now: "Weight",
            weightToFee: "Weight",
            gas: "Weight",
            input: "Weight",
            inputPerByte: "Weight",
            return: "Weight",
            returnPerByte: "Weight",
            terminate: "Weight",
            terminatePerCodeByte: "Weight",
            restoreTo: "Weight",
            restoreToPerCallerCodeByte: "Weight",
            restoreToPerTombstoneCodeByte: "Weight",
            restoreToPerDelta: "Weight",
            random: "Weight",
            depositEvent: "Weight",
            depositEventPerTopic: "Weight",
            depositEventPerByte: "Weight",
            setRentAllowance: "Weight",
            setStorage: "Weight",
            setStoragePerByte: "Weight",
            clearStorage: "Weight",
            getStorage: "Weight",
            getStoragePerByte: "Weight",
            transfer: "Weight",
            call: "Weight",
            callPerCodeByte: "Weight",
            callTransferSurcharge: "Weight",
            callPerInputByte: "Weight",
            callPerOutputByte: "Weight",
            instantiate: "Weight",
            instantiatePerCodeByte: "Weight",
            instantiatePerInputByte: "Weight",
            instantiatePerOutputByte: "Weight",
            instantiatePerSaltByte: "Weight",
            hashSha2256: "Weight",
            hashSha2256PerByte: "Weight",
            hashKeccak256: "Weight",
            hashKeccak256PerByte: "Weight",
            hashBlake2256: "Weight",
            hashBlake2256PerByte: "Weight",
            hashBlake2128: "Weight",
            hashBlake2128PerByte: "Weight",
            rentParams: "Weight"
        },
        InstantiateRequestV1: {
            origin: "AccountId",
            value: "Balance",
            gasLimit: "Gas",
            code: "Bytes",
            data: "Bytes",
            salt: "Bytes"
        },
        InstantiateRequestV2: {
            _fallback: "InstantiateRequestV1",
            origin: "AccountId",
            value: "Balance",
            gasLimit: "Gas",
            storageDepositLimit: "Option<Balance>",
            code: "Bytes",
            data: "Bytes",
            salt: "Bytes"
        },
        InstantiateRequest: {
            _fallback: "InstantiateRequestV2",
            origin: "AccountId",
            value: "Balance",
            gasLimit: "Gas",
            storageDepositLimit: "Option<Balance>",
            code: "CodeSource",
            data: "Bytes",
            salt: "Bytes"
        },
        ContractInstantiateResultTo267: "Result<InstantiateReturnValueTo267, Null>",
        ContractInstantiateResultTo299: "Result<InstantiateReturnValueOk, Null>",
        ContractInstantiateResult: {
            _fallback: "ContractInstantiateResultTo299",
            gasConsumed: "u64",
            gasRequired: "u64",
            storageDeposit: "StorageDeposit",
            debugMessage: "Text",
            result: "InstantiateReturnValue"
        },
        InstantiateReturnValueTo267: {
            result: "ExecReturnValue",
            accountId: "AccountId",
            rentProjection: "Option<RentProjection>"
        },
        InstantiateReturnValueOk: {
            result: "ExecReturnValue",
            accountId: "AccountId"
        },
        InstantiateReturnValue: "Result<InstantiateReturnValueOk, DispatchError>",
        InstructionWeights: {
            i64const: "u32",
            i64load: "u32",
            i64store: "u32",
            select: "u32",
            rIf: "u32",
            br: "u32",
            brIf: "u32",
            brIable: "u32",
            brIablePerEntry: "u32",
            call: "u32",
            callIndirect: "u32",
            callIndirectPerParam: "u32",
            localGet: "u32",
            localSet: "u32",
            local_tee: "u32",
            globalGet: "u32",
            globalSet: "u32",
            memoryCurrent: "u32",
            memoryGrow: "u32",
            i64clz: "u32",
            i64ctz: "u32",
            i64popcnt: "u32",
            i64eqz: "u32",
            i64extendsi32: "u32",
            i64extendui32: "u32",
            i32wrapi64: "u32",
            i64eq: "u32",
            i64ne: "u32",
            i64lts: "u32",
            i64ltu: "u32",
            i64gts: "u32",
            i64gtu: "u32",
            i64les: "u32",
            i64leu: "u32",
            i64ges: "u32",
            i64geu: "u32",
            i64add: "u32",
            i64sub: "u32",
            i64mul: "u32",
            i64divs: "u32",
            i64divu: "u32",
            i64rems: "u32",
            i64remu: "u32",
            i64and: "u32",
            i64or: "u32",
            i64xor: "u32",
            i64shl: "u32",
            i64shrs: "u32",
            i64shru: "u32",
            i64rotl: "u32",
            i64rotr: "u32"
        },
        LimitsTo264: {
            eventTopics: "u32",
            stackHeight: "u32",
            globals: "u32",
            parameters: "u32",
            memoryPages: "u32",
            tableSize: "u32",
            brTableSize: "u32",
            subjectLen: "u32",
            codeSize: "u32"
        },
        Limits: {
            eventTopics: "u32",
            stackHeight: "u32",
            globals: "u32",
            parameters: "u32",
            memoryPages: "u32",
            tableSize: "u32",
            brTableSize: "u32",
            subjectLen: "u32"
        },
        PrefabWasmModule: {
            scheduleVersion: "Compact<u32>",
            initial: "Compact<u32>",
            maximum: "Compact<u32>",
            refcount: "Compact<u64>",
            _reserved: "Option<Null>",
            code: "Bytes",
            originalCodeLen: "u32"
        },
        RentProjection: {
            _enum: {
                EvictionAt: "BlockNumber",
                NoEviction: "Null"
            }
        },
        ScheduleTo212: {
            version: "u32",
            putCodePerByteCost: "Gas",
            growMemCost: "Gas",
            regularOpCost: "Gas",
            returnDataPerByteCost: "Gas",
            eventDataPerByteCost: "Gas",
            eventPerTopicCost: "Gas",
            eventBaseCost: "Gas",
            sandboxDataReadCost: "Gas",
            sandboxDataWriteCost: "Gas",
            maxEventTopics: "u32",
            maxStackHeight: "u32",
            maxMemoryPages: "u32",
            enablePrintln: "bool",
            maxSubjectLen: "u32"
        },
        ScheduleTo258: {
            version: "u32",
            putCodePerByteCost: "Gas",
            growMemCost: "Gas",
            regularOpCost: "Gas",
            returnDataPerByteCost: "Gas",
            eventDataPerByteCost: "Gas",
            eventPerTopicCost: "Gas",
            eventBaseCost: "Gas",
            sandboxDataReadCost: "Gas",
            sandboxDataWriteCost: "Gas",
            transferCost: "Gas",
            maxEventTopics: "u32",
            maxStackHeight: "u32",
            maxMemoryPages: "u32",
            enablePrintln: "bool",
            maxSubjectLen: "u32"
        },
        ScheduleTo264: {
            version: "u32",
            enablePrintln: "bool",
            limits: "LimitsTo264",
            instructionWeights: "InstructionWeights",
            hostFnWeights: "HostFnWeightsTo264"
        },
        Schedule: {
            version: "u32",
            enablePrintln: "bool",
            limits: "Limits",
            instructionWeights: "InstructionWeights",
            hostFnWeights: "HostFnWeights"
        },
        SeedOf: "Hash",
        StorageDeposit: {
            _enum: {
                Refund: "Balance",
                Charge: "Balance"
            }
        },
        TombstoneContractInfo: "Hash",
        TrieId: "Bytes"
    }
};

},{"./rpc.js":"2SnMw","./runtime.js":"KvWWg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2SnMw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    call: {
        description: "Executes a call to a contract",
        params: [
            {
                name: "callRequest",
                type: "ContractCallRequest"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "ContractExecResult"
    },
    getStorage: {
        description: "Returns the value under a specified storage key in a contract",
        params: [
            {
                name: "address",
                type: "AccountId"
            },
            {
                name: "key",
                type: "H256"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Option<Bytes>"
    },
    instantiate: {
        description: "Instantiate a new contract",
        params: [
            {
                name: "request",
                type: "InstantiateRequest"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "ContractInstantiateResult"
    },
    rentProjection: {
        description: "Returns the projected time a given contract will be able to sustain paying its rent",
        params: [
            {
                name: "address",
                type: "AccountId"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Option<BlockNumber>"
    },
    uploadCode: {
        description: "Upload new code without instantiating a contract from it",
        // The RPC here is terribly misnamed - somebody forgot how the RPCs
        // are actually done, ie. <module>_<camelCasedMethod>
        endpoint: "contracts_upload_code",
        params: [
            {
                name: "uploadRequest",
                type: "CodeUploadRequest"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "CodeUploadResult"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"KvWWg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    ContractsApi: [
        {
            methods: {
                call: {
                    description: "Perform a call from a specified account to a given contract.",
                    params: [
                        {
                            name: "origin",
                            type: "AccountId"
                        },
                        {
                            name: "dest",
                            type: "AccountId"
                        },
                        {
                            name: "value",
                            type: "Balance"
                        },
                        {
                            name: "gasLimit",
                            type: "u64"
                        },
                        {
                            name: "storageDepositLimit",
                            type: "Option<Balance>"
                        },
                        {
                            name: "inputData",
                            type: "Vec<u8>"
                        }
                    ],
                    type: "ContractExecResult"
                },
                get_storage: {
                    description: "Query a given storage key in a given contract.",
                    params: [
                        {
                            name: "address",
                            type: "AccountId"
                        },
                        {
                            name: "key",
                            type: "Bytes"
                        }
                    ],
                    type: "Option<Bytes>"
                },
                instantiate: {
                    description: "Instantiate a new contract.",
                    params: [
                        {
                            name: "origin",
                            type: "AccountId"
                        },
                        {
                            name: "value",
                            type: "Balance"
                        },
                        {
                            name: "gasLimit",
                            type: "u64"
                        },
                        {
                            name: "storageDepositLimit",
                            type: "Option<Balance>"
                        },
                        {
                            name: "code",
                            type: "Bytes"
                        },
                        {
                            name: "data",
                            type: "Bytes"
                        },
                        {
                            name: "salt",
                            type: "Bytes"
                        }
                    ],
                    type: "ContractInstantiateResult"
                },
                upload_code: {
                    description: "Upload new code without instantiating a contract from it.",
                    params: [
                        {
                            name: "origin",
                            type: "AccountId"
                        },
                        {
                            name: "code",
                            type: "Bytes"
                        },
                        {
                            name: "storageDepositLimit",
                            type: "Option<Balance>"
                        }
                    ],
                    type: "CodeUploadResult"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lbBfn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AllConvictions", ()=>AllConvictions);
const AllConvictions = [
    "None",
    "Locked1x",
    "Locked2x",
    "Locked3x",
    "Locked4x",
    "Locked5x",
    "Locked6x"
];
exports.default = {
    rpc: {},
    types: {
        AccountVote: {
            _enum: {
                Standard: "AccountVoteStandard",
                Split: "AccountVoteSplit"
            }
        },
        AccountVoteSplit: {
            aye: "Balance",
            nay: "Balance"
        },
        AccountVoteStandard: {
            vote: "Vote",
            balance: "Balance"
        },
        Conviction: {
            _enum: AllConvictions
        },
        Delegations: {
            votes: "Balance",
            capital: "Balance"
        },
        PreimageStatus: {
            _enum: {
                Missing: "BlockNumber",
                Available: "PreimageStatusAvailable"
            }
        },
        PreimageStatusAvailable: {
            data: "Bytes",
            provider: "AccountId",
            deposit: "Balance",
            since: "BlockNumber",
            expiry: "Option<BlockNumber>"
        },
        PriorLock: "(BlockNumber, Balance)",
        PropIndex: "u32",
        Proposal: "Call",
        ProxyState: {
            _enum: {
                Open: "AccountId",
                Active: "AccountId"
            }
        },
        ReferendumIndex: "u32",
        ReferendumInfoTo239: {
            end: "BlockNumber",
            proposalHash: "Hash",
            threshold: "VoteThreshold",
            delay: "BlockNumber"
        },
        ReferendumInfo: {
            _enum: {
                Ongoing: "ReferendumStatus",
                Finished: "ReferendumInfoFinished"
            }
        },
        ReferendumInfoFinished: {
            approved: "bool",
            end: "BlockNumber"
        },
        ReferendumStatus: {
            end: "BlockNumber",
            proposalHash: "Hash",
            threshold: "VoteThreshold",
            delay: "BlockNumber",
            tally: "Tally"
        },
        Tally: {
            ayes: "Balance",
            nays: "Balance",
            turnout: "Balance"
        },
        Voting: {
            _enum: {
                Direct: "VotingDirect",
                Delegating: "VotingDelegating"
            }
        },
        VotingDirect: {
            votes: "Vec<VotingDirectVote>",
            delegations: "Delegations",
            prior: "PriorLock"
        },
        VotingDirectVote: "(ReferendumIndex, AccountVote)",
        VotingDelegating: {
            balance: "Balance",
            target: "AccountId",
            conviction: "Conviction",
            delegations: "Delegations",
            prior: "PriorLock"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"206dY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    types: {
        BlockStats: {
            witnessLen: "u64",
            witnessCompactLen: "u64",
            blockLen: "u64",
            blockNumExtrinsics: "u64"
        }
    }
};

},{"./rpc.js":"b427p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b427p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    getBlockStats: {
        description: "Reexecute the specified `block_hash` and gather statistics while doing so",
        params: [
            {
                isHistoric: true,
                name: "at",
                type: "Hash"
            }
        ],
        type: "Option<BlockStats>"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8l8G5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {}
};

},{"./runtime.js":"2flQR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2flQR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    AuthorityDiscoveryApi: [
        {
            methods: {
                authorities: {
                    description: "Retrieve authority identifiers of the current and next authority set.",
                    params: [],
                    type: "Vec<AuthorityId>"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7432Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        ApprovalFlag: "u32",
        DefunctVoter: {
            who: "AccountId",
            voteCount: "Compact<u32>",
            candidateCount: "Compact<u32>"
        },
        Renouncing: {
            _enum: {
                Member: "Null",
                RunnerUp: "Null",
                Candidate: "Compact<u32>"
            }
        },
        SetIndex: "u32",
        Vote: "GenericVote",
        VoteIndex: "u32",
        VoterInfo: {
            lastActive: "VoteIndex",
            lastWin: "VoteIndex",
            pot: "Balance",
            stake: "Balance"
        },
        VoteThreshold: {
            _enum: [
                "Super Majority Approve",
                "Super Majority Against",
                "Simple Majority"
            ]
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8IgZM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    types: {
        CreatedBlock: {
            _alias: {
                blockHash: "hash"
            },
            blockHash: "BlockHash",
            aux: "ImportedAux"
        },
        ImportedAux: {
            headerOnly: "bool",
            clearJustificationRequests: "bool",
            needsJustification: "bool",
            badJustification: "bool",
            needsFinalityProof: "bool",
            isNewBest: "bool"
        }
    }
};

},{"./rpc.js":"031Qb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"031Qb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    createBlock: {
        description: "Instructs the manual-seal authorship task to create a new block",
        params: [
            {
                name: "createEmpty",
                type: "bool"
            },
            {
                name: "finalize",
                type: "bool"
            },
            {
                isOptional: true,
                name: "parentHash",
                type: "BlockHash"
            }
        ],
        type: "CreatedBlock"
    },
    finalizeBlock: {
        description: "Instructs the manual-seal authorship task to finalize a block",
        params: [
            {
                name: "hash",
                type: "BlockHash"
            },
            {
                isOptional: true,
                name: "justification",
                type: "Justification"
            }
        ],
        type: "bool"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hshdN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        EvmAccount: {
            nonce: "u256",
            balance: "u256"
        },
        EvmCallInfo: {
            exitReason: "ExitReason",
            value: "Bytes",
            usedGas: "U256",
            logs: "Vec<EvmLog>"
        },
        EvmCreateInfo: {
            exitReason: "ExitReason",
            value: "H160",
            usedGas: "U256",
            logs: "Vec<EvmLog>"
        },
        EvmLog: {
            address: "H160",
            topics: "Vec<H256>",
            data: "Bytes"
        },
        EvmVicinity: {
            gasPrice: "u256",
            origin: "H160"
        },
        ExitError: {
            _enum: {
                StackUnderflow: "Null",
                StackOverflow: "Null",
                InvalidJump: "Null",
                InvalidRange: "Null",
                DesignatedInvalid: "Null",
                CallTooDeep: "Null",
                CreateCollision: "Null",
                CreateContractLimit: "Null",
                OutOfOffset: "Null",
                OutOfGas: "Null",
                OutOfFund: "Null",
                PCUnderflow: "Null",
                CreateEmpty: "Null",
                Other: "Text"
            }
        },
        ExitFatal: {
            _enum: {
                NotSupported: "Null",
                UnhandledInterrupt: "Null",
                CallErrorAsFatal: "ExitError",
                Other: "Text"
            }
        },
        ExitReason: {
            _enum: {
                Succeed: "ExitSucceed",
                Error: "ExitError",
                Revert: "ExitRevert",
                Fatal: "ExitFatal"
            }
        },
        ExitRevert: {
            _enum: [
                "Reverted"
            ]
        },
        ExitSucceed: {
            _enum: [
                "Stopped",
                "Returned",
                "Suicided"
            ]
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3jfHp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        Extrinsic: "GenericExtrinsic",
        ExtrinsicEra: "GenericExtrinsicEra",
        ExtrinsicPayload: "GenericExtrinsicPayload",
        ExtrinsicSignature: "MultiSignature",
        ExtrinsicV4: "GenericExtrinsicV4",
        ExtrinsicPayloadV4: "GenericExtrinsicPayloadV4",
        ExtrinsicSignatureV4: "GenericExtrinsicSignatureV4",
        ExtrinsicUnknown: "GenericExtrinsicUnknown",
        ExtrinsicPayloadUnknown: "GenericExtrinsicPayloadUnknown",
        // eras
        Era: "ExtrinsicEra",
        ImmortalEra: "GenericImmortalEra",
        MortalEra: "GenericMortalEra",
        // signatures & signer
        AnySignature: "H512",
        MultiSignature: {
            _enum: {
                Ed25519: "Ed25519Signature",
                Sr25519: "Sr25519Signature",
                Ecdsa: "EcdsaSignature"
            }
        },
        Signature: "H512",
        SignerPayload: "GenericSignerPayload",
        EcdsaSignature: "[u8; 65]",
        Ed25519Signature: "H512",
        Sr25519Signature: "H512"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"03qFj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        AssetOptions: {
            initalIssuance: "Compact<Balance>",
            permissions: "PermissionLatest"
        },
        Owner: {
            _enum: {
                None: "Null",
                Address: "AccountId"
            }
        },
        PermissionsV1: {
            update: "Owner",
            mint: "Owner",
            burn: "Owner"
        },
        PermissionVersions: {
            _enum: {
                V1: "PermissionsV1"
            }
        },
        PermissionLatest: "PermissionsV1"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cghBp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        ActiveGilt: {
            proportion: "Perquintill",
            amount: "Balance",
            who: "AccountId",
            expiry: "BlockNumber"
        },
        ActiveGiltsTotal: {
            frozen: "Balance",
            proportion: "Perquintill",
            index: "ActiveIndex",
            target: "Perquintill"
        },
        ActiveIndex: "u32",
        GiltBid: {
            amount: "Balance",
            who: "AccountId"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cVXOr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    runtime: (0, _runtimeJs.runtime),
    types: {
        AuthorityIndex: "u64",
        AuthorityList: "Vec<NextAuthority>",
        AuthoritySet: {
            currentAuthorities: "AuthorityList",
            setId: "u64",
            pendingStandardChanges: "ForkTreePendingChange",
            pendingForcedChanges: "Vec<PendingChange>",
            authoritySetChanges: "AuthoritySetChanges"
        },
        ForkTreePendingChange: {
            roots: "Vec<ForkTreePendingChangeNode>",
            bestFinalizedNumber: "Option<BlockNumber>"
        },
        ForkTreePendingChangeNode: {
            hash: "BlockHash",
            number: "BlockNumber",
            data: "PendingChange",
            // actual data, here PendingChange
            children: "Vec<ForkTreePendingChangeNode>"
        },
        AuthoritySetChange: "(U64, BlockNumber)",
        AuthoritySetChanges: "Vec<AuthoritySetChange>",
        AuthorityWeight: "u64",
        DelayKind: {
            _enum: {
                Finalized: "Null",
                Best: "DelayKindBest"
            }
        },
        DelayKindBest: {
            medianLastFinalized: "BlockNumber"
        },
        EncodedFinalityProofs: "Bytes",
        GrandpaEquivocation: {
            _enum: {
                Prevote: "GrandpaEquivocationValue",
                Precommit: "GrandpaEquivocationValue"
            }
        },
        GrandpaEquivocationProof: {
            setId: "SetId",
            equivocation: "GrandpaEquivocation"
        },
        GrandpaEquivocationValue: {
            roundNumber: "u64",
            identity: "AuthorityId",
            first: "(GrandpaPrevote, AuthoritySignature)",
            second: "(GrandpaPrevote, AuthoritySignature)"
        },
        GrandpaPrevote: {
            targetHash: "Hash",
            targetNumber: "BlockNumber"
        },
        GrandpaCommit: {
            targetHash: "BlockHash",
            targetNumber: "BlockNumber",
            precommits: "Vec<GrandpaSignedPrecommit>"
        },
        GrandpaPrecommit: {
            targetHash: "BlockHash",
            targetNumber: "BlockNumber"
        },
        GrandpaSignedPrecommit: {
            precommit: "GrandpaPrecommit",
            signature: "AuthoritySignature",
            id: "AuthorityId"
        },
        GrandpaJustification: {
            round: "u64",
            commit: "GrandpaCommit",
            votesAncestries: "Vec<Header>"
        },
        JustificationNotification: "Bytes",
        KeyOwnerProof: "MembershipProof",
        NextAuthority: "(AuthorityId, AuthorityWeight)",
        PendingChange: {
            nextAuthorities: "AuthorityList",
            delay: "BlockNumber",
            canonHeight: "BlockNumber",
            canonHash: "BlockHash",
            delayKind: "DelayKind"
        },
        PendingPause: {
            scheduledAt: "BlockNumber",
            delay: "BlockNumber"
        },
        PendingResume: {
            scheduledAt: "BlockNumber",
            delay: "BlockNumber"
        },
        Precommits: {
            currentWeight: "u32",
            missing: "BTreeSet<AuthorityId>"
        },
        Prevotes: {
            currentWeight: "u32",
            missing: "BTreeSet<AuthorityId>"
        },
        ReportedRoundStates: {
            setId: "u32",
            best: "RoundState",
            background: "Vec<RoundState>"
        },
        RoundState: {
            round: "u32",
            totalWeight: "u32",
            thresholdWeight: "u32",
            prevotes: "Prevotes",
            precommits: "Precommits"
        },
        SetId: "u64",
        StoredPendingChange: {
            scheduledAt: "BlockNumber",
            delay: "BlockNumber",
            nextAuthorities: "AuthorityList"
        },
        StoredState: {
            _enum: {
                Live: "Null",
                PendingPause: "PendingPause",
                Paused: "Null",
                PendingResume: "PendingResume"
            }
        }
    }
};

},{"./rpc.js":"4E0am","./runtime.js":"474kj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4E0am":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    proveFinality: {
        description: "Prove finality for the given block number, returning the Justification for the last block in the set.",
        params: [
            {
                name: "blockNumber",
                type: "BlockNumber"
            }
        ],
        type: "Option<EncodedFinalityProofs>"
    },
    roundState: {
        description: "Returns the state of the current best round state as well as the ongoing background rounds",
        params: [],
        type: "ReportedRoundStates"
    },
    subscribeJustifications: {
        description: "Subscribes to grandpa justifications",
        params: [],
        pubsub: [
            "justifications",
            "subscribeJustifications",
            "unsubscribeJustifications"
        ],
        type: "JustificationNotification"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"474kj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const GRANDPA_V2_V3 = {
    generate_key_ownership_proof: {
        description: "Generates a proof of key ownership for the given authority in the given set.",
        params: [
            {
                name: "setId",
                type: "SetId"
            },
            {
                name: "authorityId",
                type: "AuthorityId"
            }
        ],
        type: "Option<OpaqueKeyOwnershipProof>"
    },
    grandpa_authorities: {
        description: "Get the current GRANDPA authorities and weights. This should not change except for when changes are scheduled and the corresponding delay has passed.",
        params: [],
        type: "AuthorityList"
    },
    submit_report_equivocation_unsigned_extrinsic: {
        description: "Submits an unsigned extrinsic to report an equivocation.",
        params: [
            {
                name: "equivocationProof",
                type: "GrandpaEquivocationProof"
            },
            {
                name: "keyOwnerProof",
                type: "OpaqueKeyOwnershipProof"
            }
        ],
        type: "Option<Null>"
    }
};
const runtime = {
    GrandpaApi: [
        {
            methods: (0, _util.objectSpread)({
                current_set_id: {
                    description: "Get current GRANDPA authority set id.",
                    params: [],
                    type: "SetId"
                }
            }, GRANDPA_V2_V3),
            version: 3
        },
        {
            methods: GRANDPA_V2_V3,
            version: 2
        }
    ]
};

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1WVt1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        IdentityFields: {
            _set: {
                _bitLength: 64,
                // Mapped here to 32 bits, in Rust these are 64-bit values
                Display: 1,
                Legal: 2,
                Web: 4,
                Riot: 8,
                Email: 16,
                PgpFingerprint: 32,
                Image: 64,
                Twitter: 128
            }
        },
        IdentityInfoAdditional: "(Data, Data)",
        IdentityInfoTo198: {
            additional: "Vec<IdentityInfoAdditional>",
            display: "Data",
            legal: "Data",
            web: "Data",
            riot: "Data",
            email: "Data",
            pgpFingerprint: "Option<H160>",
            image: "Data"
        },
        IdentityInfo: {
            _fallback: "IdentityInfoTo198",
            additional: "Vec<IdentityInfoAdditional>",
            display: "Data",
            legal: "Data",
            web: "Data",
            riot: "Data",
            email: "Data",
            pgpFingerprint: "Option<H160>",
            image: "Data",
            twitter: "Data"
        },
        IdentityJudgement: {
            _enum: {
                Unknown: "Null",
                FeePaid: "Balance",
                Reasonable: "Null",
                KnownGood: "Null",
                OutOfDate: "Null",
                LowQuality: "Null",
                Erroneous: "Null"
            }
        },
        RegistrationJudgement: "(RegistrarIndex, IdentityJudgement)",
        RegistrationTo198: {
            judgements: "Vec<RegistrationJudgement>",
            deposit: "Balance",
            info: "IdentityInfoTo198"
        },
        Registration: {
            _fallback: "RegistrationTo198",
            judgements: "Vec<RegistrationJudgement>",
            deposit: "Balance",
            info: "IdentityInfo"
        },
        RegistrarIndex: "u32",
        RegistrarInfo: {
            account: "AccountId",
            fee: "Balance",
            fields: "IdentityFields"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i0Bt2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        AuthIndex: "u32",
        AuthoritySignature: "Signature",
        Heartbeat: {
            blockNumber: "BlockNumber",
            networkState: "OpaqueNetworkState",
            sessionIndex: "SessionIndex",
            authorityIndex: "AuthIndex",
            validatorsLen: "u32"
        },
        HeartbeatTo244: {
            blockNumber: "BlockNumber",
            networkState: "OpaqueNetworkState",
            sessionIndex: "SessionIndex",
            authorityIndex: "AuthIndex"
        },
        OpaqueMultiaddr: "Opaque<Bytes>",
        OpaquePeerId: "Opaque<Bytes>",
        OpaqueNetworkState: {
            peerId: "OpaquePeerId",
            externalAddresses: "Vec<OpaqueMultiaddr>"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"acY4d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        CallIndex: "(u8, u8)",
        LotteryConfig: {
            price: "Balance",
            start: "BlockNumber",
            length: "BlockNumber",
            delay: "BlockNumber",
            repeat: "bool"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gutES":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    runtime: (0, _runtimeJs.runtime),
    types: {
        MmrBatchProof: {
            leafIndices: "Vec<MmrLeafIndex>",
            leafCount: "MmrNodeIndex",
            items: "Vec<Hash>"
        },
        MmrEncodableOpaqueLeaf: "Bytes",
        MmrError: {
            _enum: [
                "Push",
                "GetRoot",
                "Commit",
                "GenerateProof",
                "Verify",
                "LeafNotFound",
                " PalletNotIncluded",
                "InvalidLeafIndex"
            ]
        },
        MmrLeafBatchProof: {
            blockHash: "BlockHash",
            leaves: "Bytes",
            proof: "Bytes"
        },
        MmrLeafIndex: "u64",
        MmrLeafProof: {
            blockHash: "BlockHash",
            leaf: "Bytes",
            proof: "Bytes"
        },
        MmrNodeIndex: "u64",
        MmrProof: {
            leafIndex: "MmrLeafIndex",
            leafCount: "MmrNodeIndex",
            items: "Vec<Hash>"
        }
    }
};

},{"./rpc.js":"1FDZJ","./runtime.js":"4bUy3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1FDZJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    generateBatchProof: {
        description: "Generate MMR proof for the given leaf indices.",
        params: [
            {
                name: "leafIndices",
                type: "Vec<u64>"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "MmrLeafProof"
    },
    generateProof: {
        description: "Generate MMR proof for given leaf index.",
        params: [
            {
                name: "leafIndex",
                type: "u64"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "MmrLeafBatchProof"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4bUy3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    MmrApi: [
        {
            methods: {
                generate_batch_proof: {
                    description: "Generate MMR proof for a series of leaves under given indices.",
                    params: [
                        {
                            name: "leafIndices",
                            type: "Vec<MmrLeafIndex>"
                        }
                    ],
                    type: "Result<(Vec<MmrEncodableOpaqueLeaf>, MmrBatchProof), MmrError>"
                },
                generate_proof: {
                    description: "Generate MMR proof for a leaf under given index.",
                    params: [
                        {
                            name: "leafIndex",
                            type: "MmrLeafIndex"
                        }
                    ],
                    type: "Result<(MmrEncodableOpaqueLeaf, MmrProof), MmrError>"
                },
                mmr_root: {
                    description: "Return the on-chain MMR root hash.",
                    params: [],
                    type: "Result<Hash, MmrError>"
                },
                verify_batch_proof: {
                    description: "Verify MMR proof against on-chain MMR for a batch of leaves.",
                    params: [
                        {
                            name: "leaves",
                            type: "Vec<MmrEncodableOpaqueLeaf>"
                        },
                        {
                            name: "proof",
                            type: "MmrBatchProof"
                        }
                    ],
                    type: "Result<(), MmrError>"
                },
                verify_batch_proof_stateless: {
                    description: "Verify MMR proof against given root hash or a batch of leaves.",
                    params: [
                        {
                            name: "root",
                            type: "Hash"
                        },
                        {
                            name: "leaves",
                            type: "Vec<MmrEncodableOpaqueLeaf>"
                        },
                        {
                            name: "proof",
                            type: "MmrBatchProof"
                        }
                    ],
                    type: "Result<(), MmrError>"
                },
                verify_proof: {
                    description: "Verify MMR proof against on-chain MMR.",
                    params: [
                        {
                            name: "leaf",
                            type: "MmrEncodableOpaqueLeaf"
                        },
                        {
                            name: "proof",
                            type: "MmrProof"
                        }
                    ],
                    type: "Result<(), MmrError>"
                },
                verify_proof_stateless: {
                    description: "Verify MMR proof against given root hash.",
                    params: [
                        {
                            name: "root",
                            type: "Hash"
                        },
                        {
                            name: "leaf",
                            type: "MmrEncodableOpaqueLeaf"
                        },
                        {
                            name: "proof",
                            type: "MmrProof"
                        }
                    ],
                    type: "Result<(), MmrError>"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8BZbl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {
        NpApiError: {
            _enum: [
                "MemberNotFound",
                "OverflowInPendingRewards"
            ]
        }
    }
};

},{"./runtime.js":"iARNC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iARNC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    NominationPoolsApi: [
        {
            methods: {
                pending_rewards: {
                    description: "Returns the pending rewards for the given member.",
                    params: [
                        {
                            name: "member",
                            type: "AccountId"
                        }
                    ],
                    type: "Result<Balance, NpApiError>"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hmPgW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        DeferredOffenceOf: "(Vec<OffenceDetails>, Vec<Perbill>, SessionIndex)",
        Kind: "[u8; 16]",
        OffenceDetails: {
            offender: "Offender",
            reporters: "Vec<Reporter>"
        },
        Offender: "IdentificationTuple",
        OpaqueTimeSlot: "Bytes",
        ReportIdOf: "Hash",
        Reporter: "AccountId"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jrFKv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {}
};

},{"./runtime.js":"jATWx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jATWx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    DifficultyApi: [
        {
            methods: {
                difficulty: {
                    description: "Return the target difficulty of the next block.",
                    params: [],
                    // This is Difficulty in the original, however this is chain-specific
                    type: "Raw"
                }
            },
            version: 1
        }
    ],
    TimestampApi: [
        {
            methods: {
                timestamp: {
                    description: "API necessary for timestamp-based difficulty adjustment algorithms.",
                    params: [],
                    type: "Moment"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fKFwr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        ProxyDefinition: {
            delegate: "AccountId",
            proxyType: "ProxyType",
            delay: "BlockNumber"
        },
        ProxyType: {
            _enum: [
                "Any",
                "NonTransfer",
                "Governance",
                "Staking"
            ]
        },
        ProxyAnnouncement: {
            real: "AccountId",
            callHash: "Hash",
            height: "BlockNumber"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gtDUv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        ActiveRecovery: {
            created: "BlockNumber",
            deposit: "Balance",
            friends: "Vec<AccountId>"
        },
        RecoveryConfig: {
            delayPeriod: "BlockNumber",
            deposit: "Balance",
            friends: "Vec<AccountId>",
            threshold: "u16"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dT5Rh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        Period: "(BlockNumber, u32)",
        Priority: "u8",
        SchedulePeriod: "Period",
        SchedulePriority: "Priority",
        Scheduled: {
            maybeId: "Option<Bytes>",
            priority: "SchedulePriority",
            call: "Call",
            maybePeriodic: "Option<SchedulePeriod>",
            origin: "PalletsOrigin"
        },
        ScheduledTo254: {
            maybeId: "Option<Bytes>",
            priority: "SchedulePriority",
            call: "Call",
            maybePeriodic: "Option<SchedulePeriod>"
        },
        TaskAddress: "(BlockNumber, u32)"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dWl4R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _util = require("@polkadot/util");
var _runtimeJs = require("./runtime.js"); // The runtime definition of SessionKeys are passed as a Trait to session
// Defined in `node/runtime/src/lib.rs` as follow
//   impl_opaque_keys! {
//     pub struct SessionKeys {
// Here we revert to tuples to keep the interfaces "opaque", as per the use
const keyTypes = {
    // key for beefy
    BeefyKey: "[u8; 33]",
    // default to Substrate master defaults, 4 keys (polkadot master, 5 keys)
    Keys: "SessionKeys4",
    SessionKeys1: "(AccountId)",
    SessionKeys2: "(AccountId, AccountId)",
    SessionKeys3: "(AccountId, AccountId, AccountId)",
    SessionKeys4: "(AccountId, AccountId, AccountId, AccountId)",
    SessionKeys5: "(AccountId, AccountId, AccountId, AccountId, AccountId)",
    SessionKeys6: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
    SessionKeys6B: "(AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
    SessionKeys7: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
    SessionKeys7B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
    SessionKeys8: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
    SessionKeys8B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
    SessionKeys9: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
    SessionKeys9B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
    SessionKeys10: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
    SessionKeys10B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)"
};
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: (0, _util.objectSpread)({}, keyTypes, {
        FullIdentification: "Exposure",
        IdentificationTuple: "(ValidatorId, FullIdentification)",
        MembershipProof: {
            session: "SessionIndex",
            trieNodes: "Vec<Bytes>",
            validatorCount: "ValidatorCount"
        },
        SessionIndex: "u32",
        ValidatorCount: "u32"
    })
};

},{"@polkadot/util":"3HnHw","./runtime.js":"90WzH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"90WzH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    SessionKeys: [
        {
            methods: {
                decode_session_keys: {
                    description: "Decode the given public session keys.",
                    params: [
                        {
                            name: "encoded",
                            type: "Bytes"
                        }
                    ],
                    type: "Option<Vec<(Bytes, KeyTypeId)>>"
                },
                generate_session_keys: {
                    description: "Generate a set of session keys with optionally using the given seed.",
                    params: [
                        {
                            name: "seed",
                            type: "Option<Bytes>"
                        }
                    ],
                    type: "Bytes"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7KBk2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        Bid: {
            who: "AccountId",
            kind: "BidKind",
            value: "Balance"
        },
        BidKind: {
            _enum: {
                Deposit: "Balance",
                Vouch: "(AccountId, Balance)"
            }
        },
        // a society-specific Judgement (not the same as identity Judgement)
        SocietyJudgement: {
            _enum: [
                "Rebid",
                "Reject",
                "Approve"
            ]
        },
        // a society-specific Vote
        SocietyVote: {
            _enum: [
                "Skeptic",
                "Reject",
                "Approve"
            ]
        },
        StrikeCount: "u32",
        VouchingStatus: {
            _enum: [
                "Vouching",
                "Banned"
            ]
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6HHiX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _util = require("@polkadot/util");
const deprecated = {
    Points: "u32",
    EraPoints: {
        total: "Points",
        individual: "Vec<Points>"
    }
};
const phragmen = {
    CompactAssignments: "CompactAssignmentsWith16",
    CompactAssignmentsWith16: {
        votes1: "Vec<(NominatorIndexCompact, ValidatorIndexCompact)>",
        votes2: "Vec<(NominatorIndexCompact, CompactScoreCompact, ValidatorIndexCompact)>",
        votes3: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 2], ValidatorIndexCompact)>",
        votes4: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 3], ValidatorIndexCompact)>",
        votes5: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 4], ValidatorIndexCompact)>",
        votes6: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 5], ValidatorIndexCompact)>",
        votes7: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 6], ValidatorIndexCompact)>",
        votes8: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 7], ValidatorIndexCompact)>",
        votes9: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 8], ValidatorIndexCompact)>",
        votes10: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 9], ValidatorIndexCompact)>",
        votes11: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 10], ValidatorIndexCompact)>",
        votes12: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 11], ValidatorIndexCompact)>",
        votes13: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 12], ValidatorIndexCompact)>",
        votes14: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 13], ValidatorIndexCompact)>",
        votes15: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 14], ValidatorIndexCompact)>",
        votes16: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 15], ValidatorIndexCompact)>"
    },
    CompactAssignmentsWith24: {
        votes1: "Vec<(NominatorIndexCompact, ValidatorIndexCompact)>",
        votes2: "Vec<(NominatorIndexCompact, CompactScoreCompact, ValidatorIndexCompact)>",
        votes3: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 2], ValidatorIndexCompact)>",
        votes4: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 3], ValidatorIndexCompact)>",
        votes5: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 4], ValidatorIndexCompact)>",
        votes6: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 5], ValidatorIndexCompact)>",
        votes7: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 6], ValidatorIndexCompact)>",
        votes8: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 7], ValidatorIndexCompact)>",
        votes9: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 8], ValidatorIndexCompact)>",
        votes10: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 9], ValidatorIndexCompact)>",
        votes11: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 10], ValidatorIndexCompact)>",
        votes12: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 11], ValidatorIndexCompact)>",
        votes13: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 12], ValidatorIndexCompact)>",
        votes14: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 13], ValidatorIndexCompact)>",
        votes15: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 14], ValidatorIndexCompact)>",
        votes16: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 15], ValidatorIndexCompact)>",
        votes17: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 16], ValidatorIndexCompact)>",
        votes18: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 17], ValidatorIndexCompact)>",
        votes19: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 18], ValidatorIndexCompact)>",
        votes20: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 19], ValidatorIndexCompact)>",
        votes21: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 20], ValidatorIndexCompact)>",
        votes22: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 21], ValidatorIndexCompact)>",
        votes23: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 22], ValidatorIndexCompact)>",
        votes24: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 23], ValidatorIndexCompact)>"
    },
    CompactAssignmentsTo265: "CompactAssignmentsWith16",
    CompactAssignmentsTo257: {
        votes1: "Vec<(NominatorIndex, [CompactScore; 0], ValidatorIndex)>",
        votes2: "Vec<(NominatorIndex, [CompactScore; 1], ValidatorIndex)>",
        votes3: "Vec<(NominatorIndex, [CompactScore; 2], ValidatorIndex)>",
        votes4: "Vec<(NominatorIndex, [CompactScore; 3], ValidatorIndex)>",
        votes5: "Vec<(NominatorIndex, [CompactScore; 4], ValidatorIndex)>",
        votes6: "Vec<(NominatorIndex, [CompactScore; 5], ValidatorIndex)>",
        votes7: "Vec<(NominatorIndex, [CompactScore; 6], ValidatorIndex)>",
        votes8: "Vec<(NominatorIndex, [CompactScore; 7], ValidatorIndex)>",
        votes9: "Vec<(NominatorIndex, [CompactScore; 8], ValidatorIndex)>",
        votes10: "Vec<(NominatorIndex, [CompactScore; 9], ValidatorIndex)>",
        votes11: "Vec<(NominatorIndex, [CompactScore; 10], ValidatorIndex)>",
        votes12: "Vec<(NominatorIndex, [CompactScore; 11], ValidatorIndex)>",
        votes13: "Vec<(NominatorIndex, [CompactScore; 12], ValidatorIndex)>",
        votes14: "Vec<(NominatorIndex, [CompactScore; 13], ValidatorIndex)>",
        votes15: "Vec<(NominatorIndex, [CompactScore; 14], ValidatorIndex)>",
        votes16: "Vec<(NominatorIndex, [CompactScore; 15], ValidatorIndex)>"
    },
    CompactScore: "(ValidatorIndex, OffchainAccuracy)",
    CompactScoreCompact: "(ValidatorIndexCompact, OffchainAccuracyCompact)",
    ElectionCompute: {
        // in previous versions the last entry was "AuthorityId"
        // (since no data attached, and it is via SCALE can rename)
        _enum: [
            "OnChain",
            "Signed",
            "Unsigned"
        ]
    },
    ElectionPhase: {
        _enum: {
            Off: null,
            Signed: null,
            Unsigned: "(bool, BlockNumber)",
            Emergency: null
        }
    },
    ElectionResult: {
        compute: "ElectionCompute",
        slotStake: "Balance",
        electedStashes: "Vec<AccountId>",
        exposures: "Vec<(AccountId, Exposure)>"
    },
    ElectionScore: "[u128; 3]",
    ElectionSize: {
        validators: "Compact<ValidatorIndex>",
        nominators: "Compact<NominatorIndex>"
    },
    ElectionStatus: {
        _enum: {
            Close: "Null",
            Open: "BlockNumber"
        }
    },
    ExtendedBalance: "u128",
    RawSolution: "RawSolutionWith16",
    RawSolutionWith16: {
        compact: "CompactAssignmentsWith16",
        score: "ElectionScore",
        round: "u32"
    },
    RawSolutionWith24: {
        compact: "CompactAssignmentsWith24",
        score: "ElectionScore",
        round: "u32"
    },
    RawSolutionTo265: "RawSolutionWith16",
    ReadySolution: {
        supports: "SolutionSupports",
        score: "ElectionScore",
        compute: "ElectionCompute"
    },
    RoundSnapshot: {
        voters: "Vec<(AccountId, VoteWeight, Vec<AccountId>)>",
        targets: "Vec<AccountId>"
    },
    SeatHolder: {
        who: "AccountId",
        stake: "Balance",
        deposit: "Balance"
    },
    SignedSubmission: {
        _fallback: "SignedSubmissionTo276",
        who: "AccountId",
        deposit: "Balance",
        solution: "RawSolution",
        reward: "Balance"
    },
    SignedSubmissionTo276: {
        who: "AccountId",
        deposit: "Balance",
        solution: "RawSolution"
    },
    SignedSubmissionOf: "SignedSubmission",
    SolutionOrSnapshotSize: {
        voters: "Compact<u32>",
        targets: "Compact<u32>"
    },
    SolutionSupport: {
        total: "ExtendedBalance",
        voters: "Vec<(AccountId, ExtendedBalance)>"
    },
    SolutionSupports: "Vec<(AccountId, SolutionSupport)>",
    Supports: "SolutionSupports",
    SubmissionIndicesOf: "BTreeMap<ElectionScore, u32>",
    Voter: {
        votes: "Vec<AccountId>",
        stake: "Balance",
        deposit: "Balance"
    },
    VoteWeight: "u64"
};
exports.default = {
    rpc: {},
    types: (0, _util.objectSpread)({}, deprecated, phragmen, {
        ActiveEraInfo: {
            index: "EraIndex",
            start: "Option<Moment>"
        },
        EraIndex: "u32",
        EraRewardPoints: {
            total: "RewardPoint",
            individual: "BTreeMap<AccountId, RewardPoint>"
        },
        EraRewards: {
            total: "u32",
            rewards: "Vec<u32>"
        },
        Exposure: {
            total: "Compact<Balance>",
            own: "Compact<Balance>",
            others: "Vec<IndividualExposure>"
        },
        Forcing: {
            _enum: [
                "NotForcing",
                "ForceNew",
                "ForceNone",
                "ForceAlways"
            ]
        },
        IndividualExposure: {
            who: "AccountId",
            value: "Compact<Balance>"
        },
        KeyType: "AccountId",
        MomentOf: "Moment",
        Nominations: {
            targets: "Vec<AccountId>",
            submittedIn: "EraIndex",
            suppressed: "bool"
        },
        NominatorIndex: "u32",
        NominatorIndexCompact: "Compact<NominatorIndex>",
        OffchainAccuracy: "PerU16",
        OffchainAccuracyCompact: "Compact<OffchainAccuracy>",
        PhragmenScore: "[u128; 3]",
        Points: "u32",
        RewardDestination: {
            _enum: {
                Staked: "Null",
                Stash: "Null",
                Controller: "Null",
                Account: "AccountId",
                None: "Null"
            }
        },
        RewardPoint: "u32",
        SlashJournalEntry: {
            who: "AccountId",
            amount: "Balance",
            ownSlash: "Balance"
        },
        SlashingSpansTo204: {
            spanIndex: "SpanIndex",
            lastStart: "EraIndex",
            prior: "Vec<EraIndex>"
        },
        SlashingSpans: {
            spanIndex: "SpanIndex",
            lastStart: "EraIndex",
            lastNonzeroSlash: "EraIndex",
            prior: "Vec<EraIndex>"
        },
        SpanIndex: "u32",
        SpanRecord: {
            slashed: "Balance",
            paidOut: "Balance"
        },
        StakingLedgerTo223: {
            stash: "AccountId",
            total: "Compact<Balance>",
            active: "Compact<Balance>",
            unlocking: "Vec<UnlockChunk>"
        },
        StakingLedgerTo240: {
            stash: "AccountId",
            total: "Compact<Balance>",
            active: "Compact<Balance>",
            unlocking: "Vec<UnlockChunk>",
            lastReward: "Option<EraIndex>"
        },
        StakingLedger: {
            stash: "AccountId",
            total: "Compact<Balance>",
            active: "Compact<Balance>",
            unlocking: "Vec<UnlockChunk>",
            claimedRewards: "Vec<EraIndex>"
        },
        UnappliedSlashOther: "(AccountId, Balance)",
        UnappliedSlash: {
            validator: "AccountId",
            own: "Balance",
            others: "Vec<UnappliedSlashOther>",
            reporters: "Vec<AccountId>",
            payout: "Balance"
        },
        UnlockChunk: {
            value: "Compact<Balance>",
            era: "Compact<BlockNumber>"
        },
        ValidatorIndex: "u16",
        ValidatorIndexCompact: "Compact<ValidatorIndex>",
        ValidatorPrefs: "ValidatorPrefsWithBlocked",
        ValidatorPrefsWithCommission: {
            commission: "Compact<Perbill>"
        },
        ValidatorPrefsWithBlocked: {
            commission: "Compact<Perbill>",
            blocked: "bool"
        },
        ValidatorPrefsTo196: {
            validatorPayment: "Compact<Balance>"
        },
        ValidatorPrefsTo145: {
            unstakeThreshold: "Compact<u32>",
            validatorPayment: "Compact<Balance>"
        }
    })
};

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lyZLt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        WeightToFeeCoefficient: {
            coeffInteger: "Balance",
            coeffFrac: "Perbill",
            negative: "bool",
            degree: "u8"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"PEQ39":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    types: {}
};

},{"./rpc.js":"cGB7P","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cGB7P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    genSyncSpec: {
        description: "Returns the json-serialized chainspec running the node, with a sync state.",
        endpoint: "sync_state_genSyncSpec",
        params: [
            {
                name: "raw",
                type: "bool"
            }
        ],
        type: "Json"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l4H65":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    runtime: (0, _runtimeJs.runtime),
    types: {
        AccountInfo: "AccountInfoWithTripleRefCount",
        AccountInfoWithRefCountU8: {
            nonce: "Index",
            refcount: "u8",
            data: "AccountData"
        },
        AccountInfoWithRefCount: {
            _fallback: "AccountInfoWithRefCountU8",
            nonce: "Index",
            refcount: "RefCount",
            data: "AccountData"
        },
        AccountInfoWithDualRefCount: {
            _fallback: "AccountInfoWithRefCount",
            nonce: "Index",
            consumers: "RefCount",
            providers: "RefCount",
            data: "AccountData"
        },
        // original naming
        AccountInfoWithProviders: "AccountInfoWithDualRefCount",
        AccountInfoWithTripleRefCount: {
            _fallback: "AccountInfoWithDualRefCount",
            nonce: "Index",
            consumers: "RefCount",
            providers: "RefCount",
            sufficients: "RefCount",
            data: "AccountData"
        },
        ApplyExtrinsicResult: "Result<DispatchOutcome, TransactionValidityError>",
        ApplyExtrinsicResultPre6: "Result<DispatchOutcomePre6, TransactionValidityError>",
        ArithmeticError: {
            _enum: [
                "Underflow",
                "Overflow",
                "DivisionByZero"
            ]
        },
        BlockLength: {
            max: "PerDispatchClassU32"
        },
        BlockWeights: {
            baseBlock: "Weight",
            maxBlock: "Weight",
            perClass: "PerDispatchClassWeightsPerClass"
        },
        ChainProperties: "GenericChainProperties",
        ChainType: {
            _enum: {
                Development: "Null",
                Local: "Null",
                Live: "Null",
                Custom: "Text"
            }
        },
        ConsumedWeight: "PerDispatchClassWeight",
        DigestOf: "Digest",
        DispatchClass: {
            _enum: [
                "Normal",
                "Operational",
                "Mandatory"
            ]
        },
        DispatchError: {
            _enum: {
                Other: "Null",
                CannotLookup: "Null",
                BadOrigin: "Null",
                Module: "DispatchErrorModule",
                ConsumerRemaining: "Null",
                NoProviders: "Null",
                TooManyConsumers: "Null",
                Token: "TokenError",
                Arithmetic: "ArithmeticError",
                Transactional: "TransactionalError"
            }
        },
        DispatchErrorPre6: {
            _enum: {
                Other: "Null",
                CannotLookup: "Null",
                BadOrigin: "Null",
                Module: "DispatchErrorModulePre6",
                ConsumerRemaining: "Null",
                NoProviders: "Null",
                TooManyConsumers: "Null",
                Token: "TokenError",
                Arithmetic: "ArithmeticError",
                Transactional: "TransactionalError"
            }
        },
        DispatchErrorPre6First: {
            // The enum was modified mid-flight, affecting asset chains -
            // https://github.com/paritytech/substrate/pull/10382/files#diff-e4e016b33a82268b6208dc974eea841bad47597865a749fee2f937eb6fdf67b4R498
            _enum: {
                Other: "Null",
                CannotLookup: "Null",
                BadOrigin: "Null",
                Module: "DispatchErrorModulePre6",
                ConsumerRemaining: "Null",
                NoProviders: "Null",
                Token: "TokenError",
                Arithmetic: "ArithmeticError",
                Transactional: "TransactionalError"
            }
        },
        DispatchErrorModuleU8: {
            index: "u8",
            error: "u8"
        },
        DispatchErrorModuleU8a: {
            index: "u8",
            error: "[u8; 4]"
        },
        DispatchErrorModule: "DispatchErrorModuleU8a",
        DispatchErrorModulePre6: "DispatchErrorModuleU8",
        DispatchErrorTo198: {
            module: "Option<u8>",
            error: "u8"
        },
        DispatchInfo: {
            weight: "Weight",
            class: "DispatchClass",
            paysFee: "Pays"
        },
        DispatchInfoTo190: {
            weight: "Weight",
            class: "DispatchClass"
        },
        DispatchInfoTo244: {
            weight: "Weight",
            class: "DispatchClass",
            paysFee: "bool"
        },
        DispatchOutcome: "Result<(), DispatchError>",
        DispatchOutcomePre6: "Result<(), DispatchErrorPre6>",
        DispatchResult: "Result<(), DispatchError>",
        DispatchResultOf: "DispatchResult",
        DispatchResultTo198: "Result<(), Text>",
        Event: "GenericEvent",
        EventId: "[u8; 2]",
        EventIndex: "u32",
        EventRecord: {
            phase: "Phase",
            event: "Event",
            topics: "Vec<Hash>"
        },
        Health: {
            peers: "u64",
            isSyncing: "bool",
            shouldHavePeers: "bool"
        },
        InvalidTransaction: {
            _enum: {
                Call: "Null",
                Payment: "Null",
                Future: "Null",
                Stale: "Null",
                BadProof: "Null",
                AncientBirthBlock: "Null",
                ExhaustsResources: "Null",
                Custom: "u8",
                BadMandatory: "Null",
                MandatoryDispatch: "Null",
                BadSigner: "Null"
            }
        },
        Key: "Bytes",
        LastRuntimeUpgradeInfo: {
            specVersion: "Compact<u32>",
            specName: "Text"
        },
        NetworkState: {
            peerId: "Text",
            listenedAddresses: "Vec<Text>",
            externalAddresses: "Vec<Text>",
            connectedPeers: "HashMap<Text, Peer>",
            notConnectedPeers: "HashMap<Text, NotConnectedPeer>",
            averageDownloadPerSec: "u64",
            averageUploadPerSec: "u64",
            peerset: "NetworkStatePeerset"
        },
        NetworkStatePeerset: {
            messageQueue: "u64",
            nodes: "HashMap<Text, NetworkStatePeersetInfo>"
        },
        NetworkStatePeersetInfo: {
            connected: "bool",
            reputation: "i32"
        },
        NodeRole: {
            _enum: {
                Full: "Null",
                LightClient: "Null",
                Authority: "Null",
                UnknownRole: "u8"
            }
        },
        NotConnectedPeer: {
            knownAddresses: "Vec<Text>",
            latestPingTime: "Option<PeerPing>",
            versionString: "Option<Text>"
        },
        Peer: {
            enabled: "bool",
            endpoint: "PeerEndpoint",
            knownAddresses: "Vec<Text>",
            latestPingTime: "PeerPing",
            open: "bool",
            versionString: "Text"
        },
        PeerEndpoint: {
            listening: "PeerEndpointAddr"
        },
        PeerEndpointAddr: {
            _alias: {
                localAddr: "local_addr",
                sendBackAddr: "send_back_addr"
            },
            localAddr: "Text",
            sendBackAddr: "Text"
        },
        PeerPing: {
            nanos: "u64",
            secs: "u64"
        },
        PeerInfo: {
            peerId: "Text",
            roles: "Text",
            protocolVersion: "u32",
            bestHash: "Hash",
            bestNumber: "BlockNumber"
        },
        PerDispatchClassU32: {
            normal: "u32",
            operational: "u32",
            mandatory: "u32"
        },
        PerDispatchClassWeight: {
            normal: "Weight",
            operational: "Weight",
            mandatory: "Weight"
        },
        PerDispatchClassWeightsPerClass: {
            normal: "WeightPerClass",
            operational: "WeightPerClass",
            mandatory: "WeightPerClass"
        },
        Phase: {
            _enum: {
                ApplyExtrinsic: "u32",
                Finalization: "Null",
                Initialization: "Null"
            }
        },
        RawOrigin: {
            _enum: {
                Root: "Null",
                Signed: "AccountId",
                None: "Null"
            }
        },
        RefCount: "u32",
        RefCountTo259: "u8",
        SyncState: {
            startingBlock: "BlockNumber",
            currentBlock: "BlockNumber",
            highestBlock: "Option<BlockNumber>"
        },
        SystemOrigin: "RawOrigin",
        TokenError: {
            _enum: [
                "NoFunds",
                "WouldDie",
                "BelowMinimum",
                "CannotCreate",
                "UnknownAsset",
                "Frozen",
                "Unsupported",
                // (if this adjusts, will need to take a re-look)
                "Underflow",
                "Overflow"
            ]
        },
        TransactionValidityError: {
            _enum: {
                Invalid: "InvalidTransaction",
                Unknown: "UnknownTransaction"
            }
        },
        TransactionalError: {
            _enum: [
                "LimitReached",
                "NoLayer"
            ]
        },
        UnknownTransaction: {
            _enum: {
                CannotLookup: "Null",
                NoUnsignedValidator: "Null",
                Custom: "u8"
            }
        },
        WeightPerClass: {
            baseExtrinsic: "Weight",
            maxExtrinsic: "Option<Weight>",
            maxTotal: "Option<Weight>",
            reserved: "Option<Weight>"
        }
    }
};

},{"./rpc.js":"gyb28","./runtime.js":"1FVI1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gyb28":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    accountNextIndex: {
        alias: [
            "account_nextIndex"
        ],
        description: "Retrieves the next accountIndex as available on the node",
        params: [
            {
                name: "accountId",
                type: "AccountId"
            }
        ],
        type: "Index"
    },
    addLogFilter: {
        description: "Adds the supplied directives to the current log filter",
        params: [
            {
                name: "directives",
                type: "Text"
            }
        ],
        type: "Null"
    },
    addReservedPeer: {
        description: "Adds a reserved peer",
        params: [
            {
                name: "peer",
                type: "Text"
            }
        ],
        type: "Text"
    },
    chain: {
        description: "Retrieves the chain",
        params: [],
        type: "Text"
    },
    chainType: {
        description: "Retrieves the chain type",
        params: [],
        type: "ChainType"
    },
    dryRun: {
        alias: [
            "system_dryRunAt"
        ],
        description: "Dry run an extrinsic at a given block",
        params: [
            {
                name: "extrinsic",
                type: "Bytes"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "ApplyExtrinsicResult"
    },
    health: {
        description: "Return health status of the node",
        noErrorLog: true,
        params: [],
        type: "Health"
    },
    localListenAddresses: {
        description: "The addresses include a trailing /p2p/ with the local PeerId, and are thus suitable to be passed to addReservedPeer or as a bootnode address for example",
        params: [],
        type: "Vec<Text>"
    },
    localPeerId: {
        description: "Returns the base58-encoded PeerId of the node",
        params: [],
        type: "Text"
    },
    name: {
        description: "Retrieves the node name",
        params: [],
        type: "Text"
    },
    networkState: {
        alias: [
            "system_unstable_networkState"
        ],
        description: "Returns current state of the network",
        params: [],
        type: "NetworkState"
    },
    nodeRoles: {
        description: "Returns the roles the node is running as",
        params: [],
        type: "Vec<NodeRole>"
    },
    peers: {
        description: "Returns the currently connected peers",
        params: [],
        type: "Vec<PeerInfo>"
    },
    properties: {
        description: "Get a custom set of properties as a JSON object, defined in the chain spec",
        params: [],
        type: "ChainProperties"
    },
    removeReservedPeer: {
        description: "Remove a reserved peer",
        params: [
            {
                name: "peerId",
                type: "Text"
            }
        ],
        type: "Text"
    },
    reservedPeers: {
        description: "Returns the list of reserved peers",
        params: [],
        type: "Vec<Text>"
    },
    resetLogFilter: {
        description: "Resets the log filter to Substrate defaults",
        params: [],
        type: "Null"
    },
    syncState: {
        description: "Returns the state of the syncing of the node",
        params: [],
        type: "SyncState"
    },
    version: {
        description: "Retrieves the version of the node",
        params: [],
        type: "Text"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1FVI1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    AccountNonceApi: [
        {
            methods: {
                account_nonce: {
                    description: "The API to query account nonce (aka transaction index)",
                    params: [
                        {
                            name: "accountId",
                            type: "AccountId"
                        }
                    ],
                    type: "Index"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3e69H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        Bounty: {
            proposer: "AccountId",
            value: "Balance",
            fee: "Balance",
            curatorDeposit: "Balance",
            bond: "Balance",
            status: "BountyStatus"
        },
        BountyIndex: "u32",
        BountyStatus: {
            _enum: {
                Proposed: "Null",
                Approved: "Null",
                Funded: "Null",
                CuratorProposed: "BountyStatusCuratorProposed",
                Active: "BountyStatusActive",
                PendingPayout: "BountyStatusPendingPayout"
            }
        },
        BountyStatusActive: {
            curator: "AccountId",
            updateDue: "BlockNumber"
        },
        BountyStatusCuratorProposed: {
            curator: "AccountId"
        },
        BountyStatusPendingPayout: {
            curator: "AccountId",
            beneficiary: "AccountId",
            unlockAt: "BlockNumber"
        },
        OpenTip: {
            reason: "Hash",
            who: "AccountId",
            finder: "AccountId",
            deposit: "Balance",
            closes: "Option<BlockNumber>",
            tips: "Vec<OpenTipTip>",
            findersFee: "bool"
        },
        OpenTipTo225: {
            reason: "Hash",
            who: "AccountId",
            finder: "Option<OpenTipFinderTo225>",
            closes: "Option<BlockNumber>",
            tips: "Vec<OpenTipTip>"
        },
        OpenTipFinderTo225: "(AccountId, Balance)",
        OpenTipTip: "(AccountId, Balance)",
        TreasuryProposal: {
            proposer: "AccountId",
            value: "Balance",
            beneficiary: "AccountId",
            bond: "Balance"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iNbEd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
exports.default = {
    rpc: {},
    types: {
        Multiplier: "Fixed128"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCot4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {
        TransactionSource: {
            _enum: [
                "InBlock",
                "Local",
                "External"
            ]
        },
        TransactionValidity: "Result<ValidTransaction, TransactionValidityError>",
        ValidTransaction: {
            priority: "TransactionPriority",
            requires: "Vec<TransactionTag>",
            provides: "Vec<TransactionTag>",
            longevity: "TransactionLongevity",
            propagate: "bool"
        }
    }
};

},{"./runtime.js":"jgWWl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jgWWl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    TaggedTransactionQueue: [
        {
            methods: {
                validate_transaction: {
                    description: "Validate the transaction.",
                    params: [
                        {
                            name: "source",
                            type: "TransactionSource"
                        },
                        {
                            name: "tx",
                            type: "Extrinsic"
                        },
                        {
                            name: "blockHash",
                            type: "BlockHash"
                        }
                    ],
                    type: "TransactionValidity"
                }
            },
            version: 3
        },
        {
            methods: {
                validate_transaction: {
                    description: "Validate the transaction.",
                    params: [
                        {
                            name: "source",
                            type: "TransactionSource"
                        },
                        {
                            name: "tx",
                            type: "Extrinsic"
                        }
                    ],
                    type: "TransactionValidity"
                }
            },
            version: 2
        },
        {
            methods: {
                validate_transaction: {
                    description: "Validate the transaction.",
                    params: [
                        {
                            name: "tx",
                            type: "Extrinsic"
                        }
                    ],
                    type: "TransactionValidity"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lOumW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        ClassId: "u32",
        InstanceId: "u32",
        DepositBalance: "Balance",
        DepositBalanceOf: "Balance",
        ClassDetails: {
            owner: "AccountId",
            issuer: "AccountId",
            admin: "AccountId",
            freezer: "AccountId",
            totalDeposit: "DepositBalance",
            freeHolding: "bool",
            instances: "u32",
            instanceMetadatas: "u32",
            attributes: "u32",
            isFrozen: "bool"
        },
        DestroyWitness: {
            instances: "Compact<u32>",
            instanceMetadatas: "Compact<u32>",
            attributes: "Compact<u32>"
        },
        InstanceDetails: {
            owner: "AccountId",
            approved: "Option<AccountId>",
            isFrozen: "bool",
            deposit: "DepositBalance"
        },
        ClassMetadata: {
            deposit: "DepositBalance",
            data: "Vec<u8>",
            isFrozen: "bool"
        },
        InstanceMetadata: {
            deposit: "DepositBalance",
            data: "Vec<u8>",
            isFrozen: "bool"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"buWug":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        Multisig: {
            when: "Timepoint",
            deposit: "Balance",
            depositor: "AccountId",
            approvals: "Vec<AccountId>"
        },
        Timepoint: {
            height: "BlockNumber",
            index: "u32"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ioJDd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        VestingInfo: {
            locked: "Balance",
            perBlock: "Balance",
            startingBlock: "BlockNumber"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bzheC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        BlockAttestations: {
            receipt: "CandidateReceipt",
            valid: "Vec<AccountId>",
            invalid: "Vec<AccountId>"
        },
        IncludedBlocks: {
            actualNumber: "BlockNumber",
            session: "SessionIndex",
            randomSeed: "H256",
            activeParachains: "Vec<ParaId>",
            paraBlocks: "Vec<Hash>"
        },
        MoreAttestations: {}
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hWXsW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        BridgedBlockHash: "H256",
        BridgedBlockNumber: "BlockNumber",
        BridgedHeader: "Header",
        BridgeMessageId: "(LaneId, MessageNonce)",
        CallOrigin: {
            _enum: {
                SourceRoot: "Null",
                TargetAccount: "(AccountId, MultiSigner, MultiSignature)",
                SourceAccount: "AccountId"
            }
        },
        ChainId: "[u8; 4]",
        DeliveredMessages: {
            begin: "MessageNonce",
            end: "MessageNonce",
            // pub type DispatchResultsBitVec = BitVec<Msb0, u8>;
            dispatchResults: "BitVec"
        },
        DispatchFeePayment: {
            _enum: [
                "AtSourceChain",
                "AtTargetChain"
            ]
        },
        InboundLaneData: {
            relayers: "Vec<UnrewardedRelayer>",
            lastConfirmedNonce: "MessageNonce"
        },
        InboundRelayer: "AccountId",
        InitializationData: {
            header: "Header",
            authorityList: "AuthorityList",
            setId: "SetId",
            isHalted: "bool"
        },
        LaneId: "[u8; 4]",
        MessageData: {
            payload: "Bytes",
            fee: "Balance"
        },
        MessagesDeliveryProofOf: {
            bridgedHeaderHash: "BlockHash",
            storageProof: "Vec<Bytes>",
            lane: "LaneId"
        },
        MessageKey: {
            laneId: "LaneId",
            nonce: "MessageNonce"
        },
        MessageNonce: "u64",
        MessagesProofOf: {
            bridgedHeaderHash: "BridgedBlockHash",
            storageProof: "Vec<Bytes>",
            lane: "LaneId",
            noncesStart: "MessageNonce",
            noncesEnd: "MessageNonce"
        },
        OperatingMode: {
            _enum: [
                "Normal",
                "RejectingOutboundMessages",
                "Halted"
            ]
        },
        OutboundLaneData: {
            oldestUnprunedNonce: "MessageNonce",
            latestReceivedNonce: "MessageNonce",
            latestGeneratedNonce: "MessageNonce"
        },
        OutboundMessageFee: "Balance",
        OutboundPayload: {
            specVersion: "u32",
            weight: "Weight",
            origin: "CallOrigin",
            dispatchFeePayment: "DispatchFeePayment",
            call: "Bytes"
        },
        Parameter: "Null",
        RelayerId: "AccountId",
        UnrewardedRelayer: {
            relayer: "RelayerId",
            messages: "DeliveredMessages"
        },
        UnrewardedRelayersState: {
            unrewardedRelayer_Entries: "MessageNonce",
            messagesInOldestEntry: "MessageNonce",
            totalMessages: "MessageNonce"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iGvqz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        StatementKind: {
            _enum: [
                "Regular",
                "Saft"
            ]
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aDOdR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        FundIndex: "u32",
        LastContribution: {
            _enum: {
                Never: "Null",
                PreEnding: "u32",
                Ending: "BlockNumber"
            }
        },
        FundInfo: {
            depositor: "AccountId",
            verifier: "Option<MultiSigner>",
            deposit: "Balance",
            raised: "Balance",
            end: "BlockNumber",
            cap: "Balance",
            lastContribution: "LastContribution",
            firstPeriod: "LeasePeriod",
            lastPeriod: "LeasePeriod",
            trieIndex: "TrieIndex"
        },
        TrieIndex: "u32"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jSZGb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
const dmpQueue = {
    CollationInfo: {
        upwardMessages: "Vec<UpwardMessage>",
        horizontalMessages: "Vec<OutboundHrmpMessage>",
        newValidationCode: "Option<ValidationCode>",
        processedDownwardMessages: "u32",
        hrmpWatermark: "RelayBlockNumber",
        headData: "HeadData"
    },
    CollationInfoV1: {
        upwardMessages: "Vec<UpwardMessage>",
        horizontalMessages: "Vec<OutboundHrmpMessage>",
        newValidationCode: "Option<ValidationCode>",
        processedDownwardMessages: "u32",
        hrmpWatermark: "RelayBlockNumber"
    },
    ConfigData: {
        maxIndividual: "Weight"
    },
    MessageId: "[u8; 32]",
    OverweightIndex: "u64",
    PageCounter: "u32",
    PageIndexData: {
        beginUsed: "PageCounter",
        endUsed: "PageCounter",
        overweightCount: "OverweightIndex"
    }
};
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: dmpQueue
};

},{"./runtime.js":"bTYzM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bTYzM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    CollectCollationInfo: [
        {
            methods: {
                collect_collation_info: {
                    description: "Collect information about a collation.",
                    params: [
                        {
                            name: "header",
                            type: "Header"
                        }
                    ],
                    type: "CollationInfo"
                }
            },
            version: 2
        },
        {
            methods: {
                collect_collation_info: {
                    description: "Collect information about a collation.",
                    params: [],
                    type: "CollationInfoV1"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"41cWe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {}
};

},{"./runtime.js":"fuz2t","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fuz2t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// implemented by chains bridging into the relay, not the relay itself
const finalityV1 = {
    methods: {
        best_finalized: {
            description: "Returns number and hash of the best finalized header known to the bridge module.",
            params: [],
            type: "(BlockNumber, Hash)"
        }
    },
    version: 1
};
const runtime = {
    KusamaFinalityApi: [
        finalityV1
    ],
    PolkadotFinalityApi: [
        finalityV1
    ],
    RococoFinalityApi: [
        finalityV1
    ],
    WestendFinalityApi: [
        finalityV1
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"htNih":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _util = require("@polkadot/util");
var _hrmpJs = require("./hrmp.js");
var _hrmpJsDefault = parcelHelpers.interopDefault(_hrmpJs);
var _runtimeJs = require("./runtime.js");
var _slotsJs = require("./slots.js"); // proposeParachain
var _slotsJsDefault = parcelHelpers.interopDefault(_slotsJs);
const proposeTypes = {
    ParachainProposal: {
        proposer: "AccountId",
        genesisHead: "HeadData",
        validators: "Vec<ValidatorId>",
        name: "Bytes",
        balance: "Balance"
    },
    RegisteredParachainInfo: {
        validators: "Vec<ValidatorId>",
        proposer: "AccountId"
    }
};
const cumulusTypes = {
    ServiceQuality: {
        _enum: [
            "Ordered",
            "Fast"
        ]
    }
};
const disputeTypes = {
    DisputeLocation: {
        _enum: [
            "Local",
            "Remote"
        ]
    },
    DisputeResult: {
        _enum: [
            "Valid",
            "Invalid"
        ]
    },
    DisputeState: {
        validatorsFor: "BitVec",
        validatorsAgainst: "BitVec",
        start: "BlockNumber",
        concludedAt: "Option<BlockNumber>"
    },
    DisputeStatement: {
        _enum: {
            Valid: "ValidDisputeStatementKind",
            Invalid: "InvalidDisputeStatementKind"
        }
    },
    DisputeStatementSet: {
        candidateHash: "CandidateHash",
        session: "SessionIndex",
        statements: "Vec<(DisputeStatement, ParaValidatorIndex, ValidatorSignature)>"
    },
    ExplicitDisputeStatement: {
        valid: "bool",
        candidateHash: "CandidateHash",
        session: "SessionIndex"
    },
    InvalidDisputeStatementKind: {
        _enum: [
            "Explicit"
        ]
    },
    MultiDisputeStatementSet: "Vec<DisputeStatementSet>",
    ValidDisputeStatementKind: {
        _enum: {
            Explicit: "Null",
            BackingSeconded: "Hash",
            BackingValid: "Hash",
            ApprovalChecking: "Null"
        }
    }
};
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: (0, _util.objectSpread)({}, cumulusTypes, disputeTypes, (0, _hrmpJsDefault.default), proposeTypes, (0, _slotsJsDefault.default), {
        AbridgedCandidateReceipt: {
            parachainIndex: "ParaId",
            relayParent: "Hash",
            headData: "HeadData",
            collator: "CollatorId",
            signature: "CollatorSignature",
            povBlockHash: "Hash",
            commitments: "CandidateCommitments"
        },
        AbridgedHostConfiguration: {
            maxCodeSize: "u32",
            maxHeadDataSize: "u32",
            maxUpwardQueueCount: "u32",
            maxUpwardQueueSize: "u32",
            maxUpwardMessageSize: "u32",
            maxUpwardMessageNumPerCandidate: "u32",
            hrmpMaxMessageNumPerCandidate: "u32",
            validationUpgradeFrequency: "BlockNumber",
            validationUpgradeDelay: "BlockNumber"
        },
        AbridgedHrmpChannel: {
            maxCapacity: "u32",
            maxTotalSize: "u32",
            maxMessageSize: "u32",
            msgCount: "u32",
            totalSize: "u32",
            mqcHead: "Option<Hash>"
        },
        AssignmentId: "AccountId",
        AssignmentKind: {
            _enum: {
                Parachain: "Null",
                Parathread: "(CollatorId, u32)"
            }
        },
        AttestedCandidate: {
            candidate: "AbridgedCandidateReceipt",
            validityVotes: "Vec<ValidityAttestation>",
            validatorIndices: "BitVec"
        },
        AuthorityDiscoveryId: "AccountId",
        AvailabilityBitfield: "BitVec",
        AvailabilityBitfieldRecord: {
            bitfield: "AvailabilityBitfield",
            submittedTt: "BlockNumber"
        },
        BackedCandidate: {
            candidate: "CommittedCandidateReceipt",
            validityVotes: "Vec<ValidityAttestation>",
            validatorIndices: "BitVec"
        },
        BufferedSessionChange: {
            applyAt: "BlockNumber",
            validators: "Vec<ValidatorId>",
            queued: "Vec<ValidatorId>",
            sessionIndex: "SessionIndex"
        },
        CandidateCommitments: {
            upwardMessages: "Vec<UpwardMessage>",
            horizontalMessages: "Vec<OutboundHrmpMessage>",
            newValidationCode: "Option<ValidationCode>",
            headData: "HeadData",
            processedDownwardMessages: "u32",
            hrmpWatermark: "BlockNumber"
        },
        CandidateDescriptor: {
            paraId: "ParaId",
            relayParent: "RelayChainHash",
            collatorId: "CollatorId",
            persistedValidationDataHash: "Hash",
            povHash: "Hash",
            erasureRoot: "Hash",
            signature: "CollatorSignature",
            paraHead: "Hash",
            validationCodeHash: "ValidationCodeHash"
        },
        CandidateEvent: {
            _enum: {
                CandidateBacked: "(CandidateReceipt, HeadData, CoreIndex, GroupIndex)",
                CandidateIncluded: "(CandidateReceipt, HeadData, CoreIndex, GroupIndex)",
                CandidateTimedOut: "(CandidateReceipt, HeadData, CoreIndex)"
            }
        },
        CandidateHash: "Hash",
        CandidateInfo: {
            who: "AccountId",
            deposit: "Balance"
        },
        CandidatePendingAvailability: {
            core: "CoreIndex",
            hash: "CandidateHash",
            descriptor: "CandidateDescriptor",
            availabilityVotes: "BitVec",
            backers: "BitVec",
            relayParentNumber: "BlockNumber",
            backedInNumber: "BlockNumber",
            backingGroup: "GroupIndex"
        },
        CandidateReceipt: {
            descriptor: "CandidateDescriptor",
            commitmentsHash: "Hash"
        },
        GlobalValidationData: {
            maxCodeSize: "u32",
            maxHeadDataSize: "u32",
            blockNumber: "BlockNumber"
        },
        CollatorId: "H256",
        CollatorSignature: "Signature",
        CommittedCandidateReceipt: {
            descriptor: "CandidateDescriptor",
            commitments: "CandidateCommitments"
        },
        CoreAssignment: {
            core: "CoreIndex",
            paraId: "ParaId",
            kind: "AssignmentKind",
            groupIdx: "GroupIndex"
        },
        CoreIndex: "u32",
        CoreOccupied: {
            _enum: {
                Parathread: "ParathreadEntry",
                Parachain: "Null"
            }
        },
        CoreState: {
            _enum: {
                Occupied: "OccupiedCore",
                Scheduled: "ScheduledCore",
                Free: "Null"
            }
        },
        DoubleVoteReport: {
            identity: "ValidatorId",
            first: "(Statement, ValidatorSignature)",
            second: "(Statement, ValidatorSignature)",
            proof: "MembershipProof",
            signingContext: "SigningContext"
        },
        DownwardMessage: "Bytes",
        GroupIndex: "u32",
        GroupRotationInfo: {
            sessionStartBlock: "BlockNumber",
            groupRotationFrequency: "BlockNumber",
            now: "BlockNumber"
        },
        GlobalValidationSchedule: {
            maxCodeSize: "u32",
            maxHeadDataSize: "u32",
            blockNumber: "BlockNumber"
        },
        HeadData: "Bytes",
        HostConfiguration: {
            maxCodeSize: "u32",
            maxHeadDataSize: "u32",
            maxUpwardQueueCount: "u32",
            maxUpwardQueueSize: "u32",
            maxUpwardMessageSize: "u32",
            maxUpwardMessageNumPerCandidate: "u32",
            hrmpMaxMessageNumPerCandidate: "u32",
            validationUpgradeFrequency: "BlockNumber",
            validationUpgradeDelay: "BlockNumber",
            maxPovSize: "u32",
            maxDownwardMessageSize: "u32",
            preferredDispatchableUpwardMessagesStepWeight: "Weight",
            hrmpMaxParachainOutboundChannels: "u32",
            hrmpMaxParathreadOutboundChannels: "u32",
            hrmpOpenRequestTtl: "u32",
            hrmpSenderDeposit: "Balance",
            hrmpRecipientDeposit: "Balance",
            hrmpChannelMaxCapacity: "u32",
            hrmpChannelMaxTotalSize: "u32",
            hrmpMaxParachainInboundChannels: "u32",
            hrmpMaxParathreadInboundChannels: "u32",
            hrmpChannelMaxMessageSize: "u32",
            codeRetentionPeriod: "BlockNumber",
            parathreadCores: "u32",
            parathreadRetries: "u32",
            groupRotationFrequency: "BlockNumber",
            chainAvailabilityPeriod: "BlockNumber",
            threadAvailabilityPeriod: "BlockNumber",
            schedulingLookahead: "u32",
            maxValidatorsPerCore: "Option<u32>",
            maxValidators: "Option<u32>",
            disputePeriod: "SessionIndex",
            disputePostConclusionAcceptancePeriod: "BlockNumber",
            disputeMaxSpamSlots: "u32",
            disputeConclusionByTimeOutPeriod: "BlockNumber",
            noShowSlots: "u32",
            nDelayTranches: "u32",
            zerothDelayTrancheWidth: "u32",
            neededApprovals: "u32",
            relayVrfModuloSamples: "u32"
        },
        InboundDownwardMessage: {
            pubSentAt: "BlockNumber",
            pubMsg: "DownwardMessage"
        },
        InboundHrmpMessage: {
            sentAt: "BlockNumber",
            data: "Bytes"
        },
        InboundHrmpMessages: "Vec<InboundHrmpMessage>",
        LocalValidationData: {
            parentHead: "HeadData",
            balance: "Balance",
            codeUpgradeAllowed: "Option<BlockNumber>"
        },
        MessageIngestionType: {
            downwardMessages: "Vec<InboundDownwardMessage>",
            horizontalMessages: "BTreeMap<ParaId, InboundHrmpMessages>"
        },
        MessageQueueChain: "RelayChainHash",
        OccupiedCore: {
            nextUpOnAvailable: "Option<ScheduledCore>",
            occupiedSince: "BlockNumber",
            timeOutAt: "BlockNumber",
            nextUpOnTimeOut: "Option<ScheduledCore>",
            availability: "BitVec",
            groupResponsible: "GroupIndex",
            candidateHash: "CandidateHash",
            candidateDescriptor: "CandidateDescriptor"
        },
        OccupiedCoreAssumption: {
            _enum: [
                "Included,",
                "TimedOut",
                "Free"
            ]
        },
        OutboundHrmpMessage: {
            recipient: "u32",
            data: "Bytes"
        },
        ParachainDispatchOrigin: {
            _enum: [
                "Signed",
                "Parachain",
                "Root"
            ]
        },
        ParachainInherentData: {
            validationData: "PersistedValidationData",
            relayChainState: "StorageProof",
            downwardMessages: "Vec<InboundDownwardMessage>",
            horizontalMessages: "BTreeMap<ParaId, VecInboundHrmpMessage>"
        },
        ParachainsInherentData: {
            bitfields: "SignedAvailabilityBitfields",
            backedCandidates: "Vec<BackedCandidate>",
            disputes: "MultiDisputeStatementSet",
            parentHeader: "Header"
        },
        ParaGenesisArgs: {
            genesisHead: "Bytes",
            validationCode: "Bytes",
            parachain: "bool"
        },
        ParaId: "u32",
        ParaInfo: {
            manager: "AccountId",
            deposit: "Balance",
            locked: "bool"
        },
        ParaLifecycle: {
            _enum: [
                "Onboarding",
                "Parathread",
                "Parachain",
                "UpgradingToParachain",
                "DowngradingToParathread",
                "OutgoingParathread",
                "OutgoingParachain"
            ]
        },
        ParaPastCodeMeta: {
            upgradeTimes: "Vec<ReplacementTimes>",
            lastPruned: "Option<BlockNumber>"
        },
        ParaScheduling: {
            _enum: [
                "Always",
                "Dynamic"
            ]
        },
        ParathreadClaim: "(ParaId, CollatorId)",
        ParathreadClaimQueue: {
            queue: "Vec<QueuedParathread>",
            nextCoreOffset: "u32"
        },
        ParathreadEntry: {
            claim: "ParathreadClaim",
            retries: "u32"
        },
        ParaValidatorIndex: "u32",
        PersistedValidationData: {
            parentHead: "HeadData",
            relayParentNumber: "RelayChainBlockNumber",
            relayParentStorageRoot: "Hash",
            maxPovSize: "u32"
        },
        PvfCheckStatement: {
            accept: "bool",
            subject: "ValidationCodeHash",
            sessionIndex: "SessionIndex",
            validatorIndex: "ParaValidatorIndex"
        },
        QueuedParathread: {
            claim: "ParathreadEntry",
            coreOffset: "u32"
        },
        RelayBlockNumber: "u32",
        RelayChainBlockNumber: "RelayBlockNumber",
        RelayHash: "Hash",
        RelayChainHash: "RelayHash",
        Remark: "[u8; 32]",
        ReplacementTimes: {
            expectedAt: "BlockNumber",
            activatedAt: "BlockNumber"
        },
        Retriable: {
            _enum: {
                Never: "Null",
                WithRetries: "u32"
            }
        },
        ScheduledCore: {
            paraId: "ParaId",
            collator: "Option<CollatorId>"
        },
        Scheduling: {
            _enum: [
                "Always",
                "Dynamic"
            ]
        },
        ScrapedOnChainVotes: {
            session: "SessionIndex",
            backingValidatorsPerCandidate: "Vec<(CandidateReceipt, Vec<(ParaValidatorIndex, ValidityAttestation)>)>",
            disputes: "MultiDisputeStatementSet"
        },
        SessionInfo: {
            activeValidatorIndices: "Vec<ParaValidatorIndex>",
            randomSeed: "[u8; 32]",
            disputePeriod: "SessionIndex",
            validators: "Vec<ValidatorId>",
            discoveryKeys: "Vec<AuthorityDiscoveryId>",
            assignmentKeys: "Vec<AssignmentId>",
            validatorGroups: "Vec<Vec<ValidatorIndex>>",
            nCores: "u32",
            zerothDelayTrancheWidth: "u32",
            relayVrfModuloSamples: "u32",
            nDelayTranches: "u32",
            noShowSlots: "u32",
            neededApprovals: "u32"
        },
        OldV1SessionInfo: {
            validators: "Vec<ValidatorId>",
            discoveryKeys: "Vec<AuthorityDiscoveryId>",
            assignmentKeys: "Vec<AssignmentId>",
            validatorGroups: "Vec<Vec<ParaValidatorIndex>>",
            nCores: "u32",
            zerothDelayTrancheWidth: "u32",
            relayVrfModuloSamples: "u32",
            nDelayTranches: "u32",
            noShowSlots: "u32",
            neededApprovals: "u32"
        },
        SessionInfoValidatorGroup: "Vec<ParaValidatorIndex>",
        SignedAvailabilityBitfield: {
            payload: "BitVec",
            validatorIndex: "ParaValidatorIndex",
            signature: "ValidatorSignature"
        },
        SignedAvailabilityBitfields: "Vec<SignedAvailabilityBitfield>",
        SigningContext: {
            sessionIndex: "SessionIndex",
            parentHash: "Hash"
        },
        Statement: {
            _enum: {
                Never: "Null",
                // starts at 1
                Candidate: "Hash",
                Valid: "Hash",
                Invalid: "Hash"
            }
        },
        TransientValidationData: {
            maxCodeSize: "u32",
            maxHeadDataSize: "u32",
            balance: "Balance",
            codeUpgradeAllowed: "Option<BlockNumber>",
            dmqLength: "u32"
        },
        UpgradeGoAhead: {
            _enum: [
                "Abort",
                "GoAhead"
            ]
        },
        UpgradeRestriction: {
            _enum: [
                "Present"
            ]
        },
        UpwardMessage: "Bytes",
        ValidationFunctionParams: {
            maxCodeSize: "u32",
            relayChainHeight: "RelayChainBlockNumber",
            codeUpgradeAllowed: "Option<RelayChainBlockNumber>"
        },
        ValidationCode: "Bytes",
        ValidationCodeHash: "Hash",
        ValidationData: {
            persisted: "PersistedValidationData",
            transient: "TransientValidationData"
        },
        ValidationDataType: {
            validationData: "ValidationData",
            relayChainState: "Vec<Bytes>"
        },
        ValidatorSignature: "Signature",
        ValidityAttestation: {
            _enum: {
                Never: "Null",
                // starts at 1
                Implicit: "ValidatorSignature",
                Explicit: "ValidatorSignature"
            }
        },
        MessagingStateSnapshot: {
            relayDispatchQueueSize: "(u32, u32)",
            egressChannels: "Vec<MessagingStateSnapshotEgressEntry>"
        },
        MessagingStateSnapshotEgressEntry: "(ParaId, AbridgedHrmpChannel)",
        SystemInherentData: "ParachainInherentData",
        VecInboundHrmpMessage: "Vec<InboundHrmpMessage>"
    })
};

},{"@polkadot/util":"3HnHw","./hrmp.js":"jE64Y","./runtime.js":"f1A0S","./slots.js":"9EiiW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jE64Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    HrmpChannel: {
        maxCapacity: "u32",
        maxTotalSize: "u32",
        maxMessageSize: "u32",
        msgCount: "u32",
        totalSize: "u32",
        mqcHead: "Option<Hash>",
        senderDeposit: "Balance",
        recipientDeposit: "Balance"
    },
    HrmpChannelId: {
        sender: "u32",
        receiver: "u32"
    },
    HrmpOpenChannelRequest: {
        confirmed: "bool",
        age: "SessionIndex",
        senderDeposit: "Balance",
        maxMessageSize: "u32",
        maxCapacity: "u32",
        maxTotalSize: "u32"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f1A0S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const PH_V1_TO_V2 = {
    assumed_validation_data: {
        description: "Returns the persisted validation data for the given `ParaId` along with the corresponding validation code hash.",
        params: [
            {
                name: "paraId",
                type: "ParaId"
            },
            {
                name: "hash",
                type: "Hash"
            }
        ],
        type: "Option<(PersistedValidationData, ValidationCodeHash)>"
    },
    availability_cores: {
        description: "Yields information on all availability cores as relevant to the child block.",
        params: [],
        type: "Vec<CoreState>"
    },
    candidate_events: {
        description: "Get a vector of events concerning candidates that occurred within a block.",
        params: [],
        type: "Vec<CandidateEvent>"
    },
    candidate_pending_availability: {
        description: "Get the receipt of a candidate pending availability.",
        params: [
            {
                name: "paraId",
                type: "ParaId"
            }
        ],
        type: "Option<CommittedCandidateReceipt>"
    },
    check_validation_outputs: {
        description: "Checks if the given validation outputs pass the acceptance criteria.",
        params: [
            {
                name: "paraId",
                type: "ParaId"
            },
            {
                name: "outputs",
                type: "CandidateCommitments"
            }
        ],
        type: "bool"
    },
    dmq_contents: {
        description: "Get all the pending inbound messages in the downward message queue for a para.",
        params: [
            {
                name: "paraId",
                type: "ParaId"
            }
        ],
        type: "Vec<InboundDownwardMessage>"
    },
    inbound_hrmp_channels_contents: {
        description: "Get the contents of all channels addressed to the given recipient.",
        params: [
            {
                name: "paraId",
                type: "ParaId"
            }
        ],
        type: "Vec<InboundHrmpMessage>"
    },
    on_chain_votes: {
        description: "Scrape dispute relevant from on-chain, backing votes and resolved disputes.",
        params: [],
        type: "Option<ScrapedOnChainVotes>"
    },
    persisted_validation_data: {
        description: "Yields the persisted validation data for the given `ParaId` along with an assumption that should be used if the para currently occupies a core.",
        params: [
            {
                name: "paraId",
                type: "ParaId"
            },
            {
                name: "assumption",
                type: "OccupiedCoreAssumption"
            }
        ],
        type: "Option<PersistedValidationData>"
    },
    session_index_for_child: {
        description: "Returns the session index expected at a child of the block.",
        params: [],
        type: "SessionIndex"
    },
    validation_code: {
        description: "Fetch the validation code used by a para, making the given `OccupiedCoreAssumption`.",
        params: [
            {
                name: "paraId",
                type: "ParaId"
            },
            {
                name: "assumption",
                type: "OccupiedCoreAssumption"
            }
        ],
        type: "ValidationCode"
    },
    validation_code_by_hash: {
        description: "Get the validation code from its hash.",
        params: [
            {
                name: "hash",
                type: "ValidationCodeHash"
            }
        ],
        type: "Option<ValidationCode>"
    },
    validator_groups: {
        description: "Returns the validator groups and rotation info localized based on the hypothetical child of a block whose state  this is invoked on",
        params: [],
        type: "(Vec<Vec<ParaValidatorIndex>>, GroupRotationInfo)"
    },
    validators: {
        description: "Get the current validators.",
        params: [],
        type: "Vec<ValidatorId>"
    }
};
const runtime = {
    ParachainHost: [
        {
            methods: (0, _util.objectSpread)({
                pvfs_require_precheck: {
                    description: "Returns code hashes of PVFs that require pre-checking by validators in the active set.",
                    params: [],
                    type: "Vec<ValidationCodeHash>"
                },
                session_info: {
                    description: "Get the session info for the given session, if stored.",
                    params: [
                        {
                            name: "index",
                            type: "SessionIndex"
                        }
                    ],
                    type: "Option<SessionInfo>"
                },
                submit_pvf_check_statement: {
                    description: "Submits a PVF pre-checking statement into the transaction pool.",
                    params: [
                        {
                            name: "stmt",
                            type: "PvfCheckStatement"
                        },
                        {
                            name: "signature",
                            type: "ValidatorSignature"
                        }
                    ],
                    type: "Null"
                },
                validation_code_hash: {
                    description: "Fetch the hash of the validation code used by a para, making the given `OccupiedCoreAssumption`.",
                    params: [
                        {
                            name: "paraId",
                            type: "ParaId"
                        },
                        {
                            name: "assumption",
                            type: "OccupiedCoreAssumption"
                        }
                    ],
                    type: "Option<ValidationCodeHash>"
                }
            }, PH_V1_TO_V2),
            version: 2
        },
        {
            methods: (0, _util.objectSpread)({
                session_info: {
                    description: "Get the session info for the given session, if stored.",
                    params: [
                        {
                            name: "index",
                            type: "SessionIndex"
                        }
                    ],
                    type: "Option<OldV1SessionInfo>"
                }
            }, PH_V1_TO_V2),
            version: 1
        }
    ]
};

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9EiiW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util"); // order important in structs... :)
/* eslint-disable sort-keys */ const SlotRange10 = {
    _enum: [
        "ZeroZero",
        "ZeroOne",
        "ZeroTwo",
        "ZeroThree",
        "OneOne",
        "OneTwo",
        "OneThree",
        "TwoTwo",
        "TwoThree",
        "ThreeThree"
    ]
};
const SlotRange = {
    _enum: [
        "ZeroZero",
        "ZeroOne",
        "ZeroTwo",
        "ZeroThree",
        "ZeroFour",
        "ZeroFive",
        "ZeroSix",
        "ZeroSeven",
        "OneOne",
        "OneTwo",
        "OneThree",
        "OneFour",
        "OneFive",
        "OneSix",
        "OneSeven",
        "TwoTwo",
        "TwoThree",
        "TwoFour",
        "TwoFive",
        "TwoSix",
        "TwoSeven",
        "ThreeThree",
        "ThreeFour",
        "ThreeFive",
        "ThreeSix",
        "ThreeSeven",
        "FourFour",
        "FourFive",
        "FourSix",
        "FourSeven",
        "FiveFive",
        "FiveSix",
        "FiveSeven",
        "SixSix",
        "SixSeven",
        "SevenSeven"
    ]
};
const oldTypes = {
    Bidder: {
        _enum: {
            New: "NewBidder",
            Existing: "ParaId"
        }
    },
    IncomingParachain: {
        _enum: {
            Unset: "NewBidder",
            Fixed: "IncomingParachainFixed",
            Deploy: "IncomingParachainDeploy"
        }
    },
    IncomingParachainDeploy: {
        code: "ValidationCode",
        initialHeadData: "HeadData"
    },
    IncomingParachainFixed: {
        codeHash: "Hash",
        codeSize: "u32",
        initialHeadData: "HeadData"
    },
    NewBidder: {
        who: "AccountId",
        sub: "SubId"
    },
    SubId: "u32"
};
exports.default = (0, _util.objectSpread)({}, oldTypes, {
    AuctionIndex: "u32",
    LeasePeriod: "BlockNumber",
    LeasePeriodOf: "BlockNumber",
    SlotRange10,
    SlotRange,
    WinningData10: `[WinningDataEntry; ${SlotRange10._enum.length}]`,
    WinningData: `[WinningDataEntry; ${SlotRange._enum.length}]`,
    WinningDataEntry: "Option<(AccountId, ParaId, BalanceOf)>",
    WinnersData10: "Vec<WinnersDataTuple10>",
    WinnersData: "Vec<WinnersDataTuple>",
    WinnersDataTuple10: "(AccountId, ParaId, BalanceOf, SlotRange10)",
    WinnersDataTuple: "(AccountId, ParaId, BalanceOf, SlotRange)"
});

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8EFaw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        Approvals: "[bool; 4]"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1GK22":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ exports.default = {
    rpc: {},
    types: {
        AccountStatus: {
            validity: "AccountValidity",
            freeBalance: "Balance",
            lockedBalance: "Balance",
            signature: "Vec<u8>",
            vat: "Permill"
        },
        AccountValidity: {
            _enum: [
                "Invalid",
                "Initiated",
                "Pending",
                "ValidLow",
                "ValidHigh",
                "Completed"
            ]
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a37to":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _typesCreate = require("@polkadot/types-create");
var _util = require("@polkadot/util");
var _v0Js = require("./v0.js");
var _v1Js = require("./v1.js");
var _v2Js = require("./v2.js");
const XCM_LATEST = "V2";
const xcm = {
    XcmOrigin: {
        _enum: {
            Xcm: "MultiLocation"
        }
    },
    XcmpMessageFormat: {
        _enum: [
            "ConcatenatedVersionedXcm",
            "ConcatenatedEncodedBlob",
            "Signals"
        ]
    },
    XcmAssetId: {
        _enum: {
            Concrete: "MultiLocation",
            Abstract: "Bytes"
        }
    },
    InboundStatus: {
        _enum: [
            "Ok",
            "Suspended"
        ]
    },
    OutboundStatus: {
        _enum: [
            "Ok",
            "Suspended"
        ]
    },
    MultiAssets: "Vec<MultiAsset>"
};
const location = {
    BodyId: {
        _enum: {
            Unit: "Null",
            Named: "Vec<u8>",
            Index: "Compact<u32>",
            Executive: "Null",
            Technical: "Null",
            Legislative: "Null",
            Judicial: "Null"
        }
    },
    BodyPart: {
        _enum: {
            Voice: "Null",
            Members: "Compact<u32>",
            Fraction: {
                nom: "Compact<u32>",
                denom: "Compact<u32>"
            },
            AtLeastProportion: {
                nom: "Compact<u32>",
                denom: "Compact<u32>"
            },
            MoreThanProportion: {
                nom: "Compact<u32>",
                denom: "Compact<u32>"
            }
        }
    },
    InteriorMultiLocation: "Junctions",
    NetworkId: {
        _enum: {
            Any: "Null",
            Named: "Vec<u8>",
            Polkadot: "Null",
            Kusama: "Null"
        }
    }
};
exports.default = {
    rpc: {},
    types: (0, _util.objectSpread)({}, location, xcm, (0, _v0Js.v0), (0, _v1Js.v1), (0, _v2Js.v2), (0, _typesCreate.mapXcmTypes)(XCM_LATEST), {
        DoubleEncodedCall: {
            encoded: "Vec<u8>"
        },
        XcmOriginKind: {
            _enum: [
                "Native",
                "SovereignAccount",
                "Superuser",
                "Xcm"
            ]
        },
        Outcome: {
            _enum: {
                Complete: "Weight",
                Incomplete: "(Weight, XcmErrorV0)",
                Error: "XcmErrorV0"
            }
        },
        QueryId: "u64",
        QueryStatus: {
            _enum: {
                Pending: {
                    responder: "VersionedMultiLocation",
                    maybeNotify: "Option<(u8, u8)>",
                    timeout: "BlockNumber"
                },
                Ready: {
                    response: "VersionedResponse",
                    at: "BlockNumber"
                }
            }
        },
        QueueConfigData: {
            suspendThreshold: "u32",
            dropThreshold: "u32",
            resumeThreshold: "u32",
            thresholdWeight: "Weight",
            weightRestrictDecay: "Weight"
        },
        VersionMigrationStage: {
            _enum: {
                MigrateSupportedVersion: "Null",
                MigrateVersionNotifiers: "Null",
                NotifyCurrentTargets: "Option<Bytes>",
                MigrateAndNotifyOldTargets: "Null"
            }
        },
        VersionedMultiAsset: {
            _enum: {
                V0: "MultiAssetV0",
                V1: "MultiAssetV1",
                V2: "MultiAssetV2"
            }
        },
        VersionedMultiAssets: {
            _enum: {
                V0: "Vec<MultiAssetV0>",
                V1: "MultiAssetsV1",
                V2: "MultiAssetsV2"
            }
        },
        VersionedMultiLocation: {
            _enum: {
                V0: "MultiLocationV0",
                V1: "MultiLocationV1",
                V2: "MultiLocationV2"
            }
        },
        VersionedResponse: {
            V0: "ResponseV0",
            V1: "ResponseV1",
            V2: "ResponseV2"
        },
        VersionedXcm: {
            _enum: {
                V0: "XcmV0",
                V1: "XcmV1",
                V2: "XcmV2"
            }
        },
        XcmVersion: "u32"
    })
};

},{"@polkadot/types-create":"cr6lO","@polkadot/util":"3HnHw","./v0.js":"elguL","./v1.js":"gCO3S","./v2.js":"3C8Gn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cr6lO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"iLOTL","./bundle.js":"17mH9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iLOTL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"fWTcD","./packageInfo.js":"cUwPM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fWTcD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/types-codec/packageInfo");
exports.default = [
    (0, _packageInfo.packageInfo)
];

},{"@polkadot/types-codec/packageInfo":"2E3zV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"17mH9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
parcelHelpers.export(exports, "TypeDefInfo", ()=>(0, _indexJs.TypeDefInfo));
var _packageInfoJs = require("./packageInfo.js");
var _indexJs = require("./types/index.js");
var _indexJs1 = require("./create/index.js");
parcelHelpers.exportAll(_indexJs1, exports);
var _indexJs2 = require("./util/index.js");
parcelHelpers.exportAll(_indexJs2, exports);

},{"./packageInfo.js":"cUwPM","./types/index.js":"5QFWK","./create/index.js":"a9A9I","./util/index.js":"chdyR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5QFWK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _augmentRegistryJs = require("./augmentRegistry.js");
var _lookupJs = require("./lookup.js");
parcelHelpers.exportAll(_lookupJs, exports);
var _typesJs = require("./types.js");
parcelHelpers.exportAll(_typesJs, exports);

},{"./augmentRegistry.js":"7CKPf","./lookup.js":"j4Ctu","./types.js":"44zv9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CKPf":[function(require,module,exports) {
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
// import type lookup before we augment - in some environments
// this is required to allow for ambient/previous definitions
var _registry = require("@polkadot/types-codec/types/registry");

},{"@polkadot/types-codec/types/registry":"ccJK9"}],"ccJK9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j4Ctu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"44zv9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeDefInfo", ()=>TypeDefInfo);
let TypeDefInfo;
(function(TypeDefInfo) {
    TypeDefInfo[TypeDefInfo["BTreeMap"] = 0] = "BTreeMap";
    TypeDefInfo[TypeDefInfo["BTreeSet"] = 1] = "BTreeSet";
    TypeDefInfo[TypeDefInfo["Compact"] = 2] = "Compact";
    TypeDefInfo[TypeDefInfo["DoNotConstruct"] = 3] = "DoNotConstruct";
    TypeDefInfo[TypeDefInfo["Enum"] = 4] = "Enum";
    TypeDefInfo[TypeDefInfo["HashMap"] = 5] = "HashMap";
    TypeDefInfo[TypeDefInfo["Int"] = 6] = "Int";
    TypeDefInfo[TypeDefInfo["Linkage"] = 7] = "Linkage";
    TypeDefInfo[TypeDefInfo["Null"] = 8] = "Null";
    TypeDefInfo[TypeDefInfo["Option"] = 9] = "Option";
    TypeDefInfo[TypeDefInfo["Plain"] = 10] = "Plain";
    TypeDefInfo[TypeDefInfo["Range"] = 11] = "Range";
    TypeDefInfo[TypeDefInfo["RangeInclusive"] = 12] = "RangeInclusive";
    TypeDefInfo[TypeDefInfo["Result"] = 13] = "Result";
    TypeDefInfo[TypeDefInfo["Set"] = 14] = "Set";
    TypeDefInfo[TypeDefInfo["Si"] = 15] = "Si";
    TypeDefInfo[TypeDefInfo["Struct"] = 16] = "Struct";
    TypeDefInfo[TypeDefInfo["Tuple"] = 17] = "Tuple";
    TypeDefInfo[TypeDefInfo["UInt"] = 18] = "UInt";
    TypeDefInfo[TypeDefInfo["Vec"] = 19] = "Vec";
    TypeDefInfo[TypeDefInfo["VecFixed"] = 20] = "VecFixed";
    TypeDefInfo[TypeDefInfo["WrapperKeepOpaque"] = 21] = "WrapperKeepOpaque";
    TypeDefInfo[TypeDefInfo["WrapperOpaque"] = 22] = "WrapperOpaque";
})(TypeDefInfo || (TypeDefInfo = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a9A9I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _classJs = require("./class.js");
parcelHelpers.exportAll(_classJs, exports);
var _typeJs = require("./type.js");
parcelHelpers.exportAll(_typeJs, exports);

},{"./class.js":"2iCHM","./type.js":"dBiQC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2iCHM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "constructTypeClass", ()=>constructTypeClass) // Returns the type Class for construction
;
parcelHelpers.export(exports, "getTypeClass", ()=>getTypeClass);
parcelHelpers.export(exports, "createClassUnsafe", ()=>createClassUnsafe);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _indexJs = require("../types/index.js");
var _getTypeDefJs = require("../util/getTypeDef.js");
function getTypeDefType({ lookupName , type  }) {
    return lookupName || type;
}
function getSubDefArray(value) {
    if (!Array.isArray(value.sub)) throw new Error(`Expected subtype as TypeDef[] in ${(0, _util.stringify)(value)}`);
    return value.sub;
}
function getSubDef(value) {
    if (!value.sub || Array.isArray(value.sub)) throw new Error(`Expected subtype as TypeDef in ${(0, _util.stringify)(value)}`);
    return value.sub;
}
function getSubType(value) {
    return getTypeDefType(getSubDef(value));
} // create a maps of type string CodecClasss from the input
function getTypeClassMap(value) {
    const subs = getSubDefArray(value);
    const map = {};
    for(let i = 0; i < subs.length; i++)map[subs[i].name] = getTypeDefType(subs[i]);
    return map;
} // create an array of type string CodecClasss from the input
function getTypeClassArray(value) {
    return getSubDefArray(value).map(getTypeDefType);
}
function createInt(Clazz, { displayName , length  }) {
    if (!(0, _util.isNumber)(length)) throw new Error(`Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);
    return Clazz.with(length, displayName);
}
function createHashMap(Clazz, value) {
    const [keyType, valueType] = getTypeClassArray(value);
    return Clazz.with(keyType, valueType);
}
function createWithSub(Clazz, value) {
    return Clazz.with(getSubType(value));
}
const infoMapping = {
    [(0, _indexJs.TypeDefInfo).BTreeMap]: (registry, value)=>createHashMap((0, _typesCodec.BTreeMap), value),
    [(0, _indexJs.TypeDefInfo).BTreeSet]: (registry, value)=>createWithSub((0, _typesCodec.BTreeSet), value),
    [(0, _indexJs.TypeDefInfo).Compact]: (registry, value)=>createWithSub((0, _typesCodec.Compact), value),
    [(0, _indexJs.TypeDefInfo).DoNotConstruct]: (registry, value)=>(0, _typesCodec.DoNotConstruct).with(value.displayName || value.type),
    [(0, _indexJs.TypeDefInfo).Enum]: (registry, value)=>{
        const subs = getSubDefArray(value);
        return (0, _typesCodec.Enum).with(subs.every(({ type  })=>type === "Null") ? subs.reduce((out, { index , name  }, count)=>{
            out[name] = index || count;
            return out;
        }, {}) : getTypeClassMap(value));
    },
    [(0, _indexJs.TypeDefInfo).HashMap]: (registry, value)=>createHashMap((0, _typesCodec.HashMap), value),
    [(0, _indexJs.TypeDefInfo).Int]: (registry, value)=>createInt((0, _typesCodec.Int), value),
    // We have circular deps between Linkage & Struct
    [(0, _indexJs.TypeDefInfo).Linkage]: (registry, value)=>{
        const type = `Option<${getSubType(value)}>`; // eslint-disable-next-line sort-keys
        const Clazz = (0, _typesCodec.Struct).with({
            previous: type,
            next: type
        }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        Clazz.prototype.toRawType = function() {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call
            return `Linkage<${this.next.toRawType(true)}>`;
        };
        return Clazz;
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    [(0, _indexJs.TypeDefInfo).Null]: (registry, _)=>(0, _typesCodec.Null),
    [(0, _indexJs.TypeDefInfo).Option]: (registry, value)=>{
        if (!value.sub || Array.isArray(value.sub)) throw new Error("Expected type information for Option");
         // NOTE This is opt-in (unhandled), not by default
        // if (value.sub.type === 'bool') {
        //   return OptionBool;
        // }
        return createWithSub((0, _typesCodec.Option), value);
    },
    [(0, _indexJs.TypeDefInfo).Plain]: (registry, value)=>registry.getOrUnknown(value.type),
    [(0, _indexJs.TypeDefInfo).Range]: (registry, value)=>createWithSub((0, _typesCodec.Range), value),
    [(0, _indexJs.TypeDefInfo).RangeInclusive]: (registry, value)=>createWithSub((0, _typesCodec.RangeInclusive), value),
    [(0, _indexJs.TypeDefInfo).Result]: (registry, value)=>{
        const [Ok, Err] = getTypeClassArray(value); // eslint-disable-next-line @typescript-eslint/no-use-before-define
        return (0, _typesCodec.Result).with({
            Err,
            Ok
        });
    },
    [(0, _indexJs.TypeDefInfo).Set]: (registry, value)=>(0, _typesCodec.CodecSet).with(getSubDefArray(value).reduce((result, { index , name  })=>{
            result[name] = index;
            return result;
        }, {}), value.length),
    [(0, _indexJs.TypeDefInfo).Si]: (registry, value)=>getTypeClass(registry, registry.lookup.getTypeDef(value.type)),
    [(0, _indexJs.TypeDefInfo).Struct]: (registry, value)=>(0, _typesCodec.Struct).with(getTypeClassMap(value), value.alias),
    [(0, _indexJs.TypeDefInfo).Tuple]: (registry, value)=>(0, _typesCodec.Tuple).with(getTypeClassArray(value)),
    [(0, _indexJs.TypeDefInfo).UInt]: (registry, value)=>createInt((0, _typesCodec.UInt), value),
    [(0, _indexJs.TypeDefInfo).Vec]: (registry, { sub  })=>{
        if (!sub || Array.isArray(sub)) throw new Error("Expected type information for vector");
        return sub.type === "u8" ? (0, _typesCodec.Bytes) : (0, _typesCodec.Vec).with(getTypeDefType(sub));
    },
    [(0, _indexJs.TypeDefInfo).VecFixed]: (registry, { displayName , length , sub  })=>{
        if (!(0, _util.isNumber)(length) || !sub || Array.isArray(sub)) throw new Error("Expected length & type information for fixed vector");
        return sub.type === "u8" ? (0, _typesCodec.U8aFixed).with(length * 8, displayName) : (0, _typesCodec.VecFixed).with(getTypeDefType(sub), length);
    },
    [(0, _indexJs.TypeDefInfo).WrapperKeepOpaque]: (registry, value)=>createWithSub((0, _typesCodec.WrapperKeepOpaque), value),
    [(0, _indexJs.TypeDefInfo).WrapperOpaque]: (registry, value)=>createWithSub((0, _typesCodec.WrapperOpaque), value)
};
function constructTypeClass(registry, typeDef) {
    try {
        const Type = infoMapping[typeDef.info](registry, typeDef);
        if (!Type) throw new Error("No class created");
         // don't clobber any existing
        if (!Type.__fallbackType && typeDef.fallbackType) // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore ...this is the only place we we actually assign this...
        Type.__fallbackType = typeDef.fallbackType;
        return Type;
    } catch (error) {
        throw new Error(`Unable to construct class from ${(0, _util.stringify)(typeDef)}: ${error.message}`);
    }
}
function getTypeClass(registry, typeDef) {
    return registry.getUnsafe(typeDef.type, false, typeDef);
}
function createClassUnsafe(registry, type) {
    return registry.getUnsafe(type) || getTypeClass(registry, registry.isLookupType(type) ? registry.lookup.getTypeDef(type) : (0, _getTypeDefJs.getTypeDef)(type));
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","../types/index.js":"5QFWK","../util/getTypeDef.js":"gN0Rn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gvW09":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"eokNv","./bundle.js":"fE7OG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eokNv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"jMv0A","./packageInfo.js":"2E3zV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jMv0A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Empty template, auto-generated by @polkadot/dev
exports.default = [];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fE7OG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
var _packageInfoJs = require("./packageInfo.js");
var _indexJs = require("./abstract/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var _indexJs1 = require("./base/index.js");
parcelHelpers.exportAll(_indexJs1, exports);
var _indexJs2 = require("./extended/index.js");
parcelHelpers.exportAll(_indexJs2, exports);
var _indexJs3 = require("./native/index.js");
parcelHelpers.exportAll(_indexJs3, exports);
var _indexJs4 = require("./primitive/index.js");
parcelHelpers.exportAll(_indexJs4, exports);
var _indexJs5 = require("./utils/index.js");
parcelHelpers.exportAll(_indexJs5, exports);

},{"./packageInfo.js":"2E3zV","./abstract/index.js":"cwpNr","./base/index.js":"9y2cS","./extended/index.js":"lWoC7","./native/index.js":"gMGnS","./primitive/index.js":"9yjSC","./utils/index.js":"OTOl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cwpNr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "AbstractArray", ()=>(0, _arrayJs.AbstractArray));
parcelHelpers.export(exports, "AbstractBase", ()=>(0, _baseJs.AbstractBase));
parcelHelpers.export(exports, "AbstractInt", ()=>(0, _intJs.AbstractInt));
var _arrayJs = require("./Array.js");
var _baseJs = require("./Base.js");
var _intJs = require("./Int.js");

},{"./Array.js":"3VJuv","./Base.js":"4Xnx9","./Int.js":"93VT5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3VJuv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name AbstractArray
 * @description
 * This manages codec arrays. It is an extension to Array, providing
 * specific encoding/decoding on top of the base type.
 * @noInheritDoc
 */ parcelHelpers.export(exports, "AbstractArray", ()=>AbstractArray);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _compareArrayJs = require("../utils/compareArray.js");
class AbstractArray extends Array {
    /**
   * @description This ensures that operators such as clice, filter, map, etc. return
   * new Array instances (without this we need to apply overrides)
   */ static get [Symbol.species]() {
        return Array;
    }
    constructor(registry, length){
        super(length);
        this.registry = registry;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        // We need to loop through all entries since they may have a variable length themselves,
        // e.g. when a Vec or Compact is contained withing, it has a variable length based on data
        let total = (0, _util.compactToU8a)(this.length).length;
        for(let i = 0; i < this.length; i++)total += this[i].encodedLength;
        return total;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Checks if the value is an empty value
   */ get isEmpty() {
        return this.length === 0;
    }
    /**
   * @description The length of the value
   */ get length() {
        // only included here since we ignore inherited docs
        return super.length;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return (0, _compareArrayJs.compareArray)(this, other);
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            inner: this.inspectInner(),
            outer: [
                (0, _util.compactToU8a)(this.length)
            ]
        };
    }
    inspectInner() {
        const inner = new Array(this.length);
        for(let i = 0; i < this.length; i++)inner[i] = this[i].inspect();
        return inner;
    }
    /**
   * @description Converts the Object to an standard JavaScript Array
   */ toArray() {
        return Array.from(this);
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        return (0, _util.u8aToHex)(this.toU8a());
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        const result = new Array(this.length);
        for(let i = 0; i < this.length; i++)result[i] = this[i] && this[i].toHuman(isExtended);
        return result;
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        const result = new Array(this.length);
        for(let i = 0; i < this.length; i++)// We actually log inside the U8a decoding and use JSON.stringify(...), which
        // means that the Vec may be partially populated (same applies to toHuman, same check)
        result[i] = this[i] && this[i].toJSON();
        return result;
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        const result = new Array(this.length);
        for(let i = 0; i < this.length; i++)result[i] = this[i] && this[i].toPrimitive();
        return result;
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ /**
   * @description Returns the string representation of the value
   */ toString() {
        const result = new Array(this.length);
        for(let i = 0; i < this.length; i++)result[i] = this[i].toString();
        return `[${result.join(", ")}]`;
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        const encoded = this.toU8aInner();
        return isBare ? (0, _util.u8aConcatStrict)(encoded) : (0, _util.u8aConcatStrict)([
            (0, _util.compactToU8a)(this.length),
            ...encoded
        ]);
    }
    toU8aInner(isBare) {
        const encoded = new Array(this.length);
        for(let i = 0; i < this.length; i++)encoded[i] = this[i].toU8a(isBare);
        return encoded;
    }
}

},{"@polkadot/util":"3HnHw","../utils/compareArray.js":"aVGtj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aVGtj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// when the second is an Codec[] that the first has to be as well
parcelHelpers.export(exports, "compareArray", ()=>compareArray);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilJs = require("./util.js"); // NOTE These are used internally and when comparing objects, expects that
function compareArray(a, b) {
    if (Array.isArray(b)) return a.length === b.length && (0, _util.isUndefined)(a.find((v, index)=>(0, _utilJs.hasEq)(v) ? !v.eq(b[index]) : v !== b[index]));
    return false;
}

},{"@polkadot/util":"3HnHw","./util.js":"c7QwJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c7QwJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasEq", ()=>hasEq);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function hasEq(o) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return (0, _util.isFunction)(o.eq);
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Xnx9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name Base
 * @description A type extends the Base class, when it holds a value
 */ parcelHelpers.export(exports, "AbstractBase", ()=>AbstractBase);
class AbstractBase {
    #raw;
    constructor(registry, value, initialU8aLength){
        this.#raw = value;
        this.initialU8aLength = initialU8aLength;
        this.registry = registry;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return this.toU8a().length;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    get inner() {
        return this.#raw;
    }
    /**
   * @description Checks if the value is an empty value
   */ get isEmpty() {
        return this.#raw.isEmpty;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return this.#raw.eq(other);
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return this.#raw.inspect();
    }
    /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */ toHex(isLe) {
        return this.#raw.toHex(isLe);
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        return this.#raw.toHuman(isExtended);
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.#raw.toJSON();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.#raw.toPrimitive();
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return this.#raw.toString();
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        return this.#raw.toU8a(isBare);
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Base";
    }
    unwrap() {
        return this.#raw;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"93VT5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_UINT_BITS", ()=>DEFAULT_UINT_BITS);
/**
 * @name AbstractInt
 * @ignore
 * @noInheritDoc
 */ parcelHelpers.export(exports, "AbstractInt", ()=>AbstractInt);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const DEFAULT_UINT_BITS = 64; // Maximum allowed integer for JS is 2^53 - 1, set limit at 52
// In this case however, we always print any >32 as hex
const MAX_NUMBER_BITS = 52;
const MUL_P = new (0, _util.BN)(10000);
const FORMATTERS = [
    [
        "Perquintill",
        (0, _util.BN_QUINTILL)
    ],
    [
        "Perbill",
        (0, _util.BN_BILLION)
    ],
    [
        "Permill",
        (0, _util.BN_MILLION)
    ],
    [
        "Percent",
        (0, _util.BN_HUNDRED)
    ]
];
function toPercentage(value, divisor) {
    return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;
}
/** @internal */ function decodeAbstractInt(value, isNegative) {
    if ((0, _util.isNumber)(value)) {
        if (!Number.isInteger(value) || value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) throw new Error("Number needs to be an integer <= Number.MAX_SAFE_INTEGER, i.e. 2 ^ 53 - 1");
        return value;
    } else if ((0, _util.isString)(value)) {
        if ((0, _util.isHex)(value, -1, true)) return (0, _util.hexToBn)(value, {
            isLe: false,
            isNegative
        }).toString();
        if (value.includes(".") || value.includes(",") || value.includes("e")) throw new Error("String should not contain decimal points or scientific notation");
        return value;
    } else if ((0, _util.isBn)(value)) return value.toString();
    return (0, _util.bnToBn)(value).toString();
}
class AbstractInt extends (0, _util.BN) {
    #bitLength;
    constructor(registry, value = 0, bitLength = DEFAULT_UINT_BITS, isSigned = false){
        // Construct via a string/number, which will be passed in the BN constructor.
        // It would be ideal to actually return a BN, but there is an issue:
        // https://github.com/indutny/bn.js/issues/206
        super((0, _util.isU8a)(value) ? bitLength <= 48 ? (0, _util.u8aToNumber)(value.subarray(0, bitLength / 8), {
            isNegative: isSigned
        }) : (0, _util.u8aToBn)(value.subarray(0, bitLength / 8), {
            isLe: true,
            isNegative: isSigned
        }).toString() : decodeAbstractInt(value, isSigned));
        this.registry = registry;
        this.#bitLength = bitLength;
        this.encodedLength = this.#bitLength / 8;
        this.isUnsigned = !isSigned;
        const isNegative = this.isNeg();
        const maxBits = bitLength - (isSigned && !isNegative ? 1 : 0);
        if (isNegative && !isSigned) throw new Error(`${this.toRawType()}: Negative number passed to unsigned type`);
        else if (super.bitLength() > maxBits) throw new Error(`${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${maxBits}`);
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Checks if the value is a zero value (align elsewhere)
   */ get isEmpty() {
        return this.isZero();
    }
    /**
   * @description Returns the number of bits in the value
   */ bitLength() {
        return this.#bitLength;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    eq(other) {
        // Here we are actually overriding the built-in .eq to take care of both
        // number and BN inputs (no `.eqn` needed) - numbers will be converted
        return super.eq((0, _util.isHex)(other) ? (0, _util.hexToBn)(other.toString(), {
            isLe: false,
            isNegative: !this.isUnsigned
        }) : (0, _util.bnToBn)(other));
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            outer: [
                this.toU8a()
            ]
        };
    }
    /**
   * @description True if this value is the max of the type
   */ isMax() {
        const u8a = this.toU8a().filter((b)=>b === 0xff);
        return u8a.length === this.#bitLength / 8;
    }
    /**
   * @description Returns a BigInt representation of the number
   */ toBigInt() {
        return BigInt(this.toString());
    }
    /**
   * @description Returns the BN representation of the number. (Compatibility)
   */ toBn() {
        return this;
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex(isLe = false) {
        // For display/JSON, this is BE, for compare, use isLe
        return (0, _util.bnToHex)(this, {
            bitLength: this.bitLength(),
            isLe,
            isNegative: !this.isUnsigned
        });
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toHuman(isExpanded) {
        const rawType = this.toRawType();
        if (rawType === "Balance") return this.isMax() ? "everything" // FIXME In the case of multiples we need some way of detecting which instance this belongs
         : (0, _util.formatBalance)(this, {
            decimals: this.registry.chainDecimals[0],
            withSi: true,
            withUnit: this.registry.chainTokens[0]
        });
        const [, divisor] = FORMATTERS.find(([type])=>type === rawType) || [];
        return divisor ? toPercentage(this, divisor) : (0, _util.formatNumber)(this);
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON(onlyHex = false) {
        // FIXME this return type should by string | number, however BN returns string
        // Options here are
        //   - super.bitLength() - the actual used bits
        //   - this.#bitLength - the type bits (this should be used, however contracts RPC is problematic)
        return onlyHex || super.bitLength() > MAX_NUMBER_BITS ? this.toHex() : this.toNumber();
    }
    /**
   * @description Returns the value in a primitive form, either number when <= 52 bits, or string otherwise
   */ toPrimitive() {
        return super.bitLength() > MAX_NUMBER_BITS ? this.toString() : this.toNumber();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        // NOTE In the case of balances, which have a special meaning on the UI
        // and can be interpreted differently, return a specific value for it so
        // underlying it always matches (no matter which length it actually is)
        return this instanceof this.registry.createClassUnsafe("Balance") ? "Balance" : `${this.isUnsigned ? "u" : "i"}${this.bitLength()}`;
    }
    /**
   * @description Returns the string representation of the value
   * @param base The base to use for the conversion
   */ toString(base) {
        // only included here since we do not inherit docs
        return super.toString(base);
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toU8a(isBare) {
        return (0, _util.bnToU8a)(this, {
            bitLength: this.bitLength(),
            isLe: true,
            isNegative: !this.isUnsigned
        });
    }
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9y2cS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "Compact", ()=>(0, _compactJs.Compact));
parcelHelpers.export(exports, "DoNotConstruct", ()=>(0, _doNotConstructJs.DoNotConstruct));
parcelHelpers.export(exports, "Enum", ()=>(0, _enumJs.Enum));
parcelHelpers.export(exports, "Int", ()=>(0, _intJs.Int));
parcelHelpers.export(exports, "Null", ()=>(0, _nullJs.Null));
parcelHelpers.export(exports, "Option", ()=>(0, _optionJs.Option));
parcelHelpers.export(exports, "Result", ()=>(0, _resultJs.Result));
parcelHelpers.export(exports, "Tuple", ()=>(0, _tupleJs.Tuple));
parcelHelpers.export(exports, "UInt", ()=>(0, _uintJs.UInt));
parcelHelpers.export(exports, "Vec", ()=>(0, _vecJs.Vec));
parcelHelpers.export(exports, "VecAny", ()=>(0, _vecAnyJs.VecAny));
parcelHelpers.export(exports, "VecFixed", ()=>(0, _vecFixedJs.VecFixed));
var _compactJs = require("./Compact.js");
var _doNotConstructJs = require("./DoNotConstruct.js");
var _enumJs = require("./Enum.js");
var _intJs = require("./Int.js");
var _nullJs = require("./Null.js");
var _optionJs = require("./Option.js");
var _resultJs = require("./Result.js");
var _tupleJs = require("./Tuple.js");
var _uintJs = require("./UInt.js");
var _vecJs = require("./Vec.js");
var _vecAnyJs = require("./VecAny.js");
var _vecFixedJs = require("./VecFixed.js");

},{"./Compact.js":"6yd8y","./DoNotConstruct.js":"5ONYx","./Enum.js":"8x85c","./Int.js":"5SyvB","./Null.js":"9GkZn","./Option.js":"gqQka","./Result.js":"hoW8i","./Tuple.js":"jkm77","./UInt.js":"7DnCN","./Vec.js":"kpQbu","./VecAny.js":"863VH","./VecFixed.js":"7MlTe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6yd8y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Compact
 * @description
 * A compact length-encoding codec wrapper. It performs the same function as Length, however
 * differs in that it uses a variable number of bytes to do the actual encoding. This is mostly
 * used by other types to add length-prefixed encoding, or in the case of wrapped types, taking
 * a number and making the compact representation thereof
 */ parcelHelpers.export(exports, "Compact", ()=>Compact);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../utils/index.js");
function noopSetDefinition(d) {
    return d;
}
function decodeCompact(registry, Type, value) {
    if ((0, _util.isU8a)(value)) {
        const [decodedLength, bn] = (value[0] & 3) < 3 ? (0, _util.compactFromU8aLim)(value) : (0, _util.compactFromU8a)(value);
        return [
            new Type(registry, bn),
            decodedLength
        ];
    } else if (value instanceof Compact) {
        const raw = value.unwrap();
        return raw instanceof Type ? [
            raw,
            0
        ] : [
            new Type(registry, raw),
            0
        ];
    } else if (value instanceof Type) return [
        value,
        0
    ];
    return [
        new Type(registry, value),
        0
    ];
}
class Compact {
    #Type;
    #raw;
    constructor(registry, Type, value = 0, { definition , setDefinition =noopSetDefinition  } = {}){
        this.registry = registry;
        this.#Type = definition || setDefinition((0, _indexJs.typeToConstructor)(registry, Type));
        const [raw, decodedLength] = decodeCompact(registry, this.#Type, value);
        this.initialU8aLength = decodedLength;
        this.#raw = raw;
    }
    static with(Type) {
        let definition; // eslint-disable-next-line no-return-assign
        const setDefinition = (d)=>definition = d;
        return class extends Compact {
            constructor(registry, value){
                super(registry, Type, value, {
                    definition,
                    setDefinition
                });
            }
        };
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return this.toU8a().length;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Checks if the value is an empty value
   */ get isEmpty() {
        return this.#raw.isEmpty;
    }
    /**
   * @description Returns the number of bits in the value
   */ bitLength() {
        return this.#raw.bitLength();
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return this.#raw.eq(other instanceof Compact ? other.#raw : other);
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            outer: [
                this.toU8a()
            ]
        };
    }
    /**
   * @description Returns a BigInt representation of the number
   */ toBigInt() {
        return this.#raw.toBigInt();
    }
    /**
   * @description Returns the BN representation of the number
   */ toBn() {
        return this.#raw.toBn();
    }
    /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */ toHex(isLe) {
        return this.#raw.toHex(isLe);
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        return this.#raw.toHuman(isExtended);
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.#raw.toJSON();
    }
    /**
   * @description Returns the number representation for the value
   */ toNumber() {
        return this.#raw.toNumber();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.#raw.toPrimitive();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return `Compact<${this.registry.getClassName(this.#Type) || this.#raw.toRawType()}>`;
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return this.#raw.toString();
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toU8a(isBare) {
        return (0, _util.compactToU8a)(this.#raw.toBn());
    }
    /**
   * @description Returns the embedded [[UInt]] or [[Moment]] value
   */ unwrap() {
        return this.#raw;
    }
}

},{"@polkadot/util":"3HnHw","../utils/index.js":"OTOl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"OTOl1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "compareArray", ()=>(0, _compareArrayJs.compareArray));
parcelHelpers.export(exports, "compareMap", ()=>(0, _compareMapJs.compareMap));
parcelHelpers.export(exports, "compareSet", ()=>(0, _compareSetJs.compareSet));
parcelHelpers.export(exports, "decodeU8a", ()=>(0, _decodeU8AJs.decodeU8a));
parcelHelpers.export(exports, "decodeU8aStruct", ()=>(0, _decodeU8AJs.decodeU8aStruct));
parcelHelpers.export(exports, "decodeU8aVec", ()=>(0, _decodeU8AJs.decodeU8aVec));
parcelHelpers.export(exports, "mapToTypeMap", ()=>(0, _mapToTypeMapJs.mapToTypeMap));
parcelHelpers.export(exports, "typeToConstructor", ()=>(0, _typeToConstructorJs.typeToConstructor));
parcelHelpers.export(exports, "sanitize", ()=>(0, _sanitizeJs.sanitize));
parcelHelpers.export(exports, "sortAsc", ()=>(0, _sortValuesJs.sortAsc));
parcelHelpers.export(exports, "sortSet", ()=>(0, _sortValuesJs.sortSet));
parcelHelpers.export(exports, "sortMap", ()=>(0, _sortValuesJs.sortMap));
parcelHelpers.export(exports, "typesToMap", ()=>(0, _typesToMapJs.typesToMap));
var _compareArrayJs = require("./compareArray.js");
var _compareMapJs = require("./compareMap.js");
var _compareSetJs = require("./compareSet.js");
var _decodeU8AJs = require("./decodeU8a.js");
var _mapToTypeMapJs = require("./mapToTypeMap.js");
var _typeToConstructorJs = require("./typeToConstructor.js");
var _sanitizeJs = require("./sanitize.js");
var _sortValuesJs = require("./sortValues.js");
var _typesToMapJs = require("./typesToMap.js");

},{"./compareArray.js":"aVGtj","./compareMap.js":"lyYsC","./compareSet.js":"kM2qo","./decodeU8a.js":"kB9KK","./mapToTypeMap.js":"gb4jz","./typeToConstructor.js":"k17Eu","./sanitize.js":"h150C","./sortValues.js":"6P72R","./typesToMap.js":"21OUE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lyYsC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// when the second is an Map<string, Codec> that the first has to be as well
parcelHelpers.export(exports, "compareMap", ()=>compareMap);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilJs = require("./util.js");
function hasMismatch(a, b) {
    return (0, _util.isUndefined)(a) || ((0, _utilJs.hasEq)(a) ? !a.eq(b) : a !== b);
}
function notEntry(value) {
    return !Array.isArray(value) || value.length !== 2;
}
function compareMapArray(a, b) {
    // equal number of entries and each entry in the array should match
    return a.size === b.length && !b.some((e)=>notEntry(e) || hasMismatch(a.get(e[0]), e[1]));
} // NOTE These are used internally and when comparing objects, expects that
function compareMap(a, b) {
    if (Array.isArray(b)) return compareMapArray(a, b);
    else if (b instanceof Map) return compareMapArray(a, [
        ...b.entries()
    ]);
    else if ((0, _util.isObject)(b)) return compareMapArray(a, Object.entries(b));
    return false;
}

},{"@polkadot/util":"3HnHw","./util.js":"c7QwJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kM2qo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// when the second is an Set<string, Codec> that the first has to be as well
parcelHelpers.export(exports, "compareSet", ()=>compareSet);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function compareSetArray(a, b) {
    // equal number of entries and each entry in the array should match
    return a.size === b.length && !b.some((e)=>!a.has(e));
} // NOTE These are used internally and when comparing objects, expects that
function compareSet(a, b) {
    if (Array.isArray(b)) return compareSetArray(a, b);
    else if (b instanceof Set) return compareSetArray(a, [
        ...b.values()
    ]);
    else if ((0, _util.isObject)(b)) return compareSetArray(a, Object.values(b));
    return false;
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kB9KK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @internal
 *
 * Given an u8a, and an array of Type constructors, decode the u8a against the
 * types, and return an array of decoded values.
 *
 * @param u8a - The u8a to decode.
 * @param result - The result array (will be returned with values pushed)
 * @param types - The array of CodecClass to decode the U8a against.
 */ parcelHelpers.export(exports, "decodeU8a", ()=>decodeU8a);
/**
 * @internal
 *
 * Split from decodeU8a since this is specialized to zip returns ... while we duplicate, this
 * is all on the hot-path, so it is not great, however there is (some) method behind the madness
 */ parcelHelpers.export(exports, "decodeU8aStruct", ()=>decodeU8aStruct);
/**
 * @internal
 *
 * Split from decodeU8a since this is specialized to 1 instance ... while we duplicate, this
 * is all on the hot-path, so it is not great, however there is (some) method behind the madness
 */ parcelHelpers.export(exports, "decodeU8aVec", ()=>decodeU8aVec);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
/** @internal */ function formatFailure(registry, result, { message  }, u8a, i, count, Type, key) {
    let type = "";
    try {
        type = `: ${new Type(registry).toRawType()}`;
    } catch  {} // console.error(JSON.stringify(result, null, 2));
    return `decodeU8a: failed at ${(0, _util.u8aToHex)(u8a.subarray(0, 16))}‚Ä¶${key ? ` on ${key}` : ""} (index ${i}/${count})${type}:: ${message}`;
}
function decodeU8a(registry, result, u8a, [Types, keys]) {
    const count = result.length;
    let offset = 0;
    let i = 0;
    try {
        while(i < count){
            const value = new Types[i](registry, u8a.subarray(offset));
            offset += value.initialU8aLength || value.encodedLength;
            result[i] = value;
            i++;
        }
    } catch (error) {
        throw new Error(formatFailure(registry, result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));
    }
    return [
        result,
        offset
    ];
}
function decodeU8aStruct(registry, result, u8a, [Types, keys]) {
    const count = result.length;
    let offset = 0;
    let i = 0;
    try {
        while(i < count){
            const value = new Types[i](registry, u8a.subarray(offset));
            offset += value.initialU8aLength || value.encodedLength;
            result[i] = [
                keys[i],
                value
            ];
            i++;
        }
    } catch (error) {
        throw new Error(formatFailure(registry, result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));
    }
    return [
        result,
        offset
    ];
}
function decodeU8aVec(registry, result, u8a, startAt, Type) {
    const count = result.length;
    let offset = startAt;
    let i = 0;
    try {
        while(i < count){
            const value = new Type(registry, u8a.subarray(offset));
            offset += value.initialU8aLength || value.encodedLength;
            result[i] = value;
            i++;
        }
    } catch (error) {
        throw new Error(formatFailure(registry, result, error, u8a.subarray(offset), i, count, Type));
    }
    return [
        offset,
        offset - startAt
    ];
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gb4jz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description takes an input map of the form `{ [string]: string | CodecClass }` and returns a map of `{ [string]: CodecClass }`
 */ parcelHelpers.export(exports, "mapToTypeMap", ()=>mapToTypeMap);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typeToConstructorJs = require("./typeToConstructor.js");
function mapToTypeMap(registry, input) {
    const entries = Object.entries(input);
    const count = entries.length;
    const output = [
        new Array(count),
        new Array(count)
    ];
    for(let i = 0; i < count; i++){
        output[1][i] = entries[i][0];
        output[0][i] = (0, _typeToConstructorJs.typeToConstructor)(registry, entries[i][1]);
    }
    return output;
}

},{"./typeToConstructor.js":"k17Eu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k17Eu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "typeToConstructor", ()=>typeToConstructor);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function typeToConstructor(registry, type) {
    return (0, _util.isString)(type) ? registry.createClassUnsafe(type) : type;
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h150C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "trim", ()=>trim) // given a starting index, find the closing >
;
parcelHelpers.export(exports, "findClosing", ()=>findClosing);
parcelHelpers.export(exports, "alias", ()=>alias);
parcelHelpers.export(exports, "cleanupCompact", ()=>cleanupCompact);
parcelHelpers.export(exports, "flattenSingleTuple", ()=>flattenSingleTuple);
parcelHelpers.export(exports, "removeExtensions", ()=>removeExtensions);
parcelHelpers.export(exports, "removeColons", ()=>removeColons);
parcelHelpers.export(exports, "removeGenerics", ()=>removeGenerics) // remove the PairOf wrappers
;
parcelHelpers.export(exports, "removePairOf", ()=>removePairOf) // remove the type traits
;
parcelHelpers.export(exports, "removeTraits", ()=>removeTraits) // remove wrapping values, i.e. Box<Proposal> -> Proposal
;
parcelHelpers.export(exports, "removeWrap", ()=>removeWrap);
parcelHelpers.export(exports, "sanitize", ()=>sanitize);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
const BOUNDED = [
    "BTreeMap",
    "BTreeSet",
    "HashMap",
    "Vec"
];
const ALLOWED_BOXES = BOUNDED.concat([
    "Compact",
    "DoNotConstruct",
    "Int",
    "Linkage",
    "Range",
    "RangeInclusive",
    "Result",
    "Opaque",
    "Option",
    "UInt",
    "WrapperKeepOpaque",
    "WrapperOpaque"
]);
const BOX_PRECEDING = [
    "<",
    "(",
    "[",
    '"',
    ",",
    " "
]; // start of vec, tuple, fixed array, part of struct def or in tuple
const mappings = [
    alias("<T::InherentOfflineReport as InherentOfflineReport>::Inherent", "InherentOfflineReport", false),
    alias("VecDeque<", "Vec<", false),
    cleanupCompact(),
    removeExtensions("Bounded", true),
    removeExtensions("Weak", false),
    removeTraits(),
    removePairOf(),
    removeWrap("Box<"),
    removeGenerics(),
    alias("String", "Text"),
    alias("Vec<u8>", "Bytes"),
    alias("&\\[u8\\]", "Bytes"),
    alias("&'static\\[u8\\]", "Bytes"),
    alias("RawAddress", "Address"),
    alias("Lookup::Source", "LookupSource"),
    alias("Lookup::Target", "LookupTarget"),
    alias("exec::StorageKey", "ContractStorageKey"),
    flattenSingleTuple(),
    removeColons(),
    trim()
]; // given a string, trim it
function trim() {
    return (value)=>value.trim();
}
function findClosing(value, start) {
    let depth = 0;
    for(let index = start; index < value.length; index++){
        if (value[index] === ">") {
            if (!depth) return index;
            depth--;
        } else if (value[index] === "<") depth++;
    }
    throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);
}
function alias(src, dest, withChecks = true) {
    const from = new RegExp(`(^${src}|${BOX_PRECEDING.map((box)=>`\\${box}${src}`).join("|")})`, "g");
    const to = (src)=>{
        from.lastIndex = 0;
        return withChecks && BOX_PRECEDING.includes(src[0]) ? `${src[0]}${dest}` : dest;
    };
    return (value)=>value.replace(from, to);
}
function cleanupCompact() {
    return (value)=>{
        if (value.includes(" as HasCompact")) {
            for(let index = 0; index < value.length; index++)if (value[index] === "<") {
                const end = findClosing(value, index + 1) - 14;
                if (value.substring(end, end + 14) === " as HasCompact") value = `Compact<${value.substring(index + 1, end)}>`;
            }
        }
        return value;
    };
}
function flattenSingleTuple() {
    const from1 = /,\)/g;
    const from2 = /\(([^,]+)\)/;
    return (value)=>{
        from1.lastIndex = 0;
        return value // tuples may have trailing commas, e.g. (u32, BlockNumber, )
        .replace(from1, ")") // change (u32) -> u32
        .replace(from2, "$1");
    };
}
function replaceTagWith(value, matcher, replacer) {
    let index = -1;
    while(true){
        index = value.indexOf(matcher, index + 1);
        if (index === -1) return value;
        const start = index + matcher.length;
        const end = findClosing(value, start);
        value = `${value.substring(0, index)}${replacer(value.substring(start, end))}${value.substring(end + 1)}`;
    }
} // remove the Bounded* or Weak* wrappers
function removeExtensions(type, isSized) {
    return (value)=>{
        for(let i = 0; i < BOUNDED.length; i++){
            const tag = BOUNDED[i];
            value = replaceTagWith(value, `${type}${tag}<`, (v)=>{
                const parts = v.split(",").map((s)=>s.trim()).filter((s)=>s);
                if (isSized) parts.pop();
                return `${tag}<${parts.join(",")}>`;
            });
        }
        return value;
    };
}
function removeColons() {
    return (value)=>{
        let index = 0;
        while(index !== -1){
            index = value.indexOf("::");
            if (index === 0) value = value.substring(2);
            else if (index !== -1) {
                let start = index;
                while(start !== -1 && !BOX_PRECEDING.includes(value[start]))start--;
                value = `${value.substring(0, start + 1)}${value.substring(index + 2)}`;
            }
        }
        return value;
    };
}
function removeGenerics() {
    return (value)=>{
        for(let index = 0; index < value.length; index++)if (value[index] === "<") {
            // check against the allowed wrappers, be it Vec<..>, Option<...> ...
            const box = ALLOWED_BOXES.find((box)=>{
                const start = index - box.length;
                return start >= 0 && value.substring(start, index) === box && (start === 0 || BOX_PRECEDING.includes(value[start - 1]));
            }); // we have not found anything, unwrap generic innards
            if (!box) {
                const end = findClosing(value, index + 1);
                value = `${value.substring(0, index)}${value.substring(end + 1)}`;
            }
        }
        return value;
    };
}
function removePairOf() {
    const replacer = (v)=>`(${v},${v})`;
    return (value)=>replaceTagWith(value, "PairOf<", replacer);
}
function removeTraits() {
    const from1 = /\s/g;
    const from2 = /(T|Self)::/g;
    const from3 = /<(T|Self)asTrait>::/g;
    const from4 = /<Tas[a-z]+::Trait>::/g;
    const from5 = /<LookupasStaticLookup>/g;
    const from6 = /::Type/g;
    return (value)=>{
        from1.lastIndex = 0;
        from2.lastIndex = 0;
        from3.lastIndex = 0;
        from4.lastIndex = 0;
        from5.lastIndex = 0;
        from6.lastIndex = 0;
        return value // remove all whitespaces
        .replace(from1, "") // anything `T::<type>` to end up as `<type>`
        .replace(from2, "") // replace `<T as Trait>::` (whitespaces were removed above)
        .replace(from3, "") // replace `<T as something::Trait>::` (whitespaces were removed above)
        .replace(from4, "") // replace <Lookup as StaticLookup>
        .replace(from5, "Lookup") // replace `<...>::Type`
        .replace(from6, "");
    };
}
function removeWrap(check) {
    const replacer = (v)=>v;
    return (value)=>replaceTagWith(value, check, replacer);
}
const sanitizeMap = new Map();
function sanitize(value) {
    const startValue = value.toString();
    const memoized = sanitizeMap.get(startValue);
    if (memoized) return memoized;
    let result = startValue;
    for(let i = 0; i < mappings.length; i++)result = mappings[i](result);
    sanitizeMap.set(startValue, result);
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6P72R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
* Sort keys/values of BTreeSet/BTreeMap in ascending order for encoding compatibility with Rust's BTreeSet/BTreeMap
* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html)
* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html)
*/ parcelHelpers.export(exports, "sortAsc", ()=>sortAsc);
parcelHelpers.export(exports, "sortSet", ()=>sortSet);
parcelHelpers.export(exports, "sortMap", ()=>sortMap);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
/** @internal **/ function isArrayLike(arg) {
    return arg instanceof Uint8Array || Array.isArray(arg);
}
/** @internal **/ function isCodec(arg) {
    return (0, _util.isFunction)(arg && arg.toU8a);
}
/** @internal **/ function isEnum(arg) {
    return isCodec(arg) && (0, _util.isNumber)(arg.index) && isCodec(arg.value);
}
/** @internal */ function isNumberLike(arg) {
    return (0, _util.isNumber)(arg) || (0, _util.isBn)(arg) || (0, _util.isBigInt)(arg);
}
/** @internal */ function sortArray(a, b) {
    // Vec, Tuple, Bytes etc.
    let sortRes = 0;
    const minLen = Math.min(a.length, b.length);
    for(let i = 0; i < minLen; ++i){
        sortRes = sortAsc(a[i], b[i]);
        if (sortRes !== 0) return sortRes;
    }
    return a.length - b.length;
}
function sortAsc(a, b) {
    if (isNumberLike(a) && isNumberLike(b)) return (0, _util.bnToBn)(a).cmp((0, _util.bnToBn)(b));
    else if (a instanceof Map && b instanceof Map) return sortAsc(Array.from(a.values()), Array.from(b.values()));
    else if (isEnum(a) && isEnum(b)) return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);
    else if (isArrayLike(a) && isArrayLike(b)) return sortArray(a, b);
    else if (isCodec(a) && isCodec(b)) // Text, Bool etc.
    return sortAsc(a.toU8a(true), b.toU8a(true));
    throw new Error(`Attempting to sort unrecognized values: ${(0, _util.stringify)(a)} (typeof ${typeof a}) <-> ${(0, _util.stringify)(b)} (typeof ${typeof b})`);
}
function sortSet(set) {
    return new Set(Array.from(set).sort(sortAsc));
}
function sortMap(map) {
    return new Map(Array.from(map.entries()).sort(([keyA], [keyB])=>sortAsc(keyA, keyB)));
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"21OUE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "typesToMap", ()=>typesToMap);
function typesToMap(registry, [Types, keys]) {
    const result = {};
    for(let i = 0; i < keys.length; i++)result[keys[i]] = registry.getClassName(Types[i]) || new Types[i](registry).toRawType();
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5ONYx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @name DoNotConstruct
 * @description
 * An unknown type that fails on construction with the type info
 */ parcelHelpers.export(exports, "DoNotConstruct", ()=>DoNotConstruct);
class DoNotConstruct {
    #neverError;
    constructor(registry, typeName = "DoNotConstruct"){
        this.registry = registry;
        this.#neverError = new Error(`DoNotConstruct: Cannot construct unknown type ${typeName}`);
        throw this.#neverError;
    }
    static with(typeName) {
        return class extends DoNotConstruct {
            constructor(registry){
                super(registry, typeName);
            }
        };
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        throw this.#neverError;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        throw this.#neverError;
    }
    /**
   * @description Checks if the value is an empty value (always true)
   */ get isEmpty() {
        throw this.#neverError;
    }
    eq() {
        throw this.#neverError;
    }
    inspect() {
        throw this.#neverError;
    }
    toHex() {
        throw this.#neverError;
    }
    toHuman() {
        throw this.#neverError;
    }
    toJSON() {
        throw this.#neverError;
    }
    toPrimitive() {
        throw this.#neverError;
    }
    toRawType() {
        throw this.#neverError;
    }
    toString() {
        throw this.#neverError;
    }
    toU8a() {
        throw this.#neverError;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8x85c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Enum
 * @description
 * This implements an enum, that based on the value wraps a different type. It is effectively
 * an extension to enum where the value type is determined by the actual index.
 */ parcelHelpers.export(exports, "Enum", ()=>Enum);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../utils/index.js");
var _nullJs = require("./Null.js"); // export interface, this is used in Enum.with, so required as public by TS
function noopSetDefinition(d) {
    return d;
}
function isRustEnum(def) {
    const defValues = Object.values(def);
    if (defValues.some((v)=>(0, _util.isNumber)(v))) {
        if (!defValues.every((v)=>(0, _util.isNumber)(v) && v >= 0 && v <= 255)) throw new Error("Invalid number-indexed enum definition");
        return false;
    }
    return true;
}
function extractDef(registry, _def) {
    const def = {};
    let isBasic;
    let isIndexed;
    if (Array.isArray(_def)) {
        for(let i = 0; i < _def.length; i++)def[_def[i]] = {
            Type: (0, _nullJs.Null),
            index: i
        };
        isBasic = true;
        isIndexed = false;
    } else if (isRustEnum(_def)) {
        const [Types, keys] = (0, _indexJs.mapToTypeMap)(registry, _def);
        for(let i1 = 0; i1 < keys.length; i1++)def[keys[i1]] = {
            Type: Types[i1],
            index: i1
        };
        isBasic = !Object.values(def).some(({ Type  })=>Type !== (0, _nullJs.Null));
        isIndexed = false;
    } else {
        const entries = Object.entries(_def);
        for(let i2 = 0; i2 < entries.length; i2++){
            const [key, index] = entries[i2];
            def[key] = {
                Type: (0, _nullJs.Null),
                index
            };
        }
        isBasic = true;
        isIndexed = true;
    }
    return {
        def,
        isBasic,
        isIndexed
    };
}
function getEntryType(def, checkIdx) {
    const values = Object.values(def);
    for(let i = 0; i < values.length; i++){
        const { Type , index  } = values[i];
        if (index === checkIdx) return Type;
    }
    throw new Error(`Unable to create Enum via index ${checkIdx}, in ${Object.keys(def).join(", ")}`);
}
function createFromU8a(registry, def, index, value) {
    const Type = getEntryType(def, index);
    return {
        index,
        value: new Type(registry, value)
    };
}
function createFromValue(registry, def, index = 0, value) {
    const Type = getEntryType(def, index);
    return {
        index,
        value: value instanceof Type ? value : new Type(registry, value)
    };
}
function decodeFromJSON(registry, def, key, value) {
    // JSON comes in the form of { "<type (camelCase)>": "<value for type>" }, here we
    // additionally force to lower to ensure forward compat
    const keys = Object.keys(def).map((k)=>k.toLowerCase());
    const keyLower = key.toLowerCase();
    const index = keys.indexOf(keyLower);
    if (index === -1) throw new Error(`Cannot map Enum JSON, unable to find '${key}' in ${keys.join(", ")}`);
    try {
        return createFromValue(registry, def, Object.values(def)[index].index, value);
    } catch (error) {
        throw new Error(`Enum(${key}):: ${error.message}`);
    }
}
function decodeEnum(registry, def, value, index) {
    // NOTE We check the index path first, before looking at values - this allows treating
    // the optional indexes before anything else, more-specific > less-specific
    if ((0, _util.isNumber)(index)) return createFromValue(registry, def, index, value);
    else if ((0, _util.isU8a)(value) || (0, _util.isHex)(value)) {
        const u8a = (0, _util.u8aToU8a)(value); // nested, we don't want to match isObject below
        if (u8a.length) return createFromU8a(registry, def, u8a[0], u8a.subarray(1));
    } else if (value instanceof Enum) return createFromValue(registry, def, value.index, value.value);
    else if ((0, _util.isNumber)(value)) return createFromValue(registry, def, value);
    else if ((0, _util.isString)(value)) return decodeFromJSON(registry, def, value.toString());
    else if ((0, _util.isObject)(value)) {
        const key = Object.keys(value)[0];
        return decodeFromJSON(registry, def, key, value[key]);
    } // Worst-case scenario, return the first with default
    return createFromValue(registry, def, Object.values(def)[0].index);
}
class Enum {
    #def;
    #entryIndex;
    #indexes;
    #isBasic;
    #isIndexed;
    #raw;
    constructor(registry, Types, value, index, { definition , setDefinition =noopSetDefinition  } = {}){
        const { def , isBasic , isIndexed  } = definition || setDefinition(extractDef(registry, Types)); // shortcut isU8a as used in SCALE decoding
        const decoded = (0, _util.isU8a)(value) && value.length && !(0, _util.isNumber)(index) ? createFromU8a(registry, def, value[0], value.subarray(1)) : decodeEnum(registry, def, value, index);
        this.registry = registry;
        this.#def = def;
        this.#isBasic = isBasic;
        this.#isIndexed = isIndexed;
        this.#indexes = Object.values(def).map(({ index  })=>index);
        this.#entryIndex = this.#indexes.indexOf(decoded.index);
        this.#raw = decoded.value;
        if (this.#raw.initialU8aLength) this.initialU8aLength = 1 + this.#raw.initialU8aLength;
    }
    static with(Types) {
        const keys = Array.isArray(Types) ? Types : Object.keys(Types);
        const asKeys = new Array(keys.length);
        const isKeys = new Array(keys.length);
        for(let i = 0; i < keys.length; i++){
            const name = (0, _util.stringPascalCase)(keys[i]);
            asKeys[i] = `as${name}`;
            isKeys[i] = `is${name}`;
        }
        let definition; // eslint-disable-next-line no-return-assign
        const setDefinition = (d)=>definition = d;
        return class extends Enum {
            constructor(registry, value, index){
                super(registry, Types, value, index, {
                    definition,
                    setDefinition
                });
                (0, _util.objectProperties)(this, isKeys, (_, i)=>this.type === keys[i]);
                (0, _util.objectProperties)(this, asKeys, (k, i)=>{
                    if (!this[isKeys[i]]) throw new Error(`Cannot convert '${this.type}' via ${k}`);
                    return this.value;
                });
            }
        };
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return 1 + this.#raw.encodedLength;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description The index of the enum value
   */ get index() {
        return this.#indexes[this.#entryIndex];
    }
    /**
   * @description The value of the enum
   */ get inner() {
        return this.#raw;
    }
    /**
   * @description true if this is a basic enum (no values)
   */ get isBasic() {
        return this.#isBasic;
    }
    /**
   * @description Checks if the value is an empty value
   */ get isEmpty() {
        return this.#raw.isEmpty;
    }
    /**
   * @description Checks if the Enum points to a [[Null]] type
   */ get isNone() {
        return this.#raw instanceof (0, _nullJs.Null);
    }
    /**
   * @description Checks if the Enum points to a [[Null]] type
   * @deprecated use isNone
   */ get isNull() {
        return this.isNone;
    }
    /**
   * @description The available keys for this enum
   */ get defIndexes() {
        return this.#indexes;
    }
    /**
   * @description The available keys for this enum
   */ get defKeys() {
        return Object.keys(this.#def);
    }
    /**
   * @description The name of the type this enum value represents
   */ get type() {
        return this.defKeys[this.#entryIndex];
    }
    /**
   * @description The value of the enum
   */ get value() {
        return this.#raw;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        // cater for the case where we only pass the enum index
        if ((0, _util.isU8a)(other)) return !this.toU8a().some((entry, index)=>entry !== other[index]);
        else if ((0, _util.isNumber)(other)) return this.toNumber() === other;
        else if (this.#isBasic && (0, _util.isString)(other)) return this.type === other;
        else if ((0, _util.isHex)(other)) return this.toHex() === other;
        else if (other instanceof Enum) return this.index === other.index && this.value.eq(other.value);
        else if ((0, _util.isObject)(other)) return this.value.eq(other[this.type]);
         // compare the actual wrapper value
        return this.value.eq(other);
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        if (this.#isBasic) return {
            outer: [
                new Uint8Array([
                    this.index
                ])
            ]
        };
        const { inner , outer =[]  } = this.#raw.inspect();
        return {
            inner,
            outer: [
                new Uint8Array([
                    this.index
                ]),
                ...outer
            ]
        };
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        return (0, _util.u8aToHex)(this.toU8a());
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        return this.#isBasic || this.isNone ? this.type : {
            [this.type]: this.#raw.toHuman(isExtended)
        };
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.#isBasic ? this.type : {
            [(0, _util.stringCamelCase)(this.type)]: this.#raw.toJSON()
        };
    }
    /**
   * @description Returns the number representation for the value
   */ toNumber() {
        return this.index;
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.#isBasic ? this.type : {
            [(0, _util.stringCamelCase)(this.type)]: this.#raw.toPrimitive()
        };
    }
    /**
   * @description Returns a raw struct representation of the enum types
   */ _toRawStruct() {
        if (this.#isBasic) return this.#isIndexed ? this.defKeys.reduce((out, key, index)=>{
            out[key] = this.#indexes[index];
            return out;
        }, {}) : this.defKeys;
        const entries = Object.entries(this.#def);
        return (0, _indexJs.typesToMap)(this.registry, entries.reduce((out, [key, { Type  }], i)=>{
            out[0][i] = Type;
            out[1][i] = key;
            return out;
        }, [
            new Array(entries.length),
            new Array(entries.length)
        ]));
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return (0, _util.stringify)({
            _enum: this._toRawStruct()
        });
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return this.isNone ? this.type : (0, _util.stringify)(this.toJSON());
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        return isBare ? this.#raw.toU8a(isBare) : (0, _util.u8aConcatStrict)([
            new Uint8Array([
                this.index
            ]),
            this.#raw.toU8a(isBare)
        ]);
    }
}

},{"@polkadot/util":"3HnHw","../utils/index.js":"OTOl1","./Null.js":"9GkZn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9GkZn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Null
 * @description
 * Implements a type that does not contain anything (apart from `null`)
 */ parcelHelpers.export(exports, "Null", ()=>Null);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
class Null {
    encodedLength = 0;
    isEmpty = true;
    // Added for compatibility reasons, e.g. see Option
    initialU8aLength = 0;
    constructor(registry){
        this.registry = registry;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        throw new Error(".hash is not implemented on Null");
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return other instanceof Null || (0, _util.isNull)(other);
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {};
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        return "0x";
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toJSON();
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return null;
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return null;
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Null";
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return "";
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toU8a(isBare) {
        return new Uint8Array();
    }
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5SyvB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Int
 * @description
 * A generic signed integer codec. For Substrate all numbers are Little Endian encoded,
 * this handles the encoding and decoding of those numbers. Upon construction
 * the bitLength is provided and any additional use keeps the number to this
 * length. This extends `BN`, so all methods available on a normal `BN` object
 * is available here.
 * @noInheritDoc
 */ parcelHelpers.export(exports, "Int", ()=>Int);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _intJs = require("../abstract/Int.js");
class Int extends (0, _intJs.AbstractInt) {
    constructor(registry, value = 0, bitLength){
        super(registry, value, bitLength, true);
    }
    static with(bitLength, typeName) {
        return class extends Int {
            constructor(registry, value){
                super(registry, value, bitLength);
            }
            toRawType() {
                return typeName || super.toRawType();
            }
        };
    }
}

},{"../abstract/Int.js":"93VT5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gqQka":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Option
 * @description
 * An Option is an optional field. Basically the first byte indicates that there is
 * is value to follow. If the byte is `1` there is an actual value. So the Option
 * implements that - decodes, checks for optionality and wraps the required structure
 * with a value if/as required/found.
 */ parcelHelpers.export(exports, "Option", ()=>Option);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../utils/index.js");
var _nullJs = require("./Null.js");
function noopSetDefinition(d) {
    return d;
}
class None extends (0, _nullJs.Null) {
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "None";
    }
}
/** @internal */ function decodeOption(registry, Type, value) {
    if (value instanceof Type) // don't re-create, use as it (which also caters for derived types)
    return value;
    else if (value instanceof Option) {
        if (value.value instanceof Type) // same instance, return it
        return value.value;
        else if (value.isNone) // internal is None, we are also none
        return new None(registry);
         // convert the actual value into known
        return new Type(registry, value.value);
    } else if ((0, _util.isNull)(value) || (0, _util.isUndefined)(value) || value === "0x" || value instanceof None) // anyhting empty we pass as-is
    return new None(registry);
    else if ((0, _util.isU8a)(value)) // the isU8a check happens last in the if-tree - since the wrapped value
    // may be an instance of it, so Type and Option checks go in first
    return !value.length || value[0] === 0 ? new None(registry) : new Type(registry, value.subarray(1));
    return new Type(registry, value);
}
class Option {
    #Type;
    #raw;
    constructor(registry, typeName, value, { definition , setDefinition =noopSetDefinition  } = {}){
        const Type = definition || setDefinition((0, _indexJs.typeToConstructor)(registry, typeName));
        const decoded = (0, _util.isU8a)(value) && value.length && !(0, _util.isCodec)(value) ? value[0] === 0 ? new None(registry) : new Type(registry, value.subarray(1)) : decodeOption(registry, Type, value);
        this.registry = registry;
        this.#Type = Type;
        this.#raw = decoded;
        if (decoded && decoded.initialU8aLength) this.initialU8aLength = 1 + decoded.initialU8aLength;
    }
    static with(Type) {
        let definition;
        const setDefinition = (d)=>{
            definition = d;
            return d;
        };
        return class extends Option {
            constructor(registry, value){
                super(registry, Type, value, {
                    definition,
                    setDefinition
                });
            }
        };
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        // boolean byte (has value, doesn't have) along with wrapped length
        return 1 + this.#raw.encodedLength;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Checks if the Option has no value
   */ get isEmpty() {
        return this.isNone;
    }
    /**
   * @description Checks if the Option has no value
   */ get isNone() {
        return this.#raw instanceof None;
    }
    /**
   * @description Checks if the Option has a value
   */ get isSome() {
        return !this.isNone;
    }
    /**
   * @description The actual value for the Option
   */ get value() {
        return this.#raw;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        if (other instanceof Option) return this.isSome === other.isSome && this.value.eq(other.value);
        return this.value.eq(other);
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        if (this.isNone) return {
            outer: [
                new Uint8Array([
                    0
                ])
            ]
        };
        const { inner , outer =[]  } = this.#raw.inspect();
        return {
            inner,
            outer: [
                new Uint8Array([
                    1
                ]),
                ...outer
            ]
        };
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        // This attempts to align with the JSON encoding - actually in this case
        // the isSome value is correct, however the `isNone` may be problematic
        return this.isNone ? "0x" : (0, _util.u8aToHex)(this.toU8a().subarray(1));
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        return this.#raw.toHuman(isExtended);
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.isNone ? null : this.#raw.toJSON();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.isNone ? null : this.#raw.toPrimitive();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType(isBare) {
        const wrapped = this.registry.getClassName(this.#Type) || new this.#Type(this.registry).toRawType();
        return isBare ? wrapped : `Option<${wrapped}>`;
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return this.#raw.toString();
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        if (isBare) return this.#raw.toU8a(true);
        const u8a = new Uint8Array(this.encodedLength);
        if (this.isSome) {
            u8a.set([
                1
            ]);
            u8a.set(this.#raw.toU8a(), 1);
        }
        return u8a;
    }
    /**
   * @description Returns the value that the Option represents (if available), throws if null
   */ unwrap() {
        if (this.isNone) throw new Error("Option: unwrapping a None value");
        return this.#raw;
    }
    /**
   * @description Returns the value that the Option represents (if available) or defaultValue if none
   * @param defaultValue The value to return if the option isNone
   */ unwrapOr(defaultValue) {
        return this.isSome ? this.unwrap() : defaultValue;
    }
    /**
   * @description Returns the value that the Option represents (if available) or defaultValue if none
   * @param defaultValue The value to return if the option isNone
   */ unwrapOrDefault() {
        return this.isSome ? this.unwrap() : new this.#Type(this.registry);
    }
}

},{"@polkadot/util":"3HnHw","../utils/index.js":"OTOl1","./Null.js":"9GkZn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hoW8i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Result
 * @description
 * A Result maps to the Rust Result type, that can either wrap a success or error value
 */ parcelHelpers.export(exports, "Result", ()=>Result);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _enumJs = require("./Enum.js");
class Result extends (0, _enumJs.Enum) {
    constructor(registry, Ok, Err, value){
        // NOTE This is order-dependent, Ok (with index 0) needs to be first
        // eslint-disable-next-line sort-keys
        super(registry, {
            Ok,
            Err
        }, value);
    }
    static with(Types) {
        return class extends Result {
            constructor(registry, value){
                super(registry, Types.Ok, Types.Err, value);
            }
        };
    }
    /**
   * @description Returns the wrapper Err value (if isErr)
   */ get asErr() {
        if (!this.isErr) throw new Error("Cannot extract Err value from Ok result, check isErr first");
        return this.value;
    }
    /**
   * @deprecated Use asErr
   */ get asError() {
        return this.asErr;
    }
    /**
   * @description Returns the wrapper Ok value (if isOk)
   */ get asOk() {
        if (!this.isOk) throw new Error("Cannot extract Ok value from Err result, check isOk first");
        return this.value;
    }
    /**
   * @description Checks if the Result has no value
   */ get isEmpty() {
        return this.isOk && this.value.isEmpty;
    }
    /**
   * @description Checks if the Result wraps an Err value
   */ get isErr() {
        return !this.isOk;
    }
    /**
   * @deprecated Use isErr
   */ get isError() {
        return this.isErr;
    }
    /**
   * @description Checks if the Result wraps an Ok value
   */ get isOk() {
        return this.index === 0;
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        const Types = this._toRawStruct();
        return `Result<${Types.Ok},${Types.Err}>`;
    }
}

},{"./Enum.js":"8x85c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jkm77":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Tuple
 * @description
 * A Tuple defines an anonymous fixed-length array, where each element has its
 * own type. It extends the base JS `Array` object.
 */ parcelHelpers.export(exports, "Tuple", ()=>Tuple);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _arrayJs = require("../abstract/Array.js");
var _indexJs = require("../utils/index.js");
function noopSetDefinition(d) {
    return d;
}
/** @internal */ function decodeTuple(registry, result, value, Classes) {
    if ((0, _util.isU8a)(value) || (0, _util.isHex)(value)) return (0, _indexJs.decodeU8a)(registry, result, (0, _util.u8aToU8a)(value), Classes);
    const Types = Classes[0];
    for(let i = 0; i < Types.length; i++)try {
        const entry = value === null || value === void 0 ? void 0 : value[i];
        result[i] = entry instanceof Types[i] ? entry : new Types[i](registry, entry);
    } catch (error) {
        throw new Error(`Tuple: failed on ${i}:: ${error.message}`);
    }
    return [
        result,
        0
    ];
}
class Tuple extends (0, _arrayJs.AbstractArray) {
    #Types;
    constructor(registry, Types, value, { definition , setDefinition =noopSetDefinition  } = {}){
        const Classes = definition || setDefinition(Array.isArray(Types) ? [
            Types.map((t)=>(0, _indexJs.typeToConstructor)(registry, t)),
            []
        ] : (0, _util.isFunction)(Types) || (0, _util.isString)(Types) ? [
            [
                (0, _indexJs.typeToConstructor)(registry, Types)
            ],
            []
        ] : (0, _indexJs.mapToTypeMap)(registry, Types));
        super(registry, Classes[0].length);
        this.initialU8aLength = ((0, _util.isU8a)(value) ? (0, _indexJs.decodeU8a)(registry, this, value, Classes) : decodeTuple(registry, this, value, Classes))[1];
        this.#Types = Classes;
    }
    static with(Types) {
        let definition; // eslint-disable-next-line no-return-assign
        const setDefinition = (d)=>definition = d;
        return class extends Tuple {
            constructor(registry, value){
                super(registry, Types, value, {
                    definition,
                    setDefinition
                });
            }
        };
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        let total = 0;
        for(let i = 0; i < this.length; i++)total += this[i].encodedLength;
        return total;
    }
    /**
   * @description The types definition of the tuple
   */ get Types() {
        return this.#Types[1].length ? this.#Types[1] : this.#Types[0].map((T)=>new T(this.registry).toRawType());
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            inner: this.inspectInner()
        };
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        const types = this.#Types[0].map((T)=>this.registry.getClassName(T) || new T(this.registry).toRawType());
        return `(${types.join(",")})`;
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        // Overwrite the default toString representation of Array.
        return (0, _util.stringify)(this.toJSON());
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        return (0, _util.u8aConcatStrict)(this.toU8aInner(isBare));
    }
}

},{"@polkadot/util":"3HnHw","../abstract/Array.js":"3VJuv","../utils/index.js":"OTOl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7DnCN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name UInt
 * @description
 * A generic unsigned integer codec. For Substrate all numbers are Little Endian encoded,
 * this handles the encoding and decoding of those numbers. Upon construction
 * the bitLength is provided and any additional use keeps the number to this
 * length. This extends `BN`, so all methods available on a normal `BN` object
 * is available here.
 * @noInheritDoc
 */ parcelHelpers.export(exports, "UInt", ()=>UInt);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _intJs = require("../abstract/Int.js");
class UInt extends (0, _intJs.AbstractInt) {
    static with(bitLength, typeName) {
        return class extends UInt {
            constructor(registry, value){
                super(registry, value, bitLength);
            }
            toRawType() {
                return typeName || super.toRawType();
            }
        };
    }
}

},{"../abstract/Int.js":"93VT5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpQbu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeVec", ()=>decodeVec);
/**
 * @name Vec
 * @description
 * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows
 * construction with the passed `Type` in the constructor. It is an extension to Array, providing
 * specific encoding/decoding on top of the base type.
 */ parcelHelpers.export(exports, "Vec", ()=>Vec);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _arrayJs = require("../abstract/Array.js");
var _indexJs = require("../utils/index.js");
const MAX_LENGTH = 65536;
const l = (0, _util.logger)("Vec");
function noopSetDefinition(d) {
    return d;
}
function decodeVecLength(value) {
    if (Array.isArray(value)) return [
        value,
        value.length,
        0
    ];
    const u8a = (0, _util.u8aToU8a)(value);
    const [startAt, length] = (0, _util.compactFromU8aLim)(u8a);
    if (length > MAX_LENGTH) throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);
    return [
        u8a,
        length,
        startAt
    ];
}
function decodeVec(registry, result, value, startAt, Type) {
    if (Array.isArray(value)) {
        const count = result.length;
        for(let i = 0; i < count; i++){
            const entry = value[i];
            try {
                result[i] = entry instanceof Type ? entry : new Type(registry, entry);
            } catch (error) {
                l.error(`Unable to decode on index ${i}`, error.message);
                throw error;
            }
        }
        return [
            0,
            0
        ];
    }
    return (0, _indexJs.decodeU8aVec)(registry, result, (0, _util.u8aToU8a)(value), startAt, Type);
}
class Vec extends (0, _arrayJs.AbstractArray) {
    #Type;
    constructor(registry, Type, value = [], { definition , setDefinition =noopSetDefinition  } = {}){
        const [decodeFrom, length, startAt] = decodeVecLength(value);
        super(registry, length);
        this.#Type = definition || setDefinition((0, _indexJs.typeToConstructor)(registry, Type));
        this.initialU8aLength = ((0, _util.isU8a)(decodeFrom) ? (0, _indexJs.decodeU8aVec)(registry, this, decodeFrom, startAt, this.#Type) : decodeVec(registry, this, decodeFrom, startAt, this.#Type))[0];
    }
    static with(Type) {
        let definition; // eslint-disable-next-line no-return-assign
        const setDefinition = (d)=>definition = d;
        return class extends Vec {
            constructor(registry, value){
                super(registry, Type, value, {
                    definition,
                    setDefinition
                });
            }
        };
    }
    /**
   * @description The type for the items
   */ get Type() {
        return this.#Type.name;
    }
    /**
   * @description Finds the index of the value in the array
   */ indexOf(_other) {
        // convert type first, this removes overhead from the eq
        const other = _other instanceof this.#Type ? _other : new this.#Type(this.registry, _other);
        for(let i = 0; i < this.length; i++){
            if (other.eq(this[i])) return i;
        }
        return -1;
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return `Vec<${this.registry.getClassName(this.#Type) || new this.#Type(this.registry).toRawType()}>`;
    }
}

},{"@polkadot/util":"3HnHw","../abstract/Array.js":"3VJuv","../utils/index.js":"OTOl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"863VH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name VecAny
 * @description
 * This manages codec arrays, assuming that the inputs are already of type Codec. Unlike
 * a vector, this can be used to manage array-like structures with variable arguments of
 * any types
 */ parcelHelpers.export(exports, "VecAny", ()=>VecAny);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _arrayJs = require("../abstract/Array.js");
class VecAny extends (0, _arrayJs.AbstractArray) {
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        // FIXME This is basically an any type, cannot instantiate via createType
        return "Vec<Codec>";
    }
}

},{"../abstract/Array.js":"3VJuv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7MlTe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name VecFixed
 * @description
 * This manages codec arrays of a fixed length
 */ parcelHelpers.export(exports, "VecFixed", ()=>VecFixed);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _arrayJs = require("../abstract/Array.js");
var _indexJs = require("../utils/index.js");
var _vecJs = require("./Vec.js");
function noopSetDefinition(d) {
    return d;
}
class VecFixed extends (0, _arrayJs.AbstractArray) {
    #Type;
    constructor(registry, Type, length, value = [], { definition , setDefinition =noopSetDefinition  } = {}){
        super(registry, length);
        this.#Type = definition || setDefinition((0, _indexJs.typeToConstructor)(registry, Type));
        this.initialU8aLength = ((0, _util.isU8a)(value) ? (0, _indexJs.decodeU8aVec)(registry, this, value, 0, this.#Type) : (0, _vecJs.decodeVec)(registry, this, value, 0, this.#Type))[1];
    }
    static with(Type, length) {
        let definition; // eslint-disable-next-line no-return-assign
        const setDefinition = (d)=>definition = d;
        return class extends VecFixed {
            constructor(registry, value){
                super(registry, Type, length, value, {
                    definition,
                    setDefinition
                });
            }
        };
    }
    /**
   * @description The type for the items
   */ get Type() {
        return new this.#Type(this.registry).toRawType();
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        let total = 0;
        for(let i = 0; i < this.length; i++)total += this[i].encodedLength;
        return total;
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            inner: this.inspectInner()
        };
    }
    toU8a() {
        // we override, we don't add the length prefix for ourselves, and at the same time we
        // ignore isBare on entries, since they should be properly encoded at all times
        const encoded = this.toU8aInner();
        return encoded.length ? (0, _util.u8aConcatStrict)(encoded) : new Uint8Array([]);
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return `[${this.Type};${this.length}]`;
    }
}

},{"@polkadot/util":"3HnHw","../abstract/Array.js":"3VJuv","../utils/index.js":"OTOl1","./Vec.js":"kpQbu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lWoC7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "BitVec", ()=>(0, _bitVecJs.BitVec));
parcelHelpers.export(exports, "BTreeMap", ()=>(0, _btreeMapJs.BTreeMap));
parcelHelpers.export(exports, "BTreeSet", ()=>(0, _btreeSetJs.BTreeSet));
parcelHelpers.export(exports, "Bytes", ()=>(0, _bytesJs.Bytes));
parcelHelpers.export(exports, "HashMap", ()=>(0, _hashMapJs.HashMap));
parcelHelpers.export(exports, "Linkage", ()=>(0, _linkageJs.Linkage));
parcelHelpers.export(exports, "CodecMap", ()=>(0, _mapJs.CodecMap));
parcelHelpers.export(exports, "Map", ()=>(0, _mapJs.CodecMap));
parcelHelpers.export(exports, "OptionBool", ()=>(0, _optionBoolJs.OptionBool));
parcelHelpers.export(exports, "Range", ()=>(0, _rangeJs.Range));
parcelHelpers.export(exports, "RangeInclusive", ()=>(0, _rangeInclusiveJs.RangeInclusive));
parcelHelpers.export(exports, "Type", ()=>(0, _typeJs.Type));
parcelHelpers.export(exports, "U8aFixed", ()=>(0, _u8AfixedJs.U8aFixed));
parcelHelpers.export(exports, "WrapperKeepOpaque", ()=>(0, _wrapperKeepOpaqueJs.WrapperKeepOpaque));
parcelHelpers.export(exports, "WrapperOpaque", ()=>(0, _wrapperOpaqueJs.WrapperOpaque));
var _bitVecJs = require("./BitVec.js");
var _btreeMapJs = require("./BTreeMap.js");
var _btreeSetJs = require("./BTreeSet.js");
var _bytesJs = require("./Bytes.js");
var _hashMapJs = require("./HashMap.js");
var _linkageJs = require("./Linkage.js");
var _mapJs = require("./Map.js");
var _optionBoolJs = require("./OptionBool.js");
var _rangeJs = require("./Range.js");
var _rangeInclusiveJs = require("./RangeInclusive.js");
var _typeJs = require("./Type.js");
var _u8AfixedJs = require("./U8aFixed.js");
var _wrapperKeepOpaqueJs = require("./WrapperKeepOpaque.js");
var _wrapperOpaqueJs = require("./WrapperOpaque.js");

},{"./BitVec.js":"fbVqP","./BTreeMap.js":"lo3j7","./BTreeSet.js":"7yOKt","./Bytes.js":"c9fmP","./HashMap.js":"5hgIJ","./Linkage.js":"314p9","./Map.js":"jH0oY","./OptionBool.js":"hhl9t","./Range.js":"aJaQy","./RangeInclusive.js":"3TUKZ","./Type.js":"9JZHM","./U8aFixed.js":"f9P3x","./WrapperKeepOpaque.js":"3vngl","./WrapperOpaque.js":"64KfQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fbVqP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name BitVec
 * @description
 * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this
 * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes
 */ parcelHelpers.export(exports, "BitVec", ()=>BitVec);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _rawJs = require("../native/Raw.js");
/** @internal */ function decodeBitVecU8a(value) {
    if (!value || !value.length) return [
        0,
        new Uint8Array()
    ];
     // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded
    const [offset, length] = (0, _util.compactFromU8aLim)(value);
    const total = offset + Math.ceil(length / 8);
    if (total > value.length) throw new Error(`BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);
    return [
        length,
        value.subarray(offset, total)
    ];
}
/** @internal */ function decodeBitVec(value) {
    if (Array.isArray(value) || (0, _util.isString)(value)) {
        const u8a = (0, _util.u8aToU8a)(value);
        return [
            u8a.length / 8,
            u8a
        ];
    }
    return decodeBitVecU8a(value);
}
class BitVec extends (0, _rawJs.Raw) {
    #decodedLength;
    #isMsb;
    // we are dealing with Lsb, which is the default (as of writing) BitVec format used
    // in the Polkadot code (this only affects the toHuman displays)
    constructor(registry, value, isMsb = false){
        const [decodedLength, u8a] = decodeBitVec(value);
        super(registry, u8a);
        this.#decodedLength = decodedLength;
        this.#isMsb = isMsb;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return this.length + (0, _util.compactToU8a)(this.#decodedLength).length;
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            outer: [
                (0, _util.compactToU8a)(this.#decodedLength),
                super.toU8a()
            ]
        };
    }
    toHuman() {
        return `0b${[
            ...this.toU8a(true)
        ].map((d)=>`00000000${d.toString(2)}`.slice(-8)).map((s)=>this.#isMsb ? s : s.split("").reverse().join("")).join("_")}`;
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "BitVec";
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        const bitVec = super.toU8a();
        return isBare ? bitVec : (0, _util.u8aConcatStrict)([
            (0, _util.compactToU8a)(this.#decodedLength),
            bitVec
        ]);
    }
}

},{"@polkadot/util":"3HnHw","../native/Raw.js":"1rSAv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1rSAv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Raw
 * @description
 * A basic wrapper around Uint8Array, with no frills and no fuss. It does differ
 * from other implementations where it will consume the full Uint8Array as passed to it.
 * As such it is meant to be subclassed where the wrapper takes care of the
 * actual lengths instead of used directly.
 * @noInheritDoc
 */ parcelHelpers.export(exports, "Raw", ()=>Raw);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
class Raw extends Uint8Array {
    /**
   * @description This ensures that operators such as clice, filter, map, etc. return
   * new Array instances (without this we need to apply overrides)
   */ static get [Symbol.species]() {
        return Uint8Array;
    }
    constructor(registry, value, initialU8aLength){
        super((0, _util.u8aToU8a)(value));
        this.registry = registry;
        this.initialU8aLength = initialU8aLength;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return this.length;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Returns true if the wrapped value contains only ASCII printable characters
   */ get isAscii() {
        return (0, _util.isAscii)(this);
    }
    /**
   * @description Returns true if the type wraps an empty/default all-0 value
   */ get isEmpty() {
        return !this.length || (0, _util.isUndefined)(this.find((b)=>!!b));
    }
    /**
   * @description Returns true if the wrapped value contains only utf8 characters
   */ get isUtf8() {
        return (0, _util.isUtf8)(this);
    }
    /**
   * @description Returns the number of bits in the value
   */ bitLength() {
        return this.length * 8;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        if (other instanceof Uint8Array) return this.length === other.length && !this.some((b, index)=>b !== other[index]);
        return this.eq((0, _util.u8aToU8a)(other));
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            outer: [
                this.toU8a()
            ]
        };
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        return (0, _util.u8aToHex)(this);
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toPrimitive();
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.toHex();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        if (this.isAscii) {
            const text = this.toUtf8(); // ensure we didn't end up with multibyte codepoints
            if ((0, _util.isAscii)(text)) return text;
        }
        return this.toJSON();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Raw";
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return this.toHex();
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toU8a(isBare) {
        return Uint8Array.from(this);
    }
    /**
   * @description Returns the wrapped data as a UTF-8 string
   */ toUtf8() {
        if (!this.isUtf8) throw new Error("The character sequence is not a valid Utf8 string");
        return (0, _util.u8aToString)(this);
    }
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lo3j7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BTreeMap", ()=>BTreeMap);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _mapJs = require("./Map.js");
class BTreeMap extends (0, _mapJs.CodecMap) {
    static with(keyType, valType) {
        return class extends BTreeMap {
            constructor(registry, value){
                super(registry, keyType, valType, value, "BTreeMap");
            }
        };
    }
}

},{"./Map.js":"jH0oY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jH0oY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CodecMap", ()=>CodecMap);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _arrayJs = require("../abstract/Array.js");
var _enumJs = require("../base/Enum.js");
var _rawJs = require("../native/Raw.js");
var _structJs = require("../native/Struct.js");
var _indexJs = require("../utils/index.js");
const l = (0, _util.logger)("Map");
/** @internal */ function decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {
    const output = new Map();
    const [offset, count] = (0, _util.compactFromU8aLim)(u8a);
    const types = [];
    for(let i = 0; i < count; i++)types.push(KeyClass, ValClass);
    const [values, decodedLength] = (0, _indexJs.decodeU8a)(registry, new Array(types.length), u8a.subarray(offset), [
        types,
        []
    ]);
    for(let i1 = 0; i1 < values.length; i1 += 2)output.set(values[i1], values[i1 + 1]);
    return [
        KeyClass,
        ValClass,
        output,
        offset + decodedLength
    ];
}
/** @internal */ function decodeMapFromMap(registry, KeyClass, ValClass, value) {
    const output = new Map();
    for (const [key, val] of value.entries()){
        const isComplex = KeyClass.prototype instanceof (0, _arrayJs.AbstractArray) || KeyClass.prototype instanceof (0, _structJs.Struct) || KeyClass.prototype instanceof (0, _enumJs.Enum);
        try {
            output.set(key instanceof KeyClass ? key : new KeyClass(registry, isComplex ? JSON.parse(key) : key), val instanceof ValClass ? val : new ValClass(registry, val));
        } catch (error) {
            l.error("Failed to decode key or value:", error.message);
            throw error;
        }
    }
    return [
        KeyClass,
        ValClass,
        output,
        0
    ];
}
/**
 * Decode input to pass into constructor.
 *
 * @param KeyClass - Type of the map key
 * @param ValClass - Type of the map value
 * @param value - Value to decode, one of:
 * - null
 * - undefined
 * - hex
 * - Uint8Array
 * - Map<any, any>, where both key and value types are either
 *   constructors or decodeable values for their types.
 * @param jsonMap
 * @internal
 */ function decodeMap(registry, keyType, valType, value) {
    const KeyClass = (0, _indexJs.typeToConstructor)(registry, keyType);
    const ValClass = (0, _indexJs.typeToConstructor)(registry, valType);
    if (!value) return [
        KeyClass,
        ValClass,
        new Map(),
        0
    ];
    else if ((0, _util.isU8a)(value) || (0, _util.isHex)(value)) return decodeMapFromU8a(registry, KeyClass, ValClass, (0, _util.u8aToU8a)(value));
    else if (value instanceof Map) return decodeMapFromMap(registry, KeyClass, ValClass, value);
    else if ((0, _util.isObject)(value)) return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));
    throw new Error("Map: cannot decode type");
}
class CodecMap extends Map {
    #KeyClass;
    #ValClass;
    #type;
    constructor(registry, keyType, valType, rawValue, type = "HashMap"){
        const [KeyClass, ValClass, decoded, decodedLength] = decodeMap(registry, keyType, valType, rawValue);
        super(type === "BTreeMap" ? (0, _indexJs.sortMap)(decoded) : decoded);
        this.registry = registry;
        this.initialU8aLength = decodedLength;
        this.#KeyClass = KeyClass;
        this.#ValClass = ValClass;
        this.#type = type;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        let len = (0, _util.compactToU8a)(this.size).length;
        for (const [k, v] of this.entries())len += k.encodedLength + v.encodedLength;
        return len;
    }
    /**
   * @description Returns a hash of the value
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Checks if the value is an empty value
   */ get isEmpty() {
        return this.size === 0;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return (0, _indexJs.compareMap)(this, other);
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        const inner = new Array();
        for (const [k, v] of this.entries()){
            inner.push(k.inspect());
            inner.push(v.inspect());
        }
        return {
            inner,
            outer: [
                (0, _util.compactToU8a)(this.size)
            ]
        };
    }
    /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */ toHex() {
        return (0, _util.u8aToHex)(this.toU8a());
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        const json = {};
        for (const [k, v] of this.entries())json[k instanceof (0, _rawJs.Raw) && k.isAscii ? k.toUtf8() : k.toString()] = v.toHuman(isExtended);
        return json;
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        const json = {};
        for (const [k, v] of this.entries())json[k.toString()] = v.toJSON();
        return json;
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        const json = {};
        for (const [k, v] of this.entries())json[k instanceof (0, _rawJs.Raw) && k.isAscii ? k.toUtf8() : k.toString()] = v.toPrimitive();
        return json;
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return `${this.#type}<${this.registry.getClassName(this.#KeyClass) || new this.#KeyClass(this.registry).toRawType()},${this.registry.getClassName(this.#ValClass) || new this.#ValClass(this.registry).toRawType()}>`;
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return (0, _util.stringify)(this.toJSON());
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        const encoded = new Array();
        if (!isBare) encoded.push((0, _util.compactToU8a)(this.size));
        for (const [k, v] of this.entries())encoded.push(k.toU8a(isBare), v.toU8a(isBare));
        return (0, _util.u8aConcatStrict)(encoded);
    }
}

},{"@polkadot/util":"3HnHw","../abstract/Array.js":"3VJuv","../base/Enum.js":"8x85c","../native/Raw.js":"1rSAv","../native/Struct.js":"fxcsD","../utils/index.js":"OTOl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fxcsD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Struct
 * @description
 * A Struct defines an Object with key-value pairs - where the values are Codec values. It removes
 * a lot of repetition from the actual coding, define a structure type, pass it the key/Codec
 * values in the constructor and it manages the decoding. It is important that the constructor
 * values matches 100% to the order in th Rust code, i.e. don't go crazy and make it alphabetical,
 * it needs to decoded in the specific defined order.
 * @noInheritDoc
 */ parcelHelpers.export(exports, "Struct", ()=>Struct);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../utils/index.js");
function noopSetDefinition(d) {
    return d;
}
/** @internal */ function decodeStructFromObject(registry, [Types, keys], value, jsonMap) {
    let jsonObj;
    const typeofArray = Array.isArray(value);
    const typeofMap = value instanceof Map;
    if (!typeofArray && !typeofMap && !(0, _util.isObject)(value)) throw new Error(`Struct: Cannot decode value ${(0, _util.stringify)(value)} (typeof ${typeof value}), expected an input object, map or array`);
    else if (typeofArray && value.length !== keys.length) throw new Error(`Struct: Unable to map ${(0, _util.stringify)(value)} array to object with known keys ${keys.join(", ")}`);
    const raw = new Array(keys.length);
    for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        const jsonKey = jsonMap.get(key) || key;
        const Type = Types[i];
        let assign;
        try {
            if (typeofArray) assign = value[i];
            else if (typeofMap) assign = jsonKey && value.get(jsonKey);
            else {
                assign = jsonKey && value[jsonKey];
                if ((0, _util.isUndefined)(assign)) {
                    if ((0, _util.isUndefined)(jsonObj)) {
                        const entries = Object.entries(value);
                        jsonObj = {};
                        for(let e = 0; e < entries.length; e++)jsonObj[(0, _util.stringCamelCase)(entries[e][0])] = entries[e][1];
                    }
                    assign = jsonKey && jsonObj[jsonKey];
                }
            }
            raw[i] = [
                key,
                assign instanceof Type ? assign : new Type(registry, assign)
            ];
        } catch (error) {
            let type = Type.name;
            try {
                type = new Type(registry).toRawType();
            } catch (error1) {}
            throw new Error(`Struct: failed on ${jsonKey}: ${type}:: ${error.message}`);
        }
    }
    return [
        raw,
        0
    ];
}
class Struct extends Map {
    #jsonMap;
    #Types;
    constructor(registry, Types, value, jsonMap = new Map(), { definition , setDefinition =noopSetDefinition  } = {}){
        const typeMap = definition || setDefinition((0, _indexJs.mapToTypeMap)(registry, Types));
        const [decoded, decodedLength] = (0, _util.isU8a)(value) || (0, _util.isHex)(value) ? (0, _indexJs.decodeU8aStruct)(registry, new Array(typeMap[0].length), (0, _util.u8aToU8a)(value), typeMap) : value instanceof Struct ? [
            value,
            0
        ] : decodeStructFromObject(registry, typeMap, value || {}, jsonMap);
        super(decoded);
        this.initialU8aLength = decodedLength;
        this.registry = registry;
        this.#jsonMap = jsonMap;
        this.#Types = typeMap;
    }
    static with(Types, jsonMap) {
        const keys = Object.keys(Types);
        let definition; // eslint-disable-next-line no-return-assign
        const setDefinition = (d)=>definition = d;
        return class extends Struct {
            constructor(registry, value){
                super(registry, Types, value, jsonMap, {
                    definition,
                    setDefinition
                });
                (0, _util.objectProperties)(this, keys, (k)=>this.get(k));
            }
        };
    }
    /**
   * @description The available keys for this struct
   */ get defKeys() {
        return this.#Types[1];
    }
    getT(key) {
        return this.get(key);
    }
    /**
   * @description Checks if the value is an empty value
   */ get isEmpty() {
        for (const v of this.values()){
            if (!v.isEmpty) return false;
        }
        return true;
    }
    /**
   * @description Returns the Type description of the structure
   */ get Type() {
        const result = {};
        const [Types, keys] = this.#Types;
        for(let i = 0; i < keys.length; i++)result[keys[i]] = new Types[i](this.registry).toRawType();
        return result;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        let total = 0;
        for (const v of this.values())total += v.encodedLength;
        return total;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return (0, _indexJs.compareMap)(this, other);
    }
    /**
   * @description Returns a specific names entry in the structure
   * @param name The name of the entry to retrieve
   */ get(name) {
        return super.get(name);
    }
    /**
   * @description Returns the values of a member at a specific index (Rather use get(name) for performance)
   */ getAtIndex(index) {
        return this.toArray()[index];
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect(isBare) {
        const inner = new Array();
        for (const [k, v] of this.entries())inner.push({
            ...v.inspect(!isBare || (0, _util.isBoolean)(isBare) ? isBare : isBare[k]),
            name: (0, _util.stringCamelCase)(k)
        });
        return {
            inner
        };
    }
    /**
   * @description Converts the Object to an standard JavaScript Array
   */ toArray() {
        return [
            ...this.values()
        ];
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        return (0, _util.u8aToHex)(this.toU8a());
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        const json = {};
        for (const [k, v] of this.entries())json[k] = v && v.toHuman(isExtended);
        return json;
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        const json = {};
        for (const [k, v] of this.entries()){
            const jsonKey = this.#jsonMap.get(k) || k; // We actually log inside the U8a decoding and use JSON.stringify(...), which
            // means that the Vec may be partially populated (same applies to toHuman, same check)
            json[jsonKey] = v && v.toJSON();
        }
        return json;
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        const json = {};
        for (const [k, v] of this.entries()){
            const jsonKey = this.#jsonMap.get(k) || k; // We actually log inside the U8a decoding and use JSON.stringify(...), which
            // means that the Vec may be partially populated (same applies to toHuman, same check)
            json[jsonKey] = v && v.toPrimitive();
        }
        return json;
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return (0, _util.stringify)((0, _indexJs.typesToMap)(this.registry, this.#Types));
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return (0, _util.stringify)(this.toJSON());
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        const encoded = [];
        for (const [k, v] of this.entries())if (v && (0, _util.isFunction)(v.toU8a)) encoded.push(v.toU8a(!isBare || (0, _util.isBoolean)(isBare) ? isBare : isBare[k]));
        return (0, _util.u8aConcatStrict)(encoded);
    }
}

},{"@polkadot/util":"3HnHw","../utils/index.js":"OTOl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7yOKt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BTreeSet", ()=>BTreeSet);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../utils/index.js");
const l = (0, _util.logger)("BTreeSet");
/** @internal */ function decodeSetFromU8a(registry, ValClass, u8a) {
    const output = new Set();
    const [offset, count] = (0, _util.compactFromU8aLim)(u8a);
    const result = new Array(count);
    const [decodedLength] = (0, _indexJs.decodeU8aVec)(registry, result, u8a, offset, ValClass);
    for(let i = 0; i < count; i++)output.add(result[i]);
    return [
        ValClass,
        output,
        decodedLength
    ];
}
/** @internal */ function decodeSetFromSet(registry, ValClass, value) {
    const output = new Set();
    value.forEach((val)=>{
        try {
            output.add(val instanceof ValClass ? val : new ValClass(registry, val));
        } catch (error) {
            l.error("Failed to decode key or value:", error.message);
            throw error;
        }
    });
    return [
        ValClass,
        output,
        0
    ];
}
/**
 * Decode input to pass into constructor.
 *
 * @param ValClass - Type of the map value
 * @param value - Value to decode, one of:
 * - null
 * - undefined
 * - hex
 * - Uint8Array
 * - Set<any>, where both key and value types are either
 *   constructors or decodeable values for their types.
 * @param jsonSet
 * @internal
 */ function decodeSet(registry, valType, value) {
    const ValClass = (0, _indexJs.typeToConstructor)(registry, valType);
    if (!value) return [
        ValClass,
        new Set(),
        0
    ];
    else if ((0, _util.isU8a)(value) || (0, _util.isHex)(value)) return decodeSetFromU8a(registry, ValClass, (0, _util.u8aToU8a)(value));
    else if (Array.isArray(value) || value instanceof Set) return decodeSetFromSet(registry, ValClass, value);
    throw new Error("BTreeSet: cannot decode type");
}
class BTreeSet extends Set {
    #ValClass;
    constructor(registry, valType, rawValue){
        const [ValClass, values, decodedLength] = decodeSet(registry, valType, rawValue);
        super((0, _indexJs.sortSet)(values));
        this.registry = registry;
        this.initialU8aLength = decodedLength;
        this.#ValClass = ValClass;
    }
    static with(valType) {
        return class extends BTreeSet {
            constructor(registry, value){
                super(registry, valType, value);
            }
        };
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        let len = (0, _util.compactToU8a)(this.size).length;
        for (const v of this.values())len += v.encodedLength;
        return len;
    }
    /**
   * @description Returns a hash of the value
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Checks if the value is an empty value
   */ get isEmpty() {
        return this.size === 0;
    }
    /**
   * @description The actual set values as a string[]
   */ get strings() {
        return [
            ...super.values()
        ].map((v)=>v.toString());
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return (0, _indexJs.compareSet)(this, other);
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        const inner = new Array();
        for (const v of this.values())inner.push(v.inspect());
        return {
            inner,
            outer: [
                (0, _util.compactToU8a)(this.size)
            ]
        };
    }
    /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */ toHex() {
        return (0, _util.u8aToHex)(this.toU8a());
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        const json = [];
        for (const v of this.values())json.push(v.toHuman(isExtended));
        return json;
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        const json = [];
        for (const v of this.values())json.push(v.toJSON());
        return json;
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return `BTreeSet<${this.registry.getClassName(this.#ValClass) || new this.#ValClass(this.registry).toRawType()}>`;
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        const json = [];
        for (const v of this.values())json.push(v.toPrimitive());
        return json;
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return (0, _util.stringify)(this.toJSON());
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        const encoded = new Array();
        if (!isBare) encoded.push((0, _util.compactToU8a)(this.size));
        for (const v of this.values())encoded.push(v.toU8a(isBare));
        return (0, _util.u8aConcatStrict)(encoded);
    }
}

},{"@polkadot/util":"3HnHw","../utils/index.js":"OTOl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c9fmP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Bytes
 * @description
 * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array
 * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same
 * as what is found in [[Text]] and [[Vec]])
 */ parcelHelpers.export(exports, "Bytes", ()=>Bytes);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _rawJs = require("../native/Raw.js"); // Bytes are used for things like on-chain code, so it has a healthy limit
const MAX_LENGTH = 10485760;
/** @internal */ function decodeBytesU8a(value) {
    if (!value.length) return [
        new Uint8Array(),
        0
    ];
     // handle all other Uint8Array inputs, these do have a length prefix
    const [offset, length] = (0, _util.compactFromU8aLim)(value);
    const total = offset + length;
    if (length > MAX_LENGTH) throw new Error(`Bytes length ${length.toString()} exceeds ${MAX_LENGTH}`);
    else if (total > value.length) throw new Error(`Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);
    return [
        value.subarray(offset, total),
        total
    ];
}
class Bytes extends (0, _rawJs.Raw) {
    constructor(registry, value){
        const [u8a, decodedLength] = (0, _util.isU8a)(value) && !(value instanceof (0, _rawJs.Raw)) ? decodeBytesU8a(value) : Array.isArray(value) || (0, _util.isString)(value) ? [
            (0, _util.u8aToU8a)(value),
            0
        ] : [
            value,
            0
        ];
        super(registry, u8a, decodedLength);
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return this.length + (0, _util.compactToU8a)(this.length).length;
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect(isBare) {
        const clength = (0, _util.compactToU8a)(this.length);
        return {
            outer: isBare ? [
                super.toU8a()
            ] : this.length ? [
                clength,
                super.toU8a()
            ] : [
                clength
            ]
        };
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Bytes";
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        return isBare ? super.toU8a(isBare) : (0, _util.compactAddLength)(this);
    }
}

},{"@polkadot/util":"3HnHw","../native/Raw.js":"1rSAv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5hgIJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HashMap", ()=>HashMap);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _mapJs = require("./Map.js");
class HashMap extends (0, _mapJs.CodecMap) {
    static with(keyType, valType) {
        return class extends HashMap {
            constructor(registry, value){
                super(registry, keyType, valType, value);
            }
        };
    }
}

},{"./Map.js":"jH0oY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"314p9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Linkage
 * @description The wrapper for the result from a LinkedMap
 */ parcelHelpers.export(exports, "Linkage", ()=>Linkage);
/**
 * @name LinkageResult
 * @description A Linkage keys/Values tuple
 */ parcelHelpers.export(exports, "LinkageResult", ()=>LinkageResult);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _optionJs = require("../base/Option.js");
var _tupleJs = require("../base/Tuple.js");
var _vecJs = require("../base/Vec.js");
var _structJs = require("../native/Struct.js");
const EMPTY = new Uint8Array();
class Linkage extends (0, _structJs.Struct) {
    constructor(registry, Type, value){
        super(registry, {
            previous: (0, _optionJs.Option).with(Type),
            // eslint-disable-next-line sort-keys
            next: (0, _optionJs.Option).with(Type)
        }, value);
    }
    static withKey(Type) {
        return class extends Linkage {
            constructor(registry, value){
                super(registry, Type, value);
            }
        };
    }
    get previous() {
        return this.get("previous");
    }
    get next() {
        return this.get("next");
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return `Linkage<${this.next.toRawType(true)}>`;
    }
    /**
   * @description Custom toU8a which with bare mode does not return the linkage if empty
   */ toU8a() {
        // As part of a storage query (where these appear), in the case of empty, the values
        // are NOT populated by the node - follow the same logic, leaving it empty
        return this.isEmpty ? EMPTY : super.toU8a();
    }
}
class LinkageResult extends (0, _tupleJs.Tuple) {
    constructor(registry, [TypeKey, keys], [TypeValue, values]){
        super(registry, {
            Keys: (0, _vecJs.Vec).with(TypeKey),
            Values: (0, _vecJs.Vec).with(TypeValue)
        }, [
            keys,
            values
        ]);
    }
}

},{"../base/Option.js":"gqQka","../base/Tuple.js":"jkm77","../base/Vec.js":"kpQbu","../native/Struct.js":"fxcsD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hhl9t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name OptionBool
 * @description A specific implementation of Option<bool> than allows for single-byte encoding
 */ parcelHelpers.export(exports, "OptionBool", ()=>OptionBool);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _optionJs = require("../base/Option.js");
var _boolJs = require("../native/Bool.js");
function decodeU8a(registry, value) {
    // Encoded as -
    //  - 0 = None
    //  - 1 = True
    //  - 2 = False
    return value[0] === 0 ? null : new (0, _boolJs.bool)(registry, value[0] === 1);
}
class OptionBool extends (0, _optionJs.Option) {
    constructor(registry, value){
        super(registry, (0, _boolJs.bool), (0, _util.isU8a)(value) || (0, _util.isHex)(value) ? decodeU8a(registry, (0, _util.u8aToU8a)(value)) : value);
        this.initialU8aLength = 1;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return 1;
    }
    /**
   * @description Checks if the value is an empty value (always false)
   */ get isFalse() {
        return this.isSome ? !this.value.valueOf() : false;
    }
    /**
   * @description Checks if the value is an empty value (always false)
   */ get isTrue() {
        return this.isSome ? this.value.valueOf() : false;
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            outer: [
                this.toU8a()
            ]
        };
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType(isBare) {
        return isBare ? "bool" : "Option<bool>";
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        if (isBare) return super.toU8a(true);
        return this.isSome ? new Uint8Array([
            this.isTrue ? 1 : 2
        ]) : new Uint8Array([
            0
        ]);
    }
}

},{"@polkadot/util":"3HnHw","../base/Option.js":"gqQka","../native/Bool.js":"d2Fo5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d2Fo5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name bool
 * @description
 * Representation for a boolean value in the system. It extends the base JS `Boolean` class
 * @noInheritDoc
 */ parcelHelpers.export(exports, "bool", ()=>bool);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
class bool extends Boolean {
    constructor(registry, value = false){
        super((0, _util.isU8a)(value) ? value[0] === 1 : value instanceof Boolean ? value.valueOf() : !!value);
        this.registry = registry;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return 1;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Checks if the value is an empty value (true when it wraps false/default)
   */ get isEmpty() {
        return this.isFalse;
    }
    /**
   * @description Checks if the value is an empty value (always false)
   */ get isFalse() {
        return !this.isTrue;
    }
    /**
   * @description Checks if the value is an empty value (always false)
   */ get isTrue() {
        return this.valueOf();
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return this.valueOf() === (other instanceof Boolean ? other.valueOf() : other);
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            outer: [
                this.toU8a()
            ]
        };
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        return (0, _util.u8aToHex)(this.toU8a());
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toJSON();
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.valueOf();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.toJSON();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "bool";
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return this.toJSON().toString();
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toU8a(isBare) {
        return new Uint8Array([
            this.valueOf() ? 1 : 0
        ]);
    }
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aJaQy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Range
 * @description
 * Rust `Range<T>` representation
 */ parcelHelpers.export(exports, "Range", ()=>Range);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _tupleJs = require("../base/Tuple.js");
class Range extends (0, _tupleJs.Tuple) {
    #rangeName;
    constructor(registry, Type, value, { rangeName ="Range"  } = {}){
        super(registry, [
            Type,
            Type
        ], value);
        this.#rangeName = rangeName;
    }
    static with(Type) {
        return class extends Range {
            constructor(registry, value){
                super(registry, Type, value);
            }
        };
    }
    /**
   * @description Returns the starting range value
   */ get start() {
        return this[0];
    }
    /**
   * @description Returns the ending range value
   */ get end() {
        return this[1];
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return `${this.#rangeName}<${this.start.toRawType()}>`;
    }
}

},{"../base/Tuple.js":"jkm77","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3TUKZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RangeInclusive", ()=>RangeInclusive);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rangeJs = require("./Range.js");
class RangeInclusive extends (0, _rangeJs.Range) {
    constructor(registry, Type, value){
        super(registry, Type, value, {
            rangeName: "RangeInclusive"
        });
    }
    static with(Type) {
        return class extends RangeInclusive {
            constructor(registry, value){
                super(registry, Type, value);
            }
        };
    }
}

},{"./Range.js":"aJaQy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9JZHM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Type
 * @description
 * This is a extended version of Text, specifically to handle types. Here we rely fully
 * on what Text provides us, however we also adjust the types received from the runtime,
 * i.e. we remove the `T::` prefixes found in some types for consistency across implementation.
 */ parcelHelpers.export(exports, "Type", ()=>Type);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _textJs = require("../native/Text.js");
var _indexJs = require("../utils/index.js");
class Type extends (0, _textJs.Text) {
    constructor(registry, value = ""){
        super(registry, value);
        this.setOverride((0, _indexJs.sanitize)(this.toString()));
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Type";
    }
}

},{"../native/Text.js":"HLBie","../utils/index.js":"OTOl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"HLBie":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Text
 * @description
 * This is a string wrapper, along with the length. It is used both for strings as well
 * as items such as documentation. It simply extends the standard JS `String` built-in
 * object, inheriting all methods exposed from `String`.
 * @noInheritDoc
 */ parcelHelpers.export(exports, "Text", ()=>Text);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _rawJs = require("./Raw.js");
const MAX_LENGTH = 131072;
/** @internal */ function decodeText(value) {
    if ((0, _util.isU8a)(value)) {
        if (!value.length) return [
            "",
            0
        ];
         // for Raw, the internal buffer does not have an internal length
        // (the same applies in e.g. Bytes, where length is added at encoding-time)
        if (value instanceof (0, _rawJs.Raw)) return [
            (0, _util.u8aToString)(value),
            0
        ];
        const [offset, length] = (0, _util.compactFromU8aLim)(value);
        const total = offset + length;
        if (length > MAX_LENGTH) throw new Error(`Text: length ${length.toString()} exceeds ${MAX_LENGTH}`);
        else if (total > value.length) throw new Error(`Text: required length less than remainder, expected at least ${total}, found ${value.length}`);
        return [
            (0, _util.u8aToString)(value.subarray(offset, total)),
            total
        ];
    } else if ((0, _util.isHex)(value)) return [
        (0, _util.u8aToString)((0, _util.hexToU8a)(value)),
        0
    ];
    return [
        value ? value.toString() : "",
        0
    ];
}
class Text extends String {
    #override = null;
    constructor(registry, value){
        const [str, decodedLength] = decodeText(value);
        super(str);
        this.registry = registry;
        this.initialU8aLength = decodedLength;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return this.toU8a().length;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Checks if the value is an empty value
   */ get isEmpty() {
        return this.length === 0;
    }
    /**
   * @description The length of the value
   */ get length() {
        // only included here since we ignore inherited docs
        return super.length;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return (0, _util.isString)(other) ? this.toString() === other.toString() : false;
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        const value = (0, _util.stringToU8a)(super.toString());
        return {
            outer: value.length ? [
                (0, _util.compactToU8a)(value.length),
                value
            ] : [
                (0, _util.compactToU8a)(value.length)
            ]
        };
    }
    /**
   * @description Set an override value for this
   */ setOverride(override) {
        this.#override = override;
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        // like with Vec<u8>, when we are encoding to hex, we don't actually add
        // the length prefix (it is already implied by the actual string length)
        return (0, _util.u8aToHex)(this.toU8a(true));
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toJSON();
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.toString();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.toJSON();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Text";
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return this.#override || super.toString();
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        // NOTE Here we use the super toString (we are not taking overrides into account,
        // rather encoding the original value the string was constructed with)
        const encoded = (0, _util.stringToU8a)(super.toString());
        return isBare ? encoded : (0, _util.compactAddLength)(encoded);
    }
}

},{"@polkadot/util":"3HnHw","./Raw.js":"1rSAv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f9P3x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name U8aFixed
 * @description
 * A U8a that manages a a sequence of bytes up to the specified bitLength. Not meant
 * to be used directly, rather is should be subclassed with the specific lengths.
 */ parcelHelpers.export(exports, "U8aFixed", ()=>U8aFixed);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _rawJs = require("../native/Raw.js");
/** @internal */ function decodeU8aFixed(value, bitLength) {
    const u8a = (0, _util.u8aToU8a)(value);
    const byteLength = bitLength / 8;
    if (!u8a.length) return [
        new Uint8Array(byteLength),
        0
    ];
    if ((0, _util.isU8a)(value) ? u8a.length < byteLength : u8a.length !== byteLength) throw new Error(`Expected input with ${byteLength} bytes (${bitLength} bits), found ${u8a.length} bytes`);
    return [
        u8a.subarray(0, byteLength),
        byteLength
    ];
}
class U8aFixed extends (0, _rawJs.Raw) {
    constructor(registry, value = new Uint8Array(), bitLength = 256){
        const [u8a, decodedLength] = decodeU8aFixed(value, bitLength);
        super(registry, u8a, decodedLength);
    }
    static with(bitLength, typeName) {
        return class extends U8aFixed {
            constructor(registry, value){
                super(registry, value, bitLength);
            }
            toRawType() {
                return typeName || super.toRawType();
            }
        };
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return `[u8;${this.length}]`;
    }
}

},{"@polkadot/util":"3HnHw","../native/Raw.js":"1rSAv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3vngl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WrapperKeepOpaque", ()=>WrapperKeepOpaque);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _rawJs = require("../native/Raw.js");
var _indexJs = require("../utils/index.js");
var _bytesJs = require("./Bytes.js");
function decodeRaw(registry, typeName, value) {
    const Type = (0, _indexJs.typeToConstructor)(registry, typeName);
    if ((0, _util.isU8a)(value) || (0, _util.isHex)(value)) try {
        const [, u8a] = (0, _util.isHex)(value) ? [
            0,
            (0, _util.u8aToU8a)(value)
        ] : value instanceof (0, _rawJs.Raw) ? [
            0,
            value.subarray()
        ] : (0, _util.compactStripLength)(value);
        return [
            Type,
            new Type(registry, u8a),
            value
        ];
    } catch  {
        return [
            Type,
            null,
            value
        ];
    }
    const instance = new Type(registry, value);
    return [
        Type,
        instance,
        (0, _util.compactAddLength)(instance.toU8a())
    ];
}
class WrapperKeepOpaque extends (0, _bytesJs.Bytes) {
    #Type;
    #decoded;
    #opaqueName;
    constructor(registry, typeName, value, { opaqueName ="WrapperKeepOpaque"  } = {}){
        const [Type, decoded, u8a] = decodeRaw(registry, typeName, value);
        super(registry, u8a);
        this.#Type = Type;
        this.#decoded = decoded;
        this.#opaqueName = opaqueName;
    }
    static with(Type) {
        return class extends WrapperKeepOpaque {
            constructor(registry, value){
                super(registry, Type, value);
            }
        };
    }
    /**
   * @description Checks if the wrapper is decodable
   */ get isDecoded() {
        return !!this.#decoded;
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return this.#decoded ? {
            inner: [
                this.#decoded.inspect()
            ],
            outer: [
                (0, _util.compactToU8a)(this.length)
            ]
        } : {
            outer: [
                (0, _util.compactToU8a)(this.length),
                this.toU8a(true)
            ]
        };
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        return this.#decoded ? this.#decoded.toHuman(isExtended) : super.toHuman();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.#decoded ? this.#decoded.toPrimitive() : super.toPrimitive();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return `${this.#opaqueName}<${this.registry.getClassName(this.#Type) || (this.#decoded ? this.#decoded.toRawType() : new this.#Type(this.registry).toRawType())}>`;
    }
    /**
   * @description Converts the Object to to a string (either decoded or bytes)
   */ toString() {
        return this.#decoded ? this.#decoded.toString() : super.toString();
    }
    /**
   * @description Returns the decoded that the WrapperKeepOpaque represents (if available), throws if non-decodable
   */ unwrap() {
        if (!this.#decoded) throw new Error(`${this.#opaqueName}: unwrapping an undecodable value`);
        return this.#decoded;
    }
}

},{"@polkadot/util":"3HnHw","../native/Raw.js":"1rSAv","../utils/index.js":"OTOl1","./Bytes.js":"c9fmP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"64KfQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WrapperOpaque", ()=>WrapperOpaque);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _wrapperKeepOpaqueJs = require("./WrapperKeepOpaque.js");
class WrapperOpaque extends (0, _wrapperKeepOpaqueJs.WrapperKeepOpaque) {
    constructor(registry, typeName, value){
        super(registry, typeName, value, {
            opaqueName: "WrapperOpaque"
        });
    }
    static with(Type) {
        return class extends WrapperOpaque {
            constructor(registry, value){
                super(registry, Type, value);
            }
        };
    }
    /**
   * @description The inner value for this wrapper, in all cases it _should_ be decodable (unlike KeepOpaque)
   */ get inner() {
        return this.unwrap();
    }
}

},{"./WrapperKeepOpaque.js":"3vngl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gMGnS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "bool", ()=>(0, _boolJs.bool));
parcelHelpers.export(exports, "Bool", ()=>(0, _boolJs.bool));
parcelHelpers.export(exports, "CodecDate", ()=>(0, _dateJs.CodecDate));
parcelHelpers.export(exports, "Date", ()=>(0, _dateJs.CodecDate));
parcelHelpers.export(exports, "Float", ()=>(0, _floatJs.Float));
parcelHelpers.export(exports, "Json", ()=>(0, _jsonJs.Json));
parcelHelpers.export(exports, "Raw", ()=>(0, _rawJs.Raw));
parcelHelpers.export(exports, "CodecSet", ()=>(0, _setJs.CodecSet));
parcelHelpers.export(exports, "Set", ()=>(0, _setJs.CodecSet));
parcelHelpers.export(exports, "Struct", ()=>(0, _structJs.Struct));
parcelHelpers.export(exports, "Text", ()=>(0, _textJs.Text));
var _boolJs = require("./Bool.js");
var _dateJs = require("./Date.js");
var _floatJs = require("./Float.js");
var _jsonJs = require("./Json.js");
var _rawJs = require("./Raw.js");
var _setJs = require("./Set.js");
var _structJs = require("./Struct.js");
var _textJs = require("./Text.js");

},{"./Bool.js":"d2Fo5","./Date.js":"be6yM","./Float.js":"9v5v9","./Json.js":"hmUkQ","./Raw.js":"1rSAv","./Set.js":"644Dd","./Struct.js":"fxcsD","./Text.js":"HLBie","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"be6yM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Date
 * @description
 * A wrapper around seconds/timestamps. Internally the representation only has
 * second precicion (aligning with Rust), so any numbers passed an/out are always
 * per-second. For any encoding/decoding the 1000 multiplier would be applied to
 * get it in line with JavaScript formats. It extends the base JS `Date` object
 * and has all the methods available that are applicable to any `Date`
 * @noInheritDoc
 */ parcelHelpers.export(exports, "CodecDate", ()=>CodecDate);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const BITLENGTH = 64;
const U8A_OPTS = {
    bitLength: BITLENGTH,
    isLe: true
};
function decodeDate(value) {
    if ((0, _util.isU8a)(value)) value = (0, _util.u8aToBn)(value.subarray(0, BITLENGTH / 8));
    else if (value instanceof Date) return value;
    else if ((0, _util.isString)(value)) value = new (0, _util.BN)(value.toString(), 10, "le");
    return new Date((0, _util.bnToBn)(value).toNumber() * 1000);
}
class CodecDate extends Date {
    constructor(registry, value = 0){
        super(decodeDate(value));
        this.registry = registry;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return BITLENGTH / 8;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Checks if the value is an empty value
   */ get isEmpty() {
        return this.getTime() === 0;
    }
    /**
   * @description Returns the number of bits in the value
   */ bitLength() {
        return BITLENGTH;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return decodeDate(other).getTime() === this.getTime();
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            outer: [
                this.toU8a()
            ]
        };
    }
    /**
   * @description Returns a BigInt representation of the number
   */ toBigInt() {
        return BigInt(this.toNumber());
    }
    /**
   * @description Returns the BN representation of the timestamp
   */ toBn() {
        return new (0, _util.BN)(this.toNumber());
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex(isLe = false) {
        return (0, _util.bnToHex)(this.toBn(), {
            bitLength: BITLENGTH,
            isLe,
            isNegative: false
        });
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toISOString();
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        // FIXME Return type should be number, but conflicts with Date.toJSON()
        // which returns string
        return this.toNumber();
    }
    /**
   * @description Returns the number representation for the timestamp
   */ toNumber() {
        return Math.ceil(this.getTime() / 1000);
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.toNumber();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Moment";
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        // only included here since we do not inherit docs
        return super.toString();
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toU8a(isBare) {
        return (0, _util.bnToU8a)(this.toNumber(), U8A_OPTS);
    }
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9v5v9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Float
 * @description
 * A Codec wrapper for F32 & F64 values. You generally don't want to be using
 * f32/f64 in your runtime, operations on fixed points numbers are preferable. This class
 * was explicitly added since scale-codec has a flag that enables this and it is available
 * in some eth_* RPCs
 */ parcelHelpers.export(exports, "Float", ()=>Float);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
class Float extends Number {
    #bitLength;
    constructor(registry, value, { bitLength =32  } = {}){
        super((0, _util.isU8a)(value) || (0, _util.isHex)(value) ? value.length === 0 ? 0 : (0, _util.u8aToFloat)((0, _util.u8aToU8a)(value), {
            bitLength
        }) : value || 0);
        this.#bitLength = bitLength;
        this.encodedLength = bitLength / 8;
        this.initialU8aLength = this.encodedLength;
        this.registry = registry;
    }
    static with(bitLength) {
        return class extends Float {
            constructor(registry, value){
                super(registry, value, {
                    bitLength
                });
            }
        };
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Returns true if the type wraps an empty/default all-0 value
   */ get isEmpty() {
        return this.valueOf() === 0;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return this.valueOf() === Number(other);
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            outer: [
                this.toU8a()
            ]
        };
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        return (0, _util.u8aToHex)(this.toU8a());
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toString();
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        // Not sure if this is actually a hex or a string value
        // (would need to check against RPCs to see the result here)
        return this.toHex();
    }
    /**
   * @description Returns the number representation (Same as valueOf)
   */ toNumber() {
        return this.valueOf();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.toNumber();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return `f${this.#bitLength}`;
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */ toU8a() {
        return (0, _util.floatToU8a)(this, {
            bitLength: this.#bitLength
        });
    }
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hmUkQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Json
 * @description
 * Wraps the a JSON structure retrieve via RPC. It extends the standard JS Map with. While it
 * implements a Codec, it is limited in that it can only be used with input objects via RPC,
 * i.e. no hex decoding. Unlike a struct, this waps a JSON object with unknown keys
 * @noInheritDoc
 */ parcelHelpers.export(exports, "Json", ()=>Json);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../utils/index.js");
/** @internal */ function decodeJson(value) {
    return Object.entries(value || {});
}
class Json extends Map {
    constructor(registry, value){
        const decoded = decodeJson(value);
        super(decoded);
        this.registry = registry;
        (0, _util.objectProperties)(this, decoded.map(([k])=>k), (k)=>this.get(k));
    }
    /**
   * @description Always 0, never encodes as a Uint8Array
   */ get encodedLength() {
        return 0;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description Checks if the value is an empty value
   */ get isEmpty() {
        return [
            ...this.keys()
        ].length === 0;
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return (0, _indexJs.compareMap)(this, other);
    }
    /**
   * @description Returns a typed value from the internal map
   */ getT(key) {
        return this.get(key);
    }
    /**
   * @description Unimplemented, will throw
   */ inspect() {
        throw new Error("Unimplemented");
    }
    /**
   * @description Unimplemented, will throw
   */ toHex() {
        throw new Error("Unimplemented");
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return [
            ...this.entries()
        ].reduce((json, [key, value])=>{
            json[key] = (0, _util.isFunction)(value.toHuman) ? value.toHuman() : value;
            return json;
        }, {});
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return [
            ...this.entries()
        ].reduce((json, [key, value])=>{
            json[key] = value;
            return json;
        }, {});
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return [
            ...this.entries()
        ].reduce((json, [key, value])=>{
            json[key] = (0, _util.isFunction)(value.toHuman) ? value.toPrimitive() : value;
            return json;
        }, {});
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Json";
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return (0, _util.stringify)(this.toJSON());
    }
    /**
   * @description Unimplemented, will throw
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toU8a(isBare) {
        throw new Error("Unimplemented");
    }
}

},{"@polkadot/util":"3HnHw","../utils/index.js":"OTOl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"644Dd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Set
 * @description
 * An Set is an array of string values, represented an an encoded type by
 * a bitwise representation of the values.
 */ parcelHelpers.export(exports, "CodecSet", ()=>CodecSet);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../utils/index.js");
function encodeSet(setValues, values) {
    const encoded = new (0, _util.BN)(0);
    for(let i = 0; i < values.length; i++)encoded.ior((0, _util.bnToBn)(setValues[values[i]] || 0));
    return encoded;
}
/** @internal */ function decodeSetArray(setValues, values) {
    const result = new Array(values.length);
    for(let i = 0; i < values.length; i++){
        const key = values[i];
        if ((0, _util.isUndefined)(setValues[key])) throw new Error(`Set: Invalid key '${key}' passed to Set, allowed ${Object.keys(setValues).join(", ")}`);
        result[i] = key;
    }
    return result;
}
/** @internal */ function decodeSetNumber(setValues, _value) {
    const bn = (0, _util.bnToBn)(_value);
    const keys = Object.keys(setValues);
    const result = [];
    for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        if (bn.and((0, _util.bnToBn)(setValues[key])).eq((0, _util.bnToBn)(setValues[key]))) result.push(key);
    }
    const computed = encodeSet(setValues, result);
    if (!bn.eq(computed)) throw new Error(`Set: Mismatch decoding '${bn.toString()}', computed as '${computed.toString()}' with ${result.join(", ")}`);
    return result;
}
/** @internal */ function decodeSet(setValues, value = 0, bitLength) {
    if (bitLength % 8 !== 0) throw new Error(`Expected valid bitLength, power of 8, found ${bitLength}`);
    const byteLength = bitLength / 8;
    if ((0, _util.isU8a)(value)) return value.length === 0 ? [] : decodeSetNumber(setValues, (0, _util.u8aToBn)(value.subarray(0, byteLength), {
        isLe: true
    }));
    else if ((0, _util.isString)(value)) return decodeSet(setValues, (0, _util.u8aToU8a)(value), byteLength);
    else if (value instanceof Set || Array.isArray(value)) {
        const input = Array.isArray(value) ? value : [
            ...value.values()
        ];
        return decodeSetArray(setValues, input);
    }
    return decodeSetNumber(setValues, value);
}
class CodecSet extends Set {
    #allowed;
    #byteLength;
    constructor(registry, setValues, value, bitLength = 8){
        super(decodeSet(setValues, value, bitLength));
        this.registry = registry;
        this.#allowed = setValues;
        this.#byteLength = bitLength / 8;
    }
    static with(values, bitLength) {
        const keys = Object.keys(values);
        const isKeys = new Array(keys.length);
        for(let i = 0; i < keys.length; i++)isKeys[i] = `is${(0, _util.stringPascalCase)(keys[i])}`;
        return class extends CodecSet {
            constructor(registry, value){
                super(registry, values, value, bitLength);
                (0, _util.objectProperties)(this, isKeys, (_, i)=>this.strings.includes(keys[i]));
            }
        };
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return this.#byteLength;
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description true is the Set contains no values
   */ get isEmpty() {
        return this.size === 0;
    }
    /**
   * @description The actual set values as a string[]
   */ get strings() {
        return [
            ...super.values()
        ];
    }
    /**
   * @description The encoded value for the set members
   */ get valueEncoded() {
        return encodeSet(this.#allowed, this.strings);
    }
    /**
   * @description adds a value to the Set (extended to allow for validity checking)
   */ add = (key)=>{
        // ^^^ add = () property done to assign this instance's this, otherwise Set.add creates "some" chaos
        // we have the isUndefined(this._setValues) in here as well, add is used internally
        // in the Set constructor (so it is undefined at this point, and should allow)
        if (this.#allowed && (0, _util.isUndefined)(this.#allowed[key])) throw new Error(`Set: Invalid key '${key}' on add`);
        super.add(key);
        return this;
    };
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        if (Array.isArray(other)) // we don't actually care about the order, sort the values
        return (0, _indexJs.compareArray)(this.strings.sort(), other.sort());
        else if (other instanceof Set) return this.eq([
            ...other.values()
        ]);
        else if ((0, _util.isNumber)(other) || (0, _util.isBn)(other)) return this.valueEncoded.eq((0, _util.bnToBn)(other));
        return false;
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return {
            outer: [
                this.toU8a()
            ]
        };
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        return (0, _util.u8aToHex)(this.toU8a());
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toJSON();
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.strings;
    }
    /**
   * @description The encoded value for the set members
   */ toNumber() {
        return this.valueEncoded.toNumber();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.toJSON();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return (0, _util.stringify)({
            _set: this.#allowed
        });
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return `[${this.strings.join(", ")}]`;
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toU8a(isBare) {
        return (0, _util.bnToU8a)(this.valueEncoded, {
            bitLength: this.#byteLength * 8,
            isLe: true
        });
    }
}

},{"@polkadot/util":"3HnHw","../utils/index.js":"OTOl1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9yjSC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "f32", ()=>(0, _f32Js.f32));
parcelHelpers.export(exports, "F32", ()=>(0, _f32Js.f32));
parcelHelpers.export(exports, "f64", ()=>(0, _f64Js.f64));
parcelHelpers.export(exports, "F64", ()=>(0, _f64Js.f64));
parcelHelpers.export(exports, "i8", ()=>(0, _i8Js.i8));
parcelHelpers.export(exports, "I8", ()=>(0, _i8Js.i8));
parcelHelpers.export(exports, "i16", ()=>(0, _i16Js.i16));
parcelHelpers.export(exports, "I16", ()=>(0, _i16Js.i16));
parcelHelpers.export(exports, "i32", ()=>(0, _i32Js.i32));
parcelHelpers.export(exports, "I32", ()=>(0, _i32Js.i32));
parcelHelpers.export(exports, "i64", ()=>(0, _i64Js.i64));
parcelHelpers.export(exports, "I64", ()=>(0, _i64Js.i64));
parcelHelpers.export(exports, "i128", ()=>(0, _i128Js.i128));
parcelHelpers.export(exports, "I128", ()=>(0, _i128Js.i128));
parcelHelpers.export(exports, "i256", ()=>(0, _i256Js.i256));
parcelHelpers.export(exports, "I256", ()=>(0, _i256Js.i256));
parcelHelpers.export(exports, "u8", ()=>(0, _u8Js.u8));
parcelHelpers.export(exports, "U8", ()=>(0, _u8Js.u8));
parcelHelpers.export(exports, "u16", ()=>(0, _u16Js.u16));
parcelHelpers.export(exports, "U16", ()=>(0, _u16Js.u16));
parcelHelpers.export(exports, "u32", ()=>(0, _u32Js.u32));
parcelHelpers.export(exports, "U32", ()=>(0, _u32Js.u32));
parcelHelpers.export(exports, "u64", ()=>(0, _u64Js.u64));
parcelHelpers.export(exports, "U64", ()=>(0, _u64Js.u64));
parcelHelpers.export(exports, "u128", ()=>(0, _u128Js.u128));
parcelHelpers.export(exports, "U128", ()=>(0, _u128Js.u128));
parcelHelpers.export(exports, "u256", ()=>(0, _u256Js.u256));
parcelHelpers.export(exports, "U256", ()=>(0, _u256Js.u256));
parcelHelpers.export(exports, "usize", ()=>(0, _usizeJs.usize));
parcelHelpers.export(exports, "USize", ()=>(0, _usizeJs.usize));
var _f32Js = require("./F32.js");
var _f64Js = require("./F64.js");
var _i8Js = require("./I8.js");
var _i16Js = require("./I16.js");
var _i32Js = require("./I32.js");
var _i64Js = require("./I64.js");
var _i128Js = require("./I128.js");
var _i256Js = require("./I256.js");
var _u8Js = require("./U8.js");
var _u16Js = require("./U16.js");
var _u32Js = require("./U32.js");
var _u64Js = require("./U64.js");
var _u128Js = require("./U128.js");
var _u256Js = require("./U256.js");
var _usizeJs = require("./USize.js");

},{"./F32.js":"awSOK","./F64.js":"6b4Od","./I8.js":"lhoVQ","./I16.js":"jHMKD","./I32.js":"fbklR","./I64.js":"cyjGn","./I128.js":"8VHJL","./I256.js":"4VZP6","./U8.js":"kBtxK","./U16.js":"bOhln","./U32.js":"f75PP","./U64.js":"kMWnC","./U128.js":"hbDKB","./U256.js":"9kzUq","./USize.js":"7nYsN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"awSOK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name f32
 * @description
 * A 32-bit float
 */ parcelHelpers.export(exports, "f32", ()=>f32);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _floatJs = require("../native/Float.js");
class f32 extends (0, _floatJs.Float).with(32) {
    // NOTE without this, we cannot properly determine extensions
    __FloatType = "f32";
}

},{"../native/Float.js":"9v5v9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6b4Od":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name f64
 * @description
 * A 64-bit float
 */ parcelHelpers.export(exports, "f64", ()=>f64);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _floatJs = require("../native/Float.js");
class f64 extends (0, _floatJs.Float).with(64) {
    // NOTE without this, we cannot properly determine extensions
    __FloatType = "f64";
}

},{"../native/Float.js":"9v5v9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lhoVQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name i8
 * @description
 * An 8-bit signed integer
 */ parcelHelpers.export(exports, "i8", ()=>i8);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _intJs = require("../base/Int.js");
class i8 extends (0, _intJs.Int).with(8) {
    // NOTE without this, we cannot properly determine extensions
    __IntType = "i8";
}

},{"../base/Int.js":"5SyvB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jHMKD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name i16
 * @description
 * A 16-bit signed integer
 */ parcelHelpers.export(exports, "i16", ()=>i16);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _intJs = require("../base/Int.js");
class i16 extends (0, _intJs.Int).with(16) {
    // NOTE without this, we cannot properly determine extensions
    __IntType = "i16";
}

},{"../base/Int.js":"5SyvB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fbklR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name i32
 * @description
 * A 32-bit signed integer
 */ parcelHelpers.export(exports, "i32", ()=>i32);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _intJs = require("../base/Int.js");
class i32 extends (0, _intJs.Int).with(32) {
    // NOTE without this, we cannot properly determine extensions
    __IntType = "i32";
}

},{"../base/Int.js":"5SyvB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cyjGn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name i64
 * @description
 * A 64-bit signed integer
 */ parcelHelpers.export(exports, "i64", ()=>i64);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _intJs = require("../base/Int.js");
class i64 extends (0, _intJs.Int).with(64) {
    // NOTE without this, we cannot properly determine extensions
    __IntType = "i64";
}

},{"../base/Int.js":"5SyvB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8VHJL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name i128
 * @description
 * A 128-bit signed integer
 */ parcelHelpers.export(exports, "i128", ()=>i128);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _intJs = require("../base/Int.js");
class i128 extends (0, _intJs.Int).with(128) {
    // NOTE without this, we cannot properly determine extensions
    __IntType = "i128";
}

},{"../base/Int.js":"5SyvB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4VZP6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name i256
 * @description
 * A 256-bit signed integer
 */ parcelHelpers.export(exports, "i256", ()=>i256);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _intJs = require("../base/Int.js");
class i256 extends (0, _intJs.Int).with(256) {
    // NOTE without this, we cannot properly determine extensions
    __IntType = "i256";
}

},{"../base/Int.js":"5SyvB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kBtxK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u8
 * @description
 * An 8-bit unsigned integer
 */ parcelHelpers.export(exports, "u8", ()=>u8);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _uintJs = require("../base/UInt.js");
class u8 extends (0, _uintJs.UInt).with(8) {
    // NOTE without this, we cannot properly determine extensions
    __UIntType = "u8";
}

},{"../base/UInt.js":"7DnCN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bOhln":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u16
 * @description
 * A 16-bit unsigned integer
 */ parcelHelpers.export(exports, "u16", ()=>u16);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _uintJs = require("../base/UInt.js");
class u16 extends (0, _uintJs.UInt).with(16) {
    // NOTE without this, we cannot properly determine extensions
    __UIntType = "u16";
}

},{"../base/UInt.js":"7DnCN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f75PP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u32
 * @description
 * A 32-bit unsigned integer
 */ parcelHelpers.export(exports, "u32", ()=>u32);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _uintJs = require("../base/UInt.js");
class u32 extends (0, _uintJs.UInt).with(32) {
    // NOTE without this, we cannot properly determine extensions
    __UIntType = "u32";
}

},{"../base/UInt.js":"7DnCN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kMWnC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u64
 * @description
 * A 64-bit unsigned integer
 */ parcelHelpers.export(exports, "u64", ()=>u64);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _uintJs = require("../base/UInt.js");
class u64 extends (0, _uintJs.UInt).with(64) {
    // NOTE without this, we cannot properly determine extensions
    __UIntType = "u64";
}

},{"../base/UInt.js":"7DnCN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hbDKB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u128
 * @description
 * A 128-bit unsigned integer
 */ parcelHelpers.export(exports, "u128", ()=>u128);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _uintJs = require("../base/UInt.js");
class u128 extends (0, _uintJs.UInt).with(128) {
    // NOTE without this, we cannot properly determine extensions
    __UIntType = "u128";
}

},{"../base/UInt.js":"7DnCN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9kzUq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name u256
 * @description
 * A 256-bit unsigned integer
 */ parcelHelpers.export(exports, "u256", ()=>u256);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _uintJs = require("../base/UInt.js");
class u256 extends (0, _uintJs.UInt).with(256) {
    // NOTE without this, we cannot properly determine extensions
    __UIntType = "u256";
}

},{"../base/UInt.js":"7DnCN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7nYsN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name USize
 * @description
 * A System default unsigned number, typically used in RPC to report non-consensus
 * data. It is a wrapper for [[U32]] as a WASM default (as generated by Rust bindings).
 * It is not to be used, since it created consensus mismatches.
 */ parcelHelpers.export(exports, "usize", ()=>usize);
// Copyright 2017-2022 @polkadot/types-codec authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _u32Js = require("./U32.js");
class usize extends (0, _u32Js.u32) {
    constructor(registry, value){
        super(registry, value);
        throw new Error("The `usize` type should not be used. Since it is platform-specific, it creates incompatibilities between native (generally u64) and WASM (always u32) code. Use one of the `u32` or `u64` types explicitly.");
    }
}

},{"./U32.js":"f75PP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gN0Rn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTypeDef", ()=>getTypeDef);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _indexJs = require("../types/index.js");
var _typeSplitJs = require("./typeSplit.js");
const KNOWN_INTERNALS = [
    "_alias",
    "_fallback"
];
function getTypeString(typeOrObj) {
    return (0, _util.isString)(typeOrObj) ? typeOrObj.toString() : JSON.stringify(typeOrObj);
}
function isRustEnum(details) {
    const values = Object.values(details);
    if (values.some((v)=>(0, _util.isNumber)(v))) {
        if (!values.every((v)=>(0, _util.isNumber)(v) && v >= 0 && v <= 255)) throw new Error("Invalid number-indexed enum definition");
        return false;
    }
    return true;
} // decode an enum of either of the following forms
//  { _enum: ['A', 'B', 'C'] }
//  { _enum: { A: AccountId, B: Balance, C: u32 } }
//  { _enum: { A: 1, B: 2 } }
function _decodeEnum(value, details, count, fallbackType) {
    value.info = (0, _indexJs.TypeDefInfo).Enum;
    value.fallbackType = fallbackType; // not as pretty, but remain compatible with oo7 for both struct and Array types
    if (Array.isArray(details)) value.sub = details.map((name, index)=>({
            index,
            info: (0, _indexJs.TypeDefInfo).Plain,
            name,
            type: "Null"
        }));
    else if (isRustEnum(details)) value.sub = Object.entries(details).map(([name, typeOrObj], index)=>(0, _util.objectSpread)({}, getTypeDef(getTypeString(typeOrObj || "Null"), {
            name
        }, count), {
            index
        }));
    else value.sub = Object.entries(details).map(([name, index])=>({
            index,
            info: (0, _indexJs.TypeDefInfo).Plain,
            name,
            type: "Null"
        }));
    return value;
} // decode a set of the form
//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }
function _decodeSet(value, details, fallbackType) {
    value.info = (0, _indexJs.TypeDefInfo).Set;
    value.fallbackType = fallbackType;
    value.length = details._bitLength;
    value.sub = Object.entries(details).filter(([name])=>!name.startsWith("_")).map(([name, index])=>({
            index,
            info: (0, _indexJs.TypeDefInfo).Plain,
            name,
            type: "Null"
        }));
    return value;
} // decode a struct, set or enum
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function _decodeStruct(value, type, _, count) {
    const parsed = JSON.parse(type);
    const keys = Object.keys(parsed);
    if (keys.includes("_enum")) return _decodeEnum(value, parsed._enum, count, parsed._fallback);
    else if (keys.includes("_set")) return _decodeSet(value, parsed._set, parsed._fallback);
    value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;
    value.fallbackType = parsed._fallback;
    value.sub = keys.filter((name)=>!KNOWN_INTERNALS.includes(name)).map((name)=>getTypeDef(getTypeString(parsed[name]), {
            name
        }, count));
    return value;
} // decode a fixed vector, e.g. [u8;32]
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function _decodeFixedVec(value, type, _, count) {
    const max = type.length - 1;
    let index = -1;
    let inner = 0;
    for(let i = 1; i < max && index === -1; i++)switch(type[i]){
        case ";":
            if (inner === 0) index = i;
            break;
        case "[":
        case "(":
        case "<":
            inner++;
            break;
        case "]":
        case ")":
        case ">":
            inner--;
            break;
    }
    if (index === -1) throw new Error(`${type}: Unable to extract location of ';'`);
    const vecType = type.substring(1, index);
    const [strLength, displayName] = type.substring(index + 1, max).split(";");
    const length = parseInt(strLength.trim(), 10);
    if (length > 2048) throw new Error(`${type}: Only support for [Type; <length>], where length <= 2048`);
    value.displayName = displayName;
    value.length = length;
    value.sub = getTypeDef(vecType, {}, count);
    return value;
} // decode a tuple
function _decodeTuple(value, _, subType, count) {
    value.sub = subType.length === 0 ? [] : (0, _typeSplitJs.typeSplit)(subType).map((inner)=>getTypeDef(inner, {}, count));
    return value;
} // decode a Int/UInt<bitLength[, name]>
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function _decodeAnyInt(value, type, _, clazz) {
    const [strLength, displayName] = type.substring(clazz.length + 1, type.length - 1).split(",");
    const length = parseInt(strLength.trim(), 10);
    if (length > 8192 || length % 8) throw new Error(`${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);
    value.displayName = displayName;
    value.length = length;
    return value;
}
function _decodeInt(value, type, subType) {
    return _decodeAnyInt(value, type, subType, "Int");
}
function _decodeUInt(value, type, subType) {
    return _decodeAnyInt(value, type, subType, "UInt");
} // eslint-disable-next-line @typescript-eslint/no-unused-vars
function _decodeDoNotConstruct(value, type, _) {
    const NAME_LENGTH = 14;
    value.displayName = type.substring(NAME_LENGTH + 1, type.length - 1);
    return value;
}
function hasWrapper(type, [start, end]) {
    return type.substring(0, start.length) === start && type.slice(-1 * end.length) === end;
}
const nestedExtraction = [
    [
        "[",
        "]",
        (0, _indexJs.TypeDefInfo).VecFixed,
        _decodeFixedVec
    ],
    [
        "{",
        "}",
        (0, _indexJs.TypeDefInfo).Struct,
        _decodeStruct
    ],
    [
        "(",
        ")",
        (0, _indexJs.TypeDefInfo).Tuple,
        _decodeTuple
    ],
    [
        "BTreeMap<",
        ">",
        (0, _indexJs.TypeDefInfo).BTreeMap,
        _decodeTuple
    ],
    [
        "HashMap<",
        ">",
        (0, _indexJs.TypeDefInfo).HashMap,
        _decodeTuple
    ],
    [
        "Int<",
        ">",
        (0, _indexJs.TypeDefInfo).Int,
        _decodeInt
    ],
    [
        "Result<",
        ">",
        (0, _indexJs.TypeDefInfo).Result,
        _decodeTuple
    ],
    [
        "UInt<",
        ">",
        (0, _indexJs.TypeDefInfo).UInt,
        _decodeUInt
    ],
    [
        "DoNotConstruct<",
        ">",
        (0, _indexJs.TypeDefInfo).DoNotConstruct,
        _decodeDoNotConstruct
    ]
];
const wrappedExtraction = [
    [
        "BTreeSet<",
        ">",
        (0, _indexJs.TypeDefInfo).BTreeSet
    ],
    [
        "Compact<",
        ">",
        (0, _indexJs.TypeDefInfo).Compact
    ],
    [
        "Linkage<",
        ">",
        (0, _indexJs.TypeDefInfo).Linkage
    ],
    [
        "Opaque<",
        ">",
        (0, _indexJs.TypeDefInfo).WrapperOpaque
    ],
    [
        "Option<",
        ">",
        (0, _indexJs.TypeDefInfo).Option
    ],
    [
        "Range<",
        ">",
        (0, _indexJs.TypeDefInfo).Range
    ],
    [
        "RangeInclusive<",
        ">",
        (0, _indexJs.TypeDefInfo).RangeInclusive
    ],
    [
        "Vec<",
        ">",
        (0, _indexJs.TypeDefInfo).Vec
    ],
    [
        "WrapperKeepOpaque<",
        ">",
        (0, _indexJs.TypeDefInfo).WrapperKeepOpaque
    ],
    [
        "WrapperOpaque<",
        ">",
        (0, _indexJs.TypeDefInfo).WrapperOpaque
    ]
];
function extractSubType(type, [start, end]) {
    return type.substring(start.length, type.length - end.length);
}
function getTypeDef(_type, { displayName , name  } = {}, count = 0) {
    // create the type via Type, allowing types to be sanitized
    const type = (0, _typesCodec.sanitize)(_type);
    const value = {
        displayName,
        info: (0, _indexJs.TypeDefInfo).Plain,
        name,
        type
    };
    if (++count > 64) throw new Error("getTypeDef: Maximum nested limit reached");
    const nested = nestedExtraction.find((nested)=>hasWrapper(type, nested));
    if (nested) {
        value.info = nested[2];
        return nested[3](value, type, extractSubType(type, nested), count);
    }
    const wrapped = wrappedExtraction.find((wrapped)=>hasWrapper(type, wrapped));
    if (wrapped) {
        value.info = wrapped[2];
        value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);
    }
    return value;
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","../types/index.js":"5QFWK","./typeSplit.js":"1qCwf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1qCwf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
// safely split a string on ', ' while taking care of any nested occurences
parcelHelpers.export(exports, "typeSplit", ()=>typeSplit);
function typeSplit(type) {
    const result = []; // these are the depths of the various tokens: <, [, {, (
    let c = 0;
    let f = 0;
    let s = 0;
    let t = 0; // current start position
    let start = 0;
    for(let i = 0; i < type.length; i++)switch(type[i]){
        // if we are not nested, add the type
        case ",":
            if (!(c || f || s || t)) {
                result.push(type.substring(start, i).trim());
                start = i + 1;
            }
            break;
        // adjust compact/vec (and friends) depth
        case "<":
            c++;
            break;
        case ">":
            c--;
            break;
        // adjust fixed vec depths
        case "[":
            f++;
            break;
        case "]":
            f--;
            break;
        // adjust struct depth
        case "{":
            s++;
            break;
        case "}":
            s--;
            break;
        // adjust tuple depth
        case "(":
            t++;
            break;
        case ")":
            t--;
            break;
    }
     // ensure we have all the terminators taken care of
    if (c || f || s || t) throw new Error(`Invalid definition (missing terminators) found in ${type}`);
     // the final leg of the journey
    result.push(type.substring(start, type.length).trim());
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dBiQC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// argument here can be any string, which, when it cannot parse, will yield a
// runtime error.
parcelHelpers.export(exports, "createTypeUnsafe", ()=>createTypeUnsafe);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _classJs = require("./class.js"); // With isPedantic, actually check that the encoding matches that supplied. This
// is much slower, but verifies that we have the correct types defined
function checkInstance(created, matcher) {
    const u8a = created.toU8a();
    const rawType = created.toRawType();
    const isOk = (0, _util.u8aEq)(u8a, matcher) || [
        "Bytes",
        "Text",
        "Type"
    ].includes(rawType) && matcher.length === created.length || created.isEmpty && matcher.every((v)=>!v);
    if (!isOk) throw new Error(`${rawType}:: Decoded input doesn't match input, received ${(0, _util.u8aToHex)(matcher, 512)} (${matcher.length} bytes), created ${(0, _util.u8aToHex)(u8a, 512)} (${u8a.length} bytes)`);
}
function checkPedantic(created, [value]) {
    if ((0, _util.isU8a)(value)) checkInstance(created, value);
    else if ((0, _util.isHex)(value)) checkInstance(created, (0, _util.u8aToU8a)(value));
} // Initializes a type with a value. This also checks for fallbacks and in the cases
// where isPedantic is specified (storage decoding), also check the format/structure
function initType(registry, Type, params = [], { blockHash , isOptional , isPedantic  } = {}) {
    const created = new (isOptional ? (0, _typesCodec.Option).with(Type) : Type)(registry, ...params);
    isPedantic && checkPedantic(created, params);
    if (blockHash) created.createdAtHash = createTypeUnsafe(registry, "Hash", [
        blockHash
    ]);
    return created;
} // An unsafe version of the `createType` below. It's unsafe because the `type`
function createTypeUnsafe(registry, type, params = [], options = {}) {
    let Clazz = null;
    let firstError = null;
    try {
        Clazz = (0, _classJs.createClassUnsafe)(registry, type);
        return initType(registry, Clazz, params, options);
    } catch (error) {
        firstError = new Error(`createType(${type}):: ${error.message}`);
    }
    if (Clazz && Clazz.__fallbackType) try {
        Clazz = (0, _classJs.createClassUnsafe)(registry, Clazz.__fallbackType);
        return initType(registry, Clazz, params, options);
    } catch  {}
    throw firstError;
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","./class.js":"2iCHM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"chdyR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _encodeTypesJs = require("./encodeTypes.js");
parcelHelpers.exportAll(_encodeTypesJs, exports);
var _getTypeDefJs = require("./getTypeDef.js");
parcelHelpers.exportAll(_getTypeDefJs, exports);
var _typeSplitJs = require("./typeSplit.js");
parcelHelpers.exportAll(_typeSplitJs, exports);
var _xcmJs = require("./xcm.js");
parcelHelpers.exportAll(_xcmJs, exports);

},{"./encodeTypes.js":"hlrL1","./getTypeDef.js":"gN0Rn","./typeSplit.js":"1qCwf","./xcm.js":"hA0GC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hlrL1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "paramsNotation", ()=>paramsNotation);
parcelHelpers.export(exports, "encodeTypeDef", ()=>encodeTypeDef);
parcelHelpers.export(exports, "withTypeString", ()=>withTypeString);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../types/index.js");
const stringIdentity = (value)=>value.toString();
const INFO_WRAP = [
    "BTreeMap",
    "BTreeSet",
    "Compact",
    "HashMap",
    "Option",
    "Result",
    "Vec"
];
function paramsNotation(outer, inner, transform = stringIdentity) {
    return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [
        inner
    ]).map(transform).join(", ")}>` : ""}`;
}
function encodeWithParams(registry, typeDef, outer) {
    const { info , sub  } = typeDef;
    switch(info){
        case (0, _indexJs.TypeDefInfo).BTreeMap:
        case (0, _indexJs.TypeDefInfo).BTreeSet:
        case (0, _indexJs.TypeDefInfo).Compact:
        case (0, _indexJs.TypeDefInfo).HashMap:
        case (0, _indexJs.TypeDefInfo).Linkage:
        case (0, _indexJs.TypeDefInfo).Option:
        case (0, _indexJs.TypeDefInfo).Range:
        case (0, _indexJs.TypeDefInfo).RangeInclusive:
        case (0, _indexJs.TypeDefInfo).Result:
        case (0, _indexJs.TypeDefInfo).Vec:
        case (0, _indexJs.TypeDefInfo).WrapperKeepOpaque:
        case (0, _indexJs.TypeDefInfo).WrapperOpaque:
            return paramsNotation(outer, sub, (p)=>encodeTypeDef(registry, p));
    }
    throw new Error(`Unable to encode ${(0, _util.stringify)(typeDef)} with params`);
}
function encodeSubTypes(registry, sub, asEnum, extra) {
    const names = sub.map(({ name  })=>name);
    if (!names.every((n)=>!!n)) throw new Error(`Subtypes does not have consistent names, ${names.join(", ")}`);
    const inner = (0, _util.objectSpread)({}, extra);
    for(let i = 0; i < sub.length; i++){
        const def = sub[i];
        inner[def.name] = encodeTypeDef(registry, def);
    }
    return (0, _util.stringify)(asEnum ? {
        _enum: inner
    } : inner);
} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result
// in a compile-time error with the missing index)
const encoders = {
    [(0, _indexJs.TypeDefInfo).BTreeMap]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "BTreeMap"),
    [(0, _indexJs.TypeDefInfo).BTreeSet]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "BTreeSet"),
    [(0, _indexJs.TypeDefInfo).Compact]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "Compact"),
    [(0, _indexJs.TypeDefInfo).DoNotConstruct]: (registry, { displayName , lookupIndex , lookupName  })=>`DoNotConstruct<${lookupName || displayName || ((0, _util.isUndefined)(lookupIndex) ? "Unknown" : registry.createLookupType(lookupIndex))}>`,
    [(0, _indexJs.TypeDefInfo).Enum]: (registry, { sub  })=>{
        if (!Array.isArray(sub)) throw new Error("Unable to encode Enum type");
         // c-like enums have all Null entries
        // TODO We need to take the disciminant into account and auto-add empty entries
        return sub.every(({ type  })=>type === "Null") ? (0, _util.stringify)({
            _enum: sub.map(({ name  }, index)=>`${name || `Empty${index}`}`)
        }) : encodeSubTypes(registry, sub, true);
    },
    [(0, _indexJs.TypeDefInfo).HashMap]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "HashMap"),
    [(0, _indexJs.TypeDefInfo).Int]: (registry, { length =32  })=>`Int<${length}>`,
    [(0, _indexJs.TypeDefInfo).Linkage]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "Linkage"),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    [(0, _indexJs.TypeDefInfo).Null]: (registry, typeDef)=>"Null",
    [(0, _indexJs.TypeDefInfo).Option]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "Option"),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    [(0, _indexJs.TypeDefInfo).Plain]: (registry, { displayName , type  })=>displayName || type,
    [(0, _indexJs.TypeDefInfo).Range]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "Range"),
    [(0, _indexJs.TypeDefInfo).RangeInclusive]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "RangeInclusive"),
    [(0, _indexJs.TypeDefInfo).Result]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "Result"),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    [(0, _indexJs.TypeDefInfo).Set]: (registry, { length =8 , sub  })=>{
        if (!Array.isArray(sub)) throw new Error("Unable to encode Set type");
        return (0, _util.stringify)({
            _set: sub.reduce((all, { index , name  }, count)=>(0, _util.objectSpread)(all, {
                    [`${name || `Unknown${index || count}`}`]: index || count
                }), {
                _bitLength: length || 8
            })
        });
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    [(0, _indexJs.TypeDefInfo).Si]: (registry, { lookupName , type  })=>lookupName || type,
    [(0, _indexJs.TypeDefInfo).Struct]: (registry, { alias , sub  })=>{
        if (!Array.isArray(sub)) throw new Error("Unable to encode Struct type");
        return encodeSubTypes(registry, sub, false, alias ? {
            _alias: [
                ...alias.entries()
            ].reduce((all, [k, v])=>(0, _util.objectSpread)(all, {
                    [k]: v
                }), {})
        } : {});
    },
    [(0, _indexJs.TypeDefInfo).Tuple]: (registry, { sub  })=>{
        if (!Array.isArray(sub)) throw new Error("Unable to encode Tuple type");
        return `(${sub.map((type)=>encodeTypeDef(registry, type)).join(",")})`;
    },
    [(0, _indexJs.TypeDefInfo).UInt]: (registry, { length =32  })=>`UInt<${length}>`,
    [(0, _indexJs.TypeDefInfo).Vec]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "Vec"),
    [(0, _indexJs.TypeDefInfo).VecFixed]: (registry, { length , sub  })=>{
        if (!(0, _util.isNumber)(length) || !sub || Array.isArray(sub)) throw new Error("Unable to encode VecFixed type");
        return `[${sub.type};${length}]`;
    },
    [(0, _indexJs.TypeDefInfo).WrapperKeepOpaque]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "WrapperKeepOpaque"),
    [(0, _indexJs.TypeDefInfo).WrapperOpaque]: (registry, typeDef)=>encodeWithParams(registry, typeDef, "WrapperOpaque")
};
function encodeType(registry, typeDef, withLookup = true) {
    return withLookup && typeDef.lookupName ? typeDef.lookupName : encoders[typeDef.info](registry, typeDef);
}
function encodeTypeDef(registry, typeDef) {
    // In the case of contracts we do have the unfortunate situation where the displayName would
    // refer to "Option" when it is an option. For these, string it out, only using when actually
    // not a top-level element to be used
    return typeDef.displayName && !INFO_WRAP.some((i)=>typeDef.displayName === i) ? typeDef.displayName : encodeType(registry, typeDef);
}
function withTypeString(registry, typeDef) {
    return (0, _util.objectSpread)({}, typeDef, {
        type: encodeType(registry, typeDef, false)
    });
}

},{"@polkadot/util":"3HnHw","../types/index.js":"5QFWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hA0GC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "XCM_MAPPINGS", ()=>XCM_MAPPINGS);
parcelHelpers.export(exports, "mapXcmTypes", ()=>mapXcmTypes);
// Copyright 2017-2022 @polkadot/types-create authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const XCM_MAPPINGS = [
    "AssetInstance",
    "Fungibility",
    "Junction",
    "Junctions",
    "MultiAsset",
    "MultiAssetFilter",
    "MultiLocation",
    "Response",
    "WildFungibility",
    "WildMultiAsset",
    "Xcm",
    "XcmError",
    "XcmOrder"
];
function mapXcmTypes(version) {
    return XCM_MAPPINGS.reduce((all, key)=>(0, _util.objectSpread)(all, {
            [key]: `${key}${version}`
        }), {});
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"elguL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v0", ()=>v0);
const v0 = {
    FungibilityV0: "FungibilityV1",
    WildFungibilityV0: "WildFungibilityV1",
    AssetInstanceV0: {
        _enum: {
            Undefined: "Null",
            Index8: "u8",
            Index16: "Compact<u16>",
            Index32: "Compact<u32>",
            Index64: "Compact<u64>",
            Index128: "Compact<u128>",
            Array4: "[u8; 4]",
            Array8: "[u8; 8]",
            Array16: "[u8; 16]",
            Array32: "[u8; 32]",
            Blob: "Vec<u8>"
        }
    },
    JunctionV0: {
        _enum: {
            Parent: "Null",
            Parachain: "Compact<u32>",
            AccountId32: {
                network: "NetworkId",
                id: "AccountId"
            },
            AccountIndex64: {
                network: "NetworkId",
                index: "Compact<u64>"
            },
            AccountKey20: {
                network: "NetworkId",
                key: "[u8; 20]"
            },
            PalletInstance: "u8",
            GeneralIndex: "Compact<u128>",
            GeneralKey: "Vec<u8>",
            OnlyChild: "Null",
            Plurality: {
                id: "BodyId",
                part: "BodyPart"
            }
        }
    },
    MultiAssetV0: {
        _enum: {
            None: "Null",
            All: "Null",
            AllFungible: "Null",
            AllNonFungible: "Null",
            AllAbstractFungible: "Vec<u8>",
            AllAbstractNonFungible: "Vec<u8>",
            AllConcreteFungible: "MultiLocationV0",
            AllConcreteNonFungible: "MultiLocationV0",
            AbstractFungible: {
                id: "Vec<u8>",
                instance: "Compact<u128>"
            },
            AbstractNonFungible: {
                class: "Vec<u8>",
                instance: "AssetInstanceV0"
            },
            ConcreteFungible: {
                id: "MultiLocationV0",
                amount: "Compact<u128>"
            },
            ConcreteNonFungible: {
                class: "MultiLocationV0",
                instance: "AssetInstanceV0"
            }
        }
    },
    MultiLocationV0: {
        _enum: {
            Here: "Null",
            X1: "JunctionV0",
            X2: "(JunctionV0, JunctionV0)",
            X3: "(JunctionV0, JunctionV0, JunctionV0)",
            X4: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
            X5: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
            X6: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
            X7: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
            X8: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)"
        }
    },
    OriginKindV0: {
        _enum: [
            "Native",
            "SovereignAccount",
            "Superuser",
            "Xcm"
        ]
    },
    ResponseV0: {
        _enum: {
            Assets: "Vec<MultiAssetV0>"
        }
    },
    XcmV0: {
        _enum: {
            WithdrawAsset: {
                assets: "Vec<MultiAssetV0>",
                effects: "Vec<XcmOrderV0>"
            },
            ReserveAssetDeposit: {
                assets: "Vec<MultiAssetV0>",
                effects: "Vec<XcmOrderV0>"
            },
            ReceiveTeleportedAsset: {
                assets: "Vec<MultiAssetV0>",
                effects: "Vec<XcmOrderV0>"
            },
            QueryResponse: {
                queryId: "Compact<u64>",
                response: "ResponseV0"
            },
            TransferAsset: {
                assets: "Vec<MultiAssetV0>",
                dest: "MultiLocationV0"
            },
            TransferReserveAsset: {
                assets: "Vec<MultiAssetV0>",
                dest: "MultiLocationV0",
                effects: "Vec<XcmOrderV0>"
            },
            Transact: {
                originType: "XcmOriginKind",
                requireWeightAtMost: "u64",
                call: "DoubleEncodedCall"
            },
            HrmpNewChannelOpenRequest: {
                sender: "Compact<u32>",
                maxMessageSize: "Compact<u32>",
                maxCapacity: "Compact<u32>"
            },
            HrmpChannelAccepted: {
                recipient: "Compact<u32>"
            },
            HrmpChannelClosing: {
                initiator: "Compact<u32>",
                sender: "Compact<u32>",
                recipient: "Compact<u32>"
            },
            RelayedFrom: {
                who: "MultiLocationV0",
                message: "XcmV0"
            }
        }
    },
    XcmErrorV0: {
        _enum: {
            Undefined: "Null",
            Overflow: "Null",
            Unimplemented: "Null",
            UnhandledXcmVersion: "Null",
            UnhandledXcmMessage: "Null",
            UnhandledEffect: "Null",
            EscalationOfPrivilege: "Null",
            UntrustedReserveLocation: "Null",
            UntrustedTeleportLocation: "Null",
            DestinationBufferOverflow: "Null",
            SendFailed: "Null",
            CannotReachDestination: "(MultiLocation, Xcm)",
            MultiLocationFull: "Null",
            FailedToDecode: "Null",
            BadOrigin: "Null",
            ExceedsMaxMessageSize: "Null",
            FailedToTransactAsset: "Null",
            WeightLimitReached: "Weight",
            Wildcard: "Null",
            TooMuchWeightRequired: "Null",
            NotHoldingFees: "Null",
            WeightNotComputable: "Null",
            Barrier: "Null",
            NotWithdrawable: "Null",
            LocationCannotHold: "Null",
            TooExpensive: "Null",
            AssetNotFound: "Null",
            RecursionLimitReached: "Null"
        }
    },
    XcmOrderV0: {
        _enum: {
            Null: "Null",
            DepositAsset: {
                assets: "Vec<MultiAssetV0>",
                dest: "MultiLocationV0"
            },
            DepositReserveAsset: {
                assets: "Vec<MultiAssetV0>",
                dest: "MultiLocationV0",
                effects: "Vec<XcmOrderV0>"
            },
            ExchangeAsset: {
                give: "Vec<MultiAssetV0>",
                receive: "Vec<MultiAssetV0>"
            },
            InitiateReserveWithdraw: {
                assets: "Vec<MultiAssetV0>",
                reserve: "MultiLocationV0",
                effects: "Vec<XcmOrderV0>"
            },
            InitiateTeleport: {
                assets: "Vec<MultiAssetV0>",
                dest: "MultiLocationV0",
                effects: "Vec<XcmOrderV0>"
            },
            QueryHolding: {
                queryId: "Compact<u64>",
                dest: "MultiLocationV0",
                assets: "Vec<MultiAssetV0>"
            },
            BuyExecution: {
                fees: "MultiAssetV0",
                weight: "u64",
                debt: "u64",
                haltOnError: "bool",
                xcm: "Vec<XcmV0>"
            }
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gCO3S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>v1);
const v1 = {
    AssetInstanceV1: {
        _enum: {
            Undefined: "Null",
            Index: "Compact<u128>",
            Array4: "[u8; 4]",
            Array8: "[u8; 8]",
            Array16: "[u8; 16]",
            Array32: "[u8; 32]",
            Blob: "Bytes"
        }
    },
    FungibilityV1: {
        _enum: {
            Fungible: "Compact<u128>",
            NonFungible: "AssetInstanceV1"
        }
    },
    JunctionV1: {
        _enum: {
            Parachain: "Compact<u32>",
            AccountId32: {
                network: "NetworkId",
                id: "AccountId"
            },
            AccountIndex64: {
                network: "NetworkId",
                index: "Compact<u64>"
            },
            AccountKey20: {
                network: "NetworkId",
                key: "[u8; 20]"
            },
            PalletInstance: "u8",
            GeneralIndex: "Compact<u128>",
            GeneralKey: "Vec<u8>",
            OnlyChild: "Null",
            Plurality: {
                id: "BodyId",
                part: "BodyPart"
            }
        }
    },
    JunctionsV1: {
        _enum: {
            Here: "Null",
            X1: "JunctionV1",
            X2: "(JunctionV1, JunctionV1)",
            X3: "(JunctionV1, JunctionV1, JunctionV1)",
            X4: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
            X5: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
            X6: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
            X7: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
            X8: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)"
        }
    },
    MultiAssetsV1: "Vec<MultiAssetV1>",
    MultiAssetV1: {
        id: "XcmAssetId",
        fungibility: "FungibilityV1"
    },
    MultiAssetFilterV1: {
        _enum: {
            Definite: "MultiAssetsV1",
            Wild: "WildMultiAssetV1"
        }
    },
    MultiLocationV1: {
        parents: "u8",
        interior: "JunctionsV1"
    },
    OriginKindV1: "OriginKindV0",
    ResponseV1: {
        _enum: {
            Assets: "MultiAssetsV1"
        }
    },
    WildFungibilityV1: {
        _enum: [
            "Fungible",
            "NonFungible"
        ]
    },
    WildMultiAssetV1: {
        _enum: {
            All: "Null",
            AllOf: {
                id: "XcmAssetId",
                fungibility: "WildFungibilityV1"
            }
        }
    },
    XcmV1: {
        _enum: {
            WithdrawAsset: {
                assets: "MultiAssetsV1",
                effects: "Vec<XcmOrderV1>"
            },
            ReserveAssetDeposit: {
                assets: "MultiAssetsV1",
                effects: "Vec<XcmOrderV1>"
            },
            ReceiveTeleportedAsset: {
                assets: "MultiAssetsV1",
                effects: "Vec<XcmOrderV1>"
            },
            QueryResponse: {
                queryId: "Compact<u64>",
                response: "ResponseV1"
            },
            TransferAsset: {
                assets: "MultiAssetsV1",
                dest: "MultiLocationV1"
            },
            TransferReserveAsset: {
                assets: "MultiAssetsV1",
                dest: "MultiLocationV1",
                effects: "Vec<XcmOrderV1>"
            },
            Transact: {
                originType: "XcmOriginKind",
                requireWeightAtMost: "u64",
                call: "DoubleEncodedCall"
            },
            HrmpNewChannelOpenRequest: {
                sender: "Compact<u32>",
                maxMessageSize: "Compact<u32>",
                maxCapacity: "Compact<u32>"
            },
            HrmpChannelAccepted: {
                recipient: "Compact<u32>"
            },
            HrmpChannelClosing: {
                initiator: "Compact<u32>",
                sender: "Compact<u32>",
                recipient: "Compact<u32>"
            },
            RelayedFrom: {
                who: "MultiLocationV1",
                message: "XcmV1"
            }
        }
    },
    XcmErrorV1: {
        _enum: {
            Undefined: "Null",
            Overflow: "Null",
            Unimplemented: "Null",
            UnhandledXcmVersion: "Null",
            UnhandledXcmMessage: "Null",
            UnhandledEffect: "Null",
            EscalationOfPrivilege: "Null",
            UntrustedReserveLocation: "Null",
            UntrustedTeleportLocation: "Null",
            DestinationBufferOverflow: "Null",
            SendFailed: "Null",
            CannotReachDestination: "(MultiLocationV1, XcmV1)",
            MultiLocationFull: "Null",
            FailedToDecode: "Null",
            BadOrigin: "Null",
            ExceedsMaxMessageSize: "Null",
            FailedToTransactAsset: "Null",
            WeightLimitReached: "Weight",
            Wildcard: "Null",
            TooMuchWeightRequired: "Null",
            NotHoldingFees: "Null",
            WeightNotComputable: "Null",
            Barrier: "Null",
            NotWithdrawable: "Null",
            LocationCannotHold: "Null",
            TooExpensive: "Null",
            AssetNotFound: "Null",
            DestinationUnsupported: "Null",
            RecursionLimitReached: "Null"
        }
    },
    XcmOrderV1: {
        _enum: {
            Noop: "Null",
            DepositAsset: {
                assets: "MultiAssetFilterV1",
                maxAssets: "u32",
                beneficiary: "MultiLocationV1"
            },
            DepositReserveAsset: {
                assets: "MultiAssetFilterV1",
                maxAssets: "u32",
                dest: "MultiLocationV1",
                effects: "Vec<XcmOrderV1>"
            },
            ExchangeAsset: {
                give: "MultiAssetFilterV1",
                receive: "MultiAssetsV1"
            },
            InitiateReserveWithdraw: {
                assets: "MultiAssetFilterV1",
                reserve: "MultiLocationV1",
                effects: "Vec<XcmOrderV1>"
            },
            InitiateTeleport: {
                assets: "MultiAssetFilterV1",
                dest: "MultiLocationV1",
                effects: "Vec<XcmOrderV1>"
            },
            QueryHolding: {
                queryId: "Compact<u64>",
                dest: "MultiLocationV1",
                assets: "MultiAssetFilterV1"
            },
            BuyExecution: {
                fees: "MultiAssetV1",
                weight: "u64",
                debt: "u64",
                haltOnError: "bool",
                instructions: "Vec<XcmV1>"
            }
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3C8Gn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v2", ()=>v2);
const v2 = {
    AssetInstanceV2: "AssetInstanceV1",
    FungibilityV2: "FungibilityV1",
    JunctionV2: "JunctionV1",
    JunctionsV2: "JunctionsV1",
    MultiAssetsV2: "MultiAssetsV1",
    MultiAssetV2: "MultiAssetV1",
    MultiAssetFilterV2: "MultiAssetFilterV1",
    MultiLocationV2: "MultiLocationV1",
    OriginKindV2: "OriginKindV1",
    WildFungibilityV2: "WildFungibilityV1",
    ResponseV2: {
        _enum: {
            Null: "Null",
            Assets: "MultiAssetsV2",
            ExecutionResult: "ResponseV2Result"
        }
    },
    ResponseV2Error: "(u32, XcmErrorV2)",
    ResponseV2Result: "Result<Null, ResponseV2Error>",
    WeightLimitV2: {
        _enum: {
            Unlimited: "Null",
            Limited: "Compact<u64>"
        }
    },
    InstructionV2: {
        _enum: {
            WithdrawAsset: "MultiAssetsV2",
            ReserveAssetDeposited: "MultiAssetsV2",
            ReceiveTeleportedAsset: "MultiAssetsV2",
            QueryResponse: {
                queryId: "Compact<u64>",
                response: "ResponseV2",
                maxWeight: "Compact<u64>"
            },
            TransferAsset: {
                assets: "MultiAssetsV2",
                beneficiary: "MultiLocationV2"
            },
            TransferReserveAsset: {
                assets: "MultiAssetsV2",
                dest: "MultiLocationV2",
                xcm: "XcmV2"
            },
            Transact: {
                originType: "OriginKindV2",
                requireWeightAtMost: "u64",
                call: "DoubleEncodedCall"
            },
            HrmpNewChannelOpenRequest: {
                sender: "Compact<u32>",
                maxMessageSize: "Compact<u32>",
                maxCapacity: "Compact<u32>"
            },
            HrmpChannelAccepted: {
                recipient: "Compact<u32>"
            },
            HrmpChannelClosing: {
                initiator: "Compact<u32>",
                sender: "Compact<u32>",
                recipient: "Compact<u32>"
            },
            ClearOrigin: "Null",
            DescendOrigin: "InteriorMultiLocation",
            ReportError: {
                queryId: "Compact<u64>",
                dest: "MultiLocationV2",
                maxResponseWeight: "Compact<u64>"
            },
            DepositAsset: {
                assets: "MultiAssetFilterV2",
                maxAssets: "u32",
                beneficiary: "MultiLocationV2"
            },
            DepositReserveAsset: {
                assets: "MultiAssetFilterV2",
                maxAssets: "u32",
                dest: "MultiLocationV2",
                xcm: "XcmV2"
            },
            ExchangeAsset: {
                give: "MultiAssetFilterV2",
                receive: "MultiAssetsV2"
            },
            InitiateReserveWithdraw: {
                assets: "MultiAssetFilterV2",
                reserve: "MultiLocationV2",
                xcm: "XcmV2"
            },
            InitiateTeleport: {
                assets: "MultiAssetFilterV2",
                dest: "MultiLocationV2",
                xcm: "XcmV2"
            },
            QueryHolding: {
                query_id: "Compact<u64>",
                dest: "MultiLocationV2",
                assets: "MultiAssetFilterV2",
                maxResponse_Weight: "Compact<u64>"
            },
            BuyExecution: {
                fees: "MultiAssetV2",
                weightLimit: "WeightLimitV2"
            },
            RefundSurplus: "Null",
            SetErrorHandler: "XcmV2",
            SetAppendix: "XcmV2",
            ClearError: "Null",
            ClaimAsset: {
                assets: "MultiAssetsV2",
                ticket: "MultiLocationV2"
            },
            Trap: "u64"
        }
    },
    WildMultiAssetV2: "WildMultiAssetV1",
    XcmV2: "Vec<InstructionV2>",
    XcmErrorV2: {
        _enum: {
            Undefined: "Null",
            Overflow: "Null",
            Unimplemented: "Null",
            UnhandledXcmVersion: "Null",
            UnhandledXcmMessage: "Null",
            UnhandledEffect: "Null",
            EscalationOfPrivilege: "Null",
            UntrustedReserveLocation: "Null",
            UntrustedTeleportLocation: "Null",
            DestinationBufferOverflow: "Null",
            MultiLocationFull: "Null",
            MultiLocationNotInvertible: "Null",
            FailedToDecode: "Null",
            BadOrigin: "Null",
            ExceedsMaxMessageSize: "Null",
            FailedToTransactAsset: "Null",
            WeightLimitReached: "Weight",
            Wildcard: "Null",
            TooMuchWeightRequired: "Null",
            NotHoldingFees: "Null",
            WeightNotComputable: "Null",
            Barrier: "Null",
            NotWithdrawable: "Null",
            LocationCannotHold: "Null",
            TooExpensive: "Null",
            AssetNotFound: "Null",
            DestinationUnsupported: "Null",
            RecursionLimitReached: "Null",
            Transport: "Null",
            Unroutable: "Null",
            UnknownWeightRequired: "Null",
            Trap: "u64",
            UnknownClaim: "Null",
            InvalidLocation: "Null"
        }
    },
    XcmOrderV2: "XcmOrderV1"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5CyRS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util"); // order important in structs... :)
/* eslint-disable sort-keys */ const layout = {
    ContractCryptoHasher: {
        _enum: [
            "Blake2x256",
            "Sha2x256",
            "Keccak256"
        ]
    },
    ContractDiscriminant: "u32",
    ContractLayoutArray: {
        offset: "ContractLayoutKey",
        len: "u32",
        cellsPerElem: "u64",
        layout: "ContractStorageLayout"
    },
    ContractLayoutCell: {
        key: "ContractLayoutKey",
        ty: "SiLookupTypeId"
    },
    ContractLayoutEnum: {
        dispatchKey: "ContractLayoutKey",
        variants: "BTreeMap<ContractDiscriminant, ContractLayoutStruct>"
    },
    ContractLayoutHash: {
        offset: "ContractLayoutKey",
        strategy: "ContractLayoutHashingStrategy",
        layout: "ContractStorageLayout"
    },
    ContractLayoutHashingStrategy: {
        hasher: "ContractCryptoHasher",
        postfix: "Vec<u8>",
        prefix: "Vec<u8>"
    },
    ContractLayoutKey: "[u8; 32]",
    ContractLayoutStruct: {
        fields: "Vec<ContractLayoutStructField>"
    },
    ContractLayoutStructField: {
        layout: "ContractStorageLayout",
        name: "Text"
    },
    ContractStorageLayout: {
        _enum: {
            Cell: "ContractLayoutCell",
            Hash: "ContractLayoutHash",
            Array: "ContractLayoutArray",
            Struct: "ContractLayoutStruct",
            Enum: "ContractLayoutEnum"
        }
    }
};
const spec = {
    ContractConstructorSpecV0: {
        name: "Text",
        selector: "ContractSelector",
        args: "Vec<ContractMessageParamSpecV0>",
        docs: "Vec<Text>"
    },
    ContractConstructorSpecV1: {
        name: "Vec<Text>",
        selector: "ContractSelector",
        args: "Vec<ContractMessageParamSpecV0>",
        docs: "Vec<Text>"
    },
    ContractConstructorSpecV2: {
        label: "Text",
        selector: "ContractSelector",
        args: "Vec<ContractMessageParamSpecV2>",
        docs: "Vec<Text>"
    },
    ContractConstructorSpecV3: {
        label: "Text",
        selector: "ContractSelector",
        payable: "bool",
        args: "Vec<ContractMessageParamSpecV2>",
        docs: "Vec<Text>"
    },
    ContractContractSpecV0: {
        constructors: "Vec<ContractConstructorSpecV0>",
        messages: "Vec<ContractMessageSpecV0>",
        events: "Vec<ContractEventSpecV0>",
        docs: "Vec<Text>"
    },
    ContractContractSpecV1: {
        constructors: "Vec<ContractConstructorSpecV1>",
        messages: "Vec<ContractMessageSpecV1>",
        events: "Vec<ContractEventSpecV1>",
        docs: "Vec<Text>"
    },
    ContractContractSpecV2: {
        constructors: "Vec<ContractConstructorSpecV2>",
        messages: "Vec<ContractMessageSpecV2>",
        events: "Vec<ContractEventSpecV2>",
        docs: "Vec<Text>"
    },
    ContractContractSpecV3: {
        constructors: "Vec<ContractConstructorSpecV3>",
        messages: "Vec<ContractMessageSpecV2>",
        events: "Vec<ContractEventSpecV2>",
        docs: "Vec<Text>"
    },
    ContractDisplayName: "SiPath",
    ContractEventParamSpecV0: {
        name: "Text",
        indexed: "bool",
        type: "ContractTypeSpec",
        docs: "Vec<Text>"
    },
    ContractEventParamSpecV2: {
        label: "Text",
        indexed: "bool",
        type: "ContractTypeSpec",
        docs: "Vec<Text>"
    },
    ContractEventSpecV0: {
        name: "Text",
        args: "Vec<ContractEventParamSpecV0>",
        docs: "Vec<Text>"
    },
    ContractEventSpecV1: {
        name: "Text",
        args: "Vec<ContractEventParamSpecV0>",
        docs: "Vec<Text>"
    },
    ContractEventSpecV2: {
        label: "Text",
        args: "Vec<ContractEventParamSpecV2>",
        docs: "Vec<Text>"
    },
    ContractMessageParamSpecV0: {
        name: "Text",
        type: "ContractTypeSpec"
    },
    ContractMessageParamSpecV2: {
        label: "Text",
        type: "ContractTypeSpec"
    },
    ContractMessageSpecV0: {
        name: "Text",
        selector: "ContractSelector",
        mutates: "bool",
        payable: "bool",
        args: "Vec<ContractMessageParamSpecV0>",
        returnType: "Option<ContractTypeSpec>",
        docs: "Vec<Text>"
    },
    ContractMessageSpecV1: {
        name: "Vec<Text>",
        selector: "ContractSelector",
        mutates: "bool",
        payable: "bool",
        args: "Vec<ContractMessageParamSpecV0>",
        returnType: "Option<ContractTypeSpec>",
        docs: "Vec<Text>"
    },
    ContractMessageSpecV2: {
        label: "Text",
        selector: "ContractSelector",
        mutates: "bool",
        payable: "bool",
        args: "Vec<ContractMessageParamSpecV2>",
        returnType: "Option<ContractTypeSpec>",
        docs: "Vec<Text>"
    },
    ContractSelector: "[u8; 4]",
    ContractTypeSpec: {
        type: "SiLookupTypeId",
        displayName: "ContractDisplayName"
    }
};
const ContractMetadataV0 = {
    types: "Vec<Si0Type>",
    spec: "ContractContractSpecV0"
};
const ContractMetadataV1 = {
    types: "Vec<PortableType>",
    spec: "ContractContractSpecV1"
};
const ContractMetadataV2 = {
    types: "Vec<PortableType>",
    spec: "ContractContractSpecV2"
};
const ContractMetadataV3 = {
    types: "Vec<PortableType>",
    spec: "ContractContractSpecV3"
};
const ContractProjectInfo = {
    source: "ContractProjectSource",
    contract: "ContractProjectContract"
};
const latest = {
    ContractConstructorSpecLatest: "ContractConstructorSpecV3",
    ContractEventSpecLatest: "ContractEventSpecV2",
    ContractEventParamSpecLatest: "ContractEventParamSpecV2",
    ContractMessageParamSpecLatest: "ContractMessageParamSpecV2",
    ContractMessageSpecLatest: "ContractMessageSpecV2",
    ContractMetadataLatest: "ContractMetadataV3"
};
exports.default = {
    rpc: {},
    types: (0, _util.objectSpread)({}, layout, spec, latest, {
        ContractProjectInfo,
        ContractMetadataV0,
        ContractMetadataV1,
        ContractMetadataV2,
        ContractMetadataV3,
        ContractMetadata: {
            _enum: {
                V0: "ContractMetadataV0",
                V1: "ContractMetadataV1",
                V2: "ContractMetadataV2",
                V3: "ContractMetadataV3"
            }
        },
        ContractProjectV0: (0, _util.objectSpread)({
            metadataVersion: "Text"
        }, ContractProjectInfo, ContractMetadataV0),
        ContractProject: "(ContractProjectInfo, ContractMetadata)",
        ContractProjectContract: {
            _alias: {
                docs: "documentation"
            },
            name: "Text",
            version: "Text",
            authors: "Vec<Text>",
            description: "Option<Text>",
            docs: "Option<Text>",
            repository: "Option<Text>",
            homepage: "Option<Text>",
            license: "Option<Text>"
        },
        ContractProjectSource: {
            _alias: {
                wasmHash: "hash"
            },
            wasmHash: "[u8; 32]",
            language: "Text",
            compiler: "Text",
            wasm: "Raw"
        }
    })
};

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h4sbM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ // As per frontier
var _util = require("@polkadot/util");
var _rpcJs = require("./rpc.js");
var _runtimeJs = require("./runtime.js");
const V0 = {
    BlockV0: {
        header: "EthHeader",
        transactions: "Vec<TransactionV0>",
        ommers: "Vec<EthHeader>"
    },
    LegacyTransaction: {
        nonce: "U256",
        gasPrice: "U256",
        gasLimit: "U256",
        action: "EthTransactionAction",
        value: "U256",
        input: "Bytes",
        signature: "EthTransactionSignature"
    },
    TransactionV0: "LegacyTransaction"
};
const V1 = {
    BlockV1: {
        header: "EthHeader",
        transactions: "Vec<TransactionV1>",
        ommers: "Vec<EthHeader>"
    },
    EIP2930Transaction: {
        chainId: "u64",
        nonce: "U256",
        gasPrice: "U256",
        gasLimit: "U256",
        action: "EthTransactionAction",
        value: "U256",
        input: "Bytes",
        accessList: "EthAccessList",
        oddYParity: "bool",
        r: "H256",
        s: "H256"
    },
    TransactionV1: {
        _enum: {
            Legacy: "LegacyTransaction",
            EIP2930: "EIP2930Transaction"
        }
    }
};
const V2 = {
    BlockV2: {
        header: "EthHeader",
        transactions: "Vec<TransactionV2>",
        ommers: "Vec<EthHeader>"
    },
    EIP1559Transaction: {
        chainId: "u64",
        nonce: "U256",
        maxPriorityFeePerGas: "U256",
        maxFeePerGas: "U256",
        gasLimit: "U256",
        action: "EthTransactionAction",
        value: "U256",
        input: "Bytes",
        accessList: "EthAccessList",
        oddYParity: "bool",
        r: "H256",
        s: "H256"
    },
    TransactionV2: {
        _enum: {
            Legacy: "LegacyTransaction",
            EIP2930: "EIP2930Transaction",
            EIP1559: "EIP1559Transaction"
        }
    }
};
const types = (0, _util.objectSpread)({}, V0, V1, V2, {
    EthereumAccountId: "GenericEthereumAccountId",
    EthereumAddress: "GenericEthereumAccountId",
    EthereumLookupSource: "GenericEthereumLookupSource",
    EthereumSignature: "[u8; 65]",
    EthAccessListItem: {
        address: "EthAddress",
        slots: "Vec<H256>"
    },
    EthAccessList: "Vec<EthAccessListItem>",
    EthAccount: {
        address: "EthAddress",
        balance: "U256",
        nonce: "U256",
        codeHash: "H256",
        storageHash: "H256",
        accountProof: "Vec<Bytes>",
        storageProof: "Vec<EthStorageProof>"
    },
    EthAddress: "H160",
    EthBlock: {
        header: "EthHeader",
        transactions: "Vec<EthTransaction>",
        ommers: "Vec<EthHeader>"
    },
    EthHeader: {
        parentHash: "H256",
        ommersHash: "H256",
        beneficiary: "EthAddress",
        stateRoot: "H256",
        transactionsRoot: "H256",
        receiptsRoot: "H256",
        logsBloom: "EthBloom",
        difficulty: "U256",
        number: "U256",
        gasLimit: "U256",
        gasUsed: "U256",
        timestamp: "u64",
        extraData: "Bytes",
        mixMash: "H256",
        nonce: "H64"
    },
    EthRichBlock: {
        _alias: {
            blockHash: "hash",
            blockSize: "size"
        },
        blockHash: "Option<H256>",
        parentHash: "H256",
        sha3Uncles: "H256",
        author: "EthAddress",
        miner: "EthAddress",
        stateRoot: "H256",
        transactionsRoot: "H256",
        receiptsRoot: "H256",
        number: "Option<U256>",
        gasUsed: "U256",
        gasLimit: "U256",
        extraData: "Bytes",
        logsBloom: "EthBloom",
        timestamp: "U256",
        difficulty: "U256",
        totalDifficulty: "Option<U256>",
        sealFields: "Vec<Bytes>",
        uncles: "Vec<H256>",
        transactions: "Vec<EthTransaction>",
        blockSize: "Option<U256>"
    },
    EthBloom: "H2048",
    EthCallRequest: {
        from: "Option<EthAddress>",
        to: "Option<EthAddress>",
        gasPrice: "Option<U256>",
        gas: "Option<U256>",
        value: "Option<U256>",
        data: "Option<Bytes>",
        nonce: "Option<U256>"
    },
    EthFeeHistory: {
        oldestBlock: "U256",
        baseFeePerGas: "Vec<U256>",
        gasUsedRatio: "Vec<f64>",
        reward: "Option<Vec<Vec<U256>>>"
    },
    EthFilter: {
        fromBlock: "Option<BlockNumber>",
        toBlock: "Option<BlockNumber>",
        blockHash: "Option<H256>",
        address: "Option<EthFilterAddress>",
        topics: "Option<EthFilterTopic>"
    },
    EthFilterAddress: {
        _enum: {
            Single: "EthAddress",
            Multiple: "Vec<EthAddress>",
            Null: "Null"
        }
    },
    EthFilterChanges: {
        _enum: {
            Logs: "Vec<EthLog>",
            Hashes: "Vec<H256>",
            Empty: "Null"
        }
    },
    EthFilterTopic: {
        _enum: {
            Single: "EthFilterTopicInner",
            Multiple: "Vec<EthFilterTopicInner>",
            Null: "Null"
        }
    },
    EthFilterTopicEntry: "Option<H256>",
    EthFilterTopicInner: {
        _enum: {
            Single: "EthFilterTopicEntry",
            Multiple: "Vec<EthFilterTopicEntry>",
            Null: "Null"
        }
    },
    EthRichHeader: {
        _alias: {
            blockHash: "hash",
            blockSize: "size"
        },
        blockHash: "Option<H256>",
        parentHash: "H256",
        sha3Uncles: "H256",
        author: "EthAddress",
        miner: "EthAddress",
        stateRoot: "H256",
        transactionsRoot: "H256",
        receiptsRoot: "H256",
        number: "Option<U256>",
        gasUsed: "U256",
        gasLimit: "U256",
        extraData: "Bytes",
        logsBloom: "EthBloom",
        timestamp: "U256",
        difficulty: "U256",
        sealFields: "Vec<Bytes>",
        blockSize: "Option<U256>"
    },
    EthLog: {
        address: "EthAddress",
        topics: "Vec<H256>",
        data: "Bytes",
        blockHash: "Option<H256>",
        blockNumber: "Option<U256>",
        transactionHash: "Option<H256>",
        transactionIndex: "Option<U256>",
        logIndex: "Option<U256>",
        transactionLogIndex: "Option<U256>",
        removed: "bool"
    },
    EthReceipt: {
        transactionHash: "Option<H256>",
        transactionIndex: "Option<U256>",
        blockHash: "Option<H256>",
        from: "Option<EthAddress>",
        to: "Option<EthAddress>",
        blockNumber: "Option<U256>",
        cumulativeGasUsed: "U256",
        gasUsed: "Option<U256>",
        contractAddress: "Option<EthAddress>",
        logs: "Vec<EthLog>",
        root: "Option<H256>",
        logsBloom: "EthBloom",
        statusCode: "Option<U64>"
    },
    // not convinced, however the original commit matches, so... (maybe V3 is incorrect?)
    EthReceiptV0: "EthReceipt",
    EthReceiptV3: "EthReceipt",
    EthStorageProof: {
        key: "U256",
        value: "U256",
        proof: "Vec<Bytes>"
    },
    EthSubKind: {
        _enum: [
            "newHeads",
            "logs",
            "newPendingTransactions",
            "syncing"
        ]
    },
    EthSubParams: {
        _enum: {
            None: "Null",
            Logs: "EthFilter"
        }
    },
    EthSubResult: {
        _enum: {
            Header: "EthRichHeader",
            Log: "EthLog",
            TransactionHash: "H256",
            SyncState: "EthSyncStatus"
        }
    },
    EthSyncInfo: {
        startingBlock: "U256",
        currentBlock: "U256",
        highestBlock: "U256",
        warpChunksAmount: "Option<U256>",
        warpChunksProcessed: "Option<U256>"
    },
    EthSyncStatus: {
        _enum: {
            Info: "EthSyncInfo",
            None: "Null"
        }
    },
    EthTransaction: {
        hash: "H256",
        nonce: "U256",
        blockHash: "Option<H256>",
        blockNumber: "Option<U256>",
        transactionIndex: "Option<U256>",
        from: "H160",
        to: "Option<H160>",
        value: "U256",
        gasPrice: "Option<U256>",
        maxFeePerGas: "Option<U256>",
        maxPriorityFeePerGas: "Option<U256>",
        gas: "U256",
        input: "Bytes",
        creates: "Option<H160>",
        raw: "Bytes",
        publicKey: "Option<H512>",
        chainId: "Option<U64>",
        standardV: "U256",
        v: "U256",
        r: "U256",
        s: "U256",
        accessList: "Option<Vec<EthAccessListItem>>",
        transactionType: "Option<U256>"
    },
    EthTransactionSignature: {
        v: "u64",
        r: "H256",
        s: "H256"
    },
    EthTransactionAction: {
        _enum: {
            Call: "H160",
            Create: "Null"
        }
    },
    EthTransactionCondition: {
        _enum: {
            block: "u64",
            time: "u64"
        }
    },
    EthTransactionRequest: {
        from: "Option<EthAddress>",
        to: "Option<EthAddress>",
        gasPrice: "Option<U256>",
        gas: "Option<U256>",
        value: "Option<U256>",
        data: "Option<Bytes>",
        nonce: "Option<U256>"
    },
    EthTransactionStatus: {
        transactionHash: "H256",
        transactionIndex: "u32",
        from: "EthAddress",
        to: "Option<EthAddress>",
        contractAddress: "Option<EthAddress>",
        logs: "Vec<EthLog>",
        logsBloom: "EthBloom"
    },
    EthWork: {
        powHash: "H256",
        seedHash: "H256",
        target: "H256",
        number: "Option<u64>"
    }
});
exports.default = {
    rpc: (0, _rpcJs.rpc),
    runtime: (0, _runtimeJs.runtime),
    types
};

},{"@polkadot/util":"3HnHw","./rpc.js":"a3K56","./runtime.js":"hPRUR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a3K56":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// As per frontier
var _util = require("@polkadot/util"); // We use aliasSection here to override since these are in another namespace
const netRpc = {
    listening: {
        aliasSection: "net",
        description: "Returns true if client is actively listening for network connections. Otherwise false.",
        params: [],
        type: "bool"
    },
    peerCount: {
        aliasSection: "net",
        description: "Returns number of peers connected to node.",
        params: [],
        type: "String"
    },
    version: {
        aliasSection: "net",
        description: "Returns protocol version.",
        params: [],
        type: "String"
    }
};
const web3Rpc = {
    clientVersion: {
        aliasSection: "web3",
        description: "Returns current client version.",
        params: [],
        type: "String"
    },
    sha3: {
        aliasSection: "web3",
        description: "Returns sha3 of the given data",
        params: [
            {
                name: "data",
                type: "Bytes"
            }
        ],
        type: "H256"
    }
};
const rpc = (0, _util.objectSpread)({}, netRpc, web3Rpc, {
    accounts: {
        description: "Returns accounts list.",
        params: [],
        type: "Vec<H160>"
    },
    blockNumber: {
        description: "Returns the blockNumber",
        params: [],
        type: "U256"
    },
    call: {
        description: "Call contract, returning the output data.",
        params: [
            {
                name: "request",
                type: "EthCallRequest"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "number",
                type: "BlockNumber"
            }
        ],
        type: "Bytes"
    },
    chainId: {
        description: "Returns the chain ID used for transaction signing at the current best block. None is returned if not available.",
        params: [],
        type: "U64"
    },
    coinbase: {
        description: "Returns block author.",
        params: [],
        type: "H160"
    },
    estimateGas: {
        description: "Estimate gas needed for execution of given contract.",
        params: [
            {
                name: "request",
                type: "EthCallRequest"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "number",
                type: "BlockNumber"
            }
        ],
        type: "U256"
    },
    feeHistory: {
        description: "Returns fee history for given block count & reward percentiles",
        params: [
            {
                name: "blockCount",
                type: "U256"
            },
            {
                name: "newestBlock",
                type: "BlockNumber"
            },
            {
                name: "rewardPercentiles",
                type: "Option<Vec<f64>>"
            }
        ],
        type: "EthFeeHistory"
    },
    gasPrice: {
        description: "Returns current gas price.",
        params: [],
        type: "U256"
    },
    getBalance: {
        description: "Returns balance of the given account.",
        params: [
            {
                name: "address",
                type: "H160"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "number",
                type: "BlockNumber"
            }
        ],
        type: "U256"
    },
    getBlockByHash: {
        description: "Returns block with given hash.",
        params: [
            {
                name: "hash",
                type: "H256"
            },
            {
                name: "full",
                type: "bool"
            }
        ],
        type: "Option<EthRichBlock>"
    },
    getBlockByNumber: {
        description: "Returns block with given number.",
        params: [
            {
                name: "block",
                type: "BlockNumber"
            },
            {
                name: "full",
                type: "bool"
            }
        ],
        type: "Option<EthRichBlock>"
    },
    getBlockTransactionCountByHash: {
        description: "Returns the number of transactions in a block with given hash.",
        params: [
            {
                name: "hash",
                type: "H256"
            }
        ],
        type: "U256"
    },
    getBlockTransactionCountByNumber: {
        description: "Returns the number of transactions in a block with given block number.",
        params: [
            {
                name: "block",
                type: "BlockNumber"
            }
        ],
        type: "U256"
    },
    getCode: {
        description: "Returns the code at given address at given time (block number).",
        params: [
            {
                name: "address",
                type: "H160"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "number",
                type: "BlockNumber"
            }
        ],
        type: "Bytes"
    },
    getFilterChanges: {
        description: "Returns filter changes since last poll.",
        params: [
            {
                name: "index",
                type: "U256"
            }
        ],
        type: "EthFilterChanges"
    },
    getFilterLogs: {
        description: "Returns all logs matching given filter (in a range 'from' - 'to').",
        params: [
            {
                name: "index",
                type: "U256"
            }
        ],
        type: "Vec<EthLog>"
    },
    getLogs: {
        description: "Returns logs matching given filter object.",
        params: [
            {
                name: "filter",
                type: "EthFilter"
            }
        ],
        type: "Vec<EthLog>"
    },
    getProof: {
        description: "Returns proof for account and storage.",
        params: [
            {
                name: "address",
                type: "H160"
            },
            {
                name: "storageKeys",
                type: "Vec<H256>"
            },
            {
                name: "number",
                type: "BlockNumber"
            }
        ],
        type: "EthAccount"
    },
    getStorageAt: {
        description: "Returns content of the storage at given address.",
        params: [
            {
                name: "address",
                type: "H160"
            },
            {
                name: "index",
                type: "U256"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "number",
                type: "BlockNumber"
            }
        ],
        type: "H256"
    },
    getTransactionByBlockHashAndIndex: {
        description: "Returns transaction at given block hash and index.",
        params: [
            {
                name: "hash",
                type: "H256"
            },
            {
                name: "index",
                type: "U256"
            }
        ],
        type: "EthTransaction"
    },
    getTransactionByBlockNumberAndIndex: {
        description: "Returns transaction by given block number and index.",
        params: [
            {
                name: "number",
                type: "BlockNumber"
            },
            {
                name: "index",
                type: "U256"
            }
        ],
        type: "EthTransaction"
    },
    getTransactionByHash: {
        description: "Get transaction by its hash.",
        params: [
            {
                name: "hash",
                type: "H256"
            }
        ],
        type: "EthTransaction"
    },
    getTransactionCount: {
        description: "Returns the number of transactions sent from given address at given time (block number).",
        params: [
            {
                name: "hash",
                type: "H256"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "number",
                type: "BlockNumber"
            }
        ],
        type: "U256"
    },
    getTransactionReceipt: {
        description: "Returns transaction receipt by transaction hash.",
        params: [
            {
                name: "hash",
                type: "H256"
            }
        ],
        type: "EthReceipt"
    },
    getUncleByBlockHashAndIndex: {
        description: "Returns an uncles at given block and index.",
        params: [
            {
                name: "hash",
                type: "H256"
            },
            {
                name: "index",
                type: "U256"
            }
        ],
        type: "EthRichBlock"
    },
    getUncleByBlockNumberAndIndex: {
        description: "Returns an uncles at given block and index.",
        params: [
            {
                name: "number",
                type: "BlockNumber"
            },
            {
                name: "index",
                type: "U256"
            }
        ],
        type: "EthRichBlock"
    },
    getUncleCountByBlockHash: {
        description: "Returns the number of uncles in a block with given hash.",
        params: [
            {
                name: "hash",
                type: "H256"
            }
        ],
        type: "U256"
    },
    getUncleCountByBlockNumber: {
        description: "Returns the number of uncles in a block with given block number.",
        params: [
            {
                name: "number",
                type: "BlockNumber"
            }
        ],
        type: "U256"
    },
    getWork: {
        description: "Returns the hash of the current block, the seedHash, and the boundary condition to be met.",
        params: [],
        type: "EthWork"
    },
    hashrate: {
        description: "Returns the number of hashes per second that the node is mining with.",
        params: [],
        type: "U256"
    },
    maxPriorityFeePerGas: {
        description: "Returns max priority fee per gas",
        params: [],
        type: "U256"
    },
    mining: {
        description: "Returns true if client is actively mining new blocks.",
        params: [],
        type: "bool"
    },
    newBlockFilter: {
        description: "Returns id of new block filter.",
        params: [],
        type: "U256"
    },
    newFilter: {
        description: "Returns id of new filter.",
        params: [
            {
                name: "filter",
                type: "EthFilter"
            }
        ],
        type: "U256"
    },
    newPendingTransactionFilter: {
        description: "Returns id of new block filter.",
        params: [],
        type: "U256"
    },
    protocolVersion: {
        description: "Returns protocol version encoded as a string (quotes are necessary).",
        params: [],
        type: "u64"
    },
    sendRawTransaction: {
        description: "Sends signed transaction, returning its hash.",
        params: [
            {
                name: "bytes",
                type: "Bytes"
            }
        ],
        type: "H256"
    },
    sendTransaction: {
        description: "Sends transaction; will block waiting for signer to return the transaction hash",
        params: [
            {
                name: "tx",
                type: "EthTransactionRequest"
            }
        ],
        type: "H256"
    },
    submitHashrate: {
        description: "Used for submitting mining hashrate.",
        params: [
            {
                name: "index",
                type: "U256"
            },
            {
                name: "hash",
                type: "H256"
            }
        ],
        type: "bool"
    },
    submitWork: {
        description: "Used for submitting a proof-of-work solution.",
        params: [
            {
                name: "nonce",
                type: "H64"
            },
            {
                name: "headerHash",
                type: "H256"
            },
            {
                name: "mixDigest",
                type: "H256"
            }
        ],
        type: "bool"
    },
    subscribe: {
        description: "Subscribe to Eth subscription.",
        params: [
            {
                name: "kind",
                type: "EthSubKind"
            },
            {
                isOptional: true,
                name: "params",
                type: "EthSubParams"
            }
        ],
        pubsub: [
            "subscription",
            "subscribe",
            "unsubscribe"
        ],
        type: "Null"
    },
    syncing: {
        description: "Returns an object with data about the sync status or false.",
        params: [],
        type: "EthSyncStatus"
    },
    uninstallFilter: {
        description: "Uninstalls filter.",
        params: [
            {
                name: "index",
                type: "U256"
            }
        ],
        type: "bool"
    }
});

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hPRUR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    ConvertTransactionRuntimeApi: [
        {
            methods: {
                convert_transaction: {
                    description: "Converts an Ethereum-style transaction to Extrinsic",
                    params: [
                        {
                            name: "transaction",
                            type: "TransactionV2"
                        }
                    ],
                    type: "Extrinsic"
                }
            },
            version: 2
        }
    ],
    DebugRuntimeApi: [
        {
            methods: {
                trace_block: {
                    description: "Trace all block extrinsics",
                    params: [
                        {
                            name: "extrinsics",
                            type: "Vec<Extrinsic>"
                        },
                        {
                            name: "knownTransactions",
                            type: "Vec<H256>"
                        }
                    ],
                    type: "Result<(), DispatchError>"
                },
                trace_transaction: {
                    description: "Trace transaction extrinsics",
                    params: [
                        {
                            name: "extrinsics",
                            type: "Vec<Extrinsic>"
                        },
                        {
                            name: "transaction",
                            type: "EthTransaction"
                        }
                    ],
                    type: "Result<(), DispatchError>"
                }
            },
            version: 4
        }
    ],
    EthereumRuntimeRPCApi: [
        {
            methods: {
                account_basic: {
                    description: "Returns pallet_evm::Accounts by address.",
                    params: [
                        {
                            name: "address",
                            type: "H160"
                        }
                    ],
                    type: "EvmAccount"
                },
                account_code_at: {
                    description: "For a given account address, returns pallet_evm::AccountCodes.",
                    params: [
                        {
                            name: "address",
                            type: "H160"
                        }
                    ],
                    type: "Bytes"
                },
                author: {
                    description: "Returns the converted FindAuthor::find_author authority id.",
                    params: [],
                    type: "H160"
                },
                call: {
                    description: "Returns a frame_ethereum::call response. If `estimate` is true,",
                    params: [
                        {
                            name: "from",
                            type: "H160"
                        },
                        {
                            name: "to",
                            type: "H160"
                        },
                        {
                            name: "data",
                            type: "Vec<u8>"
                        },
                        {
                            name: "value",
                            type: "U256"
                        },
                        {
                            name: "gasLimit",
                            type: "U256"
                        },
                        {
                            name: "maxFeePerGas",
                            type: "Option<U256>"
                        },
                        {
                            name: "maxPriorityFeePerGas",
                            type: "Option<U256>"
                        },
                        {
                            name: "nonce",
                            type: "Option<U256>"
                        },
                        {
                            name: "estimate",
                            type: "bool"
                        },
                        {
                            name: "accessList",
                            type: "Option<Vec<(H160, Vec<H256>)>>"
                        }
                    ],
                    type: "Result<EvmCallInfo, DispatchError>"
                },
                chain_id: {
                    description: "Returns runtime defined pallet_evm::ChainId.",
                    params: [],
                    type: "u64"
                },
                create: {
                    description: "Returns a frame_ethereum::call response. If `estimate` is true,",
                    params: [
                        {
                            name: "from",
                            type: "H160"
                        },
                        {
                            name: "data",
                            type: "Vec<u8>"
                        },
                        {
                            name: "value",
                            type: "U256"
                        },
                        {
                            name: "gasLimit",
                            type: "U256"
                        },
                        {
                            name: "maxFeePerGas",
                            type: "Option<U256>"
                        },
                        {
                            name: "maxPriorityFeePerGas",
                            type: "Option<U256>"
                        },
                        {
                            name: "nonce",
                            type: "Option<U256>"
                        },
                        {
                            name: "estimate",
                            type: "bool"
                        },
                        {
                            name: "accessList",
                            type: "Option<Vec<(H160, Vec<H256>)>>"
                        }
                    ],
                    type: "Result<EvmCreateInfo, DispatchError>"
                },
                current_all: {
                    description: "Return all the current data for a block in a single runtime call.",
                    params: [],
                    type: "(Option<BlockV2>, Option<Vec<ReceiptV0>>, Option<Vec<TransactionStatus>>)"
                },
                current_block: {
                    description: "Return the current block.",
                    params: [],
                    type: "BlockV2"
                },
                current_receipts: {
                    description: "Return the current receipt.",
                    params: [],
                    type: "Option<Vec<EthReceiptV3>>"
                },
                current_transaction_statuses: {
                    description: "Return the current transaction status.",
                    params: [],
                    type: "Option<Vec<EthTransactionStatus>>"
                },
                elasticity: {
                    description: "Return the elasticity multiplier.",
                    params: [],
                    type: "Option<Permill>"
                },
                extrinsic_filter: {
                    description: "Receives a `Vec<OpaqueExtrinsic>` and filters all the ethereum transactions.",
                    params: [
                        {
                            name: "xts",
                            type: "Vec<Extrinsic>"
                        }
                    ],
                    type: "Vec<TransactionV2>"
                },
                gas_price: {
                    description: "Returns FixedGasPrice::min_gas_price",
                    params: [],
                    type: "u256"
                },
                storage_at: {
                    description: "For a given account address and index, returns pallet_evm::AccountStorages.",
                    params: [
                        {
                            name: "address",
                            type: "H160"
                        },
                        {
                            name: "index",
                            type: "u256"
                        }
                    ],
                    type: "H256"
                }
            },
            version: 4
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eMBA0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {}
};

},{"./runtime.js":"286O2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"286O2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    // deprecated, the NimbusApi is current - this is for backwards compat
    AuthorFilterAPI: [
        {
            methods: {
                can_author: {
                    description: "The runtime api used to predict whether an author will be eligible in the given slot",
                    params: [
                        {
                            name: "author",
                            type: "AccountId"
                        },
                        {
                            name: "relayParent",
                            type: "u32"
                        },
                        {
                            name: "parentHeader",
                            type: "Header"
                        }
                    ],
                    type: "bool"
                }
            },
            version: 2
        },
        {
            methods: {
                can_author: {
                    description: "The runtime api used to predict whether an author will be eligible in the given slot",
                    params: [
                        {
                            name: "author",
                            type: "AccountId"
                        },
                        {
                            name: "relayParent",
                            type: "u32"
                        }
                    ],
                    type: "bool"
                }
            },
            version: 1
        }
    ],
    NimbusApi: [
        {
            methods: {
                can_author: {
                    description: "The runtime api used to predict whether a Nimbus author will be eligible in the given slot",
                    params: [
                        {
                            name: "author",
                            type: "AccountId"
                        },
                        {
                            name: "relayParent",
                            type: "u32"
                        },
                        {
                            name: "parentHeader",
                            type: "Header"
                        }
                    ],
                    type: "bool"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kTf8P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {}
};

},{"./runtime.js":"3DHfS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3DHfS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    // https://github.com/open-web3-stack/open-runtime-module-library/blob/b57f88b39cd547e2fb51727d8bb9bcc64fddf8b5/oracle/rpc/runtime-api/src/lib.rs#L12-L21
    OracleApi: [
        {
            methods: {
                get_all_values: {
                    description: "Retrieves all values",
                    params: [
                        {
                            name: "providerId",
                            // This is a Codec type
                            type: "Raw"
                        }
                    ],
                    // This won't actually work as expected - since we have
                    // no information about the actual Raw sizes, we cannot
                    // handle it in this format (it would need an override
                    // for the specific Codec). So return the Raw value.
                    // type: 'Vec<(Raw, Option<Raw>)>'
                    type: "Raw"
                },
                get_value: {
                    description: "Retrieves a single value",
                    params: [
                        {
                            name: "providerId",
                            // This is a Codec type
                            type: "Raw"
                        },
                        {
                            name: "key",
                            // This is a Codec type
                            type: "Raw"
                        }
                    ],
                    // This is an Option<Codec> type
                    type: "Option<Raw>"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"grkrk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: {},
    runtime: (0, _runtimeJs.runtime),
    types: {}
};

},{"./runtime.js":"hxNvT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hxNvT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    // https://github.com/open-web3-stack/open-runtime-module-library/blob/b57f88b39cd547e2fb51727d8bb9bcc64fddf8b5/tokens/rpc/runtime-api/src/lib.rs#L11-L18
    TokensApi: [
        {
            methods: {
                query_existential_deposit: {
                    description: "Query the existential amount for a specific currency",
                    params: [
                        {
                            name: "currencyId",
                            // This is CurrencyId, as per the return value, we are unsure
                            // if this is specialized and/or global to the chain or not
                            type: "Raw"
                        }
                    ],
                    // This is Balance - since we don't understand enough about the way
                    // in which this is used, we default to u128 here (it certainly could
                    // be a specialized type that doesn't map to the on-chain Balance)
                    type: "u128"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dIscT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    types: {
        RpcMethods: {
            version: "u32",
            methods: "Vec<Text>"
        }
    }
};

},{"./rpc.js":"znrHt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"znrHt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    methods: {
        description: "Retrieves the list of RPC methods that are exposed by the node",
        params: [],
        type: "RpcMethods"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hkDY6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    types: {
        ExtrinsicOrHash: {
            _enum: {
                Hash: "Hash",
                Extrinsic: "Bytes"
            }
        },
        ExtrinsicStatus: {
            _enum: {
                Future: "Null",
                Ready: "Null",
                Broadcast: "Vec<Text>",
                InBlock: "Hash",
                Retracted: "Hash",
                FinalityTimeout: "Hash",
                Finalized: "Hash",
                Usurped: "Hash",
                Dropped: "Null",
                Invalid: "Null"
            }
        }
    }
};

},{"./rpc.js":"lGyys","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lGyys":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    hasKey: {
        description: "Returns true if the keystore has private keys for the given public key and key type.",
        params: [
            {
                name: "publicKey",
                type: "Bytes"
            },
            {
                name: "keyType",
                type: "Text"
            }
        ],
        type: "bool"
    },
    hasSessionKeys: {
        description: "Returns true if the keystore has private keys for the given session public keys.",
        params: [
            {
                name: "sessionKeys",
                type: "Bytes"
            }
        ],
        type: "bool"
    },
    insertKey: {
        description: "Insert a key into the keystore.",
        params: [
            {
                name: "keyType",
                type: "Text"
            },
            {
                name: "suri",
                type: "Text"
            },
            {
                name: "publicKey",
                type: "Bytes"
            }
        ],
        type: "Bytes"
    },
    pendingExtrinsics: {
        description: "Returns all pending extrinsics, potentially grouped by sender",
        params: [],
        type: "Vec<Extrinsic>"
    },
    removeExtrinsic: {
        description: "Remove given extrinsic from the pool and temporarily ban it to prevent reimporting",
        params: [
            {
                name: "bytesOrHash",
                type: "Vec<ExtrinsicOrHash>"
            }
        ],
        type: "Vec<Hash>"
    },
    rotateKeys: {
        description: "Generate new session keys and returns the corresponding public keys",
        params: [],
        type: "Bytes"
    },
    submitAndWatchExtrinsic: {
        description: "Submit and subscribe to watch an extrinsic until unsubscribed",
        isSigned: true,
        params: [
            {
                name: "extrinsic",
                type: "Extrinsic"
            }
        ],
        pubsub: [
            "extrinsicUpdate",
            "submitAndWatchExtrinsic",
            "unwatchExtrinsic"
        ],
        type: "ExtrinsicStatus"
    },
    submitExtrinsic: {
        description: "Submit a fully formatted extrinsic for block inclusion",
        isSigned: true,
        params: [
            {
                name: "extrinsic",
                type: "Extrinsic"
            }
        ],
        type: "Hash"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iLEm8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    types: {
        BlockHash: "Hash"
    }
};

},{"./rpc.js":"ayz85","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ayz85":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    getBlock: {
        description: "Get header and body of a relay chain block",
        params: [
            {
                isHistoric: true,
                isOptional: true,
                name: "hash",
                type: "BlockHash"
            }
        ],
        type: "SignedBlock"
    },
    getBlockHash: {
        description: "Get the block hash for a specific block",
        params: [
            {
                isOptional: true,
                name: "blockNumber",
                type: "BlockNumber"
            }
        ],
        type: "BlockHash"
    },
    getFinalizedHead: {
        alias: [
            "chain_getFinalisedHead"
        ],
        description: "Get hash of the last finalized block in the canon chain",
        params: [],
        type: "BlockHash"
    },
    getHeader: {
        alias: [
            "chain_getHead"
        ],
        description: "Retrieves the header for a specific block",
        params: [
            {
                isHistoric: true,
                isOptional: true,
                name: "hash",
                type: "BlockHash"
            }
        ],
        type: "Header"
    },
    subscribeAllHeads: {
        description: "Retrieves the newest header via subscription",
        params: [],
        pubsub: [
            "allHead",
            "subscribeAllHeads",
            "unsubscribeAllHeads"
        ],
        type: "Header"
    },
    subscribeFinalizedHeads: {
        alias: [
            "chain_subscribeFinalisedHeads",
            "chain_unsubscribeFinalisedHeads"
        ],
        description: "Retrieves the best finalized header via subscription",
        params: [],
        pubsub: [
            "finalizedHead",
            "subscribeFinalizedHeads",
            "unsubscribeFinalizedHeads"
        ],
        type: "Header"
    },
    subscribeNewHeads: {
        alias: [
            "chain_unsubscribeNewHeads",
            "subscribe_newHead",
            "unsubscribe_newHead"
        ],
        description: "Retrieves the best header via subscription",
        params: [],
        // NOTE These still has the aliassed version, compatible with 1.x
        pubsub: [
            "newHead",
            "subscribeNewHead",
            "unsubscribeNewHead"
        ],
        type: "Header"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4gxGw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    types: {
        // StorageKey extends Bytes
        PrefixedStorageKey: "StorageKey"
    }
};

},{"./rpc.js":"3j6oB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3j6oB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    getKeys: {
        description: "Returns the keys with prefix from a child storage, leave empty to get all the keys",
        params: [
            {
                name: "childKey",
                type: "PrefixedStorageKey"
            },
            {
                name: "prefix",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "Hash"
            }
        ],
        type: "Vec<StorageKey>"
    },
    getKeysPaged: {
        alias: [
            "childstate_getKeysPagedAt"
        ],
        description: "Returns the keys with prefix from a child storage with pagination support",
        params: [
            {
                name: "childKey",
                type: "PrefixedStorageKey"
            },
            {
                name: "prefix",
                type: "StorageKey"
            },
            {
                name: "count",
                type: "u32"
            },
            {
                isOptional: true,
                name: "startKey",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "Hash"
            }
        ],
        type: "Vec<StorageKey>"
    },
    getStorage: {
        description: "Returns a child storage entry at a specific block state",
        params: [
            {
                name: "childKey",
                type: "PrefixedStorageKey"
            },
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "Hash"
            }
        ],
        type: "Option<StorageData>"
    },
    getStorageEntries: {
        description: "Returns child storage entries for multiple keys at a specific block state",
        params: [
            {
                name: "childKey",
                type: "PrefixedStorageKey"
            },
            {
                name: "keys",
                type: "Vec<StorageKey>"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "Hash"
            }
        ],
        type: "Vec<Option<StorageData>>"
    },
    getStorageHash: {
        description: "Returns the hash of a child storage entry at a block state",
        params: [
            {
                name: "childKey",
                type: "PrefixedStorageKey"
            },
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "Hash"
            }
        ],
        type: "Option<Hash>"
    },
    getStorageSize: {
        description: "Returns the size of a child storage entry at a block state",
        params: [
            {
                name: "childKey",
                type: "PrefixedStorageKey"
            },
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "Hash"
            }
        ],
        type: "Option<u64>"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"CTv6V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    runtime: (0, _runtimeJs.runtime),
    types: {
        StorageKind: {
            _enum: {
                PERSISTENT: 1,
                LOCAL: 2
            }
        }
    }
};

},{"./rpc.js":"6HZha","./runtime.js":"llXdp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6HZha":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    localStorageGet: {
        description: "Get offchain local storage under given key and prefix",
        params: [
            {
                name: "kind",
                type: "StorageKind"
            },
            {
                name: "key",
                type: "Bytes"
            }
        ],
        type: "Option<Bytes>"
    },
    localStorageSet: {
        description: "Set offchain local storage under given key and prefix",
        params: [
            {
                name: "kind",
                type: "StorageKind"
            },
            {
                name: "key",
                type: "Bytes"
            },
            {
                name: "value",
                type: "Bytes"
            }
        ],
        type: "Null"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llXdp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    OffchainWorkerApi: [
        {
            methods: {
                offchain_worker: {
                    description: "Starts the off-chain task for given block header.",
                    params: [
                        {
                            name: "header",
                            type: "Header"
                        }
                    ],
                    type: "Null"
                }
            },
            version: 2
        },
        {
            methods: {
                offchain_worker: {
                    description: "Starts the off-chain task for given block header.",
                    params: [
                        {
                            name: "number",
                            type: "BlockNumber"
                        }
                    ],
                    type: "Null"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5fFfa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
var _runtimeJs = require("./runtime.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    runtime: (0, _runtimeJs.runtime),
    types: {
        FeeDetails: {
            inclusionFee: "Option<InclusionFee>" // skipped in serde
        },
        InclusionFee: {
            baseFee: "Balance",
            lenFee: "Balance",
            adjustedWeightFee: "Balance"
        },
        RuntimeDispatchInfo: {
            weight: "Weight",
            class: "DispatchClass",
            partialFee: "Balance"
        }
    }
};

},{"./rpc.js":"98nDr","./runtime.js":"62k9j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"98nDr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    queryFeeDetails: {
        description: "Query the detailed fee of a given encoded extrinsic",
        params: [
            {
                name: "extrinsic",
                type: "Bytes"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "FeeDetails"
    },
    queryInfo: {
        description: "Retrieves the fee information for an encoded extrinsic",
        params: [
            {
                name: "extrinsic",
                type: "Bytes"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "RuntimeDispatchInfo"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"62k9j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runtime", ()=>runtime);
const runtime = {
    TransactionPaymentApi: [
        {
            methods: {
                query_fee_details: {
                    description: "The transaction fee details",
                    params: [
                        {
                            name: "uxt",
                            type: "Extrinsic"
                        },
                        {
                            name: "len",
                            type: "u32"
                        }
                    ],
                    type: "FeeDetails"
                },
                query_info: {
                    description: "The transaction info",
                    params: [
                        {
                            name: "uxt",
                            type: "Extrinsic"
                        },
                        {
                            name: "len",
                            type: "u32"
                        }
                    ],
                    type: "RuntimeDispatchInfo"
                }
            },
            version: 1
        }
    ],
    TransactionPaymentCallApi: [
        {
            methods: {
                query_call_fee_details: {
                    description: "The call fee details",
                    params: [
                        {
                            name: "call",
                            type: "Call"
                        },
                        {
                            name: "len",
                            type: "u32"
                        }
                    ],
                    type: "FeeDetails"
                },
                query_call_info: {
                    description: "The call info",
                    params: [
                        {
                            name: "call",
                            type: "Call"
                        },
                        {
                            name: "len",
                            type: "u32"
                        }
                    ],
                    type: "RuntimeDispatchInfo"
                }
            },
            version: 1
        }
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8p1Cg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)
/* eslint-disable sort-keys */ var _rpcJs = require("./rpc.js");
exports.default = {
    rpc: (0, _rpcJs.rpc),
    types: {
        ApiId: "[u8; 8]",
        BlockTrace: {
            blockHash: "Text",
            parentHash: "Text",
            tracingTargets: "Text",
            storageKeys: "Text",
            spans: "Vec<BlockTraceSpan>",
            events: "Vec<BlockTraceEvent>"
        },
        BlockTraceEvent: {
            target: "Text",
            data: "BlockTraceEventData",
            parentId: "Option<u64>"
        },
        BlockTraceEventData: {
            stringValues: "HashMap<Text, Text>"
        },
        BlockTraceSpan: {
            id: "u64",
            parentId: "Option<u64>",
            name: "Text",
            target: "Text",
            wasm: "bool"
        },
        KeyValueOption: "(StorageKey, Option<StorageData>)",
        MigrationStatusResult: {
            topRemainingToMigrate: "u64",
            childRemainingToMigrate: "u64"
        },
        ReadProof: {
            at: "Hash",
            proof: "Vec<Bytes>"
        },
        RuntimeVersionApi: "(ApiId, u32)",
        RuntimeVersion: {
            specName: "Text",
            implName: "Text",
            authoringVersion: "u32",
            specVersion: "u32",
            implVersion: "u32",
            apis: "Vec<RuntimeVersionApi>",
            transactionVersion: "u32",
            stateVersion: "u8"
        },
        RuntimeVersionPre4: {
            specName: "Text",
            implName: "Text",
            authoringVersion: "u32",
            specVersion: "u32",
            implVersion: "u32",
            apis: "Vec<RuntimeVersionApi>",
            transactionVersion: "u32"
        },
        RuntimeVersionPre3: {
            specName: "Text",
            implName: "Text",
            authoringVersion: "u32",
            specVersion: "u32",
            implVersion: "u32",
            apis: "Vec<RuntimeVersionApi>"
        },
        RuntimeVersionPartial: {
            specName: "Text",
            specVersion: "u32",
            apis: "Vec<RuntimeVersionApi>"
        },
        SpecVersion: "u32",
        StorageChangeSet: {
            block: "Hash",
            changes: "Vec<KeyValueOption>"
        },
        TraceBlockResponse: {
            _enum: {
                TraceError: "TraceError",
                BlockTrace: "BlockTrace"
            }
        },
        TraceError: {
            error: "Text"
        }
    }
};

},{"./rpc.js":"fp4Y3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fp4Y3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>rpc);
const rpc = {
    call: {
        alias: [
            "state_callAt"
        ],
        description: "Perform a call to a builtin on the chain",
        params: [
            {
                name: "method",
                type: "Text"
            },
            {
                name: "data",
                type: "Bytes"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Bytes"
    },
    getChildKeys: {
        description: "Retrieves the keys with prefix of a specific child storage",
        params: [
            {
                name: "childStorageKey",
                type: "StorageKey"
            },
            {
                name: "childDefinition",
                type: "StorageKey"
            },
            {
                name: "childType",
                type: "u32"
            },
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Vec<StorageKey>"
    },
    getChildReadProof: {
        description: "Returns proof of storage for child key entries at a specific block state.",
        params: [
            {
                name: "childStorageKey",
                type: "PrefixedStorageKey"
            },
            {
                name: "keys",
                type: "Vec<StorageKey>"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "ReadProof"
    },
    getChildStorage: {
        description: "Retrieves the child storage for a key",
        params: [
            {
                name: "childStorageKey",
                type: "StorageKey"
            },
            {
                name: "childDefinition",
                type: "StorageKey"
            },
            {
                name: "childType",
                type: "u32"
            },
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "StorageData"
    },
    getChildStorageHash: {
        description: "Retrieves the child storage hash",
        params: [
            {
                name: "childStorageKey",
                type: "StorageKey"
            },
            {
                name: "childDefinition",
                type: "StorageKey"
            },
            {
                name: "childType",
                type: "u32"
            },
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Hash"
    },
    getChildStorageSize: {
        description: "Retrieves the child storage size",
        params: [
            {
                name: "childStorageKey",
                type: "StorageKey"
            },
            {
                name: "childDefinition",
                type: "StorageKey"
            },
            {
                name: "childType",
                type: "u32"
            },
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "u64"
    },
    getKeys: {
        description: "Retrieves the keys with a certain prefix",
        params: [
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Vec<StorageKey>"
    },
    getKeysPaged: {
        alias: [
            "state_getKeysPagedAt"
        ],
        description: "Returns the keys with prefix with pagination support.",
        params: [
            {
                name: "key",
                type: "StorageKey"
            },
            {
                name: "count",
                type: "u32"
            },
            {
                isOptional: true,
                name: "startKey",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Vec<StorageKey>"
    },
    getMetadata: {
        description: "Returns the runtime metadata",
        params: [
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Metadata"
    },
    getPairs: {
        description: "Returns the keys with prefix, leave empty to get all the keys (deprecated: Use getKeysPaged)",
        params: [
            {
                name: "prefix",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Vec<KeyValue>"
    },
    getReadProof: {
        description: "Returns proof of storage entries at a specific block state",
        params: [
            {
                name: "keys",
                type: "Vec<StorageKey>"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "ReadProof"
    },
    getRuntimeVersion: {
        alias: [
            "chain_getRuntimeVersion"
        ],
        description: "Get the runtime version",
        params: [
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "RuntimeVersion"
    },
    getStorage: {
        alias: [
            "state_getStorageAt"
        ],
        description: "Retrieves the storage for a key",
        params: [
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "StorageData"
    },
    getStorageHash: {
        alias: [
            "state_getStorageHashAt"
        ],
        description: "Retrieves the storage hash",
        params: [
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Hash"
    },
    getStorageSize: {
        alias: [
            "state_getStorageSizeAt"
        ],
        description: "Retrieves the storage size",
        params: [
            {
                name: "key",
                type: "StorageKey"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "u64"
    },
    queryStorage: {
        description: "Query historical storage entries (by key) starting from a start block",
        params: [
            {
                name: "keys",
                type: "Vec<StorageKey>"
            },
            {
                name: "fromBlock",
                type: "Hash"
            },
            {
                isOptional: true,
                name: "toBlock",
                type: "BlockHash"
            }
        ],
        type: "Vec<StorageChangeSet>"
    },
    queryStorageAt: {
        description: "Query storage entries (by key) starting at block hash given as the second parameter",
        params: [
            {
                name: "keys",
                type: "Vec<StorageKey>"
            },
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "Vec<StorageChangeSet>"
    },
    subscribeRuntimeVersion: {
        alias: [
            "chain_subscribeRuntimeVersion",
            "chain_unsubscribeRuntimeVersion"
        ],
        description: "Retrieves the runtime version via subscription",
        params: [],
        pubsub: [
            "runtimeVersion",
            "subscribeRuntimeVersion",
            "unsubscribeRuntimeVersion"
        ],
        type: "RuntimeVersion"
    },
    subscribeStorage: {
        description: "Subscribes to storage changes for the provided keys",
        params: [
            {
                isOptional: true,
                name: "keys",
                type: "Vec<StorageKey>"
            }
        ],
        pubsub: [
            "storage",
            "subscribeStorage",
            "unsubscribeStorage"
        ],
        type: "StorageChangeSet"
    },
    traceBlock: {
        description: "Provides a way to trace the re-execution of a single block",
        params: [
            {
                name: "block",
                type: "Hash"
            },
            {
                name: "targets",
                type: "Option<Text>"
            },
            {
                name: "storageKeys",
                type: "Option<Text>"
            },
            {
                name: "methods",
                type: "Option<Text>"
            }
        ],
        type: "TraceBlockResponse"
    },
    trieMigrationStatus: {
        description: "Check current migration state",
        params: [
            {
                isHistoric: true,
                isOptional: true,
                name: "at",
                type: "BlockHash"
            }
        ],
        type: "MigrationStatusResult"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"WQpKM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _definitionsJs = require("./definitions.js");
const jsonrpc = {};
Object.keys(_definitionsJs).forEach((s)=>Object.entries(_definitionsJs[s].rpc || {}).forEach(([method, def])=>{
        // allow for section overrides
        const section = def.aliasSection || s;
        if (!jsonrpc[section]) jsonrpc[section] = {};
        jsonrpc[section][method] = (0, _util.objectSpread)({}, def, {
            isSubscription: !!def.pubsub,
            jsonrpc: `${section}_${method}`,
            method,
            section
        });
    }));
exports.default = jsonrpc;

},{"@polkadot/util":"3HnHw","./definitions.js":"44OZI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iQbAh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// NOTE We are not exporting everything here. These _should_ be enough to use the
// actual interfaces from a "create-a-working-coder" perspective. If not, we should
// expand with slight care (for instance, Length is really only used internally to
// others, so there _should_ not be need for direct use)
parcelHelpers.export(exports, "BTreeMap", ()=>(0, _typesCodec.BTreeMap));
parcelHelpers.export(exports, "BTreeSet", ()=>(0, _typesCodec.BTreeSet));
parcelHelpers.export(exports, "Compact", ()=>(0, _typesCodec.Compact));
parcelHelpers.export(exports, "DoNotConstruct", ()=>(0, _typesCodec.DoNotConstruct));
parcelHelpers.export(exports, "Enum", ()=>(0, _typesCodec.Enum));
parcelHelpers.export(exports, "HashMap", ()=>(0, _typesCodec.HashMap));
parcelHelpers.export(exports, "Int", ()=>(0, _typesCodec.Int));
parcelHelpers.export(exports, "Json", ()=>(0, _typesCodec.Json));
parcelHelpers.export(exports, "Linkage", ()=>(0, _typesCodec.Linkage));
parcelHelpers.export(exports, "CodecMap", ()=>(0, _typesCodec.CodecMap));
parcelHelpers.export(exports, "Map", ()=>(0, _typesCodec.Map));
parcelHelpers.export(exports, "Option", ()=>(0, _typesCodec.Option));
parcelHelpers.export(exports, "Range", ()=>(0, _typesCodec.Range));
parcelHelpers.export(exports, "RangeInclusive", ()=>(0, _typesCodec.RangeInclusive));
parcelHelpers.export(exports, "Raw", ()=>(0, _typesCodec.Raw));
parcelHelpers.export(exports, "Result", ()=>(0, _typesCodec.Result));
parcelHelpers.export(exports, "CodecSet", ()=>(0, _typesCodec.CodecSet));
parcelHelpers.export(exports, "Set", ()=>(0, _typesCodec.Set));
parcelHelpers.export(exports, "Struct", ()=>(0, _typesCodec.Struct));
parcelHelpers.export(exports, "Tuple", ()=>(0, _typesCodec.Tuple));
parcelHelpers.export(exports, "UInt", ()=>(0, _typesCodec.UInt));
parcelHelpers.export(exports, "U8aFixed", ()=>(0, _typesCodec.U8aFixed));
parcelHelpers.export(exports, "Vec", ()=>(0, _typesCodec.Vec));
parcelHelpers.export(exports, "VecFixed", ()=>(0, _typesCodec.VecFixed));
parcelHelpers.export(exports, "WrapperKeepOpaque", ()=>(0, _typesCodec.WrapperKeepOpaque));
parcelHelpers.export(exports, "WrapperOpaque", ()=>(0, _typesCodec.WrapperOpaque));
var _typesCodec = require("@polkadot/types-codec");

},{"@polkadot/types-codec":"gvW09","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7qdxB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCreate = require("@polkadot/types-create");
parcelHelpers.exportAll(_typesCreate, exports);
var _createClassJs = require("./createClass.js");
parcelHelpers.exportAll(_createClassJs, exports);
var _createTypeJs = require("./createType.js");
parcelHelpers.exportAll(_createTypeJs, exports);
var _lazyJs = require("./lazy.js");
parcelHelpers.exportAll(_lazyJs, exports);
var _registryJs = require("./registry.js");
parcelHelpers.exportAll(_registryJs, exports);

},{"@polkadot/types-create":"cr6lO","./createClass.js":"iEsFj","./createType.js":"koXpO","./lazy.js":"3F1qc","./registry.js":"f3AxF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iEsFj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createClass", ()=>createClass);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCreate = require("@polkadot/types-create");
function createClass(registry, type) {
    return (0, _typesCreate.createClassUnsafe)(registry, type);
}

},{"@polkadot/types-create":"cr6lO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"koXpO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create an instance of a `type` with a given `params`.
 * @param type - A recognizable string representing the type to create an
 * instance from
 * @param params - The value to instantiate the type with
 */ parcelHelpers.export(exports, "createType", ()=>createType);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCreate = require("@polkadot/types-create");
function createType(registry, type, ...params) {
    return (0, _typesCreate.createTypeUnsafe)(registry, type, params);
}

},{"@polkadot/types-create":"cr6lO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3F1qc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lazyVariants", ()=>lazyVariants);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function lazyVariants(lookup, { type  }, getName, creator) {
    const result = {};
    const variants = lookup.getSiType(type).def.asVariant.variants;
    for(let i = 0; i < variants.length; i++)(0, _util.lazyMethod)(result, variants[i], creator, getName);
    return result;
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f3AxF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeRegistry", ()=>TypeRegistry);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _typesCreate = require("@polkadot/types-create");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _indexJs = require("../extrinsic/signedExtensions/index.js");
var _eventJs = require("../generic/Event.js");
var _indexTypesJs = require("../index.types.js");
var _definitionsJs = require("../interfaces/definitions.js");
var _indexJs1 = require("../metadata/decorate/index.js");
var _indexJs2 = require("../metadata/decorate/extrinsics/index.js");
var _metadataJs = require("../metadata/Metadata.js");
var _indexJs3 = require("../metadata/PortableRegistry/index.js");
var _lazyJs = require("./lazy.js");
const DEFAULT_FIRST_CALL_IDX = new Uint8Array(2);
const l = (0, _util.logger)("registry");
function sortDecimalStrings(a, b) {
    return parseInt(a, 10) - parseInt(b, 10);
}
function valueToString(v) {
    return v.toString();
}
function getFieldArgs(lookup, fields) {
    const args = new Array(fields.length);
    for(let i = 0; i < fields.length; i++)args[i] = lookup.getTypeDef(fields[i].type).type;
    return args;
}
function clearRecord(record) {
    const keys = Object.keys(record);
    for(let i = 0; i < keys.length; i++)delete record[keys[i]];
}
function getVariantStringIdx({ index  }) {
    return index.toString();
} // create error mapping from metadata
function injectErrors(_, { lookup , pallets  }, version, result) {
    clearRecord(result);
    for(let i = 0; i < pallets.length; i++){
        const { errors , index , name  } = pallets[i];
        if (errors.isSome) {
            const sectionName = (0, _util.stringCamelCase)(name);
            (0, _util.lazyMethod)(result, version >= 12 ? index.toNumber() : i, ()=>(0, _lazyJs.lazyVariants)(lookup, errors.unwrap(), getVariantStringIdx, ({ docs , fields , index , name  })=>({
                        args: getFieldArgs(lookup, fields),
                        docs: docs.map(valueToString),
                        fields,
                        index: index.toNumber(),
                        method: name.toString(),
                        name: name.toString(),
                        section: sectionName
                    })));
        }
    }
} // create event classes from metadata
function injectEvents(registry, { lookup , pallets  }, version, result) {
    const filtered = pallets.filter((0, _indexJs1.filterEventsSome));
    clearRecord(result);
    for(let i = 0; i < filtered.length; i++){
        const { events , index , name  } = filtered[i];
        (0, _util.lazyMethod)(result, version >= 12 ? index.toNumber() : i, ()=>(0, _lazyJs.lazyVariants)(lookup, events.unwrap(), getVariantStringIdx, (variant)=>{
                const meta = registry.createType("EventMetadataLatest", (0, _util.objectSpread)({}, variant, {
                    args: getFieldArgs(lookup, variant.fields)
                }));
                return class extends (0, _eventJs.GenericEventData) {
                    constructor(registry, value){
                        super(registry, value, meta, (0, _util.stringCamelCase)(name), variant.name.toString());
                    }
                };
            }));
    }
} // create extrinsic mapping from metadata
function injectExtrinsics(registry, { lookup , pallets  }, version, result, mapping) {
    const filtered = pallets.filter((0, _indexJs1.filterCallsSome));
    clearRecord(result);
    clearRecord(mapping);
    for(let i = 0; i < filtered.length; i++){
        const { calls , index , name  } = filtered[i];
        const sectionIndex = version >= 12 ? index.toNumber() : i;
        const sectionName = (0, _util.stringCamelCase)(name);
        const allCalls = calls.unwrap();
        (0, _util.lazyMethod)(result, sectionIndex, ()=>(0, _lazyJs.lazyVariants)(lookup, allCalls, getVariantStringIdx, (variant)=>(0, _indexJs2.createCallFunction)(registry, lookup, variant, sectionName, sectionIndex)));
        const { path  } = registry.lookup.getSiType(allCalls.type); // frame_system::pallet::Call / pallet_balances::pallet::Call / polkadot_runtime_parachains::configuration::pallet::Call /
        const palletIdx = path.findIndex((v)=>v.eq("pallet"));
        if (palletIdx !== -1) {
            const name1 = (0, _util.stringCamelCase)(path.slice(0, palletIdx).map((p, i)=>i === 0 // frame_system || pallet_balances
                 ? p.replace(/^(frame|pallet)_/, "") : p).join(" "));
            if (!mapping[name1]) mapping[name1] = [
                sectionName
            ];
            else mapping[name1].push(sectionName);
        }
    }
} // extract additional properties from the metadata
function extractProperties(registry, metadata) {
    const original = registry.getChainProperties();
    const constants = (0, _indexJs1.decorateConstants)(registry, metadata.asLatest, metadata.version);
    const ss58Format = constants.system && (constants.system.sS58Prefix || constants.system.ss58Prefix);
    if (!ss58Format) return original;
    const { tokenDecimals , tokenSymbol  } = original || {};
    return registry.createTypeUnsafe("ChainProperties", [
        {
            ss58Format,
            tokenDecimals,
            tokenSymbol
        }
    ]);
}
class TypeRegistry {
    #classes = new Map();
    #definitions = new Map();
    #firstCallIndex = null;
    #lookup;
    #metadata;
    #metadataVersion = 0;
    #metadataCalls = {};
    #metadataErrors = {};
    #metadataEvents = {};
    #moduleMap = {};
    #unknownTypes = new Map();
    #chainProperties;
    #hasher = (0, _utilCrypto.blake2AsU8a);
    #knownDefaults;
    #knownDefinitions;
    #knownTypes = {};
    #signedExtensions = (0, _indexJs.fallbackExtensions);
    #userExtensions;
    constructor(createdAtHash){
        this.#knownDefaults = (0, _util.objectSpread)({
            Json: (0, _typesCodec.Json),
            Metadata: (0, _metadataJs.Metadata),
            PortableRegistry: (0, _indexJs3.PortableRegistry),
            Raw: (0, _typesCodec.Raw)
        }, _indexTypesJs);
        this.#knownDefinitions = _definitionsJs;
        const allKnown = Object.values(this.#knownDefinitions);
        for(let i = 0; i < allKnown.length; i++)this.register(allKnown[i].types);
        if (createdAtHash) this.createdAtHash = this.createType("Hash", createdAtHash);
    }
    get chainDecimals() {
        var _this$chainProperties;
        if ((_this$chainProperties = this.#chainProperties) !== null && _this$chainProperties !== void 0 && _this$chainProperties.tokenDecimals.isSome) {
            const allDecimals = this.#chainProperties.tokenDecimals.unwrap();
            if (allDecimals.length) return allDecimals.map((b)=>b.toNumber());
        }
        return [
            12
        ];
    }
    get chainSS58() {
        var _this$chainProperties2;
        return (_this$chainProperties2 = this.#chainProperties) !== null && _this$chainProperties2 !== void 0 && _this$chainProperties2.ss58Format.isSome ? this.#chainProperties.ss58Format.unwrap().toNumber() : undefined;
    }
    get chainTokens() {
        var _this$chainProperties3;
        if ((_this$chainProperties3 = this.#chainProperties) !== null && _this$chainProperties3 !== void 0 && _this$chainProperties3.tokenSymbol.isSome) {
            const allTokens = this.#chainProperties.tokenSymbol.unwrap();
            if (allTokens.length) return allTokens.map(valueToString);
        }
        return [
            (0, _util.formatBalance).getDefaults().unit
        ];
    }
    get firstCallIndex() {
        return this.#firstCallIndex || DEFAULT_FIRST_CALL_IDX;
    }
    /**
   * @description Returns true if the type is in a Compat format
   */ isLookupType(value) {
        return /Lookup\d+$/.test(value);
    }
    /**
   * @description Creates a lookup string from the supplied id
   */ createLookupType(lookupId) {
        return `Lookup${lookupId.toString()}`;
    }
    get knownTypes() {
        return this.#knownTypes;
    }
    get lookup() {
        return (0, _util.assertReturn)(this.#lookup, "Lookup has not been set on this registry");
    }
    get metadata() {
        return (0, _util.assertReturn)(this.#metadata, "Metadata has not been set on this registry");
    }
    get unknownTypes() {
        return [
            ...this.#unknownTypes.keys()
        ];
    }
    get signedExtensions() {
        return this.#signedExtensions;
    }
    clearCache() {
        this.#classes = new Map();
    }
    /**
   * @describe Creates an instance of the class
   */ createClass(type) {
        return (0, _typesCreate.createClassUnsafe)(this, type);
    }
    /**
   * @describe Creates an instance of the class
   */ createClassUnsafe(type) {
        return (0, _typesCreate.createClassUnsafe)(this, type);
    }
    /**
   * @description Creates an instance of a type as registered
   */ createType(type, ...params) {
        return (0, _typesCreate.createTypeUnsafe)(this, type, params);
    }
    /**
   * @description Creates an instance of a type as registered
   */ createTypeUnsafe(type, params, options) {
        return (0, _typesCreate.createTypeUnsafe)(this, type, params, options);
    }
    findMetaCall(callIndex) {
        const [section, method] = [
            callIndex[0],
            callIndex[1]
        ];
        return (0, _util.assertReturn)(this.#metadataCalls[`${section}`] && this.#metadataCalls[`${section}`][`${method}`], ()=>`findMetaCall: Unable to find Call with index [${section}, ${method}]/[${callIndex.toString()}]`);
    }
    findMetaError(errorIndex) {
        const [section, method] = (0, _util.isU8a)(errorIndex) ? [
            errorIndex[0],
            errorIndex[1]
        ] : [
            errorIndex.index.toNumber(),
            (0, _util.isU8a)(errorIndex.error) ? errorIndex.error[0] : errorIndex.error.toNumber()
        ];
        return (0, _util.assertReturn)(this.#metadataErrors[`${section}`] && this.#metadataErrors[`${section}`][`${method}`], ()=>`findMetaError: Unable to find Error with index [${section}, ${method}]/[${errorIndex.toString()}]`);
    }
    findMetaEvent(eventIndex) {
        const [section, method] = [
            eventIndex[0],
            eventIndex[1]
        ];
        return (0, _util.assertReturn)(this.#metadataEvents[`${section}`] && this.#metadataEvents[`${section}`][`${method}`], ()=>`findMetaEvent: Unable to find Event with index [${section}, ${method}]/[${eventIndex.toString()}]`);
    }
    get(name, withUnknown, knownTypeDef) {
        return this.getUnsafe(name, withUnknown, knownTypeDef);
    }
    getUnsafe(name, withUnknown, knownTypeDef) {
        let Type = this.#classes.get(name) || this.#knownDefaults[name]; // we have not already created the type, attempt it
        if (!Type) {
            const definition = this.#definitions.get(name);
            let BaseType; // we have a definition, so create the class now (lazily)
            if (definition) BaseType = (0, _typesCreate.createClassUnsafe)(this, definition);
            else if (knownTypeDef) BaseType = (0, _typesCreate.constructTypeClass)(this, knownTypeDef);
            else if (withUnknown) {
                l.warn(`Unable to resolve type ${name}, it will fail on construction`);
                this.#unknownTypes.set(name, true);
                BaseType = (0, _typesCodec.DoNotConstruct).with(name);
            }
            if (BaseType) {
                // NOTE If we didn't extend here, we would have strange artifacts. An example is
                // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128
                // Additionally, we now pass through the registry, which is a link to ourselves
                Type = class extends BaseType {
                };
                this.#classes.set(name, Type); // In the case of lookups, we also want to store the actual class against
                // the lookup name, instad of having to traverse again
                if (knownTypeDef && (0, _util.isNumber)(knownTypeDef.lookupIndex)) this.#classes.set(this.createLookupType(knownTypeDef.lookupIndex), Type);
            }
        }
        return Type;
    }
    getChainProperties() {
        return this.#chainProperties;
    }
    getClassName(Type) {
        // we cannot rely on export order (anymore, since babel/core 7.15.8), so in the case of
        // items such as u32 & U32, we get the lowercase versions here... not quite as optimal
        // (previously this used to be a simple find & return)
        const names = [];
        for (const [name, Clazz] of Object.entries(this.#knownDefaults))if (Type === Clazz) names.push(name);
        for (const [name1, Clazz1] of this.#classes.entries())if (Type === Clazz1) names.push(name1);
         // both sort and reverse are done in-place
        names.sort().reverse();
        return names.length ? names[0] : undefined;
    }
    getDefinition(typeName) {
        return this.#definitions.get(typeName);
    }
    getModuleInstances(specName, moduleName) {
        var _this$knownTypes, _this$knownTypes$type, _this$knownTypes$type2, _this$knownTypes$type3, _this$knownTypes$type4;
        return ((_this$knownTypes = this.#knownTypes) === null || _this$knownTypes === void 0 ? void 0 : (_this$knownTypes$type = _this$knownTypes.typesBundle) === null || _this$knownTypes$type === void 0 ? void 0 : (_this$knownTypes$type2 = _this$knownTypes$type.spec) === null || _this$knownTypes$type2 === void 0 ? void 0 : (_this$knownTypes$type3 = _this$knownTypes$type2[specName.toString()]) === null || _this$knownTypes$type3 === void 0 ? void 0 : (_this$knownTypes$type4 = _this$knownTypes$type3.instances) === null || _this$knownTypes$type4 === void 0 ? void 0 : _this$knownTypes$type4[moduleName]) || this.#moduleMap[moduleName];
    }
    getOrThrow(name, msg) {
        const Clazz = this.get(name);
        if (!Clazz) throw new Error(msg || `type ${name} not found`);
        return Clazz;
    }
    getOrUnknown(name) {
        return this.get(name, true);
    }
    getSignedExtensionExtra() {
        return (0, _indexJs.expandExtensionTypes)(this.#signedExtensions, "payload", this.#userExtensions);
    }
    getSignedExtensionTypes() {
        return (0, _indexJs.expandExtensionTypes)(this.#signedExtensions, "extrinsic", this.#userExtensions);
    }
    hasClass(name) {
        return this.#classes.has(name) || !!this.#knownDefaults[name];
    }
    hasDef(name) {
        return this.#definitions.has(name);
    }
    hasType(name) {
        return !this.#unknownTypes.get(name) && (this.hasClass(name) || this.hasDef(name));
    }
    hash(data) {
        return this.createType("CodecHash", this.#hasher(data));
    }
    // eslint-disable-next-line no-dupe-class-members
    register(arg1, arg2) {
        // NOTE Constructors appear as functions here
        if ((0, _util.isFunction)(arg1)) this.#classes.set(arg1.name, arg1);
        else if ((0, _util.isString)(arg1)) {
            if (!(0, _util.isFunction)(arg2)) throw new Error(`Expected class definition passed to '${arg1}' registration`);
            else if (arg1 === arg2.toString()) throw new Error(`Unable to register circular ${arg1} === ${arg1}`);
            this.#classes.set(arg1, arg2);
        } else this._registerObject(arg1);
    }
    _registerObject(obj) {
        const entries = Object.entries(obj);
        for(let e = 0; e < entries.length; e++){
            const [name, type] = entries[e];
            if ((0, _util.isFunction)(type)) // This _looks_ a bit funny, but `typeof Clazz === 'function'
            this.#classes.set(name, type);
            else {
                const def = (0, _util.isString)(type) ? type : (0, _util.stringify)(type);
                if (name === def) throw new Error(`Unable to register circular ${name} === ${def}`);
                 // we already have this type, remove the classes registered for it
                if (this.#classes.has(name)) this.#classes.delete(name);
                this.#definitions.set(name, def);
            }
        }
    }
    setChainProperties(properties) {
        if (properties) this.#chainProperties = properties;
    }
    setHasher(hasher) {
        this.#hasher = hasher || (0, _utilCrypto.blake2AsU8a);
    }
    setKnownTypes(knownTypes) {
        this.#knownTypes = knownTypes;
    }
    setLookup(lookup) {
        this.#lookup = lookup; // register all applicable types found
        lookup.register();
    }
    setMetadata(metadata, signedExtensions, userExtensions) {
        this.#metadata = metadata.asLatest;
        this.#metadataVersion = metadata.version;
        this.#firstCallIndex = null; // attach the lookup at this point (before injecting)
        this.setLookup(this.#metadata.lookup);
        injectExtrinsics(this, this.#metadata, this.#metadataVersion, this.#metadataCalls, this.#moduleMap);
        injectErrors(this, this.#metadata, this.#metadataVersion, this.#metadataErrors);
        injectEvents(this, this.#metadata, this.#metadataVersion, this.#metadataEvents); // set the default call index (the lowest section, the lowest method)
        // in most chains this should be 0,0
        const [defSection] = Object.keys(this.#metadataCalls).sort(sortDecimalStrings);
        if (defSection) {
            const [defMethod] = Object.keys(this.#metadataCalls[defSection]).sort(sortDecimalStrings);
            if (defMethod) this.#firstCallIndex = new Uint8Array([
                parseInt(defSection, 10),
                parseInt(defMethod, 10)
            ]);
        } // setup the available extensions
        this.setSignedExtensions(signedExtensions || (this.#metadata.extrinsic.version.gt((0, _util.BN_ZERO)) // FIXME Use the extension and their injected types
         ? this.#metadata.extrinsic.signedExtensions.map(({ identifier  })=>identifier.toString()) : (0, _indexJs.fallbackExtensions)), userExtensions); // setup the chain properties with format overrides
        this.setChainProperties(extractProperties(this, metadata));
    }
    setSignedExtensions(signedExtensions = (0, _indexJs.fallbackExtensions), userExtensions) {
        this.#signedExtensions = signedExtensions;
        this.#userExtensions = userExtensions;
        const unknown = (0, _indexJs.findUnknownExtensions)(this.#signedExtensions, this.#userExtensions);
        if (unknown.length) l.warn(`Unknown signed extensions ${unknown.join(", ")} found, treating them as no-effect`);
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/types-create":"cr6lO","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","../extrinsic/signedExtensions/index.js":"2BKKc","../generic/Event.js":"jknfu","../index.types.js":"b4BtA","../interfaces/definitions.js":"44OZI","../metadata/decorate/index.js":"ltCSZ","../metadata/decorate/extrinsics/index.js":"3JIyR","../metadata/Metadata.js":"cg9v9","../metadata/PortableRegistry/index.js":"9hFU1","./lazy.js":"3F1qc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2BKKc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "allExtensions", ()=>allExtensions);
parcelHelpers.export(exports, "fallbackExtensions", ()=>fallbackExtensions);
parcelHelpers.export(exports, "findUnknownExtensions", ()=>findUnknownExtensions);
parcelHelpers.export(exports, "expandExtensionTypes", ()=>expandExtensionTypes);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _polkadotJs = require("./polkadot.js");
var _shellJs = require("./shell.js");
var _statemintJs = require("./statemint.js");
var _substrateJs = require("./substrate.js"); // A mapping of the known signed extensions to the extra fields that they
const allExtensions = (0, _util.objectSpread)({}, (0, _substrateJs.substrate), (0, _polkadotJs.polkadot), (0, _shellJs.shell), (0, _statemintJs.statemint)); // the v4 signed extensions prior to the point of exposing these to the
const fallbackExtensions = [
    "CheckVersion",
    "CheckGenesis",
    "CheckEra",
    "CheckNonce",
    "CheckWeight",
    "ChargeTransactionPayment",
    "CheckBlockGasLimit"
];
function findUnknownExtensions(extensions, userExtensions = {}) {
    const names = [
        ...Object.keys(allExtensions),
        ...Object.keys(userExtensions)
    ];
    return extensions.filter((k)=>!names.includes(k));
}
function expandExtensionTypes(extensions, type, userExtensions = {}) {
    return extensions // Always allow user extensions first - these should provide overrides
    .map((k)=>userExtensions[k] || allExtensions[k]).filter((info)=>!!info).reduce((result, info)=>(0, _util.objectSpread)(result, info[type]), {});
}

},{"@polkadot/util":"3HnHw","./polkadot.js":"b6nDZ","./shell.js":"bHaqk","./statemint.js":"gYfNZ","./substrate.js":"1eK0J","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b6nDZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "polkadot", ()=>polkadot);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _emptyCheckJs = require("./emptyCheck.js");
const polkadot = {
    LimitParathreadCommits: (0, _emptyCheckJs.emptyCheck),
    OnlyStakingAndClaims: (0, _emptyCheckJs.emptyCheck),
    PrevalidateAttests: (0, _emptyCheckJs.emptyCheck),
    RestrictFunctionality: (0, _emptyCheckJs.emptyCheck),
    TransactionCallFilter: (0, _emptyCheckJs.emptyCheck),
    ValidateDoubleVoteReports: (0, _emptyCheckJs.emptyCheck)
};

},{"./emptyCheck.js":"8emcs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8emcs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "emptyCheck", ()=>emptyCheck);
const emptyCheck = {
    extrinsic: {},
    payload: {}
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bHaqk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shell", ()=>shell);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _emptyCheckJs = require("./emptyCheck.js");
const shell = {
    DisallowSigned: (0, _emptyCheckJs.emptyCheck)
};

},{"./emptyCheck.js":"8emcs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gYfNZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "statemint", ()=>statemint);
const statemint = {
    ChargeAssetTxPayment: {
        extrinsic: {
            tip: "Compact<Balance>",
            // eslint-disable-next-line sort-keys
            assetId: "Option<AssetId>"
        },
        payload: {}
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1eK0J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "substrate", ()=>substrate);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _emptyCheckJs = require("./emptyCheck.js");
const CheckMortality = {
    extrinsic: {
        era: "ExtrinsicEra"
    },
    payload: {
        blockHash: "Hash"
    }
};
const substrate = {
    ChargeTransactionPayment: {
        extrinsic: {
            tip: "Compact<Balance>"
        },
        payload: {}
    },
    CheckBlockGasLimit: (0, _emptyCheckJs.emptyCheck),
    CheckEra: CheckMortality,
    CheckGenesis: {
        extrinsic: {},
        payload: {
            genesisHash: "Hash"
        }
    },
    CheckMortality,
    CheckNonZeroSender: (0, _emptyCheckJs.emptyCheck),
    CheckNonce: {
        extrinsic: {
            nonce: "Compact<Index>"
        },
        payload: {}
    },
    CheckSpecVersion: {
        extrinsic: {},
        payload: {
            specVersion: "u32"
        }
    },
    CheckTxVersion: {
        extrinsic: {},
        payload: {
            transactionVersion: "u32"
        }
    },
    CheckVersion: {
        extrinsic: {},
        payload: {
            specVersion: "u32"
        }
    },
    CheckWeight: (0, _emptyCheckJs.emptyCheck),
    LockStakingStatus: (0, _emptyCheckJs.emptyCheck),
    ValidateEquivocationReport: (0, _emptyCheckJs.emptyCheck)
};

},{"./emptyCheck.js":"8emcs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jknfu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericEventData
 * @description
 * Wrapper for the actual data that forms part of an [[Event]]
 */ parcelHelpers.export(exports, "GenericEventData", ()=>GenericEventData);
/**
 * @name GenericEvent
 * @description
 * A representation of a system event. These are generated via the [[Metadata]] interfaces and
 * specific to a specific Substrate runtime
 */ parcelHelpers.export(exports, "GenericEvent", ()=>GenericEvent);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
/** @internal */ function decodeEvent(registry, value) {
    if (!value || !value.length) return {
        DataType: (0, _typesCodec.Null)
    };
    const index = value.subarray(0, 2);
    return {
        DataType: registry.findMetaEvent(index),
        value: {
            data: value.subarray(2),
            index
        }
    };
}
class GenericEventData extends (0, _typesCodec.Tuple) {
    #meta;
    #method;
    #names = null;
    #section;
    #typeDef;
    constructor(registry, value, meta, section = "<unknown>", method = "<unknown>"){
        const fields = (meta === null || meta === void 0 ? void 0 : meta.fields) || [];
        super(registry, fields.map(({ type  })=>registry.createLookupType(type)), value);
        this.#meta = meta;
        this.#method = method;
        this.#section = section;
        this.#typeDef = fields.map(({ type  })=>registry.lookup.getTypeDef(type));
        const names = fields.map(({ name  })=>registry.lookup.sanitizeField(name)[0]).filter((n)=>!!n);
        if (names.length === fields.length) {
            this.#names = names;
            (0, _util.objectProperties)(this, names, (_, i)=>this[i]);
        }
    }
    /**
   * @description The wrapped [[EventMetadata]]
   */ get meta() {
        return this.#meta;
    }
    /**
   * @description The method as a string
   */ get method() {
        return this.#method;
    }
    /**
   * @description The field names (as available)
   */ get names() {
        return this.#names;
    }
    /**
   * @description The section as a string
   */ get section() {
        return this.#section;
    }
    /**
   * @description The [[TypeDef]] for this event
   */ get typeDef() {
        return this.#typeDef;
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        if (this.#names !== null) {
            const json = {};
            for(let i = 0; i < this.#names.length; i++)json[this.#names[i]] = this[i].toHuman(isExtended);
            return json;
        }
        return super.toHuman(isExtended);
    }
}
class GenericEvent extends (0, _typesCodec.Struct) {
    // Currently we _only_ decode from Uint8Array, since we expect it to
    // be used via EventRecord
    constructor(registry, _value){
        const { DataType , value  } = decodeEvent(registry, _value);
        super(registry, {
            index: "EventId",
            // eslint-disable-next-line sort-keys
            data: DataType
        }, value);
    }
    /**
   * @description The wrapped [[EventData]]
   */ get data() {
        return this.getT("data");
    }
    /**
   * @description The [[EventId]], identifying the raw event
   */ get index() {
        return this.getT("index");
    }
    /**
   * @description The [[EventMetadata]] with the documentation
   */ get meta() {
        return this.data.meta;
    }
    /**
   * @description The method string identifying the event
   */ get method() {
        return this.data.method;
    }
    /**
   * @description The section string identifying the event
   */ get section() {
        return this.data.section;
    }
    /**
   * @description The [[TypeDef]] for the event
   */ get typeDef() {
        return this.data.typeDef;
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExpanded) {
        return (0, _util.objectSpread)({
            method: this.method,
            section: this.section
        }, isExpanded ? {
            docs: this.meta.docs.map((d)=>d.toString())
        } : null, super.toHuman(isExpanded));
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b4BtA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("./extrinsic/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var _indexJs1 = require("./generic/index.js");
parcelHelpers.exportAll(_indexJs1, exports);
var _indexJs2 = require("./primitive/index.js");
parcelHelpers.exportAll(_indexJs2, exports);

},{"./extrinsic/index.js":"5khiZ","./generic/index.js":"gF9ma","./primitive/index.js":"4FGVo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5khiZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "GenericExtrinsic", ()=>(0, _extrinsicJs.GenericExtrinsic));
parcelHelpers.export(exports, "GenericExtrinsicEra", ()=>(0, _extrinsicEraJs.GenericExtrinsicEra));
parcelHelpers.export(exports, "GenericMortalEra", ()=>(0, _extrinsicEraJs.MortalEra));
parcelHelpers.export(exports, "GenericImmortalEra", ()=>(0, _extrinsicEraJs.ImmortalEra));
parcelHelpers.export(exports, "GenericExtrinsicPayload", ()=>(0, _extrinsicPayloadJs.GenericExtrinsicPayload));
parcelHelpers.export(exports, "GenericExtrinsicPayloadUnknown", ()=>(0, _extrinsicPayloadUnknownJs.GenericExtrinsicPayloadUnknown));
parcelHelpers.export(exports, "GenericExtrinsicUnknown", ()=>(0, _extrinsicUnknownJs.GenericExtrinsicUnknown));
parcelHelpers.export(exports, "GenericSignerPayload", ()=>(0, _signerPayloadJs.GenericSignerPayload));
var _extrinsicJs = require("./Extrinsic.js");
var _extrinsicEraJs = require("./ExtrinsicEra.js");
var _extrinsicPayloadJs = require("./ExtrinsicPayload.js");
var _extrinsicPayloadUnknownJs = require("./ExtrinsicPayloadUnknown.js");
var _extrinsicUnknownJs = require("./ExtrinsicUnknown.js");
var _signerPayloadJs = require("./SignerPayload.js");
var _indexJs = require("./v4/index.js");
parcelHelpers.exportAll(_indexJs, exports);

},{"./Extrinsic.js":"lBqTY","./ExtrinsicEra.js":"fiuwA","./ExtrinsicPayload.js":"g8v6p","./ExtrinsicPayloadUnknown.js":"bzf8A","./ExtrinsicUnknown.js":"h76Za","./SignerPayload.js":"79cxZ","./v4/index.js":"k7HoD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lBqTY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LATEST_EXTRINSIC_VERSION", ()=>(0, _extrinsicJs.EXTRINSIC_VERSION));
/**
 * @name GenericExtrinsic
 * @description
 * Representation of an Extrinsic in the system. It contains the actual call,
 * (optional) signature and encodes with an actual length prefix
 *
 * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.
 *
 * Can be:
 * - signed, to create a transaction
 * - left as is, to create an inherent
 */ parcelHelpers.export(exports, "GenericExtrinsic", ()=>GenericExtrinsic);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _constantsJs = require("./constants.js");
var _extrinsicJs = require("./v4/Extrinsic.js");
const VERSIONS = [
    "ExtrinsicUnknown",
    "ExtrinsicUnknown",
    "ExtrinsicUnknown",
    "ExtrinsicUnknown",
    "ExtrinsicV4"
];
/** @internal */ function newFromValue(registry, value, version) {
    if (value instanceof GenericExtrinsic) return value.unwrap();
    const isSigned = (version & (0, _constantsJs.BIT_SIGNED)) === (0, _constantsJs.BIT_SIGNED);
    const type = VERSIONS[version & (0, _constantsJs.UNMASK_VERSION)] || VERSIONS[0]; // we cast here since the VERSION definition is incredibly broad - we don't have a
    // slice for "only add extrinsic types", and more string definitions become unwieldy
    return registry.createTypeUnsafe(type, [
        value,
        {
            isSigned,
            version
        }
    ]);
}
/** @internal */ function decodeExtrinsic(registry, value, version = (0, _constantsJs.DEFAULT_VERSION)) {
    if ((0, _util.isU8a)(value) || Array.isArray(value) || (0, _util.isHex)(value)) return decodeU8a(registry, (0, _util.u8aToU8a)(value), version);
    else if (value instanceof registry.createClassUnsafe("Call")) return newFromValue(registry, {
        method: value
    }, version);
    return newFromValue(registry, value, version);
}
/** @internal */ function decodeU8a(registry, value, version) {
    if (!value.length) return newFromValue(registry, new Uint8Array(), version);
    const [offset, length] = (0, _util.compactFromU8a)(value);
    const total = offset + length.toNumber();
    if (total > value.length) throw new Error(`Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);
    const data = value.subarray(offset, total);
    return newFromValue(registry, data.subarray(1), data[0]);
}
class ExtrinsicBase extends (0, _typesCodec.AbstractBase) {
    constructor(registry, value, initialU8aLength){
        super(registry, value, initialU8aLength);
        const signKeys = Object.keys(registry.getSignedExtensionTypes());
        const getter = (key)=>this.inner.signature[key]; // This is on the abstract class, ensuring that hasOwnProperty operates
        // correctly, i.e. it needs to be on the base class exposing it
        for(let i = 0; i < signKeys.length; i++)(0, _util.objectProperty)(this, signKeys[i], getter);
    }
    /**
   * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]
   */ get args() {
        return this.method.args;
    }
    /**
   * @description The argument definitions, compatible with [[Call]]
   */ get argsDef() {
        return this.method.argsDef;
    }
    /**
   * @description The actual `[sectionIndex, methodIndex]` as used in the Call
   */ get callIndex() {
        return this.method.callIndex;
    }
    /**
   * @description The actual data for the Call
   */ get data() {
        return this.method.data;
    }
    /**
   * @description The era for this extrinsic
   */ get era() {
        return this.inner.signature.era;
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return this.toU8a().length;
    }
    /**
   * @description `true` id the extrinsic is signed
   */ get isSigned() {
        return this.inner.signature.isSigned;
    }
    /**
   * @description The length of the actual data, excluding prefix
   */ get length() {
        return this.toU8a(true).length;
    }
    /**
   * @description The [[FunctionMetadataLatest]] that describes the extrinsic
   */ get meta() {
        return this.method.meta;
    }
    /**
   * @description The [[Call]] this extrinsic wraps
   */ get method() {
        return this.inner.method;
    }
    /**
   * @description The nonce for this extrinsic
   */ get nonce() {
        return this.inner.signature.nonce;
    }
    /**
   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]
   */ get signature() {
        return this.inner.signature.signature;
    }
    /**
   * @description The [[Address]] that signed
   */ get signer() {
        return this.inner.signature.signer;
    }
    /**
   * @description Forwards compat
   */ get tip() {
        return this.inner.signature.tip;
    }
    /**
   * @description Returns the raw transaction version (not flagged with signing information)
  */ get type() {
        return this.inner.version;
    }
    get inner() {
        return this.unwrap();
    }
    /**
   * @description Returns the encoded version flag
  */ get version() {
        return this.type | (this.isSigned ? (0, _constantsJs.BIT_SIGNED) : (0, _constantsJs.BIT_UNSIGNED));
    }
    /**
   * @description Checks if the source matches this in type
   */ is(other) {
        return this.method.is(other);
    }
    unwrap() {
        return super.unwrap();
    }
}
class GenericExtrinsic extends ExtrinsicBase {
    #hashCache;
    constructor(registry, value, { version  } = {}){
        super(registry, decodeExtrinsic(registry, value, version));
    }
    /**
   * @description returns a hash of the contents
   */ get hash() {
        if (!this.#hashCache) this.#hashCache = super.hash;
        return this.#hashCache;
    }
    /**
   * @description Injects an already-generated signature into the extrinsic
   */ addSignature(signer, signature, payload) {
        this.inner.addSignature(signer, signature, payload);
        this.#hashCache = undefined;
        return this;
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        const encoded = (0, _util.u8aConcat)(...this.toU8aInner());
        return {
            inner: this.isSigned ? this.inner.inspect().inner : this.inner.method.inspect().inner,
            outer: [
                (0, _util.compactToU8a)(encoded.length),
                new Uint8Array([
                    this.version
                ])
            ]
        };
    }
    /**
   * @description Sign the extrinsic with a specific keypair
   */ sign(account, options) {
        this.inner.sign(account, options);
        this.#hashCache = undefined;
        return this;
    }
    /**
   * @describe Adds a fake signature to the extrinsic
   */ signFake(signer, options) {
        this.inner.signFake(signer, options);
        this.#hashCache = undefined;
        return this;
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex(isBare) {
        return (0, _util.u8aToHex)(this.toU8a(isBare));
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExpanded) {
        return (0, _util.objectSpread)({}, {
            isSigned: this.isSigned,
            method: this.method.toHuman(isExpanded)
        }, this.isSigned ? {
            era: this.era.toHuman(isExpanded),
            nonce: this.nonce.toHuman(isExpanded),
            signature: this.signature.toHex(),
            signer: this.signer.toHuman(isExpanded),
            tip: this.tip.toHuman(isExpanded)
        } : null);
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.toHex();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Extrinsic";
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value is not length-prefixed
   */ toU8a(isBare) {
        const encoded = (0, _util.u8aConcat)(...this.toU8aInner());
        return isBare ? encoded : (0, _util.compactAddLength)(encoded);
    }
    toU8aInner() {
        // we do not apply bare to the internal values, rather this only determines out length addition,
        // where we strip all lengths this creates an extrinsic that cannot be decoded
        return [
            new Uint8Array([
                this.version
            ]),
            this.inner.toU8a()
        ];
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","./constants.js":"gKNvX","./v4/Extrinsic.js":"llA4W","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gKNvX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BIT_SIGNED", ()=>BIT_SIGNED);
parcelHelpers.export(exports, "BIT_UNSIGNED", ()=>BIT_UNSIGNED);
parcelHelpers.export(exports, "EMPTY_U8A", ()=>EMPTY_U8A);
parcelHelpers.export(exports, "DEFAULT_VERSION", ()=>DEFAULT_VERSION);
parcelHelpers.export(exports, "IMMORTAL_ERA", ()=>IMMORTAL_ERA);
parcelHelpers.export(exports, "UNMASK_VERSION", ()=>UNMASK_VERSION);
const BIT_SIGNED = 128;
const BIT_UNSIGNED = 0;
const EMPTY_U8A = new Uint8Array();
const DEFAULT_VERSION = 4;
const IMMORTAL_ERA = new Uint8Array([
    0
]);
const UNMASK_VERSION = 127;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llA4W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EXTRINSIC_VERSION", ()=>EXTRINSIC_VERSION);
/**
 * @name GenericExtrinsicV4
 * @description
 * The third generation of compact extrinsics
 */ parcelHelpers.export(exports, "GenericExtrinsicV4", ()=>GenericExtrinsicV4);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
const EXTRINSIC_VERSION = 4;
class GenericExtrinsicV4 extends (0, _typesCodec.Struct) {
    constructor(registry, value, { isSigned  } = {}){
        super(registry, {
            signature: "ExtrinsicSignatureV4",
            // eslint-disable-next-line sort-keys
            method: "Call"
        }, GenericExtrinsicV4.decodeExtrinsic(registry, value, isSigned));
    }
    /** @internal */ static decodeExtrinsic(registry, value, isSigned = false) {
        if (value instanceof GenericExtrinsicV4) return value;
        else if (value instanceof registry.createClassUnsafe("Call")) return {
            method: value
        };
        else if ((0, _util.isU8a)(value)) {
            // here we decode manually since we need to pull through the version information
            const signature = registry.createTypeUnsafe("ExtrinsicSignatureV4", [
                value,
                {
                    isSigned
                }
            ]);
            const method = registry.createTypeUnsafe("Call", [
                value.subarray(signature.encodedLength)
            ]);
            return {
                method,
                signature
            };
        }
        return value || {};
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return this.toU8a().length;
    }
    /**
   * @description The [[Call]] this extrinsic wraps
   */ get method() {
        return this.getT("method");
    }
    /**
   * @description The [[ExtrinsicSignatureV4]]
   */ get signature() {
        return this.getT("signature");
    }
    /**
   * @description The version for the signature
   */ get version() {
        return EXTRINSIC_VERSION;
    }
    /**
   * @description Add an [[ExtrinsicSignatureV4]] to the extrinsic (already generated)
   */ addSignature(signer, signature, payload) {
        this.signature.addSignature(signer, signature, payload);
        return this;
    }
    /**
   * @description Sign the extrinsic with a specific keypair
   */ sign(account, options) {
        this.signature.sign(this.method, account, options);
        return this;
    }
    /**
   * @describe Adds a fake signature to the extrinsic
   */ signFake(signer, options) {
        this.signature.signFake(this.method, signer, options);
        return this;
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fiuwA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name ImmortalEra
 * @description
 * The ImmortalEra for an extrinsic
 */ parcelHelpers.export(exports, "ImmortalEra", ()=>ImmortalEra);
/**
 * @name MortalEra
 * @description
 * The MortalEra for an extrinsic, indicating period and phase
 */ parcelHelpers.export(exports, "MortalEra", ()=>MortalEra);
/**
 * @name GenericExtrinsicEra
 * @description
 * The era for an extrinsic, indicating either a mortal or immortal extrinsic
 */ parcelHelpers.export(exports, "GenericExtrinsicEra", ()=>GenericExtrinsicEra);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _constantsJs = require("./constants.js");
function getTrailingZeros(period) {
    const binary = period.toString(2);
    let index = 0;
    while(binary[binary.length - 1 - index] === "0")index++;
    return index;
}
/** @internal */ function decodeMortalEra(registry, value) {
    if ((0, _util.isU8a)(value) || (0, _util.isHex)(value) || Array.isArray(value)) return decodeMortalU8a(registry, (0, _util.u8aToU8a)(value));
    else if (!value) return [
        new (0, _typesCodec.U64)(registry),
        new (0, _typesCodec.U64)(registry)
    ];
    else if ((0, _util.isObject)(value)) return decodeMortalObject(registry, value);
    throw new Error("Invalid data passed to Mortal era");
}
/** @internal */ function decodeMortalObject(registry, value) {
    const { current , period  } = value;
    let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));
    calPeriod = Math.min(Math.max(calPeriod, 4), 65536);
    const phase = current % calPeriod;
    const quantizeFactor = Math.max(calPeriod >> 12, 1);
    const quantizedPhase = phase / quantizeFactor * quantizeFactor;
    return [
        new (0, _typesCodec.U64)(registry, calPeriod),
        new (0, _typesCodec.U64)(registry, quantizedPhase)
    ];
}
/** @internal */ function decodeMortalU8a(registry, value) {
    if (value.length === 0) return [
        new (0, _typesCodec.U64)(registry),
        new (0, _typesCodec.U64)(registry)
    ];
    const first = (0, _util.u8aToBn)(value.subarray(0, 1)).toNumber();
    const second = (0, _util.u8aToBn)(value.subarray(1, 2)).toNumber();
    const encoded = first + (second << 8);
    const period = 2 << encoded % 16;
    const quantizeFactor = Math.max(period >> 12, 1);
    const phase = (encoded >> 4) * quantizeFactor;
    if (period < 4 || phase >= period) throw new Error("Invalid data passed to Mortal era");
    return [
        new (0, _typesCodec.U64)(registry, period),
        new (0, _typesCodec.U64)(registry, phase)
    ];
}
/** @internal */ // eslint-disable-next-line @typescript-eslint/ban-types
function decodeExtrinsicEra(value = new Uint8Array()) {
    if ((0, _util.isU8a)(value)) return !value.length || value[0] === 0 ? new Uint8Array([
        0
    ]) : new Uint8Array([
        1,
        value[0],
        value[1]
    ]);
    else if (!value) return new Uint8Array([
        0
    ]);
    else if (value instanceof GenericExtrinsicEra) return decodeExtrinsicEra(value.toU8a());
    else if ((0, _util.isHex)(value)) return decodeExtrinsicEra((0, _util.hexToU8a)(value));
    else if ((0, _util.isObject)(value)) {
        const entries = Object.entries(value).map(([k, v])=>[
                k.toLowerCase(),
                v
            ]);
        const mortal = entries.find(([k])=>k.toLowerCase() === "mortalera");
        const immortal = entries.find(([k])=>k.toLowerCase() === "immortalera"); // this is to de-serialize from JSON
        return mortal ? {
            MortalEra: mortal[1]
        } : immortal ? {
            ImmortalEra: immortal[1]
        } : {
            MortalEra: value
        };
    }
    throw new Error("Invalid data passed to Era");
}
class ImmortalEra extends (0, _typesCodec.Raw) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    constructor(registry, value){
        // For immortals, we always provide the known value (i.e. treated as a
        // constant no matter how it is constructed - it is a fixed structure)
        super(registry, (0, _constantsJs.IMMORTAL_ERA));
    }
}
class MortalEra extends (0, _typesCodec.Tuple) {
    constructor(registry, value){
        super(registry, {
            period: (0, _typesCodec.U64),
            phase: (0, _typesCodec.U64)
        }, decodeMortalEra(registry, value));
    }
    /**
   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`
   */ get encodedLength() {
        return 2;
    }
    /**
   * @description The period of this Mortal wraps as a [[U64]]
   */ get period() {
        return this[0];
    }
    /**
   * @description The phase of this Mortal wraps as a [[U64]]
   */ get phase() {
        return this[1];
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return {
            period: (0, _util.formatNumber)(this.period),
            phase: (0, _util.formatNumber)(this.phase)
        };
    }
    /**
   * @description Returns a JSON representation of the actual value
   */ toJSON() {
        return this.toHex();
    }
    /**
   * @description Encodes the value as a Uint8Array as per the parity-codec specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   * Period and phase are encoded:
   *   - The period of validity from the block hash found in the signing material.
   *   - The phase in the period that this transaction's lifetime begins (and, importantly,
   *     implies which block hash is included in the signature material). If the `period` is
   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that
   *     `period` is.
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toU8a(isBare) {
        const period = this.period.toNumber();
        const encoded = Math.min(15, Math.max(1, getTrailingZeros(period) - 1)) + (this.phase.toNumber() / Math.max(period >> 12, 1) << 4);
        return new Uint8Array([
            encoded & 0xff,
            encoded >> 8
        ]);
    }
    /**
   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.
   */ birth(current) {
        const phase = this.phase.toNumber();
        const period = this.period.toNumber(); // FIXME No toNumber() here
        return ~~((Math.max((0, _util.bnToBn)(current).toNumber(), phase) - phase) / period) * period + phase;
    }
    /**
   * @description Get the block number of the first block at which the era has ended.
   */ death(current) {
        // FIXME No toNumber() here
        return this.birth(current) + this.period.toNumber();
    }
}
class GenericExtrinsicEra extends (0, _typesCodec.Enum) {
    constructor(registry, value){
        super(registry, {
            ImmortalEra,
            MortalEra
        }, decodeExtrinsicEra(value));
    }
    /**
   * @description Override the encoded length method
   */ get encodedLength() {
        return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;
    }
    /**
   * @description Returns the item as a [[ImmortalEra]]
   */ get asImmortalEra() {
        if (!this.isImmortalEra) throw new Error(`Cannot convert '${this.type}' via asImmortalEra`);
        return this.inner;
    }
    /**
   * @description Returns the item as a [[MortalEra]]
   */ get asMortalEra() {
        if (!this.isMortalEra) throw new Error(`Cannot convert '${this.type}' via asMortalEra`);
        return this.inner;
    }
    /**
   * @description `true` if Immortal
   */ get isImmortalEra() {
        return this.index === 0;
    }
    /**
   * @description `true` if Mortal
   */ get isMortalEra() {
        return this.index > 0;
    }
    /**
   * @description Encodes the value as a Uint8Array as per the parity-codec specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","./constants.js":"gKNvX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g8v6p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericExtrinsicPayload
 * @description
 * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based
 * on the contents included
 */ parcelHelpers.export(exports, "GenericExtrinsicPayload", ()=>GenericExtrinsicPayload);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _constantsJs = require("./constants.js");
const VERSIONS = [
    "ExtrinsicPayloadUnknown",
    "ExtrinsicPayloadUnknown",
    "ExtrinsicPayloadUnknown",
    "ExtrinsicPayloadUnknown",
    "ExtrinsicPayloadV4"
];
/** @internal */ function decodeExtrinsicPayload(registry, value, version = (0, _constantsJs.DEFAULT_VERSION)) {
    if (value instanceof GenericExtrinsicPayload) return value.unwrap();
    return registry.createTypeUnsafe(VERSIONS[version] || VERSIONS[0], [
        value,
        {
            version
        }
    ]);
}
class GenericExtrinsicPayload extends (0, _typesCodec.AbstractBase) {
    constructor(registry, value, { version  } = {}){
        super(registry, decodeExtrinsicPayload(registry, value, version));
    }
    /**
   * @description The block [[Hash]] the signature applies to (mortal/immortal)
   */ get blockHash() {
        return this.inner.blockHash;
    }
    /**
   * @description The [[ExtrinsicEra]]
   */ get era() {
        return this.inner.era;
    }
    /**
   * @description The genesis block [[Hash]] the signature applies to
   */ get genesisHash() {
        // NOTE only v3+
        return this.inner.genesisHash || this.registry.createTypeUnsafe("Hash", []);
    }
    /**
   * @description The [[Raw]] contained in the payload
   */ get method() {
        return this.inner.method;
    }
    /**
   * @description The [[Index]]
   */ get nonce() {
        return this.inner.nonce;
    }
    /**
   * @description The specVersion as a [[u32]] for this payload
   */ get specVersion() {
        // NOTE only v3+
        return this.inner.specVersion || this.registry.createTypeUnsafe("u32", []);
    }
    /**
   * @description The [[Balance]]
   */ get tip() {
        // NOTE from v2+
        return this.inner.tip || this.registry.createTypeUnsafe("Compact<Balance>", []);
    }
    /**
   * @description The transaction version as a [[u32]] for this payload
   */ get transactionVersion() {
        // NOTE only v4+
        return this.inner.transactionVersion || this.registry.createTypeUnsafe("u32", []);
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return this.inner.eq(other);
    }
    /**
   * @description Sign the payload with the keypair
   */ sign(signerPair) {
        const signature = this.inner.sign(signerPair); // This is extensible, so we could quite readily extend to send back extra
        // information, such as for instance the payload, i.e. `payload: this.toHex()`
        // For the case here we sign via the extrinsic, we ignore the return, so generally
        // this is applicable for external signing
        return {
            signature: (0, _util.u8aToHex)(signature)
        };
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExtended) {
        return this.inner.toHuman(isExtended);
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.toHex();
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return this.toHex();
    }
    /**
   * @description Returns a serialized u8a form
   */ toU8a(isBare) {
        // call our parent, with only the method stripped
        return super.toU8a(isBare ? {
            method: true
        } : false);
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","./constants.js":"gKNvX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bzf8A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericExtrinsicPayloadUnknown
 * @description
 * A default handler for payloads where the version is not known (default throw)
 */ parcelHelpers.export(exports, "GenericExtrinsicPayloadUnknown", ()=>GenericExtrinsicPayloadUnknown);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
class GenericExtrinsicPayloadUnknown extends (0, _typesCodec.Struct) {
    constructor(registry, value, { version =0  } = {}){
        super(registry, {});
        throw new Error(`Unsupported extrinsic payload version ${version}`);
    }
}

},{"@polkadot/types-codec":"gvW09","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h76Za":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericExtrinsicUnknown
 * @description
 * A default handler for extrinsics where the version is not known (default throw)
 */ parcelHelpers.export(exports, "GenericExtrinsicUnknown", ()=>GenericExtrinsicUnknown);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _constantsJs = require("./constants.js");
class GenericExtrinsicUnknown extends (0, _typesCodec.Struct) {
    constructor(registry, value, { isSigned =false , version =0  } = {}){
        super(registry, {});
        throw new Error(`Unsupported ${isSigned ? "" : "un"}signed extrinsic version ${version & (0, _constantsJs.UNMASK_VERSION)}`);
    }
}

},{"@polkadot/types-codec":"gvW09","./constants.js":"gKNvX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"79cxZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericSignerPayload
 * @description
 * A generic signer payload that can be used for serialization between API and signer
 */ parcelHelpers.export(exports, "GenericSignerPayload", ()=>GenericSignerPayload);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
const knownTypes = {
    address: "Address",
    blockHash: "Hash",
    blockNumber: "BlockNumber",
    era: "ExtrinsicEra",
    genesisHash: "Hash",
    method: "Call",
    nonce: "Compact<Index>",
    runtimeVersion: "RuntimeVersion",
    signedExtensions: "Vec<Text>",
    tip: "Compact<Balance>",
    version: "u8"
};
class GenericSignerPayload extends (0, _typesCodec.Struct) {
    #extraTypes;
    constructor(registry, value){
        const extensionTypes = (0, _util.objectSpread)({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());
        super(registry, (0, _util.objectSpread)({}, extensionTypes, knownTypes), value);
        this.#extraTypes = {};
        const getter = (key)=>this.get(key); // add all extras that are not in the base types
        for (const [key, type] of Object.entries(extensionTypes)){
            if (!knownTypes[key]) this.#extraTypes[key] = type;
            (0, _util.objectProperty)(this, key, getter);
        }
    }
    get address() {
        return this.getT("address");
    }
    get blockHash() {
        return this.getT("blockHash");
    }
    get blockNumber() {
        return this.getT("blockNumber");
    }
    get era() {
        return this.getT("era");
    }
    get genesisHash() {
        return this.getT("genesisHash");
    }
    get method() {
        return this.getT("method");
    }
    get nonce() {
        return this.getT("nonce");
    }
    get runtimeVersion() {
        return this.getT("runtimeVersion");
    }
    get signedExtensions() {
        return this.getT("signedExtensions");
    }
    get tip() {
        return this.getT("tip");
    }
    get version() {
        return this.getT("version");
    }
    /**
   * @description Creates an representation of the structure as an ISignerPayload JSON
   */ toPayload() {
        const result = {};
        const keys = Object.keys(this.#extraTypes); // add any explicit overrides we may have
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            const value = this.get(key);
            const isOption = value instanceof (0, _typesCodec.Option); // Don't include Option.isNone
            if (!isOption || value.isSome) result[key] = value.toHex();
        }
        return (0, _util.objectSpread)(result, {
            // the known defaults as managed explicitly and has different
            // formatting in cases, e.g. we mostly expose a hex format here
            address: this.address.toString(),
            blockHash: this.blockHash.toHex(),
            blockNumber: this.blockNumber.toHex(),
            era: this.era.toHex(),
            genesisHash: this.genesisHash.toHex(),
            method: this.method.toHex(),
            nonce: this.nonce.toHex(),
            signedExtensions: this.signedExtensions.map((e)=>e.toString()),
            specVersion: this.runtimeVersion.specVersion.toHex(),
            tip: this.tip.toHex(),
            transactionVersion: this.runtimeVersion.transactionVersion.toHex(),
            version: this.version.toNumber()
        });
    }
    /**
   * @description Creates a representation of the payload in raw Exrinsic form
   */ toRaw() {
        const payload = this.toPayload();
        const data = (0, _util.u8aToHex)(this.registry.createTypeUnsafe("ExtrinsicPayload", [
            payload,
            {
                version: payload.version
            }
        ]) // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)
        .toU8a({
            method: true
        }));
        return {
            address: payload.address,
            data,
            type: "payload"
        };
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k7HoD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "GenericExtrinsicV4", ()=>(0, _extrinsicJs.GenericExtrinsicV4));
parcelHelpers.export(exports, "GenericExtrinsicPayloadV4", ()=>(0, _extrinsicPayloadJs.GenericExtrinsicPayloadV4));
parcelHelpers.export(exports, "GenericExtrinsicSignatureV4", ()=>(0, _extrinsicSignatureJs.GenericExtrinsicSignatureV4));
var _extrinsicJs = require("./Extrinsic.js");
var _extrinsicPayloadJs = require("./ExtrinsicPayload.js");
var _extrinsicSignatureJs = require("./ExtrinsicSignature.js");

},{"./Extrinsic.js":"llA4W","./ExtrinsicPayload.js":"fJtHE","./ExtrinsicSignature.js":"a0b6l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fJtHE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericExtrinsicPayloadV4
 * @description
 * A signing payload for an [[Extrinsic]]. For the final encoding, it is
 * variable length based on the contents included
 */ parcelHelpers.export(exports, "GenericExtrinsicPayloadV4", ()=>GenericExtrinsicPayloadV4);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _utilJs = require("../util.js");
class GenericExtrinsicPayloadV4 extends (0, _typesCodec.Struct) {
    #signOptions;
    constructor(registry, value){
        super(registry, (0, _util.objectSpread)({
            method: "Bytes"
        }, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra()), value); // Do detection for the type of extrinsic, in the case of MultiSignature
        // this is an enum, in the case of AnySignature, this is a Hash only
        // (which may be 64 or 65 bytes)
        this.#signOptions = {
            withType: registry.createTypeUnsafe("ExtrinsicSignature", []) instanceof (0, _typesCodec.Enum)
        };
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        return super.inspect({
            method: true
        });
    }
    /**
   * @description The block [[Hash]] the signature applies to (mortal/immortal)
   */ get blockHash() {
        return this.getT("blockHash");
    }
    /**
   * @description The [[ExtrinsicEra]]
   */ get era() {
        return this.getT("era");
    }
    /**
   * @description The genesis [[Hash]] the signature applies to (mortal/immortal)
   */ get genesisHash() {
        return this.getT("genesisHash");
    }
    /**
   * @description The [[Bytes]] contained in the payload
   */ get method() {
        return this.getT("method");
    }
    /**
   * @description The [[Index]]
   */ get nonce() {
        return this.getT("nonce");
    }
    /**
   * @description The specVersion for this signature
   */ get specVersion() {
        return this.getT("specVersion");
    }
    /**
   * @description The tip [[Balance]]
   */ get tip() {
        return this.getT("tip");
    }
    /**
   * @description The transactionVersion for this signature
   */ get transactionVersion() {
        return this.getT("transactionVersion");
    }
    /**
   * @description
   * The (optional) asset id for this signature for chains that support transaction fees in assets
   */ get assetId() {
        return this.getT("assetId");
    }
    /**
   * @description Sign the payload with the keypair
   */ sign(signerPair) {
        // NOTE The `toU8a({ method: true })` argument is absolutely critical, we
        // don't want the method (Bytes) to have the length prefix included. This
        // means that the data-as-signed is un-decodable, but is also doesn't need
        // the extra information, only the pure data (and is not decoded) ...
        // The same applies to V1..V3, if we have a V5, carrythis comment
        return (0, _utilJs.sign)(this.registry, signerPair, this.toU8a({
            method: true
        }), this.#signOptions);
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","../util.js":"5MaGk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5MaGk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// a helper function for both types of payloads, Raw and metadata-known
parcelHelpers.export(exports, "sign", ()=>sign);
function sign(registry, signerPair, u8a, options) {
    const encoded = u8a.length > 256 ? registry.hash(u8a) : u8a;
    return signerPair.sign(encoded, options);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a0b6l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericExtrinsicSignatureV4
 * @description
 * A container for the [[Signature]] associated with a specific [[Extrinsic]]
 */ parcelHelpers.export(exports, "GenericExtrinsicSignatureV4", ()=>GenericExtrinsicSignatureV4);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _constantsJs = require("../constants.js");
var _extrinsicPayloadJs = require("./ExtrinsicPayload.js"); // Ensure we have enough data for all types of signatures
const FAKE_SIGNATURE = new Uint8Array(256).fill(1);
function toAddress(registry, address) {
    return registry.createTypeUnsafe("Address", [
        (0, _util.isU8a)(address) ? (0, _util.u8aToHex)(address) : address
    ]);
}
class GenericExtrinsicSignatureV4 extends (0, _typesCodec.Struct) {
    #signKeys;
    constructor(registry, value, { isSigned  } = {}){
        const signTypes = registry.getSignedExtensionTypes();
        super(registry, (0, _util.objectSpread)({
            signer: "Address",
            signature: "ExtrinsicSignature"
        }, signTypes), GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));
        this.#signKeys = Object.keys(signTypes);
        (0, _util.objectProperties)(this, this.#signKeys, (k)=>this.get(k));
    }
    /** @internal */ static decodeExtrinsicSignature(value, isSigned = false) {
        if (!value) return 0, _constantsJs.EMPTY_U8A;
        else if (value instanceof GenericExtrinsicSignatureV4) return value;
        return isSigned ? value : (0, _constantsJs.EMPTY_U8A);
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        return this.isSigned ? super.encodedLength : 0;
    }
    /**
   * @description `true` if the signature is valid
   */ get isSigned() {
        return !this.signature.isEmpty;
    }
    /**
   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to
   */ get era() {
        return this.getT("era");
    }
    /**
   * @description The [[Index]] for the signature
   */ get nonce() {
        return this.getT("nonce");
    }
    /**
   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]
   */ get signature() {
        // the second case here is when we don't have an enum signature, treat as raw
        return this.multiSignature.value || this.multiSignature;
    }
    /**
   * @description The raw [[ExtrinsicSignature]]
   */ get multiSignature() {
        return this.getT("signature");
    }
    /**
   * @description The [[Address]] that signed
   */ get signer() {
        return this.getT("signer");
    }
    /**
   * @description The [[Balance]] tip
   */ get tip() {
        return this.getT("tip");
    }
    _injectSignature(signer, signature, payload) {
        // use the fields exposed to guide the getters
        for(let i = 0; i < this.#signKeys.length; i++){
            const k = this.#signKeys[i];
            const v = payload.get(k);
            if (!(0, _util.isUndefined)(v)) this.set(k, v);
        } // additional fields (exposed in struct itself)
        this.set("signer", signer);
        this.set("signature", signature);
        return this;
    }
    /**
   * @description Adds a raw signature
   */ addSignature(signer, signature, payload) {
        return this._injectSignature(toAddress(this.registry, signer), this.registry.createTypeUnsafe("ExtrinsicSignature", [
            signature
        ]), new (0, _extrinsicPayloadJs.GenericExtrinsicPayloadV4)(this.registry, payload));
    }
    /**
   * @description Creates a payload from the supplied options
   */ createPayload(method, options) {
        const { era , runtimeVersion: { specVersion , transactionVersion  }  } = options;
        return new (0, _extrinsicPayloadJs.GenericExtrinsicPayloadV4)(this.registry, (0, _util.objectSpread)({}, options, {
            era: era || (0, _constantsJs.IMMORTAL_ERA),
            method: method.toHex(),
            specVersion,
            transactionVersion
        }));
    }
    /**
   * @description Generate a payload and applies the signature from a keypair
   */ sign(method, account, options) {
        if (!account || !account.addressRaw) throw new Error(`Expected a valid keypair for signing, found ${(0, _util.stringify)(account)}`);
        const payload = this.createPayload(method, options);
        return this._injectSignature(toAddress(this.registry, account.addressRaw), this.registry.createTypeUnsafe("ExtrinsicSignature", [
            payload.sign(account)
        ]), payload);
    }
    /**
   * @description Generate a payload and applies a fake signature
   */ signFake(method, address, options) {
        if (!address) throw new Error(`Expected a valid address for signing, found ${(0, _util.stringify)(address)}`);
        const payload = this.createPayload(method, options);
        return this._injectSignature(toAddress(this.registry, address), this.registry.createTypeUnsafe("ExtrinsicSignature", [
            FAKE_SIGNATURE
        ]), payload);
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        return this.isSigned ? super.toU8a(isBare) : (0, _constantsJs.EMPTY_U8A);
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","../constants.js":"gKNvX","./ExtrinsicPayload.js":"fJtHE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gF9ma":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GenericAccountId", ()=>(0, _accountIdJs.GenericAccountId));
parcelHelpers.export(exports, "GenericAccountIndex", ()=>(0, _accountIndexJs.GenericAccountIndex));
parcelHelpers.export(exports, "GenericBlock", ()=>(0, _blockJs.GenericBlock));
parcelHelpers.export(exports, "GenericCall", ()=>(0, _callJs.GenericCall));
parcelHelpers.export(exports, "GenericChainProperties", ()=>(0, _chainPropertiesJs.GenericChainProperties));
parcelHelpers.export(exports, "GenericConsensusEngineId", ()=>(0, _consensusEngineIdJs.GenericConsensusEngineId));
parcelHelpers.export(exports, "GenericEvent", ()=>(0, _eventJs.GenericEvent));
parcelHelpers.export(exports, "GenericEventData", ()=>(0, _eventJs.GenericEventData));
parcelHelpers.export(exports, "GenericLookupSource", ()=>(0, _lookupSourceJs.GenericLookupSource));
parcelHelpers.export(exports, "GenericMultiAddress", ()=>(0, _multiAddressJs.GenericMultiAddress));
parcelHelpers.export(exports, "GenericAddress", ()=>(0, _multiAddressJs.GenericMultiAddress));
parcelHelpers.export(exports, "GenericVote", ()=>(0, _voteJs.GenericVote));
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../ethereum/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var _accountIdJs = require("./AccountId.js");
var _accountIndexJs = require("./AccountIndex.js");
var _blockJs = require("./Block.js");
var _callJs = require("./Call.js");
var _chainPropertiesJs = require("./ChainProperties.js");
var _consensusEngineIdJs = require("./ConsensusEngineId.js");
var _eventJs = require("./Event.js");
var _lookupSourceJs = require("./LookupSource.js");
var _multiAddressJs = require("./MultiAddress.js");
var _voteJs = require("./Vote.js");

},{"../ethereum/index.js":"kup0c","./AccountId.js":"flXVk","./AccountIndex.js":"bGqp8","./Block.js":"fZ1Kq","./Call.js":"a9Io9","./ChainProperties.js":"VbJWt","./ConsensusEngineId.js":"4dOBH","./Event.js":"jknfu","./LookupSource.js":"hefSi","./MultiAddress.js":"bAjIC","./Vote.js":"f3mO1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kup0c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "GenericEthereumAccountId", ()=>(0, _accountIdJs.GenericEthereumAccountId));
parcelHelpers.export(exports, "GenericEthereumLookupSource", ()=>(0, _lookupSourceJs.GenericEthereumLookupSource));
var _accountIdJs = require("./AccountId.js");
var _lookupSourceJs = require("./LookupSource.js");

},{"./AccountId.js":"eXUVx","./LookupSource.js":"9Y5j8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eXUVx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericEthereumAccountId
 * @description
 * A wrapper around an Ethereum-compatible AccountId. Since we are dealing with
 * underlying addresses (20 bytes in length), we extend from U8aFixed which is
 * just a Uint8Array wrapper with a fixed length.
 */ parcelHelpers.export(exports, "GenericEthereumAccountId", ()=>GenericEthereumAccountId);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
/** @internal */ function decodeAccountId(value) {
    if ((0, _util.isU8a)(value) || Array.isArray(value)) return (0, _util.u8aToU8a)(value);
    else if ((0, _util.isHex)(value) || (0, _utilCrypto.isEthereumAddress)(value.toString())) return (0, _util.hexToU8a)(value.toString());
    else if ((0, _util.isString)(value)) return (0, _util.u8aToU8a)(value);
    return value;
}
class GenericEthereumAccountId extends (0, _typesCodec.U8aFixed) {
    constructor(registry, value = new Uint8Array()){
        super(registry, decodeAccountId(value), 160);
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return super.eq(decodeAccountId(other));
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toJSON();
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.toString();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.toJSON();
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return (0, _utilCrypto.ethereumEncode)(this);
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "AccountId";
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Y5j8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ACCOUNT_ID_PREFIX", ()=>ACCOUNT_ID_PREFIX);
/**
 * @name GenericEthereumLookupSource
 * @description
 * A wrapper around an EthereumAccountId and/or AccountIndex that is encoded with a prefix.
 * Since we are dealing with underlying publicKeys (or shorter encoded addresses),
 * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address
 * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec
 */ parcelHelpers.export(exports, "GenericEthereumLookupSource", ()=>GenericEthereumLookupSource);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _accountIndexJs = require("../generic/AccountIndex.js");
var _accountIdJs = require("./AccountId.js"); // eslint-disable-next-line no-use-before-define
const ACCOUNT_ID_PREFIX = new Uint8Array([
    0xff
]);
/** @internal */ function decodeString(registry, value) {
    const decoded = (0, _utilCrypto.decodeAddress)(value);
    return decoded.length === 20 ? registry.createTypeUnsafe("EthereumAccountId", [
        decoded
    ]) : registry.createTypeUnsafe("AccountIndex", [
        (0, _util.u8aToBn)(decoded)
    ]);
}
/** @internal */ function decodeU8a(registry, value) {
    // This allows us to instantiate an address with a raw publicKey. Do this first before
    // we checking the first byte, otherwise we may split an already-existent valid address
    if (value.length === 20) return registry.createTypeUnsafe("EthereumAccountId", [
        value
    ]);
    else if (value[0] === 0xff) return registry.createTypeUnsafe("EthereumAccountId", [
        value.subarray(1)
    ]);
    const [offset, length] = (0, _accountIndexJs.GenericAccountIndex).readLength(value);
    return registry.createTypeUnsafe("AccountIndex", [
        (0, _util.u8aToBn)(value.subarray(offset, offset + length))
    ]);
}
function decodeAddressOrIndex(registry, value) {
    return value instanceof GenericEthereumLookupSource ? value.inner : value instanceof (0, _accountIdJs.GenericEthereumAccountId) || value instanceof (0, _accountIndexJs.GenericAccountIndex) ? value : (0, _util.isU8a)(value) || Array.isArray(value) || (0, _util.isHex)(value) ? decodeU8a(registry, (0, _util.u8aToU8a)(value)) : (0, _util.isBn)(value) || (0, _util.isNumber)(value) || (0, _util.isBigInt)(value) ? registry.createTypeUnsafe("AccountIndex", [
        value
    ]) : decodeString(registry, value);
}
class GenericEthereumLookupSource extends (0, _typesCodec.AbstractBase) {
    constructor(registry, value = new Uint8Array()){
        super(registry, decodeAddressOrIndex(registry, value));
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        const rawLength = this._rawLength;
        return rawLength + (rawLength > 1 ? 1 : 0);
    }
    /**
   * @description The length of the raw value, either AccountIndex or AccountId
   */ get _rawLength() {
        return this.inner instanceof (0, _accountIndexJs.GenericAccountIndex) ? (0, _accountIndexJs.GenericAccountIndex).calcLength(this.inner) : this.inner.encodedLength;
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        return (0, _util.u8aToHex)(this.toU8a());
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Address";
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        const encoded = this.inner.toU8a().subarray(0, this._rawLength);
        return isBare ? encoded : (0, _util.u8aConcat)(this.inner instanceof (0, _accountIndexJs.GenericAccountIndex) ? (0, _accountIndexJs.GenericAccountIndex).writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","../generic/AccountIndex.js":"bGqp8","./AccountId.js":"eXUVx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bGqp8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericAccountIndex
 * @description
 * A wrapper around an AccountIndex, which is a shortened, variable-length encoding
 * for an Account. We extends from [[U32]] to provide the number-like properties.
 */ parcelHelpers.export(exports, "GenericAccountIndex", ()=>GenericAccountIndex);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
const PREFIX_1BYTE = 0xef;
const PREFIX_2BYTE = 0xfc;
const PREFIX_4BYTE = 0xfd;
const PREFIX_8BYTE = 0xfe;
const MAX_1BYTE = new (0, _util.BN)(PREFIX_1BYTE);
const MAX_2BYTE = new (0, _util.BN)(1).shln(16);
const MAX_4BYTE = new (0, _util.BN)(1).shln(32);
/** @internal */ function decodeAccountIndex(value) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    if (value instanceof GenericAccountIndex) // `value.toBn()` on AccountIndex returns a pure BN (i.e. not an
    // AccountIndex), which has the initial `toString()` implementation.
    return value.toBn();
    else if ((0, _util.isBn)(value) || (0, _util.isNumber)(value) || (0, _util.isHex)(value) || (0, _util.isU8a)(value) || (0, _util.isBigInt)(value)) return value;
    return decodeAccountIndex((0, _utilCrypto.decodeAddress)(value));
}
class GenericAccountIndex extends (0, _typesCodec.u32) {
    constructor(registry, value = new (0, _util.BN)(0)){
        super(registry, decodeAccountIndex(value));
    }
    static calcLength(_value) {
        const value = (0, _util.bnToBn)(_value);
        if (value.lte(MAX_1BYTE)) return 1;
        else if (value.lt(MAX_2BYTE)) return 2;
        else if (value.lt(MAX_4BYTE)) return 4;
        return 8;
    }
    static readLength(input) {
        const first = input[0];
        if (first === PREFIX_2BYTE) return [
            1,
            2
        ];
        else if (first === PREFIX_4BYTE) return [
            1,
            4
        ];
        else if (first === PREFIX_8BYTE) return [
            1,
            8
        ];
        return [
            0,
            1
        ];
    }
    static writeLength(input) {
        switch(input.length){
            case 2:
                return new Uint8Array([
                    PREFIX_2BYTE
                ]);
            case 4:
                return new Uint8Array([
                    PREFIX_4BYTE
                ]);
            case 8:
                return new Uint8Array([
                    PREFIX_8BYTE
                ]);
            default:
                return new Uint8Array([]);
        }
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        // shortcut for BN or Number, don't create an object
        if ((0, _util.isBn)(other) || (0, _util.isNumber)(other)) return super.eq(other);
         // convert and compare
        return super.eq(this.registry.createTypeUnsafe("AccountIndex", [
            other
        ]));
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toJSON();
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.toString();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.toJSON();
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        const length = GenericAccountIndex.calcLength(this);
        return (0, _utilCrypto.encodeAddress)(this.toU8a().subarray(0, length), this.registry.chainSS58);
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "AccountIndex";
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"flXVk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericAccountId
 * @description
 * A wrapper around an AccountId/PublicKey representation. Since we are dealing with
 * underlying PublicKeys (32 bytes in length), we extend from U8aFixed which is
 * just a Uint8Array wrapper with a fixed length.
 */ parcelHelpers.export(exports, "GenericAccountId", ()=>GenericAccountId);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
/** @internal */ function decodeAccountId(value) {
    if ((0, _util.isU8a)(value) || Array.isArray(value)) return (0, _util.u8aToU8a)(value);
    else if (!value) return new Uint8Array();
    else if ((0, _util.isHex)(value)) return (0, _util.hexToU8a)(value);
    else if ((0, _util.isString)(value)) return (0, _utilCrypto.decodeAddress)(value.toString());
    throw new Error(`Unknown type passed to AccountId constructor, found typeof ${typeof value}`);
}
class GenericAccountId extends (0, _typesCodec.U8aFixed) {
    constructor(registry, value){
        const decoded = decodeAccountId(value); // Part of stream containing >= 32 bytes or a all empty (defaults)
        if (decoded.length < 32 && decoded.some((b)=>b)) throw new Error(`Invalid AccountId provided, expected 32 bytes, found ${decoded.length}`);
        super(registry, decoded, 256);
    }
    /**
   * @description Compares the value of the input to see if there is a match
   */ eq(other) {
        return super.eq(decodeAccountId(other));
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toJSON();
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        return this.toString();
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.toJSON();
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return (0, _utilCrypto.encodeAddress)(this, this.registry.chainSS58);
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "AccountId";
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fZ1Kq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericBlock
 * @description
 * A block encoded with header and extrinsics
 */ parcelHelpers.export(exports, "GenericBlock", ()=>GenericBlock);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
class GenericBlock extends (0, _typesCodec.Struct) {
    constructor(registry, value){
        super(registry, {
            header: "Header",
            // eslint-disable-next-line sort-keys
            extrinsics: "Vec<Extrinsic>"
        }, value);
    }
    /**
   * @description Encodes a content [[Hash]] for the block
   */ get contentHash() {
        return this.registry.hash(this.toU8a());
    }
    /**
   * @description The [[Extrinsic]] contained in the block
   */ get extrinsics() {
        return this.getT("extrinsics");
    }
    /**
   * @description Block/header [[Hash]]
   */ get hash() {
        return this.header.hash;
    }
    /**
   * @description The [[Header]] of the block
   */ get header() {
        return this.getT("header");
    }
}

},{"@polkadot/types-codec":"gvW09","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a9Io9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericCallIndex
 * @description
 * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method
 */ parcelHelpers.export(exports, "GenericCallIndex", ()=>GenericCallIndex);
/**
 * @name GenericCall
 * @description
 * Extrinsic function descriptor
 */ parcelHelpers.export(exports, "GenericCall", ()=>GenericCall);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
/**
 * Get a mapping of `argument name -> argument type` for the function, from
 * its metadata.
 *
 * @param meta - The function metadata used to get the definition.
 * @internal
 */ function getArgsDef(registry, meta) {
    return meta.fields.reduce((result, { name , type  }, index)=>{
        result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);
        return result;
    }, {});
}
/** @internal */ function decodeCallViaObject(registry, value, _meta) {
    // we only pass args/methodsIndex out
    const { args , callIndex  } = value; // Get the correct lookupIndex
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex
    const meta = _meta || registry.findMetaCall(lookupIndex).meta;
    return {
        args,
        argsDef: getArgsDef(registry, meta),
        callIndex,
        meta
    };
}
/** @internal */ function decodeCallViaU8a(registry, value, _meta) {
    // We need 2 bytes for the callIndex
    const callIndex = registry.firstCallIndex.slice();
    callIndex.set(value.subarray(0, 2), 0); // Find metadata with callIndex
    const meta = _meta || registry.findMetaCall(callIndex).meta;
    return {
        args: value.subarray(2),
        argsDef: getArgsDef(registry, meta),
        callIndex,
        meta
    };
}
/**
 * Decode input to pass into constructor.
 *
 * @param value - Value to decode, one of:
 * - hex
 * - Uint8Array
 * - {@see DecodeMethodInput}
 * @param _meta - Metadata to use, so that `injectMethods` lookup is not
 * necessary.
 * @internal
 */ function decodeCall(registry, value = new Uint8Array(), _meta) {
    if ((0, _util.isU8a)(value) || (0, _util.isHex)(value)) return decodeCallViaU8a(registry, (0, _util.u8aToU8a)(value), _meta);
    else if ((0, _util.isObject)(value) && value.callIndex && value.args) return decodeCallViaObject(registry, value, _meta);
    throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);
}
class GenericCallIndex extends (0, _typesCodec.U8aFixed) {
    constructor(registry, value){
        super(registry, value, 16);
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return this.toHex();
    }
}
class GenericCall extends (0, _typesCodec.Struct) {
    constructor(registry, value, meta){
        const decoded = decodeCall(registry, value, meta);
        try {
            super(registry, {
                callIndex: GenericCallIndex,
                // eslint-disable-next-line sort-keys
                args: (0, _typesCodec.Struct).with(decoded.argsDef)
            }, decoded);
        } catch (error) {
            let method = "unknown.unknown";
            try {
                const c = registry.findMetaCall(decoded.callIndex);
                method = `${c.section}.${c.method}`;
            } catch (error1) {}
            throw new Error(`Call: failed decoding ${method}:: ${error.message}`);
        }
        this._meta = decoded.meta;
    }
    /**
   * @description The arguments for the function call
   */ get args() {
        return [
            ...this.getT("args").values()
        ];
    }
    /**
   * @description The argument definitions
   */ get argsDef() {
        return getArgsDef(this.registry, this.meta);
    }
    /**
   * @description The argument entries
   */ get argsEntries() {
        return [
            ...this.getT("args").entries()
        ];
    }
    /**
   * @description The encoded `[sectionIndex, methodIndex]` identifier
   */ get callIndex() {
        return this.getT("callIndex").toU8a();
    }
    /**
   * @description The encoded data
   */ get data() {
        return this.getT("args").toU8a();
    }
    /**
   * @description The [[FunctionMetadata]]
   */ get meta() {
        return this._meta;
    }
    /**
   * @description Returns the name of the method
   */ get method() {
        return this.registry.findMetaCall(this.callIndex).method;
    }
    /**
   * @description Returns the module containing the method
   */ get section() {
        return this.registry.findMetaCall(this.callIndex).section;
    }
    /**
   * @description Checks if the source matches this in type
   */ is(other) {
        return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExpanded) {
        var _call, _call2;
        let call;
        try {
            call = this.registry.findMetaCall(this.callIndex);
        } catch (error) {}
        return (0, _util.objectSpread)({
            args: this.argsEntries.reduce((args, [n, a])=>(0, _util.objectSpread)(args, {
                    [n]: a.toHuman(isExpanded)
                }), {}),
            method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,
            section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section
        }, isExpanded && call ? {
            docs: call.meta.docs.map((d)=>d.toString())
        } : null);
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Call";
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"VbJWt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GenericChainProperties", ()=>GenericChainProperties);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
function createValue(registry, type, value, asArray = true) {
    // We detect codec here as well - when found, generally this is constructed from itself
    if (value && (0, _util.isFunction)(value.unwrapOrDefault)) return value;
    return registry.createTypeUnsafe(type, [
        asArray ? (0, _util.isNull)(value) || (0, _util.isUndefined)(value) ? null : Array.isArray(value) ? value : [
            value
        ] : value
    ]);
}
function decodeValue(registry, key, value) {
    return key === "ss58Format" ? createValue(registry, "Option<u32>", value, false) : key === "tokenDecimals" ? createValue(registry, "Option<Vec<u32>>", value) : key === "tokenSymbol" ? createValue(registry, "Option<Vec<Text>>", value) : value;
}
function decode(registry, value) {
    return (value && (0, _util.isFunction)(value.entries) ? [
        ...value.entries()
    ] : Object.entries(value || {})).reduce((all, [key, value])=>{
        all[key] = decodeValue(registry, key, value);
        return all;
    }, {
        ss58Format: registry.createTypeUnsafe("Option<u32>", []),
        tokenDecimals: registry.createTypeUnsafe("Option<Vec<u32>>", []),
        tokenSymbol: registry.createTypeUnsafe("Option<Vec<Text>>", [])
    });
}
class GenericChainProperties extends (0, _typesCodec.Json) {
    constructor(registry, value){
        super(registry, decode(registry, value));
    }
    /**
   * @description The chain ss58Format
   */ get ss58Format() {
        return this.getT("ss58Format");
    }
    /**
   * @description The decimals for each of the tokens
   */ get tokenDecimals() {
        return this.getT("tokenDecimals");
    }
    /**
   * @description The symbols for the tokens
   */ get tokenSymbol() {
        return this.getT("tokenSymbol");
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4dOBH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CID_AURA", ()=>CID_AURA);
parcelHelpers.export(exports, "CID_BABE", ()=>CID_BABE);
parcelHelpers.export(exports, "CID_GRPA", ()=>CID_GRPA);
parcelHelpers.export(exports, "CID_POW", ()=>CID_POW);
/**
 * @name GenericConsensusEngineId
 * @description
 * A 4-byte identifier identifying the engine
 */ parcelHelpers.export(exports, "GenericConsensusEngineId", ()=>GenericConsensusEngineId);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
const CID_AURA = (0, _util.stringToU8a)("aura");
const CID_BABE = (0, _util.stringToU8a)("BABE");
const CID_GRPA = (0, _util.stringToU8a)("FRNK");
const CID_POW = (0, _util.stringToU8a)("pow_");
function getAuraAuthor(registry, bytes, sessionValidators) {
    return sessionValidators[registry.createTypeUnsafe("RawAuraPreDigest", [
        bytes.toU8a(true)
    ]).slotNumber.mod(new (0, _util.BN)(sessionValidators.length)).toNumber()];
}
function getBabeAuthor(registry, bytes, sessionValidators) {
    const digest = registry.createTypeUnsafe("RawBabePreDigestCompat", [
        bytes.toU8a(true)
    ]);
    return sessionValidators[digest.value.toNumber()];
}
function getBytesAsAuthor(registry, bytes) {
    return registry.createTypeUnsafe("AccountId", [
        bytes
    ]);
}
class GenericConsensusEngineId extends (0, _typesCodec.U8aFixed) {
    constructor(registry, value){
        super(registry, (0, _util.isNumber)(value) ? (0, _util.bnToU8a)(value, {
            isLe: false
        }) : value, 32);
    }
    /**
   * @description `true` if the engine matches aura
   */ get isAura() {
        return this.eq(CID_AURA);
    }
    /**
   * @description `true` is the engine matches babe
   */ get isBabe() {
        return this.eq(CID_BABE);
    }
    /**
   * @description `true` is the engine matches grandpa
   */ get isGrandpa() {
        return this.eq(CID_GRPA);
    }
    /**
   * @description `true` is the engine matches pow
   */ get isPow() {
        return this.eq(CID_POW);
    }
    /**
   * @description From the input bytes, decode into an author
   */ extractAuthor(bytes, sessionValidators) {
        if (sessionValidators !== null && sessionValidators !== void 0 && sessionValidators.length) {
            if (this.isAura) return getAuraAuthor(this.registry, bytes, sessionValidators);
            else if (this.isBabe) return getBabeAuthor(this.registry, bytes, sessionValidators);
        } // For pow & Moonbeam, the bytes are the actual author
        if (this.isPow || bytes.length === 20) return getBytesAsAuthor(this.registry, bytes);
        return undefined;
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman() {
        return this.toString();
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "ConsensusEngineId";
    }
    /**
   * @description Override the default toString to return a 4-byte string
   */ toString() {
        return this.isAscii ? (0, _util.u8aToString)(this) : (0, _util.u8aToHex)(this);
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hefSi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ACCOUNT_ID_PREFIX", ()=>ACCOUNT_ID_PREFIX);
/**
 * @name LookupSource
 * @description
 * A wrapper around an AccountId and/or AccountIndex that is encoded with a prefix.
 * Since we are dealing with underlying publicKeys (or shorter encoded addresses),
 * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address
 * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec
 */ parcelHelpers.export(exports, "GenericLookupSource", ()=>GenericLookupSource);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _accountIdJs = require("./AccountId.js");
var _accountIndexJs = require("./AccountIndex.js"); // eslint-disable-next-line no-use-before-define
const ACCOUNT_ID_PREFIX = new Uint8Array([
    0xff
]);
/** @internal */ function decodeString(registry, value) {
    const decoded = (0, _utilCrypto.decodeAddress)(value);
    return decoded.length === 32 ? registry.createTypeUnsafe("AccountId", [
        decoded
    ]) : registry.createTypeUnsafe("AccountIndex", [
        (0, _util.u8aToBn)(decoded)
    ]);
}
/** @internal */ function decodeU8a(registry, value) {
    // This allows us to instantiate an address with a raw publicKey. Do this first before
    // we checking the first byte, otherwise we may split an already-existent valid address
    if (value.length === 32) return registry.createTypeUnsafe("AccountId", [
        value
    ]);
    else if (value[0] === 0xff) return registry.createTypeUnsafe("AccountId", [
        value.subarray(1)
    ]);
    const [offset, length] = (0, _accountIndexJs.GenericAccountIndex).readLength(value);
    return registry.createTypeUnsafe("AccountIndex", [
        (0, _util.u8aToBn)(value.subarray(offset, offset + length))
    ]);
}
/** @internal */ function decodeAddressOrIndex(registry, value) {
    return value instanceof GenericLookupSource ? value.inner : value instanceof (0, _accountIdJs.GenericAccountId) || value instanceof (0, _accountIndexJs.GenericAccountIndex) ? value : (0, _util.isBn)(value) || (0, _util.isNumber)(value) || (0, _util.isBigInt)(value) ? registry.createTypeUnsafe("AccountIndex", [
        value
    ]) : Array.isArray(value) || (0, _util.isHex)(value) || (0, _util.isU8a)(value) ? decodeU8a(registry, (0, _util.u8aToU8a)(value)) : decodeString(registry, value);
}
class GenericLookupSource extends (0, _typesCodec.AbstractBase) {
    constructor(registry, value = new Uint8Array()){
        super(registry, decodeAddressOrIndex(registry, value));
    }
    /**
   * @description The length of the value when encoded as a Uint8Array
   */ get encodedLength() {
        const rawLength = this._rawLength;
        return rawLength + (rawLength > 1 ? 1 : 0);
    }
    /**
   * @description The length of the raw value, either AccountIndex or AccountId
   */ get _rawLength() {
        return this.inner instanceof (0, _accountIndexJs.GenericAccountIndex) ? (0, _accountIndexJs.GenericAccountIndex).calcLength(this.inner) : this.inner.encodedLength;
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        const value = this.inner.toU8a().subarray(0, this._rawLength);
        return {
            outer: [
                new Uint8Array(this.inner instanceof (0, _accountIndexJs.GenericAccountIndex) ? (0, _accountIndexJs.GenericAccountIndex).writeLength(value) : ACCOUNT_ID_PREFIX),
                value
            ]
        };
    }
    /**
   * @description Returns a hex string representation of the value
   */ toHex() {
        return (0, _util.u8aToHex)(this.toU8a());
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Address";
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */ toU8a(isBare) {
        const encoded = this.inner.toU8a().subarray(0, this._rawLength);
        return isBare ? encoded : (0, _util.u8aConcat)(this.inner instanceof (0, _accountIndexJs.GenericAccountIndex) ? (0, _accountIndexJs.GenericAccountIndex).writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","./AccountId.js":"flXVk","./AccountIndex.js":"bGqp8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bAjIC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GenericMultiAddress", ()=>GenericMultiAddress);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _accountIdJs = require("./AccountId.js");
var _accountIndexJs = require("./AccountIndex.js");
function decodeU8a(registry, u8a) {
    if ([
        0,
        32
    ].includes(u8a.length)) return {
        Id: u8a
    };
    else if (u8a.length === 20) return {
        Address20: u8a
    };
    else if (u8a.length <= 8) return {
        Index: registry.createTypeUnsafe("AccountIndex", [
            u8a
        ]).toNumber()
    };
    return u8a;
}
function decodeMultiAny(registry, value) {
    if (value instanceof (0, _accountIdJs.GenericAccountId)) return {
        Id: value
    };
    else if ((0, _util.isU8a)(value)) // NOTE This is after the AccountId check (which is U8a)
    return decodeU8a(registry, value);
    else if (value instanceof GenericMultiAddress) return value;
    else if (value instanceof (0, _accountIndexJs.GenericAccountIndex) || (0, _util.isBn)(value) || (0, _util.isNumber)(value)) return {
        Index: (0, _util.isNumber)(value) ? value : value.toNumber()
    };
    else if ((0, _util.isString)(value)) return decodeU8a(registry, (0, _utilCrypto.decodeAddress)(value.toString()));
    return value;
}
class GenericMultiAddress extends (0, _typesCodec.Enum) {
    constructor(registry, value){
        super(registry, {
            Id: "AccountId",
            Index: "Compact<AccountIndex>",
            Raw: "Bytes",
            // eslint-disable-next-line sort-keys
            Address32: "H256",
            // eslint-disable-next-line sort-keys
            Address20: "H160"
        }, decodeMultiAny(registry, value));
    }
    /**
   * @description Returns a breakdown of the hex encoding for this Codec
   */ inspect() {
        const { inner , outer =[]  } = this.inner.inspect();
        return {
            inner,
            outer: [
                new Uint8Array([
                    this.index
                ]),
                ...outer
            ]
        };
    }
    /**
   * @description Returns the string representation of the value
   */ toString() {
        return this.value.toString();
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","./AccountId.js":"flXVk","./AccountIndex.js":"bGqp8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f3mO1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name GenericVote
 * @description
 * A number of lock periods, plus a vote, one way or the other.
 */ parcelHelpers.export(exports, "GenericVote", ()=>GenericVote);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
// For votes, the topmost bit indicated aye/nay, the lower bits indicate the conviction
const AYE_BITS = 128;
const NAY_BITS = 0;
const CON_MASK = 127;
const DEF_CONV = 0; // the default conviction, None
/** @internal */ function decodeVoteBool(value) {
    return value ? new Uint8Array([
        AYE_BITS | DEF_CONV
    ]) : new Uint8Array([
        NAY_BITS
    ]);
}
/** @internal */ function decodeVoteU8a(value) {
    return value.length ? value.subarray(0, 1) : new Uint8Array([
        NAY_BITS
    ]);
}
/** @internal */ function decodeVoteType(registry, value) {
    return new Uint8Array([
        (new (0, _typesCodec.Bool)(registry, value.aye).isTrue ? AYE_BITS : NAY_BITS) | registry.createTypeUnsafe("Conviction", [
            value.conviction || DEF_CONV
        ]).index
    ]);
}
/** @internal */ function decodeVote(registry, value) {
    if ((0, _util.isU8a)(value)) return decodeVoteU8a(value);
    else if ((0, _util.isUndefined)(value) || value instanceof Boolean || (0, _util.isBoolean)(value)) return decodeVoteBool(new (0, _typesCodec.Bool)(registry, value).isTrue);
    else if ((0, _util.isNumber)(value)) return decodeVoteBool(value < 0);
    return decodeVoteType(registry, value);
}
class GenericVote extends (0, _typesCodec.U8aFixed) {
    #aye;
    #conviction;
    constructor(registry, value){
        // decoded is just 1 byte
        // Aye: Most Significant Bit
        // Conviction: 0000 - 0101
        const decoded = decodeVote(registry, value);
        super(registry, decoded, 8);
        this.#aye = (decoded[0] & AYE_BITS) === AYE_BITS;
        this.#conviction = this.registry.createTypeUnsafe("Conviction", [
            decoded[0] & CON_MASK
        ]);
    }
    /**
   * @description returns a V2 conviction
   */ get conviction() {
        return this.#conviction;
    }
    /**
   * @description true if the wrapped value is a positive vote
   */ get isAye() {
        return this.#aye;
    }
    /**
   * @description true if the wrapped value is a negative vote
   */ get isNay() {
        return !this.isAye;
    }
    /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */ toHuman(isExpanded) {
        return {
            conviction: this.conviction.toHuman(isExpanded),
            vote: this.isAye ? "Aye" : "Nay"
        };
    }
    /**
   * @description Converts the value in a best-fit primitive form
   */ toPrimitive() {
        return {
            aye: this.isAye,
            conviction: this.conviction.toPrimitive()
        };
    }
    /**
   * @description Returns the base runtime type name for this instance
   */ toRawType() {
        return "Vote";
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4FGVo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @summary Type definitions that are used in the system
 */ parcelHelpers.export(exports, "BitVec", ()=>(0, _typesCodec.BitVec));
parcelHelpers.export(exports, "bool", ()=>(0, _typesCodec.bool));
parcelHelpers.export(exports, "Bool", ()=>(0, _typesCodec.Bool));
parcelHelpers.export(exports, "Bytes", ()=>(0, _typesCodec.Bytes));
parcelHelpers.export(exports, "f32", ()=>(0, _typesCodec.f32));
parcelHelpers.export(exports, "F32", ()=>(0, _typesCodec.F32));
parcelHelpers.export(exports, "f64", ()=>(0, _typesCodec.f64));
parcelHelpers.export(exports, "F64", ()=>(0, _typesCodec.F64));
parcelHelpers.export(exports, "i8", ()=>(0, _typesCodec.i8));
parcelHelpers.export(exports, "I8", ()=>(0, _typesCodec.I8));
parcelHelpers.export(exports, "i16", ()=>(0, _typesCodec.i16));
parcelHelpers.export(exports, "I16", ()=>(0, _typesCodec.I16));
parcelHelpers.export(exports, "i32", ()=>(0, _typesCodec.i32));
parcelHelpers.export(exports, "I32", ()=>(0, _typesCodec.I32));
parcelHelpers.export(exports, "i64", ()=>(0, _typesCodec.i64));
parcelHelpers.export(exports, "I64", ()=>(0, _typesCodec.I64));
parcelHelpers.export(exports, "i128", ()=>(0, _typesCodec.i128));
parcelHelpers.export(exports, "I128", ()=>(0, _typesCodec.I128));
parcelHelpers.export(exports, "i256", ()=>(0, _typesCodec.i256));
parcelHelpers.export(exports, "I256", ()=>(0, _typesCodec.I256));
parcelHelpers.export(exports, "Null", ()=>(0, _typesCodec.Null));
parcelHelpers.export(exports, "OptionBool", ()=>(0, _typesCodec.OptionBool));
parcelHelpers.export(exports, "Text", ()=>(0, _typesCodec.Text));
parcelHelpers.export(exports, "Type", ()=>(0, _typesCodec.Type));
parcelHelpers.export(exports, "u8", ()=>(0, _typesCodec.u8));
parcelHelpers.export(exports, "U8", ()=>(0, _typesCodec.U8));
parcelHelpers.export(exports, "u16", ()=>(0, _typesCodec.u16));
parcelHelpers.export(exports, "U16", ()=>(0, _typesCodec.U16));
parcelHelpers.export(exports, "u32", ()=>(0, _typesCodec.u32));
parcelHelpers.export(exports, "U32", ()=>(0, _typesCodec.U32));
parcelHelpers.export(exports, "u64", ()=>(0, _typesCodec.u64));
parcelHelpers.export(exports, "U64", ()=>(0, _typesCodec.U64));
parcelHelpers.export(exports, "u128", ()=>(0, _typesCodec.u128));
parcelHelpers.export(exports, "U128", ()=>(0, _typesCodec.U128));
parcelHelpers.export(exports, "u256", ()=>(0, _typesCodec.u256));
parcelHelpers.export(exports, "U256", ()=>(0, _typesCodec.U256));
parcelHelpers.export(exports, "usize", ()=>(0, _typesCodec.usize));
parcelHelpers.export(exports, "USize", ()=>(0, _typesCodec.USize));
parcelHelpers.export(exports, "Data", ()=>(0, _dataJs.Data));
parcelHelpers.export(exports, "StorageKey", ()=>(0, _storageKeyJs.StorageKey));
var _typesCodec = require("@polkadot/types-codec");
var _dataJs = require("./Data.js");
var _storageKeyJs = require("./StorageKey.js");

},{"@polkadot/types-codec":"gvW09","./Data.js":"hSt36","./StorageKey.js":"fD5Ag","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hSt36":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Data
 * @description
 * A [[Data]] container with node, raw or hashed data
 */ parcelHelpers.export(exports, "Data", ()=>Data);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
/** @internal */ function decodeDataU8a(registry, value) {
    const indicator = value[0];
    if (!indicator) return [
        undefined,
        undefined
    ];
    else if (indicator >= 1 && indicator <= 33) {
        const length = indicator - 1;
        const data = value.subarray(1, length + 1); // in this case, we are passing a Raw back (since we have no length)
        return [
            registry.createTypeUnsafe("Raw", [
                data
            ]),
            1
        ];
    } else if (indicator >= 34 && indicator <= 37) return [
        value.subarray(1, 33),
        indicator - 32
    ]; // 34 becomes 2
    throw new Error(`Unable to decode Data, invalid indicator byte ${indicator}`);
}
/** @internal */ function decodeData(registry, value) {
    if ((0, _util.isU8a)(value) || (0, _util.isString)(value)) return decodeDataU8a(registry, (0, _util.u8aToU8a)(value));
    else if (!value) return [
        undefined,
        undefined
    ];
     // assume we have an Enum or an  object input, handle this via the normal Enum decoding
    return [
        value,
        undefined
    ];
}
class Data extends (0, _typesCodec.Enum) {
    constructor(registry, value){
        super(registry, {
            None: "Null",
            // 0
            Raw: "Bytes",
            // 1
            // eslint-disable-next-line sort-keys
            BlakeTwo256: "H256",
            // 2
            Sha256: "H256",
            // 3
            // eslint-disable-next-line sort-keys
            Keccak256: "H256",
            // 4
            ShaThree256: "H256" // 5
        }, ...decodeData(registry, value));
        if (this.isRaw && this.asRaw.length > 32) throw new Error("Data.Raw values are limited to a maximum length of 32 bytes");
    }
    get asBlakeTwo256() {
        return this.value;
    }
    get asKeccak256() {
        return this.value;
    }
    get asRaw() {
        return this.value;
    }
    get asSha256() {
        return this.value;
    }
    get asShaThree256() {
        return this.value;
    }
    get isBlakeTwo256() {
        return this.index === 2;
    }
    get isKeccak256() {
        return this.index === 4;
    }
    get isNone() {
        return this.index === 0;
    }
    get isRaw() {
        return this.index === 1;
    }
    get isSha256() {
        return this.index === 3;
    }
    get isShaThree256() {
        return this.index === 5;
    }
    /**
   * @description The encoded length
   */ get encodedLength() {
        return this.toU8a().length;
    }
    /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */ toU8a() {
        if (this.index === 0) return new Uint8Array(1);
        else if (this.index === 1) {
            // don't add the length, just the data
            const data = this.value.toU8a(true);
            const length = Math.min(data.length, 32);
            const u8a = new Uint8Array(length + 1);
            u8a.set([
                length + 1
            ], 0);
            u8a.set(data.subarray(0, length), 1);
            return u8a;
        } // otherwise we simply have a hash
        const u8a1 = new Uint8Array(33);
        u8a1.set([
            this.index + 32
        ], 0);
        u8a1.set(this.value.toU8a(), 1);
        return u8a1;
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fD5Ag":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unwrapStorageSi", ()=>unwrapStorageSi);
/** @internal */ parcelHelpers.export(exports, "unwrapStorageType", ()=>unwrapStorageType);
/**
 * @name StorageKey
 * @description
 * A representation of a storage key (typically hashed) in the system. It can be
 * constructed by passing in a raw key or a StorageEntry with (optional) arguments.
 */ parcelHelpers.export(exports, "StorageKey", ()=>StorageKey);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _indexJs = require("../metadata/util/index.js");
// hasher type -> [initialHashLength, canDecodeKey]
const HASHER_MAP = {
    // opaque
    Blake2_128: [
        16,
        false
    ],
    // eslint-disable-line camelcase
    Blake2_128Concat: [
        16,
        true
    ],
    // eslint-disable-line camelcase
    Blake2_256: [
        32,
        false
    ],
    // eslint-disable-line camelcase
    Identity: [
        0,
        true
    ],
    Twox128: [
        16,
        false
    ],
    Twox256: [
        32,
        false
    ],
    Twox64Concat: [
        8,
        true
    ]
};
function unwrapStorageSi(type) {
    return type.isPlain ? type.asPlain : type.asMap.value;
}
function unwrapStorageType(registry, type, isOptional) {
    const outputType = (0, _indexJs.getSiName)(registry.lookup, unwrapStorageSi(type));
    return isOptional ? `Option<${outputType}>` : outputType;
}
/** @internal */ function decodeStorageKey(value) {
    if ((0, _util.isU8a)(value) || !value || (0, _util.isString)(value)) // let Bytes handle these inputs
    return {
        key: value
    };
    else if (value instanceof StorageKey) return {
        key: value,
        method: value.method,
        section: value.section
    };
    else if ((0, _util.isFunction)(value)) return {
        key: value(),
        method: value.method,
        section: value.section
    };
    else if (Array.isArray(value)) {
        const [fn, args = []] = value;
        if (!(0, _util.isFunction)(fn)) throw new Error("Expected function input for key construction");
        if (fn.meta && fn.meta.type.isMap) {
            const map = fn.meta.type.asMap;
            if (!Array.isArray(args) || args.length !== map.hashers.length) throw new Error(`Expected an array of ${map.hashers.length} values as params to a Map query`);
        }
        return {
            key: fn(...args),
            method: fn.method,
            section: fn.section
        };
    }
    throw new Error(`Unable to convert input ${value} to StorageKey`);
}
/** @internal */ function decodeHashers(registry, value, hashers) {
    // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total
    let offset = 32;
    const result = new Array(hashers.length);
    for(let i = 0; i < hashers.length; i++){
        const [hasher, type] = hashers[i];
        const [hashLen, canDecode] = HASHER_MAP[hasher.type];
        const decoded = canDecode ? registry.createTypeUnsafe((0, _indexJs.getSiName)(registry.lookup, type), [
            value.subarray(offset + hashLen)
        ]) : registry.createTypeUnsafe("Raw", [
            value.subarray(offset, offset + hashLen)
        ]);
        offset += hashLen + (canDecode ? decoded.encodedLength : 0);
        result[i] = decoded;
    }
    return result;
}
/** @internal */ function decodeArgsFromMeta(registry, value, meta) {
    if (!meta || !meta.type.isMap) return [];
    const { hashers , key  } = meta.type.asMap;
    const keys = hashers.length === 1 ? [
        key
    ] : registry.lookup.getSiType(key).def.asTuple;
    return decodeHashers(registry, value, hashers.map((h, i)=>[
            h,
            keys[i]
        ]));
}
/** @internal */ function getMeta(value) {
    if (value instanceof StorageKey) return value.meta;
    else if ((0, _util.isFunction)(value)) return value.meta;
    else if (Array.isArray(value)) {
        const [fn] = value;
        return fn.meta;
    }
    return undefined;
}
/** @internal */ function getType(registry, value) {
    if (value instanceof StorageKey) return value.outputType;
    else if ((0, _util.isFunction)(value)) return unwrapStorageType(registry, value.meta.type);
    else if (Array.isArray(value)) {
        const [fn] = value;
        if (fn.meta) return unwrapStorageType(registry, fn.meta.type);
    } // If we have no type set, default to Raw
    return "Raw";
}
class StorageKey extends (0, _typesCodec.Bytes) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore This is assigned via this.decodeArgsFromMeta()
    #args;
    #meta;
    #outputType;
    #method;
    #section;
    constructor(registry, value, override = {}){
        const { key , method , section  } = decodeStorageKey(value);
        super(registry, key);
        this.#outputType = getType(registry, value); // decode the args (as applicable based on the key and the hashers, after all init)
        this.setMeta(getMeta(value), override.section || section, override.method || method);
    }
    /**
   * @description Return the decoded arguments (applicable to map with decodable values)
   */ get args() {
        return this.#args;
    }
    /**
   * @description The metadata or `undefined` when not available
   */ get meta() {
        return this.#meta;
    }
    /**
   * @description The key method or `undefined` when not specified
   */ get method() {
        return this.#method;
    }
    /**
   * @description The output type
   */ get outputType() {
        return this.#outputType;
    }
    /**
   * @description The key section or `undefined` when not specified
   */ get section() {
        return this.#section;
    }
    is(key) {
        return key.section === this.section && key.method === this.method;
    }
    /**
   * @description Sets the meta for this key
   */ setMeta(meta, section, method) {
        this.#meta = meta;
        this.#method = method || this.#method;
        this.#section = section || this.#section;
        if (meta) this.#outputType = unwrapStorageType(this.registry, meta.type);
        try {
            this.#args = decodeArgsFromMeta(this.registry, this.toU8a(true), meta);
        } catch (error) {}
        return this;
    }
    /**
   * @description Returns the Human representation for this type
   */ toHuman() {
        return this.#args.length ? this.#args.map((a)=>a.toHuman()) : super.toHuman();
    }
    /**
   * @description Returns the raw type for this
   */ toRawType() {
        return "StorageKey";
    }
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","../metadata/util/index.js":"7JXy8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7JXy8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "flattenUniq", ()=>(0, _flattenUniqJs.flattenUniq));
parcelHelpers.export(exports, "getSiName", ()=>(0, _getSiNameJs.getSiName));
parcelHelpers.export(exports, "getUniqTypes", ()=>(0, _getUniqTypesJs.getUniqTypes));
parcelHelpers.export(exports, "toCallsOnly", ()=>(0, _toCallsOnlyJs.toCallsOnly));
parcelHelpers.export(exports, "validateTypes", ()=>(0, _validateTypesJs.validateTypes));
var _flattenUniqJs = require("./flattenUniq.js");
var _getSiNameJs = require("./getSiName.js");
var _getUniqTypesJs = require("./getUniqTypes.js");
var _toCallsOnlyJs = require("./toCallsOnly.js");
var _validateTypesJs = require("./validateTypes.js");

},{"./flattenUniq.js":"jAVp2","./getSiName.js":"8BIb5","./getUniqTypes.js":"fVAqS","./toCallsOnly.js":"h2moe","./validateTypes.js":"89p8c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jAVp2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
/** @internal */ parcelHelpers.export(exports, "flattenUniq", ()=>flattenUniq);
function flattenUniq(list, result = []) {
    for(let i = 0; i < list.length; i++){
        const entry = list[i];
        if (Array.isArray(entry)) flattenUniq(entry, result);
        else result.push(entry);
    }
    return [
        ...new Set(result)
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8BIb5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "getSiName", ()=>getSiName);
function getSiName(lookup, type) {
    const typeDef = lookup.getTypeDef(type);
    return typeDef.lookupName || typeDef.type;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fVAqS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "getUniqTypes", ()=>getUniqTypes);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _flattenUniqJs = require("./flattenUniq.js");
var _validateTypesJs = require("./validateTypes.js");
/** @internal */ function extractTypes(lookup, types) {
    return types.map(({ type  })=>lookup.getTypeDef(type).type);
}
/** @internal */ function extractFieldTypes(lookup, type) {
    return lookup.getSiType(type).def.asVariant.variants.map(({ fields  })=>extractTypes(lookup, fields));
}
/** @internal */ function getPalletNames({ lookup , pallets  }) {
    return pallets.reduce((all, { calls , constants , events , storage  })=>{
        all.push([
            extractTypes(lookup, constants)
        ]);
        if (calls.isSome) all.push(extractFieldTypes(lookup, calls.unwrap().type));
        if (events.isSome) all.push(extractFieldTypes(lookup, events.unwrap().type));
        if (storage.isSome) all.push(storage.unwrap().items.map(({ type  })=>{
            if (type.isPlain) return [
                lookup.getTypeDef(type.asPlain).type
            ];
            const { hashers , key , value  } = type.asMap;
            return hashers.length === 1 ? [
                lookup.getTypeDef(value).type,
                lookup.getTypeDef(key).type
            ] : [
                lookup.getTypeDef(value).type,
                ...lookup.getSiType(key).def.asTuple.map((t)=>lookup.getTypeDef(t).type)
            ];
        }));
        return all;
    }, []);
}
function getUniqTypes(registry, meta, throwError) {
    return (0, _validateTypesJs.validateTypes)(registry, throwError, (0, _flattenUniqJs.flattenUniq)(getPalletNames(meta)));
}

},{"./flattenUniq.js":"jAVp2","./validateTypes.js":"89p8c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"89p8c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "validateTypes", ()=>validateTypes);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _extractTypesJs = require("./extractTypes.js");
var _flattenUniqJs = require("./flattenUniq.js");
const l = (0, _util.logger)("metadata");
function validateTypes(registry, throwError, types) {
    const missing = (0, _flattenUniqJs.flattenUniq)((0, _extractTypesJs.extractTypes)(types)).filter((type)=>!registry.hasType(type) && !registry.isLookupType(type)).sort();
    if (missing.length !== 0) {
        const message = `Unknown types found, no types for ${missing.join(", ")}`;
        if (throwError) throw new Error(message);
        else l.warn(message);
    }
    return types;
}

},{"@polkadot/util":"3HnHw","./extractTypes.js":"cI9p5","./flattenUniq.js":"jAVp2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cI9p5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "extractTypes", ()=>extractTypes);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCreate = require("@polkadot/types-create");
function extractSubSingle(_, { sub  }) {
    const { lookupName , type  } = sub;
    return extractTypes([
        lookupName || type
    ]);
}
function extractSubArray(_, { sub  }) {
    return extractTypes(sub.map(({ lookupName , type  })=>lookupName || type));
}
function unhandled(type, { info  }) {
    throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${(0, _typesCreate.TypeDefInfo)[info]})`);
} // we only handle the types with params here
const mapping = {
    [(0, _typesCreate.TypeDefInfo).BTreeMap]: extractSubArray,
    [(0, _typesCreate.TypeDefInfo).BTreeSet]: extractSubSingle,
    [(0, _typesCreate.TypeDefInfo).Compact]: extractSubSingle,
    [(0, _typesCreate.TypeDefInfo).DoNotConstruct]: unhandled,
    [(0, _typesCreate.TypeDefInfo).Enum]: extractSubArray,
    [(0, _typesCreate.TypeDefInfo).HashMap]: extractSubArray,
    [(0, _typesCreate.TypeDefInfo).Int]: unhandled,
    [(0, _typesCreate.TypeDefInfo).Linkage]: extractSubSingle,
    [(0, _typesCreate.TypeDefInfo).Null]: unhandled,
    [(0, _typesCreate.TypeDefInfo).Option]: extractSubSingle,
    [(0, _typesCreate.TypeDefInfo).Plain]: (_, typeDef)=>typeDef.lookupName || typeDef.type,
    [(0, _typesCreate.TypeDefInfo).Range]: extractSubSingle,
    [(0, _typesCreate.TypeDefInfo).RangeInclusive]: extractSubSingle,
    [(0, _typesCreate.TypeDefInfo).Result]: extractSubArray,
    [(0, _typesCreate.TypeDefInfo).Set]: extractSubArray,
    [(0, _typesCreate.TypeDefInfo).Si]: unhandled,
    [(0, _typesCreate.TypeDefInfo).Struct]: extractSubArray,
    [(0, _typesCreate.TypeDefInfo).Tuple]: extractSubArray,
    [(0, _typesCreate.TypeDefInfo).UInt]: unhandled,
    [(0, _typesCreate.TypeDefInfo).Vec]: extractSubSingle,
    [(0, _typesCreate.TypeDefInfo).VecFixed]: extractSubSingle,
    [(0, _typesCreate.TypeDefInfo).WrapperKeepOpaque]: extractSubSingle,
    [(0, _typesCreate.TypeDefInfo).WrapperOpaque]: extractSubSingle
};
function extractTypes(types) {
    const count = types.length;
    const result = new Array(count);
    for(let i = 0; i < count; i++){
        const type = types[i];
        const typeDef = (0, _typesCreate.getTypeDef)(type);
        result[i] = mapping[typeDef.info](type, typeDef);
    }
    return result;
}

},{"@polkadot/types-create":"cr6lO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h2moe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "toCallsOnly", ()=>toCallsOnly);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function trimDocs(docs) {
    const strings = docs.map((d)=>d.toString().trim());
    const firstEmpty = strings.findIndex((d)=>!d.length);
    return firstEmpty === -1 ? strings : strings.slice(0, firstEmpty);
}
function toCallsOnly(registry, { extrinsic , lookup , pallets  }) {
    return registry.createTypeUnsafe("MetadataLatest", [
        {
            extrinsic,
            lookup: {
                types: lookup.types.map(({ id , type  })=>registry.createTypeUnsafe("PortableType", [
                        {
                            id,
                            type: (0, _util.objectSpread)({}, type, {
                                docs: trimDocs(type.docs)
                            })
                        }
                    ]))
            },
            pallets: pallets.map(({ calls , index , name  })=>({
                    calls: registry.createTypeUnsafe("Option<PalletCallMetadataLatest>", [
                        calls.unwrapOr(null)
                    ]),
                    index,
                    name
                }))
        }
    ]).toJSON();
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ltCSZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Expands the metadata by decoration into consts, query and tx sections
 */ parcelHelpers.export(exports, "expandMetadata", ()=>expandMetadata);
parcelHelpers.export(exports, "decorateConstants", ()=>(0, _indexJs.decorateConstants));
parcelHelpers.export(exports, "decorateErrors", ()=>(0, _indexJs1.decorateErrors));
parcelHelpers.export(exports, "decorateEvents", ()=>(0, _indexJs2.decorateEvents));
parcelHelpers.export(exports, "decorateExtrinsics", ()=>(0, _indexJs3.decorateExtrinsics));
parcelHelpers.export(exports, "decorateStorage", ()=>(0, _indexJs4.decorateStorage));
parcelHelpers.export(exports, "filterCallsSome", ()=>(0, _indexJs3.filterCallsSome));
parcelHelpers.export(exports, "filterEventsSome", ()=>(0, _indexJs2.filterEventsSome));
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _metadataJs = require("../Metadata.js");
var _indexJs = require("./constants/index.js");
var _indexJs1 = require("./errors/index.js");
var _indexJs2 = require("./events/index.js");
var _indexJs3 = require("./extrinsics/index.js");
var _indexJs4 = require("./storage/index.js");
function expandMetadata(registry, metadata) {
    if (!(metadata instanceof (0, _metadataJs.Metadata))) throw new Error("You need to pass a valid Metadata instance to Decorated");
    const latest = metadata.asLatest;
    const version = metadata.version;
    return {
        consts: (0, _indexJs.decorateConstants)(registry, latest, version),
        errors: (0, _indexJs1.decorateErrors)(registry, latest, version),
        events: (0, _indexJs2.decorateEvents)(registry, latest, version),
        query: (0, _indexJs4.decorateStorage)(registry, latest, version),
        registry,
        tx: (0, _indexJs3.decorateExtrinsics)(registry, latest, version)
    };
}

},{"../Metadata.js":"cg9v9","./constants/index.js":"lKJoC","./errors/index.js":"95TsO","./events/index.js":"XE5vW","./extrinsics/index.js":"3JIyR","./storage/index.js":"e58xK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cg9v9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name Metadata
 * @description
 * The versioned runtime metadata as a decoded structure
 */ parcelHelpers.export(exports, "Metadata", ()=>Metadata);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _metadataVersionedJs = require("./MetadataVersioned.js"); // magic + lowest supported version
const EMPTY_METADATA = new Uint8Array([
    0x6d,
    0x65,
    0x74,
    0x61,
    9
]); // magic u32 preceding the version id
const VERSION_IDX = EMPTY_METADATA.length - 1;
/** @internal */ function decodeU8a(registry, u8a) {
    if (u8a.length === 0) return EMPTY_METADATA;
    else if (u8a[VERSION_IDX] === 9) // This is an f-ing hack as a follow-up to another ugly hack
    // https://github.com/polkadot-js/api/commit/a9211690be6b68ad6c6dad7852f1665cadcfa5b2
    // when we fail on V9, try to re-parse it as v10...
    try {
        return new (0, _metadataVersionedJs.MetadataVersioned)(registry, u8a);
    } catch (error) {
        u8a[VERSION_IDX] = 10;
        return u8a;
    }
    return u8a;
}
class Metadata extends (0, _metadataVersionedJs.MetadataVersioned) {
    constructor(registry, value){
        // const timeStart = performance.now()
        super(registry, (0, _util.isU8a)(value) || (0, _util.isString)(value) ? decodeU8a(registry, (0, _util.u8aToU8a)(value)) : value); // console.log('Metadata', `${(performance.now() - timeStart).toFixed(2)}ms`)
    }
}

},{"@polkadot/util":"3HnHw","./MetadataVersioned.js":"dKeZr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dKeZr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name MetadataVersioned
 * @description
 * The versioned runtime metadata as a decoded structure
 */ parcelHelpers.export(exports, "MetadataVersioned", ()=>MetadataVersioned);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _toV10Js = require("./v9/toV10.js");
var _toV11Js = require("./v10/toV11.js");
var _toV12Js = require("./v11/toV12.js");
var _toV13Js = require("./v12/toV13.js");
var _toV14Js = require("./v13/toV14.js");
var _toLatestJs = require("./v14/toLatest.js");
var _magicNumberJs = require("./MagicNumber.js");
var _indexJs = require("./util/index.js"); // Use these to generate all the Meta* types below via template keys
// NOTE: Keep from latest -> earliest, see the LATEST_VERSION 0 index
const KNOWN_VERSIONS = [
    14,
    13,
    12,
    11,
    10,
    9
];
const LATEST_VERSION = KNOWN_VERSIONS[0];
class MetadataVersioned extends (0, _typesCodec.Struct) {
    #converted = new Map();
    constructor(registry, value){
        // const timeStart = performance.now()
        super(registry, {
            magicNumber: (0, _magicNumberJs.MagicNumber),
            metadata: "MetadataAll"
        }, value); // console.log('MetadataVersioned', `${(performance.now() - timeStart).toFixed(2)}ms`)
    }
    #assertVersion = (version)=>{
        if (this.version > version) throw new Error(`Cannot convert metadata from version ${this.version} to ${version}`);
        return this.version === version;
    };
    #getVersion = (version, fromPrev)=>{
        const asCurr = `asV${version}`;
        const asPrev = version === "latest" ? `asV${LATEST_VERSION}` : `asV${version - 1}`;
        if (version !== "latest" && this.#assertVersion(version)) return this.#metadata()[asCurr];
        if (!this.#converted.has(version)) this.#converted.set(version, fromPrev(this.registry, this[asPrev], this.version));
        return this.#converted.get(version);
    };
    /**
   * @description the metadata wrapped
   */ #metadata = ()=>{
        return this.getT("metadata");
    };
    /**
   * @description Returns the wrapped metadata as a limited calls-only (latest) version
   */ get asCallsOnly() {
        return new MetadataVersioned(this.registry, {
            magicNumber: this.magicNumber,
            metadata: this.registry.createTypeUnsafe("MetadataAll", [
                (0, _indexJs.toCallsOnly)(this.registry, this.asLatest),
                LATEST_VERSION
            ])
        });
    }
    /**
   * @description Returns the wrapped metadata as a V9 object
   */ get asV9() {
        this.#assertVersion(9);
        return this.#metadata().asV9;
    }
    /**
   * @description Returns the wrapped values as a V10 object
   */ get asV10() {
        return this.#getVersion(10, (0, _toV10Js.toV10));
    }
    /**
   * @description Returns the wrapped values as a V11 object
   */ get asV11() {
        return this.#getVersion(11, (0, _toV11Js.toV11));
    }
    /**
   * @description Returns the wrapped values as a V12 object
   */ get asV12() {
        return this.#getVersion(12, (0, _toV12Js.toV12));
    }
    /**
   * @description Returns the wrapped values as a V13 object
   */ get asV13() {
        return this.#getVersion(13, (0, _toV13Js.toV13));
    }
    /**
   * @description Returns the wrapped values as a V14 object
   */ get asV14() {
        return this.#getVersion(14, (0, _toV14Js.toV14));
    }
    /**
   * @description Returns the wrapped values as a latest version object
   */ get asLatest() {
        return this.#getVersion("latest", (0, _toLatestJs.toLatest));
    }
    /**
   * @description The magicNumber for the Metadata (known constant)
   */ get magicNumber() {
        return this.getT("magicNumber");
    }
    /**
   * @description the metadata version this structure represents
   */ get version() {
        return this.#metadata().index;
    }
    getUniqTypes(throwError) {
        return (0, _indexJs.getUniqTypes)(this.registry, this.asLatest, throwError);
    }
    /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */ toJSON() {
        // HACK(y): ensure that we apply the aliases if we have not done so already, this is
        // needed to ensure we have the correct overrides (which is only applied in toLatest)
        // eslint-disable-next-line no-unused-expressions
        this.asLatest;
        return super.toJSON();
    }
}

},{"@polkadot/types-codec":"gvW09","./v9/toV10.js":"55gGO","./v10/toV11.js":"5kWFi","./v11/toV12.js":"fs0Nk","./v12/toV13.js":"kfPjj","./v13/toV14.js":"ik141","./v14/toLatest.js":"aRjDo","./MagicNumber.js":"5Ay22","./util/index.js":"7JXy8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"55gGO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "toV10", ()=>toV10);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util"); // migrate a storage hasher type
// see https://github.com/paritytech/substrate/pull/4462
/** @internal */ function createStorageHasher(registry, hasher) {
    // Blake2_128_Concat has been added at index 2, so we increment all the
    // indexes greater than 2
    if (hasher.toNumber() >= 2) return registry.createTypeUnsafe("StorageHasherV10", [
        hasher.toNumber() + 1
    ]);
    return registry.createTypeUnsafe("StorageHasherV10", [
        hasher
    ]);
}
/** @internal */ function createStorageType(registry, entryType) {
    if (entryType.isMap) return [
        (0, _util.objectSpread)({}, entryType.asMap, {
            hasher: createStorageHasher(registry, entryType.asMap.hasher)
        }),
        1
    ];
    if (entryType.isDoubleMap) return [
        (0, _util.objectSpread)({}, entryType.asDoubleMap, {
            hasher: createStorageHasher(registry, entryType.asDoubleMap.hasher),
            key2Hasher: createStorageHasher(registry, entryType.asDoubleMap.key2Hasher)
        }),
        2
    ];
    return [
        entryType.asPlain,
        0
    ];
}
/** @internal */ function convertModule(registry, mod) {
    const storage = mod.storage.unwrapOr(null);
    return registry.createTypeUnsafe("ModuleMetadataV10", [
        (0, _util.objectSpread)({}, mod, {
            storage: storage ? (0, _util.objectSpread)({}, storage, {
                items: storage.items.map((item)=>(0, _util.objectSpread)({}, item, {
                        type: registry.createTypeUnsafe("StorageEntryTypeV10", createStorageType(registry, item.type))
                    }))
            }) : null
        })
    ]);
}
function toV10(registry, { modules  }) {
    return registry.createTypeUnsafe("MetadataV10", [
        {
            modules: modules.map((mod)=>convertModule(registry, mod))
        }
    ]);
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5kWFi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
/** @internal */ parcelHelpers.export(exports, "toV11", ()=>toV11);
function toV11(registry, { modules  }) {
    return registry.createTypeUnsafe("MetadataV11", [
        {
            // This is new in V11, pass V0 here - something non-existing, telling the API to use
            // the fallback for this information (on-chain detection)
            extrinsic: {
                signedExtensions: [],
                version: 0
            },
            modules
        }
    ]);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fs0Nk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @internal
 **/ parcelHelpers.export(exports, "toV12", ()=>toV12);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function toV12(registry, { extrinsic , modules  }) {
    return registry.createTypeUnsafe("MetadataV12", [
        {
            extrinsic,
            modules: modules.map((mod)=>registry.createTypeUnsafe("ModuleMetadataV12", [
                    (0, _util.objectSpread)({}, mod, {
                        index: 255
                    })
                ]))
        }
    ]);
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kfPjj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * @internal
 **/ parcelHelpers.export(exports, "toV13", ()=>toV13);
function toV13(registry, metadata) {
    return registry.createTypeUnsafe("MetadataV13", [
        metadata
    ]);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ik141":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Convert the Metadata to v14
 * @internal
 **/ parcelHelpers.export(exports, "toV14", ()=>toV14);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _aliasJs = require("../../interfaces/alias.js");
var _definitionsJs = require("../../interfaces/runtime/definitions.js");
const BOXES = [
    [
        "<",
        ">"
    ],
    [
        "<",
        ","
    ],
    [
        ",",
        ">"
    ],
    [
        "(",
        ")"
    ],
    [
        "(",
        ","
    ],
    [
        ",",
        ","
    ],
    [
        ",",
        ")"
    ]
];
/**
 * Creates a compatible type mapping
 * @internal
 **/ function compatType(specs, _type) {
    const type = _type.toString();
    const index = specs.findIndex(({ def  })=>def.HistoricMetaCompat === type);
    if (index !== -1) return index;
    return specs.push({
        def: {
            HistoricMetaCompat: type
        }
    }) - 1;
}
function compatTypes(specs, ...types) {
    for(let i = 0; i < types.length; i++)compatType(specs, types[i]);
}
function makeTupleType(specs, entries) {
    return specs.push({
        def: {
            Tuple: entries
        }
    }) - 1;
}
function makeVariantType(modName, variantType, specs, variants) {
    return specs.push({
        def: {
            Variant: {
                variants
            }
        },
        path: [
            `pallet_${modName.toString()}`,
            "pallet",
            variantType
        ]
    }) - 1;
}
/**
 * @internal
 * generate & register the OriginCaller type
 **/ function registerOriginCaller(registry, modules, metaVersion) {
    registry.register({
        OriginCaller: {
            _enum: modules.map((mod, index)=>[
                    mod.name.toString(),
                    metaVersion >= 12 ? mod.index.toNumber() : index
                ]).sort((a, b)=>a[1] - b[1]).reduce((result, [name, index])=>{
                for(let i = Object.keys(result).length; i < index; i++)result[`Empty${i}`] = "Null";
                result[name] = (0, _definitionsJs.knownOrigins)[name] || "Null";
                return result;
            }, {})
        }
    });
}
/**
 * Find and apply the correct type override
 * @internal
 **/ function setTypeOverride(sectionTypes, types) {
    types.forEach((type)=>{
        const override = Object.keys(sectionTypes).find((aliased)=>type.eq(aliased));
        if (override) type.setOverride(sectionTypes[override]);
        else {
            // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)
            const orig = type.toString();
            const alias = Object.entries(sectionTypes).reduce((result, [src, dst])=>BOXES.reduce((result, [a, z])=>result.replace(`${a}${src}${z}`, `${a}${dst}${z}`), result), orig);
            if (orig !== alias) type.setOverride(alias);
        }
    });
}
/**
 * Apply module-specific type overrides (always be done as part of toV14)
 * @internal
 **/ function convertCalls(specs, registry, modName, calls, sectionTypes) {
    const variants = calls.map(({ args , docs , name  }, index)=>{
        setTypeOverride(sectionTypes, args.map(({ type  })=>type));
        return registry.createTypeUnsafe("SiVariant", [
            {
                docs,
                fields: args.map(({ name , type  })=>registry.createTypeUnsafe("SiField", [
                        {
                            name,
                            type: compatType(specs, type)
                        }
                    ])),
                index,
                name
            }
        ]);
    });
    return registry.createTypeUnsafe("PalletCallMetadataV14", [
        {
            type: makeVariantType(modName, "Call", specs, variants)
        }
    ]);
}
/**
 * Apply module-specific type overrides (always be done as part of toV14)
 * @internal
 */ function convertConstants(specs, registry, constants, sectionTypes) {
    return constants.map(({ docs , name , type , value  })=>{
        setTypeOverride(sectionTypes, [
            type
        ]);
        return registry.createTypeUnsafe("PalletConstantMetadataV14", [
            {
                docs,
                name,
                type: compatType(specs, type),
                value
            }
        ]);
    });
}
/**
 * Apply module-specific type overrides (always be done as part of toV14)
 * @internal
 */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
function convertErrors(specs, registry, modName, errors, _sectionTypes) {
    const variants = errors.map(({ docs , name  }, index)=>registry.createTypeUnsafe("SiVariant", [
            {
                docs,
                fields: [],
                index,
                name
            }
        ]));
    return registry.createTypeUnsafe("PalletErrorMetadataV14", [
        {
            type: makeVariantType(modName, "Error", specs, variants)
        }
    ]);
}
/**
 * Apply module-specific type overrides (always be done as part of toV14)
 * @internal
 **/ function convertEvents(specs, registry, modName, events, sectionTypes) {
    const variants = events.map(({ args , docs , name  }, index)=>{
        setTypeOverride(sectionTypes, args);
        return registry.createTypeUnsafe("SiVariant", [
            {
                docs,
                fields: args.map((t)=>registry.createTypeUnsafe("SiField", [
                        {
                            type: compatType(specs, t)
                        }
                    ])),
                index,
                name
            }
        ]);
    });
    return registry.createTypeUnsafe("PalletEventMetadataV14", [
        {
            type: makeVariantType(modName, "Event", specs, variants)
        }
    ]);
}
function createMapEntry(specs, registry, sectionTypes, { hashers , isLinked , isOptional , keys , value  }) {
    setTypeOverride(sectionTypes, [
        value,
        ...Array.isArray(keys) ? keys : [
            keys
        ]
    ]);
    return registry.createTypeUnsafe("StorageEntryTypeV14", [
        {
            Map: {
                hashers,
                key: hashers.length === 1 ? compatType(specs, keys[0]) : makeTupleType(specs, keys.map((t)=>compatType(specs, t))),
                value: isLinked // For previous-generation linked-map support, the actual storage result
                 ? compatType(specs, `(${isOptional ? `Option<${value.toString()}>` : value.toString()}, Linkage<${keys[0].toString()}>)`) : compatType(specs, value)
            }
        }
    ]);
}
/**
 * Apply module-specific storage type overrides (always part of toV14)
 * @internal
 **/ function convertStorage(specs, registry, { items , prefix  }, sectionTypes) {
    return registry.createTypeUnsafe("PalletStorageMetadataV14", [
        {
            items: items.map(({ docs , fallback , modifier , name , type  })=>{
                let entryType;
                if (type.isPlain) {
                    const plain = type.asPlain;
                    setTypeOverride(sectionTypes, [
                        plain
                    ]);
                    entryType = registry.createTypeUnsafe("StorageEntryTypeV14", [
                        {
                            Plain: compatType(specs, plain)
                        }
                    ]);
                } else if (type.isMap) {
                    const map = type.asMap;
                    entryType = createMapEntry(specs, registry, sectionTypes, {
                        hashers: [
                            map.hasher
                        ],
                        isLinked: map.linked.isTrue,
                        isOptional: modifier.isOptional,
                        keys: [
                            map.key
                        ],
                        value: map.value
                    });
                } else if (type.isDoubleMap) {
                    const dm = type.asDoubleMap;
                    entryType = createMapEntry(specs, registry, sectionTypes, {
                        hashers: [
                            dm.hasher,
                            dm.key2Hasher
                        ],
                        isLinked: false,
                        isOptional: modifier.isOptional,
                        keys: [
                            dm.key1,
                            dm.key2
                        ],
                        value: dm.value
                    });
                } else {
                    const nm = type.asNMap;
                    entryType = createMapEntry(specs, registry, sectionTypes, {
                        hashers: nm.hashers,
                        isLinked: false,
                        isOptional: modifier.isOptional,
                        keys: nm.keyVec,
                        value: nm.value
                    });
                }
                return registry.createTypeUnsafe("StorageEntryMetadataV14", [
                    {
                        docs,
                        fallback,
                        modifier,
                        name,
                        type: entryType
                    }
                ]);
            }),
            prefix
        }
    ]);
}
/** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
function convertExtrinsic(registry, { signedExtensions , version  }) {
    return registry.createTypeUnsafe("ExtrinsicMetadataV14", [
        {
            signedExtensions: signedExtensions.map((identifier)=>({
                    identifier,
                    type: 0 // we don't map the fields at all
                })),
            type: 0,
            // Map to extrinsic like in v14?
            version
        }
    ]);
}
/** @internal */ function createPallet(specs, registry, mod, { calls , constants , errors , events , storage  }) {
    const sectionTypes = (0, _aliasJs.getAliasTypes)(registry, (0, _util.stringCamelCase)(mod.name));
    return registry.createTypeUnsafe("PalletMetadataV14", [
        {
            calls: calls && convertCalls(specs, registry, mod.name, calls, sectionTypes),
            constants: convertConstants(specs, registry, constants, sectionTypes),
            errors: errors && convertErrors(specs, registry, mod.name, errors, sectionTypes),
            events: events && convertEvents(specs, registry, mod.name, events, sectionTypes),
            index: mod.index,
            name: mod.name,
            storage: storage && convertStorage(specs, registry, storage, sectionTypes)
        }
    ]);
}
function toV14(registry, v13, metaVersion) {
    const specs = []; // position 0 always has Null, additionally add internal defaults
    compatTypes(specs, "Null", "u8", "u16", "u32", "u64");
    registerOriginCaller(registry, v13.modules, metaVersion);
    const extrinsic = convertExtrinsic(registry, v13.extrinsic);
    const pallets = v13.modules.map((mod)=>createPallet(specs, registry, mod, {
            calls: mod.calls.unwrapOr(null),
            constants: mod.constants,
            errors: mod.errors.length ? mod.errors : null,
            events: mod.events.unwrapOr(null),
            storage: mod.storage.unwrapOr(null)
        }));
    return registry.createTypeUnsafe("MetadataV14", [
        {
            extrinsic,
            lookup: {
                types: specs.map((type, id)=>registry.createTypeUnsafe("PortableType", [
                        {
                            id,
                            type
                        }
                    ]))
            },
            pallets
        }
    ]);
}

},{"@polkadot/util":"3HnHw","../../interfaces/alias.js":"71fOM","../../interfaces/runtime/definitions.js":"cRjlK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"71fOM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Get types for specific modules (metadata override)
 */ parcelHelpers.export(exports, "getAliasTypes", ()=>getAliasTypes);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util"); // type overrides for modules (where duplication between modules exist)
const typesAlias = {
    assets: {
        Approval: "AssetApproval",
        ApprovalKey: "AssetApprovalKey",
        Balance: "TAssetBalance",
        DestroyWitness: "AssetDestroyWitness"
    },
    babe: {
        EquivocationProof: "BabeEquivocationProof"
    },
    balances: {
        Status: "BalanceStatus"
    },
    beefy: {
        AuthorityId: "BeefyId"
    },
    contracts: {
        StorageKey: "ContractStorageKey"
    },
    electionProviderMultiPhase: {
        Phase: "ElectionPhase"
    },
    ethereum: {
        Block: "EthBlock",
        Header: "EthHeader",
        Receipt: "EthReceipt",
        Transaction: "EthTransaction",
        TransactionStatus: "EthTransactionStatus"
    },
    evm: {
        Account: "EvmAccount",
        Log: "EvmLog",
        Vicinity: "EvmVicinity"
    },
    grandpa: {
        Equivocation: "GrandpaEquivocation",
        EquivocationProof: "GrandpaEquivocationProof"
    },
    identity: {
        Judgement: "IdentityJudgement"
    },
    inclusion: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    paraDisputes: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    paraInclusion: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    paraScheduler: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    paraShared: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    parachains: {
        Id: "ParaId"
    },
    parasDisputes: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    parasInclusion: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    parasScheduler: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    parasShared: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    proposeParachain: {
        Proposal: "ParachainProposal"
    },
    proxy: {
        Announcement: "ProxyAnnouncement"
    },
    scheduler: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    shared: {
        ValidatorIndex: "ParaValidatorIndex"
    },
    society: {
        Judgement: "SocietyJudgement",
        Vote: "SocietyVote"
    },
    staking: {
        Compact: "CompactAssignments"
    },
    treasury: {
        Proposal: "TreasuryProposal"
    },
    xcm: {
        AssetId: "XcmAssetId"
    },
    xcmPallet: {
        AssetId: "XcmAssetId"
    }
};
function getAliasTypes({ knownTypes  }, section) {
    var _knownTypes$typesAlia;
    return (0, _util.objectSpread)({}, typesAlias[section], (_knownTypes$typesAlia = knownTypes.typesAlias) === null || _knownTypes$typesAlia === void 0 ? void 0 : _knownTypes$typesAlia[section]);
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aRjDo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
/**
 * Convert the Metadata (which is an alias) to latest
 * @internal
 **/ // eslint-disable-next-line @typescript-eslint/no-unused-vars
parcelHelpers.export(exports, "toLatest", ()=>toLatest);
function toLatest(registry, v14, _metaVersion) {
    return v14;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Ay22":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAGIC_NUMBER", ()=>MAGIC_NUMBER);
parcelHelpers.export(exports, "MagicNumber", ()=>MagicNumber);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
const MAGIC_NUMBER = 0x6174656d; // `meta`, reversed for Little Endian encoding
class MagicNumber extends (0, _typesCodec.U32) {
    constructor(registry, value){
        super(registry, value);
        if (!this.isEmpty && !this.eq(MAGIC_NUMBER)) throw new Error(`MagicNumber mismatch: expected ${registry.createTypeUnsafe("u32", [
            MAGIC_NUMBER
        ]).toHex()}, found ${this.toHex()}`);
    }
}

},{"@polkadot/types-codec":"gvW09","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lKJoC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
parcelHelpers.export(exports, "decorateConstants", ()=>decorateConstants);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilJs = require("../util.js");
function decorateConstants(registry, { pallets  }, _version) {
    const result = {};
    for(let i = 0; i < pallets.length; i++){
        const { constants , name  } = pallets[i];
        if (!constants.isEmpty) (0, _util.lazyMethod)(result, (0, _util.stringCamelCase)(name), ()=>(0, _util.lazyMethods)({}, constants, (constant)=>{
                const codec = registry.createTypeUnsafe(registry.createLookupType(constant.type), [
                    (0, _util.hexToU8a)(constant.value.toHex())
                ]);
                codec.meta = constant;
                return codec;
            }, (0, _utilJs.objectNameToCamel)));
    }
    return result;
}

},{"@polkadot/util":"3HnHw","../util.js":"cN3Id","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cN3Id":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "objectNameToCamel", ()=>objectNameToCamel);
parcelHelpers.export(exports, "objectNameToString", ()=>objectNameToString);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function convert(fn) {
    return ({ name  })=>fn(name);
}
const objectNameToCamel = convert((0, _util.stringCamelCase));
const objectNameToString = convert((n)=>n.toString());

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"95TsO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "variantToMeta", ()=>variantToMeta);
/** @internal */ parcelHelpers.export(exports, "decorateErrors", ()=>decorateErrors);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _lazyJs = require("../../../create/lazy.js");
var _utilJs = require("../util.js");
function variantToMeta(lookup, variant) {
    return (0, _util.objectSpread)({
        args: variant.fields.map(({ type  })=>lookup.getTypeDef(type).type)
    }, variant);
}
function decorateErrors(registry, { lookup , pallets  }, version) {
    const result = {};
    for(let i = 0; i < pallets.length; i++){
        const { errors , index , name  } = pallets[i];
        if (errors.isSome) {
            const sectionIndex = version >= 12 ? index.toNumber() : i;
            (0, _util.lazyMethod)(result, (0, _util.stringCamelCase)(name), ()=>(0, _lazyJs.lazyVariants)(lookup, errors.unwrap(), (0, _utilJs.objectNameToString), (variant)=>({
                        // We sprinkle in isCodec & isU8a to ensure we are dealing with the correct objects
                        is: (errorMod)=>(0, _util.isCodec)(errorMod) && (0, _util.isCodec)(errorMod.index) && errorMod.index.eq(sectionIndex) && ((0, _util.isU8a)(errorMod.error) ? errorMod.error[0] === variant.index.toNumber() : (0, _util.isCodec)(errorMod.error) && errorMod.error.eq(variant.index)),
                        meta: registry.createTypeUnsafe("ErrorMetadataLatest", [
                            variantToMeta(lookup, variant)
                        ])
                    })));
        }
    }
    return result;
}

},{"@polkadot/util":"3HnHw","../../../create/lazy.js":"3F1qc","../util.js":"cN3Id","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"XE5vW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterEventsSome", ()=>filterEventsSome);
/** @internal */ parcelHelpers.export(exports, "decorateEvents", ()=>decorateEvents);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _lazyJs = require("../../../create/lazy.js");
var _indexJs = require("../errors/index.js");
var _utilJs = require("../util.js");
function filterEventsSome({ events  }) {
    return events.isSome;
}
function decorateEvents(registry, { lookup , pallets  }, version) {
    const result = {};
    const filtered = pallets.filter(filterEventsSome);
    for(let i = 0; i < filtered.length; i++){
        const { events , index , name  } = filtered[i];
        const sectionIndex = version >= 12 ? index.toNumber() : i;
        (0, _util.lazyMethod)(result, (0, _util.stringCamelCase)(name), ()=>(0, _lazyJs.lazyVariants)(lookup, events.unwrap(), (0, _utilJs.objectNameToString), (variant)=>({
                    // We sprinkle in isCodec & isU8a to ensure we are dealing with the correct objects
                    is: (eventRecord)=>(0, _util.isCodec)(eventRecord) && (0, _util.isU8a)(eventRecord.index) && sectionIndex === eventRecord.index[0] && variant.index.eq(eventRecord.index[1]),
                    meta: registry.createTypeUnsafe("EventMetadataLatest", [
                        (0, _indexJs.variantToMeta)(lookup, variant)
                    ])
                })));
    }
    return result;
}

},{"@polkadot/util":"3HnHw","../../../create/lazy.js":"3F1qc","../errors/index.js":"95TsO","../util.js":"cN3Id","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3JIyR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterCallsSome", ()=>filterCallsSome);
parcelHelpers.export(exports, "createCallFunction", ()=>createCallFunction);
/** @internal */ parcelHelpers.export(exports, "decorateExtrinsics", ()=>decorateExtrinsics);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _lazyJs = require("../../../create/lazy.js");
var _indexJs = require("../../util/index.js");
var _utilJs = require("../util.js");
var _createUncheckedJs = require("./createUnchecked.js");
function filterCallsSome({ calls  }) {
    return calls.isSome;
}
function createCallFunction(registry, lookup, variant, sectionName, sectionIndex) {
    const { fields , index  } = variant;
    const args = new Array(fields.length);
    for(let a = 0; a < fields.length; a++){
        const { name , type , typeName  } = fields[a];
        args[a] = (0, _util.objectSpread)({
            name: (0, _util.stringCamelCase)(name.unwrapOr(`param${a}`)),
            type: (0, _indexJs.getSiName)(lookup, type)
        }, typeName.isSome ? {
            typeName: typeName.unwrap()
        } : null);
    }
    return (0, _createUncheckedJs.createUnchecked)(registry, sectionName, new Uint8Array([
        sectionIndex,
        index.toNumber()
    ]), registry.createTypeUnsafe("FunctionMetadataLatest", [
        (0, _util.objectSpread)({
            args
        }, variant)
    ]));
}
function decorateExtrinsics(registry, { lookup , pallets  }, version) {
    const result = {};
    const filtered = pallets.filter(filterCallsSome);
    for(let i = 0; i < filtered.length; i++){
        const { calls , index , name  } = filtered[i];
        const sectionName = (0, _util.stringCamelCase)(name);
        const sectionIndex = version >= 12 ? index.toNumber() : i;
        (0, _util.lazyMethod)(result, sectionName, ()=>(0, _lazyJs.lazyVariants)(lookup, calls.unwrap(), (0, _utilJs.objectNameToCamel), (variant)=>createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));
    }
    return result;
}

},{"@polkadot/util":"3HnHw","../../../create/lazy.js":"3F1qc","../../util/index.js":"7JXy8","../util.js":"cN3Id","./createUnchecked.js":"6fyBo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6fyBo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "createUnchecked", ()=>createUnchecked);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function isTx(tx, callIndex) {
    return tx.callIndex[0] === callIndex[0] && tx.callIndex[1] === callIndex[1];
}
function createUnchecked(registry, section, callIndex, callMetadata) {
    const expectedArgs = callMetadata.fields;
    const funcName = (0, _util.stringCamelCase)(callMetadata.name);
    const extrinsicFn = (...args)=>{
        if (expectedArgs.length !== args.length) throw new Error(`Extrinsic ${section}.${funcName} expects ${expectedArgs.length} arguments, got ${args.length}.`);
        return registry.createTypeUnsafe("Call", [
            {
                args,
                callIndex
            },
            callMetadata
        ]);
    };
    extrinsicFn.is = (tx)=>isTx(tx, callIndex);
    extrinsicFn.callIndex = callIndex;
    extrinsicFn.meta = callMetadata;
    extrinsicFn.method = funcName;
    extrinsicFn.section = section;
    extrinsicFn.toJSON = ()=>callMetadata.toJSON();
    return extrinsicFn;
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e58xK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
parcelHelpers.export(exports, "decorateStorage", ()=>decorateStorage);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilJs = require("../util.js");
var _createFunctionJs = require("./createFunction.js");
var _getStorageJs = require("./getStorage.js");
var _utilJs1 = require("./util.js");
const VERSION_NAME = "palletVersion";
const VERSION_KEY = ":__STORAGE_VERSION__:";
const VERSION_DOCS = {
    docs: "Returns the current pallet version from storage",
    type: "u16"
};
function decorateStorage(registry, { pallets  }, _metaVersion) {
    const result = (0, _getStorageJs.getStorage)(registry);
    for(let i = 0; i < pallets.length; i++){
        const { name , storage  } = pallets[i];
        if (storage.isSome) {
            const section = (0, _util.stringCamelCase)(name);
            const { items , prefix: _prefix  } = storage.unwrap();
            const prefix = _prefix.toString();
            (0, _util.lazyMethod)(result, section, ()=>(0, _util.lazyMethods)({
                    palletVersion: (0, _utilJs1.createRuntimeFunction)({
                        method: VERSION_NAME,
                        prefix,
                        section
                    }, (0, _createFunctionJs.createKeyRaw)(registry, {
                        method: VERSION_KEY,
                        prefix: name.toString()
                    }, (0, _createFunctionJs.NO_RAW_ARGS)), VERSION_DOCS)(registry)
                }, items, (meta)=>(0, _createFunctionJs.createFunction)(registry, {
                        meta,
                        method: meta.name.toString(),
                        prefix,
                        section
                    }, {}), (0, _utilJs.objectNameToCamel)));
        }
    }
    return result;
}

},{"@polkadot/util":"3HnHw","../util.js":"cN3Id","./createFunction.js":"kmFgm","./getStorage.js":"2ecpX","./util.js":"llr42","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kmFgm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NO_RAW_ARGS", ()=>NO_RAW_ARGS);
/** @internal */ parcelHelpers.export(exports, "createKeyRawParts", ()=>createKeyRawParts);
/** @internal */ parcelHelpers.export(exports, "createKeyInspect", ()=>createKeyInspect);
/** @internal */ parcelHelpers.export(exports, "createKeyRaw", ()=>createKeyRaw);
/** @internal */ parcelHelpers.export(exports, "createFunction", ()=>createFunction);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _indexJs = require("../../util/index.js");
var _getHasherJs = require("./getHasher.js");
const NO_RAW_ARGS = {
    args: [],
    hashers: [],
    keys: []
};
/** @internal */ function assertArgs({ method , section  }, { args , keys  }) {
    if (!Array.isArray(args)) throw new Error(`Call to ${(0, _util.stringCamelCase)(section || "unknown")}.${(0, _util.stringCamelCase)(method || "unknown")} needs ${keys.length} arguments`);
    else if (args.filter(filterDefined).length !== keys.length) throw new Error(`Call to ${(0, _util.stringCamelCase)(section || "unknown")}.${(0, _util.stringCamelCase)(method || "unknown")} needs ${keys.length} arguments, found [${args.join(", ")}]`);
}
function createKeyRawParts(registry, itemFn, { args , hashers , keys  }) {
    const extra = new Array(keys.length);
    for(let i = 0; i < keys.length; i++)extra[i] = (0, _getHasherJs.getHasher)(hashers[i])(registry.createTypeUnsafe(registry.createLookupType(keys[i]), [
        args[i]
    ]).toU8a());
    return [
        [
            (0, _utilCrypto.xxhashAsU8a)(itemFn.prefix, 128),
            (0, _utilCrypto.xxhashAsU8a)(itemFn.method, 128)
        ],
        extra
    ];
}
function createKeyInspect(registry, itemFn, args) {
    assertArgs(itemFn, args);
    const { meta  } = itemFn;
    const [prefix, extra] = createKeyRawParts(registry, itemFn, args);
    let types = [];
    if (meta.type.isMap) {
        const { hashers , key  } = meta.type.asMap;
        types = hashers.length === 1 ? [
            `${hashers[0].type}(${(0, _indexJs.getSiName)(registry.lookup, key)})`
        ] : registry.lookup.getSiType(key).def.asTuple.map((k, i)=>`${hashers[i].type}(${(0, _indexJs.getSiName)(registry.lookup, k)})`);
    }
    const names = [
        "module",
        "method"
    ].concat(...args.args.map((_, i)=>types[i]));
    return {
        inner: prefix.concat(...extra).map((v, i)=>({
                name: names[i],
                outer: [
                    v
                ]
            }))
    };
}
function createKeyRaw(registry, itemFn, args) {
    const [prefix, extra] = createKeyRawParts(registry, itemFn, args);
    return (0, _util.u8aConcat)(...prefix, ...extra);
}
/** @internal */ function filterDefined(a) {
    return !(0, _util.isUndefined)(a);
}
/** @internal */ function createKey(registry, itemFn, args) {
    assertArgs(itemFn, args); // always add the length prefix (underlying it is Bytes)
    return (0, _util.compactAddLength)(createKeyRaw(registry, itemFn, args));
}
/** @internal */ function createStorageInspect(registry, itemFn, options) {
    const { meta: { type  }  } = itemFn;
    return (...args)=>{
        if (type.isPlain) return options.skipHashing ? {
            inner: [],
            name: "wellKnown",
            outer: [
                (0, _util.u8aToU8a)(options.key)
            ]
        } : createKeyInspect(registry, itemFn, NO_RAW_ARGS);
        const { hashers , key  } = type.asMap;
        return hashers.length === 1 ? createKeyInspect(registry, itemFn, {
            args,
            hashers,
            keys: [
                key
            ]
        }) : createKeyInspect(registry, itemFn, {
            args,
            hashers,
            keys: registry.lookup.getSiType(key).def.asTuple
        });
    };
}
/** @internal */ function createStorageFn(registry, itemFn, options) {
    const { meta: { type  }  } = itemFn;
    let cacheKey = null; // Can only have zero or one argument:
    //   - storage.system.account(address)
    //   - storage.timestamp.blockPeriod()
    // For higher-map queries the params are passed in as an tuple, [key1, key2]
    return (...args)=>{
        if (type.isPlain) {
            if (!cacheKey) cacheKey = options.skipHashing ? (0, _util.compactAddLength)((0, _util.u8aToU8a)(options.key)) : createKey(registry, itemFn, NO_RAW_ARGS);
            return cacheKey;
        }
        const { hashers , key  } = type.asMap;
        return hashers.length === 1 ? createKey(registry, itemFn, {
            args,
            hashers,
            keys: [
                key
            ]
        }) : createKey(registry, itemFn, {
            args,
            hashers,
            keys: registry.lookup.getSiType(key).def.asTuple
        });
    };
}
/** @internal */ function createWithMeta(registry, itemFn, options) {
    const { meta , method , prefix , section  } = itemFn;
    const storageFn = createStorageFn(registry, itemFn, options);
    storageFn.inspect = createStorageInspect(registry, itemFn, options);
    storageFn.meta = meta;
    storageFn.method = (0, _util.stringCamelCase)(method);
    storageFn.prefix = prefix;
    storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it
    // instances (e.g. collective) will not work since it is only matched on param meta
    storageFn.toJSON = ()=>(0, _util.objectSpread)({
            storage: {
                method,
                prefix,
                section
            }
        }, meta.toJSON());
    return storageFn;
}
/** @internal */ function extendHeadMeta(registry, { meta: { docs , name , type  } , section  }, { method  }, iterFn) {
    // metadata with a fallback value using the type of the key, the normal
    // meta fallback only applies to actual entry values, create one for head
    const meta = registry.createTypeUnsafe("StorageEntryMetadataLatest", [
        {
            docs,
            fallback: registry.createTypeUnsafe("Bytes", []),
            modifier: registry.createTypeUnsafe("StorageEntryModifierLatest", [
                1
            ]),
            // required
            name,
            type: registry.createTypeUnsafe("StorageEntryTypeLatest", [
                type.asMap.key,
                0
            ])
        }
    ]);
    iterFn.meta = meta;
    const fn = (...args)=>registry.createTypeUnsafe("StorageKey", [
            iterFn(...args),
            {
                method,
                section
            }
        ]);
    fn.meta = meta;
    return fn;
}
/** @internal */ function extendPrefixedMap(registry, itemFn, storageFn) {
    const { meta: { type  } , method , section  } = itemFn;
    storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args)=>{
        if (args.length && (type.isPlain || args.length > type.asMap.hashers.length)) throw new Error(`Iteration ${(0, _util.stringCamelCase)(section || "unknown")}.${(0, _util.stringCamelCase)(method || "unknown")} needs arguments to be at least one less than the full arguments, found [${args.join(", ")}]`);
        if (args.length) {
            if (type.isMap) {
                const { hashers , key  } = type.asMap;
                const keysVec = hashers.length === 1 ? [
                    key
                ] : registry.lookup.getSiType(key).def.asTuple;
                return new (0, _typesCodec.Raw)(registry, createKeyRaw(registry, itemFn, {
                    args,
                    hashers: hashers.slice(0, args.length),
                    keys: keysVec.slice(0, args.length)
                }));
            }
        }
        return new (0, _typesCodec.Raw)(registry, createKeyRaw(registry, itemFn, NO_RAW_ARGS));
    });
    return storageFn;
}
function createFunction(registry, itemFn, options) {
    const { meta: { type  }  } = itemFn;
    const storageFn = createWithMeta(registry, itemFn, options);
    if (type.isMap) extendPrefixedMap(registry, itemFn, storageFn);
    storageFn.keyPrefix = (...args)=>storageFn.iterKey && storageFn.iterKey(...args) || (0, _util.compactStripLength)(storageFn())[1];
    return storageFn;
}

},{"@polkadot/types-codec":"gvW09","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","../../util/index.js":"7JXy8","./getHasher.js":"8Z1o8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Z1o8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "getHasher", ()=>getHasher);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
const DEFAULT_FN = (data)=>(0, _utilCrypto.xxhashAsU8a)(data, 128);
const HASHERS = {
    Blake2_128: (data)=>(0, _utilCrypto.blake2AsU8a)(data, 128),
    Blake2_128Concat: (data)=>(0, _util.u8aConcat)((0, _utilCrypto.blake2AsU8a)(data, 128), (0, _util.u8aToU8a)(data)),
    Blake2_256: (data)=>(0, _utilCrypto.blake2AsU8a)(data, 256),
    Identity: (data)=>(0, _util.u8aToU8a)(data),
    Twox128: (data)=>(0, _utilCrypto.xxhashAsU8a)(data, 128),
    Twox256: (data)=>(0, _utilCrypto.xxhashAsU8a)(data, 256),
    Twox64Concat: (data)=>(0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(data, 64), (0, _util.u8aToU8a)(data))
};
function getHasher(hasher) {
    return HASHERS[hasher.type] || DEFAULT_FN;
}

},{"@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ecpX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "getStorage", ()=>getStorage);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _substrateJs = require("./substrate.js");
function getStorage(registry) {
    const storage = {};
    const entries = Object.entries((0, _substrateJs.substrate));
    for(let e = 0; e < entries.length; e++)storage[entries[e][0]] = entries[e][1](registry);
    return {
        substrate: storage
    };
}

},{"./substrate.js":"b4RiX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b4RiX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "substrate", ()=>substrate);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _utilJs = require("./util.js");
const prefix = "Substrate";
const section = "substrate";
function createSubstrateFn(method, key, meta) {
    return (0, _utilJs.createRuntimeFunction)({
        method,
        prefix,
        section
    }, key, meta);
}
const substrate = {
    changesTrieConfig: createSubstrateFn("changesTrieConfig", ":changes_trie", {
        docs: "Changes trie configuration is stored under this key.",
        type: "u32"
    }),
    childStorageKeyPrefix: createSubstrateFn("childStorageKeyPrefix", ":child_storage:", {
        docs: "Prefix of child storage keys.",
        type: "u32"
    }),
    code: createSubstrateFn("code", ":code", {
        docs: "Wasm code of the runtime.",
        type: "Bytes"
    }),
    extrinsicIndex: createSubstrateFn("extrinsicIndex", ":extrinsic_index", {
        docs: "Current extrinsic index (u32) is stored under this key.",
        type: "u32"
    }),
    heapPages: createSubstrateFn("heapPages", ":heappages", {
        docs: "Number of wasm linear memory pages required for execution of the runtime.",
        type: "u64"
    })
};

},{"./util.js":"llr42","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llr42":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "createRuntimeFunction", ()=>createRuntimeFunction);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _createFunctionJs = require("./createFunction.js");
function findSiPrimitive(registry, _prim) {
    const prim = _prim.toLowerCase();
    return registry.lookup.types.find((t)=>t.type.def.isPrimitive && t.type.def.asPrimitive.toString().toLowerCase() === prim || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim);
}
function findSiType(registry, orig) {
    let portable = findSiPrimitive(registry, orig);
    if (!portable && orig === "Bytes") {
        const u8 = findSiPrimitive(registry, "u8");
        if (u8) portable = registry.lookup.types.find((t)=>t.type.def.isSequence && t.type.def.asSequence.type.eq(u8.id) || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.eq(orig));
    }
    if (!portable) console.warn(`Unable to map ${orig} to a lookup index`);
    return portable;
} // Small helper function to factorize code on this page.
function createRuntimeFunction({ method , prefix , section  }, key, { docs , type  }) {
    return (registry)=>{
        var _findSiType;
        return (0, _createFunctionJs.createFunction)(registry, {
            meta: registry.createTypeUnsafe("StorageEntryMetadataLatest", [
                {
                    docs: registry.createTypeUnsafe("Vec<Text>", [
                        [
                            docs
                        ]
                    ]),
                    modifier: registry.createTypeUnsafe("StorageEntryModifierLatest", [
                        "Required"
                    ]),
                    name: registry.createTypeUnsafe("Text", [
                        method
                    ]),
                    toJSON: ()=>key,
                    type: registry.createTypeUnsafe("StorageEntryTypeLatest", [
                        {
                            Plain: ((_findSiType = findSiType(registry, type)) === null || _findSiType === void 0 ? void 0 : _findSiType.id) || 0
                        }
                    ])
                }
            ]),
            method,
            prefix,
            section
        }, {
            key,
            skipHashing: true
        });
    };
}

},{"./createFunction.js":"kmFgm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9hFU1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "PortableRegistry", ()=>(0, _portableRegistryJs.PortableRegistry));
parcelHelpers.export(exports, "convertSiV0toV1", ()=>(0, _toV1Js.toV1));
var _portableRegistryJs = require("./PortableRegistry.js");
var _toV1Js = require("./toV1.js");

},{"./PortableRegistry.js":"6xjva","./toV1.js":"33mtf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6xjva":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PortableRegistry", ()=>PortableRegistry);
var _classPrivateFieldLooseBase = require("@babel/runtime/helpers/esm/classPrivateFieldLooseBase");
var _classPrivateFieldLooseBaseDefault = parcelHelpers.interopDefault(_classPrivateFieldLooseBase);
var _classPrivateFieldLooseKey = require("@babel/runtime/helpers/esm/classPrivateFieldLooseKey");
var _classPrivateFieldLooseKeyDefault = parcelHelpers.interopDefault(_classPrivateFieldLooseKey);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _typesCodec = require("@polkadot/types-codec");
var _typesCreate = require("@polkadot/types-create");
var _util = require("@polkadot/util");
const l = (0, _util.logger)("PortableRegistry");
// Just a placeholder for a type.unrwapOr()
const TYPE_UNWRAP = {
    toNumber: ()=>-1
}; // Alias the primitive enum with out known values
const PRIMITIVE_ALIAS = {
    Char: "u32",
    // Rust char is 4-bytes
    Str: "Text"
}; // These are types where we have a specific decoding/encoding override + helpers
const PATHS_ALIAS = splitNamespace([
    // these are well-known types with additional encoding
    "sp_core::crypto::AccountId32",
    "sp_runtime::generic::era::Era",
    "sp_runtime::multiaddress::MultiAddress",
    "account::AccountId20",
    "polkadot_runtime_common::claims::EthereumAddress",
    // these have a specific encoding or logic, use a wildcard for {pallet, darwinia}_democracy
    "*_democracy::vote::Vote",
    "*_conviction_voting::vote::Vote",
    "*_identity::types::Data",
    "sp_core::OpaqueMetadata",
    "sp_core::OpaquePeerId",
    "sp_core::offchain::OpaqueMultiaddr",
    "primitive_types::*",
    "sp_arithmetic::per_things::*",
    "ink_env::types::*"
]); // Mappings for types that should be converted to set via BitVec
const PATHS_SET = splitNamespace([
    "pallet_identity::types::BitFlags"
]); // These are the set namespaces for BitVec definitions (the last 2 appear in types as well)
const BITVEC_NS_LSB = [
    "bitvec::order::Lsb0",
    "BitOrderLsb0"
];
const BITVEC_NS_MSB = [
    "bitvec::order::Msb0",
    "BitOrderMsb0"
];
const BITVEC_NS = [
    ...BITVEC_NS_LSB,
    ...BITVEC_NS_MSB
]; // These we never use these as top-level names, they are wrappers
const WRAPPERS = [
    "BoundedBTreeMap",
    "BoundedBTreeSet",
    "BoundedVec",
    "Box",
    "BTreeMap",
    "BTreeSet",
    "Cow",
    "Option",
    "Range",
    "RangeInclusive",
    "Result",
    "WeakBoundedVec",
    "WrapperKeepOpaque",
    "WrapperOpaque"
]; // These are reserved and/or conflicts with built-in Codec or JS definitions
const RESERVED = [
    "entries",
    "hash",
    "keys",
    "new",
    "size"
]; // Remove these from all paths at index 1
const PATH_RM_INDEX_1 = [
    "generic",
    "misc",
    "pallet",
    "traits",
    "types"
];
/** @internal */ function sanitizeDocs(docs) {
    const result = new Array(docs.length);
    for(let i = 0; i < docs.length; i++)result[i] = docs[i].toString();
    return result;
}
/** @internal */ function splitNamespace(values) {
    const result = new Array(values.length);
    for(let i = 0; i < values.length; i++)result[i] = values[i].split("::");
    return result;
}
/** @internal */ function matchParts(first, second) {
    return first.length === second.length && first.every((a, index)=>{
        const b = second[index].toString();
        if (a === "*" || a === b) return true;
        if (a.includes("*") && a.includes("_") && b.includes("_")) {
            let suba = a.split("_");
            let subb = b.split("_"); // match initial *'s to multiples if we have a match for the other
            if (suba[0] === "*") {
                const indexOf = subb.indexOf(suba[1]);
                if (indexOf !== -1) {
                    suba = suba.slice(1);
                    subb = subb.slice(indexOf);
                }
            } // check for * matches at the end, adjust accordingly
            if (suba.length === 2 && suba[1] === "*" && suba[0] === subb[0]) return true;
            return matchParts(suba, subb);
        }
        return false;
    });
} // check if the path matches the PATHS_ALIAS (with wildcards)
/** @internal */ function getAliasPath(path) {
    // TODO We need to handle ink! Balance in some way
    return path.length && PATHS_ALIAS.some((a)=>matchParts(a, path)) ? path[path.length - 1].toString() : null;
}
/** @internal */ function extractNameFlat(portable, lookupIndex, params, path, isInternal = false) {
    const count = path.length; // if we have no path or determined as a wrapper, we just skip it
    if (count === 0 || WRAPPERS.includes(path[count - 1].toString())) return null;
    const camels = new Array(count);
    const lowers = new Array(count); // initially just create arrays of the camelCase and lowercase path
    // parts - we will check these to extract the final values. While
    // we have 2 loops here, we also don't do the same operation twice
    for(let i = 0; i < count; i++){
        const c = (0, _util.stringPascalCase)(isInternal ? path[i].replace("pallet_", "") : path[i]);
        const l = c.toLowerCase();
        camels[i] = c;
        lowers[i] = l;
    }
    let name = "";
    for(let i1 = 0; i1 < count; i1++){
        const l1 = lowers[i1]; // Remove ::{generic, misc, pallet, traits, types}::
        if (i1 !== 1 || !PATH_RM_INDEX_1.includes(l1)) // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest
        // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress
        {
            if (l1 !== lowers[i1 + 1]) name += camels[i1];
        }
    } // do magic for RawOrigin lookup, e.g. pallet_collective::RawOrigin
    if (camels[1] === "RawOrigin" && count === 2 && params.length === 2 && params[1].type.isSome) {
        const instanceType = portable[params[1].type.unwrap().toNumber()];
        if (instanceType.type.path.length === 2) name = `${name}${instanceType.type.path[1].toString()}`;
    }
    return {
        lookupIndex,
        name,
        params
    };
}
/** @internal */ function extractName(portable, lookupIndex, { type: { params , path  }  }) {
    return extractNameFlat(portable, lookupIndex, params, path);
}
/** @internal */ function nextDupeMatches(name, startAt, names) {
    const result = [
        names[startAt]
    ];
    for(let i = startAt + 1; i < names.length; i++){
        const v = names[i];
        if (v.name === name) result.push(v);
    }
    return result;
}
/** @internal */ function rewriteDupes(input, rewrite) {
    const count = input.length;
    for(let i = 0; i < count; i++){
        const a = input[i];
        for(let j = i + 1; j < count; j++){
            const b = input[j]; // if the indexes are not the same and the names match, we have a dupe
            if (a.lookupIndex !== b.lookupIndex && a.name === b.name) return false;
        }
    } // add all the adjusted values to the rewite map
    for(let i1 = 0; i1 < count; i1++){
        const p = input[i1];
        rewrite[p.lookupIndex] = p.name;
    }
    return true;
}
/** @internal */ function removeDupeNames(lookup, portable, names) {
    const rewrite = {};
    return names.map((original, startAt)=>{
        const { lookupIndex , name , params  } = original;
        if (!name) // the name is empty (this is not expected, but have a failsafe)
        return null;
        else if (rewrite[lookupIndex]) // we have already rewritten this one, we can skip it
        return original;
         // those where the name is matching starting from this index
        const allSame = nextDupeMatches(name, startAt, names); // we only have one, so all ok
        if (allSame.length === 1) return original;
         // are there param differences between matching names
        const anyDiff = allSame.some((o)=>params.length !== o.params.length || params.some((p, index)=>!p.name.eq(o.params[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== o.params[index].type.unwrapOr(TYPE_UNWRAP).toNumber())); // everything matches, we can combine these
        if (!anyDiff) return original;
         // TODO We probably want to attach all the indexes with differences,
        // not just the first
        // find the first parameter that yields differences
        const paramIdx = params.findIndex(({ type  }, index)=>allSame.every(({ params  }, aIndex)=>params[index].type.isSome && (aIndex === 0 || !params[index].type.eq(type)))); // No param found that is different
        if (paramIdx === -1) return original;
         // see if using the param type helps
        const adjusted = new Array(allSame.length); // loop through all, specifically checking that index where the
        // first param yields differences
        for(let i = 0; i < allSame.length; i++){
            const { lookupIndex: lookupIndex1 , name: name1 , params: params1  } = allSame[i];
            const { def , path  } = lookup.getSiType(params1[paramIdx].type.unwrap()); // if it is not a primitive and it doesn't have a path, we really cannot
            // do anything at this point
            if (!def.isPrimitive && !path.length) return null;
            adjusted[i] = {
                lookupIndex: lookupIndex1,
                name: def.isPrimitive ? `${name1}${def.asPrimitive.toString()}` : `${name1}${path[path.length - 1].toString()}`
            };
        } // check to see if the adjusted names have no issues
        if (rewriteDupes(adjusted, rewrite)) return original;
         // TODO This is duplicated from the section just above...
        // ... we certainly need a better solution here
        //
        // Last-ditch effort to use the full type path - ugly
        // loop through all, specifically checking that index where the
        // first param yields differences
        for(let i1 = 0; i1 < allSame.length; i1++){
            const { lookupIndex: lookupIndex2 , name: name2 , params: params2  } = allSame[i1];
            const { def: def1 , path: path1  } = lookup.getSiType(params2[paramIdx].type.unwrap());
            const flat = extractNameFlat(portable, lookupIndex2, params2, path1, true);
            if (def1.isPrimitive || !flat) return null;
            adjusted[i1] = {
                lookupIndex: lookupIndex2,
                name: `${name2}${flat.name}`
            };
        } // check to see if the adjusted names have no issues
        if (rewriteDupes(adjusted, rewrite)) return original;
        return null;
    }).filter((n)=>!!n).map(({ lookupIndex , name , params  })=>({
            lookupIndex,
            name: rewrite[lookupIndex] || name,
            params
        }));
}
/** @internal */ function registerTypes(lookup, lookups, names, params) {
    // Register the types we extracted
    lookup.registry.register(lookups); // Try and extract the AccountId/Address/Signature type from UncheckedExtrinsic
    if (params.SpRuntimeUncheckedExtrinsic) {
        // Address, Call, Signature, Extra
        const [addrParam, , sigParam] = params.SpRuntimeUncheckedExtrinsic;
        const siAddress = lookup.getSiType(addrParam.type.unwrap());
        const siSignature = lookup.getSiType(sigParam.type.unwrap());
        const nsSignature = siSignature.path.join("::");
        let nsAccountId = siAddress.path.join("::");
        const isMultiAddress = nsAccountId === "sp_runtime::multiaddress::MultiAddress"; // With multiaddress, we check the first type param again
        if (isMultiAddress) {
            // AccountId, AccountIndex
            const [idParam] = siAddress.params;
            nsAccountId = lookup.getSiType(idParam.type.unwrap()).path.join("::");
        }
        lookup.registry.register({
            AccountId: [
                "sp_core::crypto::AccountId32"
            ].includes(nsAccountId) ? "AccountId32" : [
                "account::AccountId20",
                "primitive_types::H160"
            ].includes(nsAccountId) ? "AccountId20" : "AccountId32",
            // other, default to AccountId32
            Address: isMultiAddress ? "MultiAddress" : "AccountId",
            ExtrinsicSignature: [
                "sp_runtime::MultiSignature"
            ].includes(nsSignature) ? "MultiSignature" : names[sigParam.type.unwrap().toNumber()] || "MultiSignature"
        });
    }
} // this extracts aliases based on what we know the runtime config looks like in a
// Substrate chain. Specifically we want to have access to the Call and Event params
/** @internal */ function extractAliases(params, isContract) {
    const hasParams = Object.keys(params).some((k)=>!k.startsWith("Pallet"));
    const alias = {};
    if (params.SpRuntimeUncheckedExtrinsic) {
        // Address, Call, Signature, Extra
        const [, { type  }] = params.SpRuntimeUncheckedExtrinsic;
        alias[type.unwrap().toNumber()] = "Call";
    } else if (hasParams && !isContract) l.warn("Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic");
    if (params.FrameSystemEventRecord) {
        // Event, Topic
        const [{ type: type1  }] = params.FrameSystemEventRecord;
        alias[type1.unwrap().toNumber()] = "Event";
    } else if (hasParams && !isContract) l.warn("Unable to determine runtime Event type, cannot inspect frame_system::EventRecord");
    return alias;
}
/** @internal */ function extractTypeInfo(lookup, portable) {
    const nameInfo = [];
    const types = {};
    const porCount = portable.length;
    for(let i = 0; i < porCount; i++){
        const type = portable[i];
        const lookupIndex = type.id.toNumber();
        const extracted = extractName(portable, lookupIndex, portable[i]);
        if (extracted) nameInfo.push(extracted);
        types[lookupIndex] = type;
    }
    const lookups = {};
    const names = {};
    const params = {};
    const dedup = removeDupeNames(lookup, portable, nameInfo);
    const dedupCount = dedup.length;
    for(let i1 = 0; i1 < dedupCount; i1++){
        const { lookupIndex: lookupIndex1 , name , params: p  } = dedup[i1];
        names[lookupIndex1] = name;
        lookups[name] = lookup.registry.createLookupType(lookupIndex1);
        params[name] = p;
    }
    return {
        lookups,
        names,
        params,
        types
    };
}
var _alias = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("alias");
var _lookups = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("lookups");
var _names = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("names");
var _params = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("params");
var _typeDefs = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("typeDefs");
var _types = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("types");
var _createSiDef = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("createSiDef");
var _getLookupId = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("getLookupId");
var _extract = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extract");
var _extractArray = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractArray");
var _extractBitSequence = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractBitSequence");
var _extractCompact = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractCompact");
var _extractComposite = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractComposite");
var _extractCompositeSet = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractCompositeSet");
var _extractFields = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractFields");
var _extractFieldsAlias = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractFieldsAlias");
var _extractHistoric = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractHistoric");
var _extractPrimitive = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractPrimitive");
var _extractAliasPath = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractAliasPath");
var _extractSequence = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractSequence");
var _extractTuple = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractTuple");
var _extractVariant = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractVariant");
var _extractVariantEnum = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("extractVariantEnum");
class PortableRegistry extends (0, _typesCodec.Struct) {
    constructor(registry, value, isContract){
        // const timeStart = performance.now()
        super(registry, {
            types: "Vec<PortableType>"
        }, value);
        Object.defineProperty(this, _extractVariantEnum, {
            value: _extractVariantEnum2
        });
        Object.defineProperty(this, _extractVariant, {
            value: _extractVariant2
        });
        Object.defineProperty(this, _extractTuple, {
            value: _extractTuple2
        });
        Object.defineProperty(this, _extractSequence, {
            value: _extractSequence2
        });
        Object.defineProperty(this, _extractAliasPath, {
            value: _extractAliasPath2
        });
        Object.defineProperty(this, _extractPrimitive, {
            value: _extractPrimitive2
        });
        Object.defineProperty(this, _extractHistoric, {
            value: _extractHistoric2
        });
        Object.defineProperty(this, _extractFieldsAlias, {
            value: _extractFieldsAlias2
        });
        Object.defineProperty(this, _extractFields, {
            value: _extractFields2
        });
        Object.defineProperty(this, _extractCompositeSet, {
            value: _extractCompositeSet2
        });
        Object.defineProperty(this, _extractComposite, {
            value: _extractComposite2
        });
        Object.defineProperty(this, _extractCompact, {
            value: _extractCompact2
        });
        Object.defineProperty(this, _extractBitSequence, {
            value: _extractBitSequence2
        });
        Object.defineProperty(this, _extractArray, {
            value: _extractArray2
        });
        Object.defineProperty(this, _extract, {
            value: _extract2
        });
        Object.defineProperty(this, _getLookupId, {
            value: _getLookupId2
        });
        Object.defineProperty(this, _createSiDef, {
            value: _createSiDef2
        });
        Object.defineProperty(this, _alias, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _lookups, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _names, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _params, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _typeDefs, {
            writable: true,
            value: {}
        });
        Object.defineProperty(this, _types, {
            writable: true,
            value: void 0
        });
        const { lookups , names , params: _params2 , types  } = extractTypeInfo(this, this.types);
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _alias)[_alias] = extractAliases(_params2, isContract);
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _lookups)[_lookups] = lookups;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names] = names;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _params)[_params] = _params2;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _types)[_types] = types; // console.log('PortableRegistry', `${(performance.now() - timeStart).toFixed(2)}ms`)
    }
    get names() {
        return Object.values((0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names]).sort();
    }
    /**
   * @description The types of the registry
   */ get types() {
        return this.getT("types");
    }
    register() {
        registerTypes(this, (0, _classPrivateFieldLooseBaseDefault.default)(this, _lookups)[_lookups], (0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names], (0, _classPrivateFieldLooseBaseDefault.default)(this, _params)[_params]);
    }
    /**
   * @description Returns the name for a specific lookup
   */ getName(lookupId) {
        return (0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names][(0, _classPrivateFieldLooseBaseDefault.default)(this, _getLookupId)[_getLookupId](lookupId)];
    }
    /**
   * @description Finds a specific type in the registry
   */ getSiType(lookupId) {
        // NOTE catch-22 - this may already be used as part of the constructor, so
        // ensure that we have actually initialized it correctly
        const found = ((0, _classPrivateFieldLooseBaseDefault.default)(this, _types)[_types] || this.types)[(0, _classPrivateFieldLooseBaseDefault.default)(this, _getLookupId)[_getLookupId](lookupId)];
        if (!found) throw new Error(`PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);
        return found.type;
    }
    /**
   * @description Lookup the type definition for the index
   */ getTypeDef(lookupId) {
        const lookupIndex = (0, _classPrivateFieldLooseBaseDefault.default)(this, _getLookupId)[_getLookupId](lookupId);
        if (!(0, _classPrivateFieldLooseBaseDefault.default)(this, _typeDefs)[_typeDefs][lookupIndex]) {
            const lookupName = (0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names][lookupIndex];
            const empty = {
                info: (0, _typesCreate.TypeDefInfo).DoNotConstruct,
                lookupIndex,
                lookupName,
                type: this.registry.createLookupType(lookupIndex)
            }; // Set named items since we will get into circular lookups along the way
            if (lookupName) (0, _classPrivateFieldLooseBaseDefault.default)(this, _typeDefs)[_typeDefs][lookupIndex] = empty;
            const extracted = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex); // For non-named items, we only set this right at the end
            if (!lookupName) (0, _classPrivateFieldLooseBaseDefault.default)(this, _typeDefs)[_typeDefs][lookupIndex] = empty;
            Object.keys(extracted).forEach((k)=>{
                if (k !== "lookupName" || extracted[k]) // these are safe since we are looking through the keys as set
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];
            }); // don't set lookupName on lower-level, we want to always direct to the type
            if (extracted.info === (0, _typesCreate.TypeDefInfo).Plain) {
                (0, _classPrivateFieldLooseBaseDefault.default)(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = (0, _classPrivateFieldLooseBaseDefault.default)(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;
                delete (0, _classPrivateFieldLooseBaseDefault.default)(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;
            }
        }
        return (0, _classPrivateFieldLooseBaseDefault.default)(this, _typeDefs)[_typeDefs][lookupIndex];
    }
    sanitizeField(name) {
        let nameField = null;
        let nameOrig = null;
        if (name.isSome) {
            nameField = (0, _util.stringCamelCase)(name.unwrap());
            if (nameField.includes("#")) {
                nameOrig = nameField;
                nameField = nameOrig.replace(/#/g, "_");
            } else if (RESERVED.includes(nameField)) {
                nameOrig = nameField;
                nameField = `${nameField}_`;
            }
        }
        return [
            nameField,
            nameOrig
        ];
    }
}
function _createSiDef2(lookupId) {
    const typeDef = this.getTypeDef(lookupId);
    const lookupIndex = lookupId.toNumber(); // Setup for a lookup on complex types
    return [
        (0, _typesCreate.TypeDefInfo).DoNotConstruct,
        (0, _typesCreate.TypeDefInfo).Enum,
        (0, _typesCreate.TypeDefInfo).Struct
    ].includes(typeDef.info) && typeDef.lookupName ? {
        docs: typeDef.docs,
        info: (0, _typesCreate.TypeDefInfo).Si,
        lookupIndex,
        lookupName: (0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names][lookupIndex],
        type: this.registry.createLookupType(lookupId)
    } : typeDef;
}
function _getLookupId2(lookupId) {
    if ((0, _util.isString)(lookupId)) {
        if (!this.registry.isLookupType(lookupId)) throw new Error(`PortableRegistry: Expected a lookup string type, found ${lookupId}`);
        return parseInt(lookupId.replace("Lookup", ""), 10);
    } else if ((0, _util.isNumber)(lookupId)) return lookupId;
    return lookupId.toNumber();
}
function _extract2(type, lookupIndex) {
    const namespace = type.path.join("::");
    let typeDef;
    const aliasType = (0, _classPrivateFieldLooseBaseDefault.default)(this, _alias)[_alias][lookupIndex] || getAliasPath(type.path);
    try {
        if (aliasType) typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractAliasPath)[_extractAliasPath](lookupIndex, aliasType);
        else switch(type.def.type){
            case "Array":
                typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);
                break;
            case "BitSequence":
                typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);
                break;
            case "Compact":
                typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);
                break;
            case "Composite":
                typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);
                break;
            case "HistoricMetaCompat":
                typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);
                break;
            case "Primitive":
                typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);
                break;
            case "Sequence":
                typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);
                break;
            case "Tuple":
                typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);
                break;
            case "Variant":
                typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);
                break;
            default:
                (0, _util.assertUnreachable)(type.def.type);
        }
    } catch (error) {
        throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ""}: Error extracting ${(0, _util.stringify)(type)}: ${error.message}`);
    }
    return (0, _util.objectSpread)({
        docs: sanitizeDocs(type.docs),
        namespace
    }, typeDef);
}
function _extractArray2(_, { len , type  }) {
    const length = len.toNumber();
    if (length > 2048) throw new Error("Only support for [Type; <length>], where length <= 2048");
    return (0, _typesCreate.withTypeString)(this.registry, {
        info: (0, _typesCreate.TypeDefInfo).VecFixed,
        length,
        sub: (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](type)
    });
}
function _extractBitSequence2(_, { bitOrderType , bitStoreType  }) {
    // With the v3 of scale-info this swapped around, but obviously the decoder cannot determine
    // the order. With that in-mind, we apply a detection for LSb0/Msb and set accordingly
    const a = (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](bitOrderType);
    const b = (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](bitStoreType);
    const [bitOrder, bitStore] = BITVEC_NS.includes(a.namespace || "") ? [
        a,
        b
    ] : [
        b,
        a
    ]; // NOTE: Currently the BitVec type is one-way only, i.e. we only use it to decode, not
    // re-encode stuff. As such we ignore the msb/lsb identifier given by bitOrderType, or rather
    // we don't pass it though at all (all displays in LSB)
    if (!BITVEC_NS.includes(bitOrder.namespace || "")) throw new Error(`Unexpected bitOrder found as ${bitOrder.namespace || "<unknown>"}`);
    else if (bitStore.info !== (0, _typesCreate.TypeDefInfo).Plain || bitStore.type !== "u8") throw new Error(`Only u8 bitStore is currently supported, found ${bitStore.type}`);
    return {
        info: (0, _typesCreate.TypeDefInfo).Plain,
        type: "BitVec"
    };
}
function _extractCompact2(_, { type  }) {
    return (0, _typesCreate.withTypeString)(this.registry, {
        info: (0, _typesCreate.TypeDefInfo).Compact,
        sub: (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](type)
    });
}
function _extractComposite2(lookupIndex, { params , path  }, { fields  }) {
    const pathFirst = path[0].toString();
    const pathLast = path[path.length - 1].toString();
    if (path.length === 1 && pathFirst === "BTreeMap") return (0, _typesCreate.withTypeString)(this.registry, {
        info: (0, _typesCreate.TypeDefInfo).BTreeMap,
        sub: params.map(({ type  })=>(0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](type.unwrap()))
    });
    else if (path.length === 1 && pathFirst === "BTreeSet") return (0, _typesCreate.withTypeString)(this.registry, {
        info: (0, _typesCreate.TypeDefInfo).BTreeSet,
        sub: (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](params[0].type.unwrap())
    });
    else if ([
        "Range",
        "RangeInclusive"
    ].includes(pathFirst)) return (0, _typesCreate.withTypeString)(this.registry, {
        info: pathFirst === "Range" ? (0, _typesCreate.TypeDefInfo).Range : (0, _typesCreate.TypeDefInfo).RangeInclusive,
        sub: (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](params[0].type.unwrap()),
        type: pathFirst
    });
    else if ([
        "WrapperKeepOpaque",
        "WrapperOpaque"
    ].includes(pathLast)) return (0, _typesCreate.withTypeString)(this.registry, {
        info: pathLast === "WrapperKeepOpaque" ? (0, _typesCreate.TypeDefInfo).WrapperKeepOpaque : (0, _typesCreate.TypeDefInfo).WrapperOpaque,
        sub: (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](params[0].type.unwrap()),
        type: pathLast
    });
    return PATHS_SET.some((p)=>matchParts(p, path)) ? (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractFields)[_extractFields](lookupIndex, fields);
}
function _extractCompositeSet2(_, params, fields) {
    if (params.length !== 1 || fields.length !== 1) throw new Error("Set handling expects param/field as single entries");
    return (0, _typesCreate.withTypeString)(this.registry, {
        info: (0, _typesCreate.TypeDefInfo).Set,
        length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),
        sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({ index , name  })=>({
                // This will be an issue > 2^53 - 1 ... don't have those (yet)
                index: index.toNumber(),
                info: (0, _typesCreate.TypeDefInfo).Plain,
                name: name.toString(),
                type: "Null"
            }))
    });
}
function _extractFields2(lookupIndex, fields) {
    let isStruct = true;
    let isTuple = true;
    for(let f = 0; f < fields.length; f++){
        const { name  } = fields[f];
        isStruct = isStruct && name.isSome;
        isTuple = isTuple && name.isNone;
    }
    if (!isTuple && !isStruct) throw new Error("Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)");
    if (fields.length === 0) return {
        info: (0, _typesCreate.TypeDefInfo).Null,
        type: "Null"
    };
    else if (isTuple && fields.length === 1) {
        const typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](fields[0].type);
        return (0, _util.objectSpread)({}, typeDef, lookupIndex === -1 ? null : {
            lookupIndex,
            lookupName: (0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names][lookupIndex],
            lookupNameRoot: typeDef.lookupName
        }, fields[0].typeName.isSome ? {
            typeName: (0, _typesCodec.sanitize)(fields[0].typeName.unwrap())
        } : null);
    }
    const [sub, alias] = (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractFieldsAlias)[_extractFieldsAlias](fields);
    return (0, _typesCreate.withTypeString)(this.registry, (0, _util.objectSpread)({
        info: isTuple // Tuple check first
         ? (0, _typesCreate.TypeDefInfo).Tuple : (0, _typesCreate.TypeDefInfo).Struct,
        sub
    }, alias.size ? {
        alias
    } : null, lookupIndex === -1 ? null : {
        lookupIndex,
        lookupName: (0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names][lookupIndex]
    }));
}
function _extractFieldsAlias2(fields) {
    const alias = new Map();
    const sub = new Array(fields.length);
    for(let i = 0; i < fields.length; i++){
        const { docs , name , type , typeName  } = fields[i];
        const typeDef = (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](type);
        if (name.isNone) sub[i] = typeDef;
        else {
            const [nameField, nameOrig] = this.sanitizeField(name);
            if (nameField && nameOrig) alias.set(nameField, nameOrig);
            sub[i] = (0, _util.objectSpread)({
                docs: sanitizeDocs(docs),
                name: nameField
            }, typeDef, typeName.isSome ? {
                typeName: (0, _typesCodec.sanitize)(typeName.unwrap())
            } : null);
        }
    }
    return [
        sub,
        alias
    ];
}
function _extractHistoric2(_, type) {
    return (0, _util.objectSpread)({
        displayName: type.toString(),
        isFromSi: true
    }, (0, _typesCreate.getTypeDef)(type));
}
function _extractPrimitive2(_, type) {
    const typeStr = type.def.asPrimitive.type.toString();
    return {
        info: (0, _typesCreate.TypeDefInfo).Plain,
        type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()
    };
}
function _extractAliasPath2(_, type) {
    return {
        info: (0, _typesCreate.TypeDefInfo).Plain,
        type
    };
}
function _extractSequence2(lookupIndex, { type  }) {
    const sub = (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](type);
    if (sub.type === "u8") return {
        info: (0, _typesCreate.TypeDefInfo).Plain,
        type: "Bytes"
    };
    return (0, _typesCreate.withTypeString)(this.registry, {
        info: (0, _typesCreate.TypeDefInfo).Vec,
        lookupIndex,
        lookupName: (0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names][lookupIndex],
        sub
    });
}
function _extractTuple2(lookupIndex, ids) {
    if (ids.length === 0) return {
        info: (0, _typesCreate.TypeDefInfo).Null,
        type: "Null"
    };
    else if (ids.length === 1) return this.getTypeDef(ids[0]);
    const sub = ids.map((t)=>(0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](t));
    return (0, _typesCreate.withTypeString)(this.registry, {
        info: (0, _typesCreate.TypeDefInfo).Tuple,
        lookupIndex,
        lookupName: (0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names][lookupIndex],
        sub
    });
}
function _extractVariant2(lookupIndex, { params , path  }, { variants  }) {
    const specialVariant = path[0].toString();
    if (specialVariant === "Option") {
        const sub = (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](params[0].type.unwrap()); // NOTE This is opt-in (unhandled), not by default
        // if (sub.type === 'bool') {
        //   return withTypeString(this.registry, {
        //     info: TypeDefInfo.Plain,
        //     type: 'OptionBool'
        //   });
        // }
        return (0, _typesCreate.withTypeString)(this.registry, {
            info: (0, _typesCreate.TypeDefInfo).Option,
            sub
        });
    } else if (specialVariant === "Result") return (0, _typesCreate.withTypeString)(this.registry, {
        info: (0, _typesCreate.TypeDefInfo).Result,
        sub: params.map(({ type  }, index)=>(0, _util.objectSpread)({
                name: [
                    "Ok",
                    "Error"
                ][index]
            }, (0, _classPrivateFieldLooseBaseDefault.default)(this, _createSiDef)[_createSiDef](type.unwrap())))
    });
    else if (variants.length === 0) return {
        info: (0, _typesCreate.TypeDefInfo).Null,
        type: "Null"
    };
    return (0, _classPrivateFieldLooseBaseDefault.default)(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);
}
function _extractVariantEnum2(lookupIndex, variants) {
    const sub = []; // we may get entries out of order, arrange them first before creating with gaps filled
    // NOTE: Since we mutate, use a copy of the array as an input
    variants.slice().sort((a, b)=>a.index.cmp(b.index)).forEach(({ fields , index: bnIndex , name  })=>{
        const index = bnIndex.toNumber();
        while(sub.length !== index)sub.push({
            index: sub.length,
            info: (0, _typesCreate.TypeDefInfo).Null,
            name: `__Unused${sub.length}`,
            type: "Null"
        });
        sub.push((0, _util.objectSpread)((0, _classPrivateFieldLooseBaseDefault.default)(this, _extractFields)[_extractFields](-1, fields), {
            index,
            name: name.toString()
        }));
    });
    return (0, _typesCreate.withTypeString)(this.registry, {
        info: (0, _typesCreate.TypeDefInfo).Enum,
        lookupIndex,
        lookupName: (0, _classPrivateFieldLooseBaseDefault.default)(this, _names)[_names][lookupIndex],
        sub
    });
}

},{"@babel/runtime/helpers/esm/classPrivateFieldLooseBase":"gHEjb","@babel/runtime/helpers/esm/classPrivateFieldLooseKey":"90V54","@polkadot/types-codec":"gvW09","@polkadot/types-create":"cr6lO","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"33mtf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toV1", ()=>toV1);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function convertType(key) {
    return (registry, { type  })=>registry.createType("Si1TypeDef", {
            [key]: {
                type: type.toNumber()
            }
        });
}
function convertArray(registry, { len , type  }) {
    return registry.createType("Si1TypeDef", {
        Array: {
            len,
            type: type.toNumber()
        }
    });
}
function convertBitSequence(registry, { bitOrderType , bitStoreType  }) {
    return registry.createType("Si1TypeDef", {
        BitSequence: {
            bitOrderType: bitOrderType.toNumber(),
            bitStoreType: bitStoreType.toNumber()
        }
    });
}
const convertCompact = convertType("Compact");
function convertComposite(registry, { fields  }) {
    return registry.createType("Si1TypeDef", {
        Composite: {
            fields: convertFields(registry, fields)
        }
    });
}
function convertFields(registry, fields) {
    return fields.map(({ docs , name , type , typeName  })=>registry.createType("Si1Field", {
            docs,
            name,
            type: type.toNumber(),
            typeName
        }));
}
function convertPhantom(registry, path) {
    console.warn(`Converting phantom type ${path.map((p)=>p.toString()).join("::")} to empty tuple`);
    return registry.createType("Si1TypeDef", {
        Tuple: []
    });
}
function convertPrimitive(registry, prim) {
    return registry.createType("Si1TypeDef", {
        Primitive: prim.toString()
    });
}
const convertSequence = convertType("Sequence");
function convertTuple(registry, types) {
    return registry.createType("Si1TypeDef", {
        Tuple: types.map((t)=>t.toNumber())
    });
}
function convertVariant(registry, { variants  }) {
    return registry.createType("Si1TypeDef", {
        Variant: {
            variants: variants.map(({ discriminant , docs , fields , name  }, index)=>registry.createType("Si1Variant", {
                    docs,
                    fields: convertFields(registry, fields),
                    index: discriminant.isSome ? discriminant.unwrap().toNumber() : index,
                    name
                }))
        }
    });
}
function convertDef(registry, { def , path  }) {
    let result;
    switch(def.type){
        case "Array":
            result = convertArray(registry, def.asArray);
            break;
        case "BitSequence":
            result = convertBitSequence(registry, def.asBitSequence);
            break;
        case "Compact":
            result = convertCompact(registry, def.asCompact);
            break;
        case "Composite":
            result = convertComposite(registry, def.asComposite);
            break;
        case "Phantom":
            result = convertPhantom(registry, path);
            break;
        case "Primitive":
            result = convertPrimitive(registry, def.asPrimitive);
            break;
        case "Sequence":
            result = convertSequence(registry, def.asSequence);
            break;
        case "Tuple":
            result = convertTuple(registry, def.asTuple);
            break;
        case "Variant":
            result = convertVariant(registry, def.asVariant);
            break;
        default:
            (0, _util.assertUnreachable)(def.type);
    }
    return result;
}
function toV1(registry, types) {
    return types.map((t, index)=>registry.createType("PortableType", {
            // offsets are +1 from v0
            id: index + 1,
            type: {
                def: convertDef(registry, t),
                docs: [],
                params: t.params.map((p)=>registry.createType("Si1TypeParameter", {
                        type: p.toNumber()
                    })),
                path: t.path.map((p)=>p.toString())
            }
        }));
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5EZrK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "Metadata", ()=>(0, _metadataJs.Metadata));
parcelHelpers.export(exports, "PortableRegistry", ()=>(0, _indexJs.PortableRegistry));
parcelHelpers.export(exports, "decorateConstants", ()=>(0, _indexJs1.decorateConstants));
parcelHelpers.export(exports, "decorateExtrinsics", ()=>(0, _indexJs1.decorateExtrinsics));
parcelHelpers.export(exports, "decorateStorage", ()=>(0, _indexJs1.decorateStorage));
parcelHelpers.export(exports, "expandMetadata", ()=>(0, _indexJs1.expandMetadata));
var _metadataJs = require("./Metadata.js");
var _indexJs = require("./PortableRegistry/index.js");
var _indexJs1 = require("./decorate/index.js");

},{"./Metadata.js":"cg9v9","./PortableRegistry/index.js":"9hFU1","./decorate/index.js":"ltCSZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6dxRh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _drrJs = require("./drr.js");
parcelHelpers.exportAll(_drrJs, exports);
var _memoJs = require("./memo.js");
parcelHelpers.exportAll(_memoJs, exports);
var _refCountDelayJs = require("./refCountDelay.js");
parcelHelpers.exportAll(_refCountDelayJs, exports);

},{"./drr.js":"3LQQU","./memo.js":"1yKax","./refCountDelay.js":"5KeYw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3LQQU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drr", ()=>drr);
// Copyright 2017-2022 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _refCountDelayJs = require("./refCountDelay.js");
const l = (0, _util.logger)("drr");
const CMP = (a, b)=>(0, _util.stringify)({
        t: a
    }) === (0, _util.stringify)({
        t: b
    });
const ERR = (error)=>{
    l.error(error.message);
    throw error;
};
const NOOP = ()=>undefined;
const drr = ({ delay , skipChange =false , skipTimeout =false  } = {})=>(source$)=>source$.pipe((0, _rxjs.catchError)(ERR), skipChange ? (0, _rxjs.tap)(NOOP) : (0, _rxjs.distinctUntilChanged)(CMP), (0, _rxjs.publishReplay)(1), skipTimeout ? (0, _rxjs.refCount)() : (0, _refCountDelayJs.refCountDelay)(delay));

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","./refCountDelay.js":"5KeYw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5KeYw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "refCountDelay", ()=>refCountDelay);
// Copyright 2017-2022 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
function refCountDelay(delay = 1750) {
    return (source)=>{
        // state: 0 = disconnected, 1 = disconnecting, 2 = connecting, 3 = connected
        let [state, refCount, connection, scheduler] = [
            0,
            0,
            (0, _rxjs.Subscription).EMPTY,
            (0, _rxjs.Subscription).EMPTY
        ];
        return new (0, _rxjs.Observable)((ob)=>{
            source.subscribe(ob);
            if ((refCount++) === 0) {
                if (state === 1) scheduler.unsubscribe();
                else connection = source.connect();
                state = 3;
            }
            return ()=>{
                if (--refCount === 0) {
                    if (state === 2) {
                        state = 0;
                        scheduler.unsubscribe();
                    } else {
                        // state === 3
                        state = 1;
                        scheduler = (0, _rxjs.asapScheduler).schedule(()=>{
                            state = 0;
                            connection.unsubscribe();
                        }, delay);
                    }
                }
            };
        });
    };
}

},{"rxjs":"lLy7s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1yKax":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Wraps a derive, doing 2 things to optimize calls -
//   1. creates a memo of the inner fn -> Observable, removing when unsubscribed
//   2. wraps the observable in a drr() (which includes an unsub delay)
/** @internal */ // eslint-disable-next-line @typescript-eslint/ban-types
parcelHelpers.export(exports, "memo", ()=>memo);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _drrJs = require("./drr.js");
function memo(instanceId, inner) {
    const options = {
        getInstanceId: ()=>instanceId
    };
    const cached = (0, _util.memoize)((...params)=>new (0, _rxjs.Observable)((observer)=>{
            const subscription = inner(...params).subscribe(observer);
            return ()=>{
                cached.unmemoize(...params);
                subscription.unsubscribe();
            };
        }).pipe((0, _drrJs.drr)()), options);
    return cached;
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","./drr.js":"3LQQU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3AZuH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
/** @internal */ parcelHelpers.export(exports, "approvalFlagsToBools", ()=>approvalFlagsToBools);
function approvalFlagsToBools(flags) {
    const bools = [];
    for(let i = 0; i < flags.length; i++){
        const str = flags[i].toString(2); // read from lowest bit to highest
        for (const bit of str.split("").reverse())bools.push(!!parseInt(bit, 10));
    } // slice off trailing "false" values, as in substrate
    const lastApproval = bools.lastIndexOf(true);
    return lastApproval >= 0 ? bools.slice(0, lastApproval + 1) : [];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"40yRm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unwrapBlockNumber", ()=>unwrapBlockNumber);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function unwrapBlockNumber(hdr) {
    return (0, _util.isCompact)(hdr.number) ? hdr.number.unwrap() : hdr.number;
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"71fW9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setDeriveCache", ()=>setDeriveCache);
parcelHelpers.export(exports, "deriveCache", ()=>deriveCache);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _cacheImplJs = require("./cacheImpl.js");
const CHACHE_EXPIRY = 604800000;
let deriveCache;
function wrapCache(keyStart, cache) {
    return {
        del: (partial)=>cache.del(`${keyStart}${partial}`),
        forEach: cache.forEach,
        get: (partial)=>{
            const key = `${keyStart}${partial}`;
            const cached = cache.get(key);
            if (cached) {
                cached.x = Date.now();
                cache.set(key, cached);
                return cached.v;
            }
            return undefined;
        },
        set: (partial, v)=>{
            cache.set(`${keyStart}${partial}`, {
                v,
                x: Date.now()
            });
        }
    };
}
function clearCache(cache) {
    // clear all expired values
    const now = Date.now();
    const all = [];
    cache.forEach((key, { x  })=>{
        now - x > CHACHE_EXPIRY && all.push(key);
    }); // don't do delete inside loop, just in-case
    all.forEach((key)=>cache.del(key));
}
function setDeriveCache(prefix = "", cache) {
    deriveCache = cache ? wrapCache(`derive:${prefix}:`, cache) : (0, _cacheImplJs.deriveNoopCache);
    if (cache) clearCache(cache);
}
setDeriveCache();

},{"./cacheImpl.js":"8ec7w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8ec7w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "deriveMapCache", ()=>deriveMapCache);
parcelHelpers.export(exports, "deriveNoopCache", ()=>deriveNoopCache);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const mapCache = new Map();
const deriveMapCache = {
    del: (key)=>{
        mapCache.delete(key);
    },
    forEach: (cb)=>{
        for (const [k, v] of mapCache.entries())cb(k, v);
    },
    get: (key)=>{
        return mapCache.get(key);
    },
    set: (key, value)=>{
        mapCache.set(key, value);
    }
};
const deriveNoopCache = {
    del: ()=>undefined,
    forEach: ()=>undefined,
    get: ()=>undefined,
    set: (_, value)=>value
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"xmW8w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "firstObservable", ()=>firstObservable);
parcelHelpers.export(exports, "firstMemo", ()=>firstMemo);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _rpcCore = require("@polkadot/rpc-core");
function firstObservable(obs) {
    return obs.pipe((0, _rxjs.map)(([a])=>a));
}
function firstMemo(fn) {
    return (instanceId, api)=>(0, _rpcCore.memo)(instanceId, (...args)=>firstObservable(fn(api, ...args)));
}

},{"rxjs":"lLy7s","@polkadot/rpc-core":"8DbiP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jmKEw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lazyDeriveSection", ()=>lazyDeriveSection);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function lazyDeriveSection(result, section, getKeys, creator) {
    (0, _util.lazyMethod)(result, section, ()=>(0, _util.lazyMethods)({}, getKeys(section), (method)=>creator(section, method)));
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CqbO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_flags", ()=>_flags);
/**
 * @name info
 * @description Returns account membership flags
 */ parcelHelpers.export(exports, "flags", ()=>flags);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function parseFlags(address, [electionsMembers, councilMembers, technicalCommitteeMembers, societyMembers, sudoKey]) {
    const addrStr = address && address.toString();
    const isIncluded = (id)=>id.toString() === addrStr;
    return {
        isCouncil: ((electionsMembers === null || electionsMembers === void 0 ? void 0 : electionsMembers.map((r)=>Array.isArray(r) ? r[0] : r.who)) || councilMembers || []).some(isIncluded),
        isSociety: (societyMembers || []).some(isIncluded),
        isSudo: (sudoKey === null || sudoKey === void 0 ? void 0 : sudoKey.toString()) === addrStr,
        isTechCommittee: (technicalCommitteeMembers || []).some(isIncluded)
    };
}
function _flags(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>{
        var _ref, _api$query$council, _api$query$technicalC, _api$query$society, _api$query$sudo;
        const results = [
            undefined,
            [],
            [],
            [],
            undefined
        ];
        const calls = [
            (_ref = api.query.phragmenElection || api.query.electionsPhragmen || api.query.elections) === null || _ref === void 0 ? void 0 : _ref.members,
            (_api$query$council = api.query.council) === null || _api$query$council === void 0 ? void 0 : _api$query$council.members,
            (_api$query$technicalC = api.query.technicalCommittee) === null || _api$query$technicalC === void 0 ? void 0 : _api$query$technicalC.members,
            (_api$query$society = api.query.society) === null || _api$query$society === void 0 ? void 0 : _api$query$society.members,
            (_api$query$sudo = api.query.sudo) === null || _api$query$sudo === void 0 ? void 0 : _api$query$sudo.key
        ];
        const filtered = calls.filter((c)=>c);
        if (!filtered.length) return (0, _rxjs.of)(results);
        return api.queryMulti(filtered).pipe((0, _rxjs.map)((values)=>{
            let resultIndex = -1;
            for(let i = 0; i < calls.length; i++)if ((0, _util.isFunction)(calls[i])) results[i] = values[++resultIndex];
            return results;
        }));
    });
}
function flags(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (address)=>api.derive.accounts._flags().pipe((0, _rxjs.map)((r)=>parseFlags(address, r))));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9dHsI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name idAndIndex
 * @param {(Address | AccountId | AccountIndex | Uint8Array | string | null)} address - An accounts address in various formats.
 * @description  An array containing the [[AccountId]] and [[AccountIndex]] as optional values.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.accounts.idAndIndex('F7Hs', ([id, ix]) => {
 *   console.log(`AccountId #${id} with corresponding AccountIndex ${ix}`);
 * });
 * ```
 */ parcelHelpers.export(exports, "idAndIndex", ()=>idAndIndex);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _indexJs = require("../util/index.js");
function idAndIndex(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (address)=>{
        try {
            // yes, this can fail, don't care too much, catch will catch it
            const decoded = (0, _util.isU8a)(address) ? address : (0, _utilCrypto.decodeAddress)((address || "").toString());
            if (decoded.length > 8) {
                const accountId = api.registry.createType("AccountId", decoded);
                return api.derive.accounts.idToIndex(accountId).pipe((0, _rxjs.map)((accountIndex)=>[
                        accountId,
                        accountIndex
                    ]));
            }
            const accountIndex = api.registry.createType("AccountIndex", decoded);
            return api.derive.accounts.indexToId(accountIndex.toString()).pipe((0, _rxjs.map)((accountId)=>[
                    accountId,
                    accountIndex
                ]));
        } catch (error) {
            return (0, _rxjs.of)([
                undefined,
                undefined
            ]);
        }
    });
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h6dAG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name idToIndex
 * @param {( AccountId | string )} accountId - An accounts Id in different formats.
 * @returns Returns the corresponding AccountIndex.
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY';
 * api.derive.accounts.idToIndex(ALICE, (accountIndex) => {
 *   console.log(`The AccountIndex of ${ALICE} is ${accountIndex}`);
 * });
 * ```
 */ parcelHelpers.export(exports, "idToIndex", ()=>idToIndex);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function idToIndex(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountId)=>api.derive.accounts.indexes().pipe((0, _rxjs.map)((indexes)=>(indexes || {})[accountId.toString()])));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"15R4i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_identity", ()=>_identity);
/**
 * @name identity
 * @description Returns identity info for an account
 */ parcelHelpers.export(exports, "identity", ()=>identity);
parcelHelpers.export(exports, "hasIdentity", ()=>hasIdentity);
parcelHelpers.export(exports, "hasIdentityMulti", ()=>hasIdentityMulti);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
const UNDEF_HEX = {
    toHex: ()=>undefined
};
function dataAsString(data) {
    return data.isRaw ? (0, _util.u8aToString)(data.asRaw.toU8a(true)) : data.isNone ? undefined : data.toHex();
}
function extractOther(additional) {
    return additional.reduce((other, [_key, _value])=>{
        const key = dataAsString(_key);
        const value = dataAsString(_value);
        if (key && value) other[key] = value;
        return other;
    }, {});
}
function extractIdentity(identityOfOpt, superOf) {
    if (!(identityOfOpt !== null && identityOfOpt !== void 0 && identityOfOpt.isSome)) return {
        judgements: []
    };
    const { info , judgements  } = identityOfOpt.unwrap();
    const topDisplay = dataAsString(info.display);
    return {
        display: superOf && dataAsString(superOf[1]) || topDisplay,
        displayParent: superOf && topDisplay,
        email: dataAsString(info.email),
        image: dataAsString(info.image),
        judgements,
        legal: dataAsString(info.legal),
        other: extractOther(info.additional),
        parent: superOf && superOf[0],
        pgp: info.pgpFingerprint.unwrapOr(UNDEF_HEX).toHex(),
        riot: dataAsString(info.riot),
        twitter: dataAsString(info.twitter),
        web: dataAsString(info.web)
    };
}
function getParent(api, identityOfOpt, superOfOpt) {
    if (identityOfOpt !== null && identityOfOpt !== void 0 && identityOfOpt.isSome) // this identity has something set
    return (0, _rxjs.of)([
        identityOfOpt,
        undefined
    ]);
    else if (superOfOpt !== null && superOfOpt !== void 0 && superOfOpt.isSome) {
        const superOf = superOfOpt.unwrap();
        return (0, _rxjs.combineLatest)([
            api.derive.accounts._identity(superOf[0]).pipe((0, _rxjs.map)(([info])=>info)),
            (0, _rxjs.of)(superOf)
        ]);
    } // nothing of value returned
    return (0, _rxjs.of)([
        undefined,
        undefined
    ]);
}
function _identity(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountId)=>{
        var _api$query$identity;
        return accountId && (_api$query$identity = api.query.identity) !== null && _api$query$identity !== void 0 && _api$query$identity.identityOf ? (0, _rxjs.combineLatest)([
            api.query.identity.identityOf(accountId),
            api.query.identity.superOf(accountId)
        ]) : (0, _rxjs.of)([
            undefined,
            undefined
        ]);
    });
}
function identity(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountId)=>api.derive.accounts._identity(accountId).pipe((0, _rxjs.switchMap)(([identityOfOpt, superOfOpt])=>getParent(api, identityOfOpt, superOfOpt)), (0, _rxjs.map)(([identityOfOpt, superOf])=>extractIdentity(identityOfOpt, superOf))));
}
const hasIdentity = (0, _indexJs.firstMemo)((api, accountId)=>api.derive.accounts.hasIdentityMulti([
        accountId
    ]));
function hasIdentityMulti(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountIds)=>{
        var _api$query$identity2;
        return (_api$query$identity2 = api.query.identity) !== null && _api$query$identity2 !== void 0 && _api$query$identity2.identityOf ? (0, _rxjs.combineLatest)([
            api.query.identity.identityOf.multi(accountIds),
            api.query.identity.superOf.multi(accountIds)
        ]).pipe((0, _rxjs.map)(([identities, supers])=>identities.map((identityOfOpt, index)=>{
                const superOfOpt = supers[index];
                const parentId = superOfOpt && superOfOpt.isSome ? superOfOpt.unwrap()[0].toString() : undefined;
                let display;
                if (identityOfOpt && identityOfOpt.isSome) {
                    const value = dataAsString(identityOfOpt.unwrap().info.display);
                    if (value && !(0, _util.isHex)(value)) display = value;
                }
                return {
                    display,
                    hasIdentity: !!(display || parentId),
                    parentId
                };
            }))) : (0, _rxjs.of)(accountIds.map(()=>({
                hasIdentity: false
            })));
    });
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"17gC4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name indexToId
 * @param {( AccountIndex | string )} accountIndex - An accounts index in different formats.
 * @returns Returns the corresponding AccountId.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.accounts.indexToId('F7Hs', (accountId) => {
 *   console.log(`The AccountId of F7Hs is ${accountId}`);
 * });
 * ```
 */ parcelHelpers.export(exports, "indexToId", ()=>indexToId);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function indexToId(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountIndex)=>api.query.indices ? api.query.indices.accounts(accountIndex).pipe((0, _rxjs.map)((optResult)=>optResult.unwrapOr([])[0])) : (0, _rxjs.of)(undefined));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d1wmx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name indexes
 * @returns Returns all the indexes on the system.
 * @description This is an unwieldly query since it loops through
 * all of the enumsets and returns all of the values found. This could be up to 32k depending
 * on the number of active accounts in the system
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.accounts.indexes((indexes) => {
 *   console.log('All existing AccountIndexes', indexes);
 * });
 * ```
 */ parcelHelpers.export(exports, "indexes", ()=>indexes);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
let indicesCache = null;
function queryAccounts(api) {
    return api.query.indices.accounts.entries().pipe((0, _rxjs.map)((entries)=>entries.reduce((indexes, [key, idOpt])=>{
            if (idOpt.isSome) indexes[idOpt.unwrap()[0].toString()] = api.registry.createType("AccountIndex", key.args[0]);
            return indexes;
        }, {})));
}
function indexes(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>indicesCache ? (0, _rxjs.of)(indicesCache) : (api.query.indices ? queryAccounts(api).pipe((0, _rxjs.startWith)({})) : (0, _rxjs.of)({})).pipe((0, _rxjs.map)((indices)=>{
            indicesCache = indices;
            return indices;
        })));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b0w4D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name info
 * @description Returns aux. info with regards to an account, current that includes the accountId, accountIndex and nickname
 */ parcelHelpers.export(exports, "info", ()=>info);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function retrieveNick(api, accountId) {
    var _api$query$nicks;
    return (accountId && (_api$query$nicks = api.query.nicks) !== null && _api$query$nicks !== void 0 && _api$query$nicks.nameOf ? api.query.nicks.nameOf(accountId) : (0, _rxjs.of)(undefined)).pipe((0, _rxjs.map)((nameOf)=>nameOf !== null && nameOf !== void 0 && nameOf.isSome ? (0, _util.u8aToString)(nameOf.unwrap()[0]).substring(0, api.consts.nicks.maxLength.toNumber()) : undefined));
}
function info(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (address)=>api.derive.accounts.idAndIndex(address).pipe((0, _rxjs.switchMap)(([accountId, accountIndex])=>(0, _rxjs.combineLatest)([
                (0, _rxjs.of)({
                    accountId,
                    accountIndex
                }),
                api.derive.accounts.identity(accountId),
                retrieveNick(api, accountId)
            ])), (0, _rxjs.map)(([{ accountId , accountIndex  }, identity, nickname])=>({
                accountId,
                accountIndex,
                identity,
                nickname
            }))));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"57KV3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _getJs = require("./get.js");
parcelHelpers.exportAll(_getJs, exports);
var _getExpandedJs = require("./getExpanded.js");
parcelHelpers.exportAll(_getExpandedJs, exports);
var _listNodesJs = require("./listNodes.js");
parcelHelpers.exportAll(_listNodesJs, exports);

},{"./get.js":"7S3hJ","./getExpanded.js":"3LRlJ","./listNodes.js":"3f81h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7S3hJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_getIds", ()=>_getIds);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "get", ()=>get);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function orderBags(ids, bags) {
    const sorted = ids.map((id, index)=>({
            bag: bags[index].unwrapOr(null),
            id,
            key: id.toString()
        })).sort((a, b)=>b.id.cmp(a.id)).map((base, index)=>({
            ...base,
            bagLower: (0, _util.BN_ZERO),
            bagUpper: base.id,
            index
        }));
    const max = sorted.length - 1;
    return sorted.map((entry, index)=>index === max ? entry // We could probably use a .add(BN_ONE) here
         : {
            ...entry,
            bagLower: sorted[index + 1].bagUpper
        });
}
function _getIds(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (_ids)=>{
        const ids = _ids.map((id)=>(0, _util.bnToBn)(id));
        return ids.length ? (api.query.voterList || api.query.bagsList).listBags.multi(ids).pipe((0, _rxjs.map)((bags)=>orderBags(ids, bags))) : (0, _rxjs.of)([]);
    });
}
function all(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>(api.query.voterList || api.query.bagsList).listBags.keys().pipe((0, _rxjs.switchMap)((keys)=>api.derive.bagsList._getIds(keys.map(({ args: [id]  })=>id))), (0, _rxjs.map)((list)=>list.filter(({ bag  })=>bag))));
}
function get(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (id)=>api.derive.bagsList._getIds([
            (0, _util.bnToBn)(id)
        ]).pipe((0, _rxjs.map)((bags)=>bags[0])));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3LRlJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "expand", ()=>expand);
parcelHelpers.export(exports, "getExpanded", ()=>getExpanded);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function expand(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (bag)=>api.derive.bagsList.listNodes(bag.bag).pipe((0, _rxjs.map)((nodes)=>({
                ...bag,
                nodes
            }))));
}
function getExpanded(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (id)=>api.derive.bagsList.get(id).pipe((0, _rxjs.switchMap)((bag)=>api.derive.bagsList.expand(bag))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3f81h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "listNodes", ()=>listNodes);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function traverseLinks(api, head) {
    const subject = new (0, _rxjs.BehaviorSubject)(head);
    return subject.pipe((0, _rxjs.switchMap)((account)=>(api.query.voterList || api.query.bagsList).listNodes(account)), (0, _rxjs.tap)((node)=>{
        (0, _util.nextTick)(()=>{
            node.isSome && node.value.next.isSome ? subject.next(node.unwrap().next.unwrap()) : subject.complete();
        });
    }), (0, _rxjs.toArray)(), (0, _rxjs.map)((all)=>all.map((o)=>o.unwrap())));
}
function listNodes(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (bag)=>bag && bag.head.isSome ? traverseLinks(api, bag.head.unwrap()) : (0, _rxjs.of)([]));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jOGiw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "all", ()=>(0, _allJs.all));
parcelHelpers.export(exports, "votingBalance", ()=>votingBalance);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _allJs = require("./all.js");
var _accountJs = require("./account.js");
parcelHelpers.exportAll(_accountJs, exports);
var _votingBalancesJs = require("./votingBalances.js");
parcelHelpers.exportAll(_votingBalancesJs, exports);
const votingBalance = (0, _allJs.all);

},{"./all.js":"dlVaC","./account.js":"bDE8p","./votingBalances.js":"XbCSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dlVaC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name all
 * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.
 * @returns An object containing the results of various balance queries
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = 'F7Hs';
 *
 * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {
 *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);
 * });
 * ```
 */ parcelHelpers.export(exports, "all", ()=>all);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
const VESTING_ID = "0x76657374696e6720";
function calcLocked(api, bestNumber, locks) {
    let lockedBalance = api.registry.createType("Balance");
    let lockedBreakdown = [];
    let vestingLocked = api.registry.createType("Balance");
    let allLocked = false;
    if (Array.isArray(locks)) {
        // only get the locks that are valid until passed the current block
        lockedBreakdown = locks.filter(({ until  })=>!until || bestNumber && until.gt(bestNumber));
        allLocked = lockedBreakdown.some(({ amount  })=>amount && amount.isMax());
        vestingLocked = api.registry.createType("Balance", lockedBreakdown.filter(({ id  })=>id.eq(VESTING_ID)).reduce((result, { amount  })=>result.iadd(amount), new (0, _util.BN)(0))); // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699
        const notAll = lockedBreakdown.filter(({ amount  })=>amount && !amount.isMax());
        if (notAll.length) lockedBalance = api.registry.createType("Balance", (0, _util.bnMax)(...notAll.map(({ amount  })=>amount)));
    }
    return {
        allLocked,
        lockedBalance,
        lockedBreakdown,
        vestingLocked
    };
}
function calcShared(api, bestNumber, data, locks) {
    const { allLocked , lockedBalance , lockedBreakdown , vestingLocked  } = calcLocked(api, bestNumber, locks);
    return {
        ...data,
        availableBalance: api.registry.createType("Balance", allLocked ? 0 : (0, _util.bnMax)(new (0, _util.BN)(0), data.freeBalance.sub(lockedBalance))),
        lockedBalance,
        lockedBreakdown,
        vestingLocked
    };
}
function calcVesting(bestNumber, shared, _vesting) {
    // Calculate the vesting balances,
    //  - offset = balance locked at startingBlock
    //  - perBlock is the unlock amount
    const vesting = _vesting || [];
    const isVesting = !shared.vestingLocked.isZero();
    const vestedBalances = vesting.map(({ locked , perBlock , startingBlock  })=>bestNumber.gt(startingBlock) ? (0, _util.bnMin)(locked, perBlock.mul(bestNumber.sub(startingBlock))) : (0, _util.BN_ZERO));
    const vestedBalance = vestedBalances.reduce((all, value)=>all.iadd(value), new (0, _util.BN)(0));
    const vestingTotal = vesting.reduce((all, { locked  })=>all.iadd(locked), new (0, _util.BN)(0));
    return {
        isVesting,
        vestedBalance,
        vestedClaimable: isVesting ? shared.vestingLocked.sub(vestingTotal.sub(vestedBalance)) : (0, _util.BN_ZERO),
        vesting: vesting.map(({ locked , perBlock , startingBlock  }, index)=>({
                endBlock: locked.div(perBlock).iadd(startingBlock),
                locked,
                perBlock,
                startingBlock,
                vested: vestedBalances[index]
            })).filter(({ locked  })=>!locked.isZero()),
        vestingTotal
    };
}
function calcBalances(api, [data, [vesting, allLocks, namedReserves], bestNumber]) {
    const shared = calcShared(api, bestNumber, data, allLocks[0]);
    return {
        ...shared,
        ...calcVesting(bestNumber, shared, vesting),
        accountId: data.accountId,
        accountNonce: data.accountNonce,
        additional: allLocks.filter((_, index)=>index !== 0).map((l, index)=>calcShared(api, bestNumber, data.additional[index], l)),
        namedReserves
    };
} // old
function queryOld(api, accountId) {
    return (0, _rxjs.combineLatest)([
        api.query.balances.locks(accountId),
        api.query.balances.vesting(accountId)
    ]).pipe((0, _rxjs.map)(([locks, optVesting])=>{
        let vestingNew = null;
        if (optVesting.isSome) {
            const { offset: locked , perBlock , startingBlock  } = optVesting.unwrap();
            vestingNew = api.registry.createType("VestingInfo", {
                locked,
                perBlock,
                startingBlock
            });
        }
        return [
            vestingNew ? [
                vestingNew
            ] : null,
            [
                locks
            ],
            []
        ];
    }));
}
const isNonNullable = (nullable)=>!!nullable;
function createCalls(calls) {
    return [
        calls.map((c)=>!c),
        calls.filter(isNonNullable)
    ];
} // current (balances, vesting)
function queryCurrent(api, accountId, balanceInstances = [
    "balances"
]) {
    var _api$query$vesting;
    const [lockEmpty, lockQueries] = createCalls(balanceInstances.map((m)=>{
        var _m, _api$query;
        return ((_m = api.derive[m]) === null || _m === void 0 ? void 0 : _m.customLocks) || ((_api$query = api.query[m]) === null || _api$query === void 0 ? void 0 : _api$query.locks);
    }));
    const [reserveEmpty, reserveQueries] = createCalls(balanceInstances.map((m)=>{
        var _api$query2;
        return (_api$query2 = api.query[m]) === null || _api$query2 === void 0 ? void 0 : _api$query2.reserves;
    }));
    return (0, _rxjs.combineLatest)([
        (_api$query$vesting = api.query.vesting) !== null && _api$query$vesting !== void 0 && _api$query$vesting.vesting ? api.query.vesting.vesting(accountId) : (0, _rxjs.of)(api.registry.createType("Option<VestingInfo>")),
        lockQueries.length ? (0, _rxjs.combineLatest)(lockQueries.map((c)=>c(accountId))) : (0, _rxjs.of)([]),
        reserveQueries.length ? (0, _rxjs.combineLatest)(reserveQueries.map((c)=>c(accountId))) : (0, _rxjs.of)([])
    ]).pipe((0, _rxjs.map)(([opt, locks, reserves])=>{
        let offsetLock = -1;
        let offsetReserve = -1;
        const vesting = opt.unwrapOr(null);
        return [
            vesting ? Array.isArray(vesting) ? vesting : [
                vesting
            ] : null,
            lockEmpty.map((e)=>e ? api.registry.createType("Vec<BalanceLock>") : locks[++offsetLock]),
            reserveEmpty.map((e)=>e ? api.registry.createType("Vec<PalletBalancesReserveData>") : reserves[++offsetReserve])
        ];
    }));
}
function all(instanceId, api) {
    const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName, "balances");
    return (0, _indexJs.memo)(instanceId, (address)=>{
        var _api$query$system, _api$query$balances;
        return (0, _rxjs.combineLatest)([
            api.derive.balances.account(address),
            (0, _util.isFunction)((_api$query$system = api.query.system) === null || _api$query$system === void 0 ? void 0 : _api$query$system.account) || (0, _util.isFunction)((_api$query$balances = api.query.balances) === null || _api$query$balances === void 0 ? void 0 : _api$query$balances.account) ? queryCurrent(api, address, balanceInstances) : queryOld(api, address)
        ]).pipe((0, _rxjs.switchMap)(([account, locks])=>(0, _rxjs.combineLatest)([
                (0, _rxjs.of)(account),
                (0, _rxjs.of)(locks),
                api.derive.chain.bestNumber()
            ])), (0, _rxjs.map)((result)=>calcBalances(api, result)));
    });
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bDE8p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name account
 * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.
 * @returns An object containing the results of various balance queries
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = 'F7Hs';
 *
 * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {
 *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);
 * });
 * ```
 */ parcelHelpers.export(exports, "account", ()=>account);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function zeroBalance(api) {
    return api.registry.createType("Balance");
}
function getBalance(api, [freeBalance, reservedBalance, frozenFee, frozenMisc]) {
    const votingBalance = api.registry.createType("Balance", freeBalance.toBn());
    return {
        freeBalance,
        frozenFee,
        frozenMisc,
        reservedBalance,
        votingBalance
    };
}
function calcBalances(api, [accountId, [accountNonce, [primary, ...additional]]]) {
    return {
        accountId,
        accountNonce,
        additional: additional.map((b)=>getBalance(api, b)),
        ...getBalance(api, primary)
    };
} // old
function queryBalancesFree(api, accountId) {
    return (0, _rxjs.combineLatest)([
        api.query.balances.freeBalance(accountId),
        api.query.balances.reservedBalance(accountId),
        api.query.system.accountNonce(accountId)
    ]).pipe((0, _rxjs.map)(([freeBalance, reservedBalance, accountNonce])=>[
            accountNonce,
            [
                [
                    freeBalance,
                    reservedBalance,
                    zeroBalance(api),
                    zeroBalance(api)
                ]
            ]
        ]));
}
function queryNonceOnly(api, accountId) {
    const fill = (nonce)=>[
            nonce,
            [
                [
                    zeroBalance(api),
                    zeroBalance(api),
                    zeroBalance(api),
                    zeroBalance(api)
                ]
            ]
        ];
    return (0, _util.isFunction)(api.query.system.account) ? api.query.system.account(accountId).pipe((0, _rxjs.map)(({ nonce  })=>fill(nonce))) : (0, _util.isFunction)(api.query.system.accountNonce) ? api.query.system.accountNonce(accountId).pipe((0, _rxjs.map)((nonce)=>fill(nonce))) : (0, _rxjs.of)(fill(api.registry.createType("Index")));
}
function queryBalancesAccount(api, accountId, modules = [
    "balances"
]) {
    const balances = modules.map((m)=>{
        var _m, _api$query$m;
        return ((_m = api.derive[m]) === null || _m === void 0 ? void 0 : _m.customAccount) || ((_api$query$m = api.query[m]) === null || _api$query$m === void 0 ? void 0 : _api$query$m.account);
    }).filter((q)=>(0, _util.isFunction)(q));
    const extract = (nonce, data)=>[
            nonce,
            data.map(({ feeFrozen , free , miscFrozen , reserved  })=>[
                    free,
                    reserved,
                    feeFrozen,
                    miscFrozen
                ])
        ]; // NOTE this is for the first case where we do have instances specified
    return balances.length ? (0, _util.isFunction)(api.query.system.account) ? (0, _rxjs.combineLatest)([
        api.query.system.account(accountId),
        ...balances.map((c)=>c(accountId))
    ]).pipe((0, _rxjs.map)(([{ nonce  }, ...balances])=>extract(nonce, balances))) : (0, _rxjs.combineLatest)([
        api.query.system.accountNonce(accountId),
        ...balances.map((c)=>c(accountId))
    ]).pipe((0, _rxjs.map)(([nonce, ...balances])=>extract(nonce, balances))) : queryNonceOnly(api, accountId);
}
function querySystemAccount(api, accountId) {
    // AccountInfo is current, support old, eg. Edgeware
    return api.query.system.account(accountId).pipe((0, _rxjs.map)((infoOrTuple)=>{
        const data = infoOrTuple.nonce ? infoOrTuple.data : infoOrTuple[1];
        const nonce = infoOrTuple.nonce || infoOrTuple[0];
        if (!data || data.isEmpty) return [
            nonce,
            [
                [
                    zeroBalance(api),
                    zeroBalance(api),
                    zeroBalance(api),
                    zeroBalance(api)
                ]
            ]
        ];
        const { feeFrozen , free , miscFrozen , reserved  } = data;
        return [
            nonce,
            [
                [
                    free,
                    reserved,
                    feeFrozen,
                    miscFrozen
                ]
            ]
        ];
    }));
}
function account(instanceId, api) {
    const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName, "balances");
    const nonDefaultBalances = balanceInstances && (balanceInstances.length !== 1 || balanceInstances[0] !== "balances");
    return (0, _indexJs.memo)(instanceId, (address)=>api.derive.accounts.accountId(address).pipe((0, _rxjs.switchMap)((accountId)=>{
            var _api$query$system, _api$query$balances, _api$query$balances2;
            return accountId ? (0, _rxjs.combineLatest)([
                (0, _rxjs.of)(accountId),
                nonDefaultBalances ? queryBalancesAccount(api, accountId, balanceInstances) : (0, _util.isFunction)((_api$query$system = api.query.system) === null || _api$query$system === void 0 ? void 0 : _api$query$system.account) ? querySystemAccount(api, accountId) : (0, _util.isFunction)((_api$query$balances = api.query.balances) === null || _api$query$balances === void 0 ? void 0 : _api$query$balances.account) ? queryBalancesAccount(api, accountId) : (0, _util.isFunction)((_api$query$balances2 = api.query.balances) === null || _api$query$balances2 === void 0 ? void 0 : _api$query$balances2.freeBalance) ? queryBalancesFree(api, accountId) : queryNonceOnly(api, accountId)
            ]) : (0, _rxjs.of)([
                api.registry.createType("AccountId"),
                [
                    api.registry.createType("Index"),
                    [
                        [
                            zeroBalance(api),
                            zeroBalance(api),
                            zeroBalance(api),
                            zeroBalance(api)
                        ]
                    ]
                ]
            ]);
        }), (0, _rxjs.map)((result)=>calcBalances(api, result))));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"XbCSx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "votingBalances", ()=>votingBalances);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function votingBalances(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (addresses)=>!addresses || !addresses.length ? (0, _rxjs.of)([]) : (0, _rxjs.combineLatest)(addresses.map((accountId)=>api.derive.balances.account(accountId))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6JcL5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bountiesJs = require("./bounties.js");
parcelHelpers.exportAll(_bountiesJs, exports);

},{"./bounties.js":"jdNTh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jdNTh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bounties", ()=>bounties);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _filterBountyProposalsJs = require("./helpers/filterBountyProposals.js");
function parseResult([maybeBounties, maybeDescriptions, ids, bountyProposals]) {
    const bounties = [];
    maybeBounties.forEach((bounty, index)=>{
        if (bounty.isSome) bounties.push({
            bounty: bounty.unwrap(),
            description: maybeDescriptions[index].unwrapOrDefault().toUtf8(),
            index: ids[index],
            proposals: bountyProposals.filter((bountyProposal)=>bountyProposal.proposal && ids[index].eq(bountyProposal.proposal.args[0]))
        });
    });
    return bounties;
}
function bounties(instanceId, api) {
    const bountyBase = api.query.bounties || api.query.treasury;
    return (0, _indexJs.memo)(instanceId, ()=>bountyBase.bounties ? (0, _rxjs.combineLatest)([
            bountyBase.bountyCount(),
            api.query.council ? api.query.council.proposalCount() : (0, _rxjs.of)(0)
        ]).pipe((0, _rxjs.switchMap)(()=>(0, _rxjs.combineLatest)([
                bountyBase.bounties.keys(),
                api.derive.council ? api.derive.council.proposals() : (0, _rxjs.of)([])
            ])), (0, _rxjs.switchMap)(([keys, proposals])=>{
            const ids = keys.map(({ args: [id]  })=>id);
            return (0, _rxjs.combineLatest)([
                bountyBase.bounties.multi(ids),
                bountyBase.bountyDescriptions.multi(ids),
                (0, _rxjs.of)(ids),
                (0, _rxjs.of)((0, _filterBountyProposalsJs.filterBountiesProposals)(api, proposals))
            ]);
        }), (0, _rxjs.map)(parseResult)) : (0, _rxjs.of)(parseResult([
            [],
            [],
            [],
            []
        ])));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./helpers/filterBountyProposals.js":"4ohRx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ohRx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "filterBountiesProposals", ()=>filterBountiesProposals);
function filterBountiesProposals(api, allProposals) {
    const bountyTxBase = api.tx.bounties ? api.tx.bounties : api.tx.treasury;
    const bountyProposalCalls = [
        bountyTxBase.approveBounty,
        bountyTxBase.closeBounty,
        bountyTxBase.proposeCurator,
        bountyTxBase.unassignCurator
    ];
    return allProposals.filter((proposal)=>bountyProposalCalls.find((bountyCall)=>proposal.proposal && bountyCall.is(proposal.proposal)));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9gS3k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _bestNumberJs = require("./bestNumber.js");
parcelHelpers.exportAll(_bestNumberJs, exports);
var _bestNumberFinalizedJs = require("./bestNumberFinalized.js");
parcelHelpers.exportAll(_bestNumberFinalizedJs, exports);
var _bestNumberLagJs = require("./bestNumberLag.js");
parcelHelpers.exportAll(_bestNumberLagJs, exports);
var _getHeaderJs = require("./getHeader.js");
parcelHelpers.exportAll(_getHeaderJs, exports);
var _getBlockJs = require("./getBlock.js");
parcelHelpers.exportAll(_getBlockJs, exports);
var _getBlockByNumberJs = require("./getBlockByNumber.js");
parcelHelpers.exportAll(_getBlockByNumberJs, exports);
var _subscribeFinalizedHeadsJs = require("./subscribeFinalizedHeads.js");
parcelHelpers.exportAll(_subscribeFinalizedHeadsJs, exports);
var _subscribeNewBlocksJs = require("./subscribeNewBlocks.js");
parcelHelpers.exportAll(_subscribeNewBlocksJs, exports);
var _subscribeNewHeadsJs = require("./subscribeNewHeads.js");
parcelHelpers.exportAll(_subscribeNewHeadsJs, exports);

},{"./bestNumber.js":"chp3l","./bestNumberFinalized.js":"jnUih","./bestNumberLag.js":"331z6","./getHeader.js":"4kGuI","./getBlock.js":"jSLSH","./getBlockByNumber.js":"7DGSc","./subscribeFinalizedHeads.js":"88i90","./subscribeNewBlocks.js":"7SfzB","./subscribeNewHeads.js":"2Djww","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"chp3l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bestNumber", ()=>bestNumber);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _utilJs = require("./util.js");
const bestNumber = (0, _utilJs.createBlockNumberDerive)((api)=>api.rpc.chain.subscribeNewHeads());

},{"./util.js":"arcpB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"arcpB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// we would emit code with ../<somewhere>/src embedded in the *.d.ts files
parcelHelpers.export(exports, "createBlockNumberDerive", ()=>createBlockNumberDerive);
parcelHelpers.export(exports, "getAuthorDetails", ()=>getAuthorDetails);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js"); // re-export these - since these needs to be resolvable from api-derive, i.e. without this
function createBlockNumberDerive(fn) {
    return (instanceId, api)=>(0, _indexJs.memo)(instanceId, ()=>fn(api).pipe((0, _rxjs.map)((0, _indexJs.unwrapBlockNumber))));
}
function getAuthorDetails(header, queryAt) {
    // this is Moonbeam specific
    if (queryAt.authorMapping && queryAt.authorMapping.mappingWithDeposit) {
        const mapId = header.digest.logs[0] && (header.digest.logs[0].isConsensus && header.digest.logs[0].asConsensus[1] || header.digest.logs[0].isPreRuntime && header.digest.logs[0].asPreRuntime[1]);
        if (mapId) return (0, _rxjs.combineLatest)([
            (0, _rxjs.of)(header),
            queryAt.session ? queryAt.session.validators() : (0, _rxjs.of)(null),
            queryAt.authorMapping.mappingWithDeposit(mapId).pipe((0, _rxjs.map)((opt)=>opt.unwrapOr({
                    account: null
                }).account))
        ]);
    } // normal operation, non-mapping
    return (0, _rxjs.combineLatest)([
        (0, _rxjs.of)(header),
        queryAt.session ? queryAt.session.validators() : (0, _rxjs.of)(null),
        (0, _rxjs.of)(null)
    ]);
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jnUih":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bestNumberFinalized", ()=>bestNumberFinalized);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _utilJs = require("./util.js");
const bestNumberFinalized = (0, _utilJs.createBlockNumberDerive)((api)=>api.rpc.chain.subscribeFinalizedHeads());

},{"./util.js":"arcpB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"331z6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name bestNumberLag
 * @returns A number of blocks
 * @description Calculates the lag between finalized head and best head
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.chain.bestNumberLag((lag) => {
 *   console.log(`finalized is ${lag} blocks behind head`);
 * });
 * ```
 */ parcelHelpers.export(exports, "bestNumberLag", ()=>bestNumberLag);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function bestNumberLag(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>(0, _rxjs.combineLatest)([
            api.derive.chain.bestNumber(),
            api.derive.chain.bestNumberFinalized()
        ]).pipe((0, _rxjs.map)(([bestNumber, bestNumberFinalized])=>api.registry.createType("BlockNumber", bestNumber.sub(bestNumberFinalized)))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kGuI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name getHeader
 * @param {( Uint8Array | string )} hash - A block hash as U8 array or string.
 * @returns An array containing the block header and the block author
 * @description Get a specific block header and extend it with the author
 * @example
 * <BR>
 *
 * ```javascript
 * const { author, number } = await api.derive.chain.getHeader('0x123...456');
 *
 * console.log(`block #${number} was authored by ${author}`);
 * ```
 */ parcelHelpers.export(exports, "getHeader", ()=>getHeader);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../type/index.js");
var _indexJs1 = require("../util/index.js");
var _utilJs = require("./util.js");
function getHeader(instanceId, api) {
    return (0, _indexJs1.memo)(instanceId, (blockHash)=>(0, _rxjs.combineLatest)([
            api.rpc.chain.getHeader(blockHash),
            api.queryAt(blockHash)
        ]).pipe((0, _rxjs.switchMap)(([header, queryAt])=>(0, _utilJs.getAuthorDetails)(header, queryAt)), (0, _rxjs.map)(([header, validators, author])=>(0, _indexJs.createHeaderExtended)((validators || header).registry, header, validators, author))));
}

},{"rxjs":"lLy7s","../type/index.js":"cd05H","../util/index.js":"cN7tY","./util.js":"arcpB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cd05H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "createHeaderExtended", ()=>(0, _headerExtendedJs.createHeaderExtended));
parcelHelpers.export(exports, "createSignedBlockExtended", ()=>(0, _signedBlockExtendedJs.createSignedBlockExtended));
var _headerExtendedJs = require("./HeaderExtended.js");
var _signedBlockExtendedJs = require("./SignedBlockExtended.js");

},{"./HeaderExtended.js":"9TLLv","./SignedBlockExtended.js":"ibBf6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9TLLv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createHeaderExtended", ()=>createHeaderExtended);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _utilJs = require("./util.js");
function createHeaderExtended(registry, header, validators, author) {
    // an instance of the base extrinsic for us to extend
    const HeaderBase = registry.createClass("Header");
    class Implementation extends HeaderBase {
        #author;
        constructor(registry, header, validators, author){
            super(registry, header);
            this.#author = author || (0, _utilJs.extractAuthor)(this.digest, validators || []);
            this.createdAtHash = header === null || header === void 0 ? void 0 : header.createdAtHash;
        }
        /**
     * @description Convenience method, returns the author for the block
     */ get author() {
            return this.#author;
        }
    }
    return new Implementation(registry, header, validators, author);
}

},{"./util.js":"lWO2D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lWO2D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "extractAuthor", ()=>extractAuthor);
function extractAuthor(digest, sessionValidators = []) {
    const [citem] = digest.logs.filter((e)=>e.isConsensus);
    const [pitem] = digest.logs.filter((e)=>e.isPreRuntime);
    const [sitem] = digest.logs.filter((e)=>e.isSeal);
    let accountId;
    try {
        // This is critical to be first for BABE (before Consensus)
        // If not first, we end up dropping the author at session-end
        if (pitem) {
            const [engine, data] = pitem.asPreRuntime;
            accountId = engine.extractAuthor(data, sessionValidators);
        }
        if (!accountId && citem) {
            const [engine1, data1] = citem.asConsensus;
            accountId = engine1.extractAuthor(data1, sessionValidators);
        } // SEAL, still used in e.g. Kulupu for pow
        if (!accountId && sitem) {
            const [engine2, data2] = sitem.asSeal;
            accountId = engine2.extractAuthor(data2, sessionValidators);
        }
    } catch  {}
    return accountId;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ibBf6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createSignedBlockExtended", ()=>createSignedBlockExtended);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _utilJs = require("./util.js");
function mapExtrinsics(extrinsics, records) {
    return extrinsics.map((extrinsic, index)=>{
        let dispatchError;
        let dispatchInfo;
        const events = records.filter(({ phase  })=>phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(index)).map(({ event  })=>{
            if (event.section === "system") {
                if (event.method === "ExtrinsicSuccess") dispatchInfo = event.data[0];
                else if (event.method === "ExtrinsicFailed") {
                    dispatchError = event.data[0];
                    dispatchInfo = event.data[1];
                }
            }
            return event;
        });
        return {
            dispatchError,
            dispatchInfo,
            events,
            extrinsic
        };
    });
}
function createSignedBlockExtended(registry, block, events, validators, author) {
    // an instance of the base extrinsic for us to extend
    const SignedBlockBase = registry.createClass("SignedBlock");
    class Implementation extends SignedBlockBase {
        #author;
        #events;
        #extrinsics;
        constructor(registry, block, events, validators, author){
            super(registry, block);
            this.#author = author || (0, _utilJs.extractAuthor)(this.block.header.digest, validators || []);
            this.#events = events || [];
            this.#extrinsics = mapExtrinsics(this.block.extrinsics, this.#events);
            this.createdAtHash = block === null || block === void 0 ? void 0 : block.createdAtHash;
        }
        /**
     * @description Convenience method, returns the author for the block
     */ get author() {
            return this.#author;
        }
        /**
     * @description Convenience method, returns the events associated with the block
     */ get events() {
            return this.#events;
        }
        /**
     * @description Returns the extrinsics and their events, mapped
     */ get extrinsics() {
            return this.#extrinsics;
        }
    }
    return new Implementation(registry, block, events, validators, author);
}

},{"./util.js":"lWO2D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jSLSH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name getBlock
 * @param {( Uint8Array | string )} hash - A block hash as U8 array or string.
 * @description Get a specific block (e.g. rpc.chain.getBlock) and extend it with the author
 * @example
 * <BR>
 *
 * ```javascript
 * const { author, block } = await api.derive.chain.getBlock('0x123...456');
 *
 * console.log(`block #${block.header.number} was authored by ${author}`);
 * ```
 */ parcelHelpers.export(exports, "getBlock", ()=>getBlock);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../type/index.js");
var _indexJs1 = require("../util/index.js");
var _utilJs = require("./util.js");
function getBlock(instanceId, api) {
    return (0, _indexJs1.memo)(instanceId, (blockHash)=>(0, _rxjs.combineLatest)([
            api.rpc.chain.getBlock(blockHash),
            api.queryAt(blockHash)
        ]).pipe((0, _rxjs.switchMap)(([signedBlock, queryAt])=>(0, _rxjs.combineLatest)([
                (0, _rxjs.of)(signedBlock),
                queryAt.system.events(),
                (0, _utilJs.getAuthorDetails)(signedBlock.block.header, queryAt)
            ])), (0, _rxjs.map)(([signedBlock, events, [, validators, author]])=>(0, _indexJs.createSignedBlockExtended)(events.registry, signedBlock, events, validators, author))));
}

},{"rxjs":"lLy7s","../type/index.js":"cd05H","../util/index.js":"cN7tY","./util.js":"arcpB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7DGSc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getBlockByNumber", ()=>getBlockByNumber);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function getBlockByNumber(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (blockNumber)=>api.rpc.chain.getBlockHash(blockNumber).pipe((0, _rxjs.switchMap)((h)=>api.derive.chain.getBlock(h))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"88i90":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a header range from startHash to to (not including) endHash, i.e. lastBlock.parentHash === endHash
 */ parcelHelpers.export(exports, "_getHeaderRange", ()=>_getHeaderRange);
/**
 * @name subscribeFinalizedHeads
 * @description An observable of the finalized block headers. Unlike the base
 * chain.subscribeFinalizedHeads this does not skip any headers. Since finalization
 * may skip specific blocks (finalization happens in terms of chains), this version
 * of the derive tracks missing headers (since last  retrieved) and provides them
 * to the caller
 */ parcelHelpers.export(exports, "subscribeFinalizedHeads", ()=>subscribeFinalizedHeads);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function _getHeaderRange(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (startHash, endHash, prev = [])=>api.rpc.chain.getHeader(startHash).pipe((0, _rxjs.switchMap)((header)=>header.parentHash.eq(endHash) ? (0, _rxjs.of)([
                header,
                ...prev
            ]) : api.derive.chain._getHeaderRange(header.parentHash, endHash, [
                header,
                ...prev
            ]))));
}
function subscribeFinalizedHeads(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>{
        let prevHash = null;
        return api.rpc.chain.subscribeFinalizedHeads().pipe((0, _rxjs.switchMap)((header)=>{
            const endHash = prevHash;
            const startHash = header.parentHash;
            prevHash = header.createdAtHash = header.hash;
            return endHash === null || startHash.eq(endHash) ? (0, _rxjs.of)(header) : api.derive.chain._getHeaderRange(startHash, endHash, [
                header
            ]).pipe((0, _rxjs.switchMap)((headers)=>(0, _rxjs.from)(headers)));
        }));
    });
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7SfzB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name subscribeNewBlocks
 * @returns The latest block & events for that block
 */ parcelHelpers.export(exports, "subscribeNewBlocks", ()=>subscribeNewBlocks);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function subscribeNewBlocks(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.derive.chain.subscribeNewHeads().pipe((0, _rxjs.switchMap)((header)=>api.derive.chain.getBlock(header.createdAtHash || header.hash))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Djww":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name subscribeNewHeads
 * @returns A header with the current header (including extracted author)
 * @description An observable of the current block header and it's author
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.chain.subscribeNewHeads((header) => {
 *   console.log(`block #${header.number} was authored by ${header.author}`);
 * });
 * ```
 */ parcelHelpers.export(exports, "subscribeNewHeads", ()=>subscribeNewHeads);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../type/index.js");
var _indexJs1 = require("../util/index.js");
var _utilJs = require("./util.js");
function subscribeNewHeads(instanceId, api) {
    return (0, _indexJs1.memo)(instanceId, ()=>api.rpc.chain.subscribeNewHeads().pipe((0, _rxjs.switchMap)((header)=>(0, _rxjs.combineLatest)([
                (0, _rxjs.of)(header),
                api.queryAt(header.hash)
            ])), (0, _rxjs.switchMap)(([header, queryAt])=>(0, _utilJs.getAuthorDetails)(header, queryAt)), (0, _rxjs.map)(([header, validators, author])=>{
            header.createdAtHash = header.hash;
            return (0, _indexJs.createHeaderExtended)(header.registry, header, validators, author);
        })));
}

},{"rxjs":"lLy7s","../type/index.js":"cd05H","../util/index.js":"cN7tY","./util.js":"arcpB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5txcW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _feesJs = require("./fees.js");
parcelHelpers.exportAll(_feesJs, exports);

},{"./fees.js":"8GSY0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8GSY0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name fees
 * @returns An object containing the combined results of the queries for
 * all relevant contract fees as declared in the substrate chain spec.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.contracts.fees(([creationFee, transferFee]) => {
 *   console.log(`The fee for creating a new contract on this chain is ${creationFee} units. The fee required to call this contract is ${transferFee} units.`);
 * });
 * ```
 */ parcelHelpers.export(exports, "fees", ()=>fees);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
// query via constants (current applicable path)
function queryConstants(api) {
    return (0, _rxjs.of)([
        api.consts.contracts.callBaseFee || api.registry.createType("Balance"),
        api.consts.contracts.contractFee || api.registry.createType("Balance"),
        api.consts.contracts.creationFee || api.registry.createType("Balance"),
        api.consts.contracts.transactionBaseFee || api.registry.createType("Balance"),
        api.consts.contracts.transactionByteFee || api.registry.createType("Balance"),
        api.consts.contracts.transferFee || api.registry.createType("Balance"),
        api.consts.contracts.rentByteFee,
        api.consts.contracts.rentDepositOffset,
        api.consts.contracts.surchargeReward,
        api.consts.contracts.tombstoneDeposit
    ]);
}
function fees(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>{
        return queryConstants(api).pipe((0, _rxjs.map)(([callBaseFee, contractFee, creationFee, transactionBaseFee, transactionByteFee, transferFee, rentByteFee, rentDepositOffset, surchargeReward, tombstoneDeposit])=>({
                callBaseFee,
                contractFee,
                creationFee,
                rentByteFee,
                rentDepositOffset,
                surchargeReward,
                tombstoneDeposit,
                transactionBaseFee,
                transactionByteFee,
                transferFee
            })));
    });
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"foPeO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "members", ()=>members);
parcelHelpers.export(exports, "hasProposals", ()=>hasProposals);
parcelHelpers.export(exports, "proposal", ()=>proposal);
parcelHelpers.export(exports, "proposalCount", ()=>proposalCount);
parcelHelpers.export(exports, "proposalHashes", ()=>proposalHashes);
parcelHelpers.export(exports, "proposals", ()=>proposals);
parcelHelpers.export(exports, "prime", ()=>prime);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../collective/index.js");
var _votesJs = require("./votes.js");
parcelHelpers.exportAll(_votesJs, exports);
var _votesOfJs = require("./votesOf.js");
parcelHelpers.exportAll(_votesOfJs, exports);
const members = (0, _indexJs.members)("council");
const hasProposals = (0, _indexJs.hasProposals)("council");
const proposal = (0, _indexJs.proposal)("council");
const proposalCount = (0, _indexJs.proposalCount)("council");
const proposalHashes = (0, _indexJs.proposalHashes)("council");
const proposals = (0, _indexJs.proposals)("council");
const prime = (0, _indexJs.prime)("council");

},{"../collective/index.js":"8aK0Q","./votes.js":"3Q8SU","./votesOf.js":"3h8QH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8aK0Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _membersJs = require("./members.js");
parcelHelpers.exportAll(_membersJs, exports);
var _primeJs = require("./prime.js");
parcelHelpers.exportAll(_primeJs, exports);
var _proposalsJs = require("./proposals.js");
parcelHelpers.exportAll(_proposalsJs, exports);

},{"./members.js":"e6ONQ","./prime.js":"59DEF","./proposals.js":"ajFNI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e6ONQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "members", ()=>members);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _helpersJs = require("./helpers.js"); // We are re-exporting these from here to ensure that *.d.ts generation is correct
const members = (0, _helpersJs.callMethod)("members", []);

},{"./helpers.js":"bSVDT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSVDT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getInstance", ()=>getInstance);
parcelHelpers.export(exports, "withSection", ()=>withSection);
parcelHelpers.export(exports, "callMethod", ()=>callMethod);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function getInstance(api, section) {
    const instances = api.registry.getModuleInstances(api.runtimeVersion.specName, section);
    const name = instances && instances.length ? instances[0] : section;
    return api.query[name];
}
function withSection(section, fn) {
    return (instanceId, api)=>(0, _indexJs.memo)(instanceId, fn(getInstance(api, section), api, instanceId));
}
function callMethod(method, empty) {
    return (section)=>withSection(section, (query)=>()=>(0, _util.isFunction)(query === null || query === void 0 ? void 0 : query[method]) ? query[method]() : (0, _rxjs.of)(empty));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"59DEF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "prime", ()=>prime);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _helpersJs = require("./helpers.js"); // We are re-exporting these from here to ensure that *.d.ts generation is correct
function prime(section) {
    return (0, _helpersJs.withSection)(section, (query)=>()=>(0, _util.isFunction)(query === null || query === void 0 ? void 0 : query.prime) ? query.prime().pipe((0, _rxjs.map)((o)=>o.unwrapOr(null))) : (0, _rxjs.of)(null));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","./helpers.js":"bSVDT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ajFNI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasProposals", ()=>hasProposals);
parcelHelpers.export(exports, "proposals", ()=>proposals);
parcelHelpers.export(exports, "proposal", ()=>proposal);
parcelHelpers.export(exports, "proposalCount", ()=>proposalCount);
parcelHelpers.export(exports, "proposalHashes", ()=>proposalHashes);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
var _helpersJs = require("./helpers.js"); // We are re-exporting these from here to ensure that *.d.ts generation is correct
function parse(api, [hashes, proposals, votes]) {
    return proposals.map((o, index)=>({
            hash: api.registry.createType("Hash", hashes[index]),
            proposal: o && o.isSome ? o.unwrap() : null,
            votes: votes[index].unwrapOr(null)
        }));
}
function _proposalsFrom(api, query, hashes) {
    return ((0, _util.isFunction)(query === null || query === void 0 ? void 0 : query.proposals) && hashes.length ? (0, _rxjs.combineLatest)([
        (0, _rxjs.of)(hashes),
        // however we have had cases on Edgeware where the indices have moved around after an
        // upgrade, which results in invalid on-chain data
        query.proposalOf.multi(hashes).pipe((0, _rxjs.catchError)(()=>(0, _rxjs.of)(hashes.map(()=>null)))),
        query.voting.multi(hashes)
    ]) : (0, _rxjs.of)([
        [],
        [],
        []
    ])).pipe((0, _rxjs.map)((r)=>parse(api, r)));
}
function hasProposals(section) {
    return (0, _helpersJs.withSection)(section, (query)=>()=>(0, _rxjs.of)((0, _util.isFunction)(query === null || query === void 0 ? void 0 : query.proposals)));
}
function proposals(section) {
    return (0, _helpersJs.withSection)(section, (query, api)=>()=>api.derive[section].proposalHashes().pipe((0, _rxjs.switchMap)((all)=>_proposalsFrom(api, query, all))));
}
function proposal(section) {
    return (0, _helpersJs.withSection)(section, (query, api)=>(hash)=>(0, _util.isFunction)(query === null || query === void 0 ? void 0 : query.proposals) ? (0, _indexJs.firstObservable)(_proposalsFrom(api, query, [
                hash
            ])) : (0, _rxjs.of)(null));
}
const proposalCount = (0, _helpersJs.callMethod)("proposalCount", null);
const proposalHashes = (0, _helpersJs.callMethod)("proposals", []);

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","./helpers.js":"bSVDT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Q8SU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "votes", ()=>votes);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js"); // Voter is current tuple is 2.x-era
function isVoter(value) {
    return !Array.isArray(value);
}
function retrieveStakeOf(elections) {
    return elections.stakeOf.entries().pipe((0, _rxjs.map)((entries)=>entries.map(([{ args: [accountId]  }, stake])=>[
                accountId,
                stake
            ])));
}
function retrieveVoteOf(elections) {
    return elections.votesOf.entries().pipe((0, _rxjs.map)((entries)=>entries.map(([{ args: [accountId]  }, votes])=>[
                accountId,
                votes
            ])));
}
function retrievePrev(api, elections) {
    return (0, _rxjs.combineLatest)([
        retrieveStakeOf(elections),
        retrieveVoteOf(elections)
    ]).pipe((0, _rxjs.map)(([stakes, votes])=>{
        const result = [];
        votes.forEach(([voter, votes])=>{
            result.push([
                voter,
                {
                    stake: api.registry.createType("Balance"),
                    votes
                }
            ]);
        });
        stakes.forEach(([staker, stake])=>{
            const entry = result.find(([voter])=>voter.eq(staker));
            if (entry) entry[1].stake = stake;
            else result.push([
                staker,
                {
                    stake,
                    votes: []
                }
            ]);
        });
        return result;
    }));
}
function retrieveCurrent(elections) {
    return elections.voting.entries().pipe((0, _rxjs.map)((entries)=>entries.map(([{ args: [accountId]  }, value])=>[
                accountId,
                isVoter(value) ? {
                    stake: value.stake,
                    votes: value.votes
                } : {
                    stake: value[0],
                    votes: value[1]
                }
            ])));
}
function votes(instanceId, api) {
    const elections = api.query.phragmenElection || api.query.electionsPhragmen || api.query.elections;
    return (0, _indexJs.memo)(instanceId, ()=>elections ? elections.stakeOf ? retrievePrev(api, elections) : retrieveCurrent(elections) : (0, _rxjs.of)([]));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3h8QH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "votesOf", ()=>votesOf);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function votesOf(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountId)=>api.derive.council.votes().pipe((0, _rxjs.map)((votes)=>(votes.find(([from])=>from.eq(accountId)) || [
                null,
                {
                    stake: api.registry.createType("Balance"),
                    votes: []
                }
            ])[1])));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"emHOx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _childKeyJs = require("./childKey.js");
parcelHelpers.exportAll(_childKeyJs, exports);
var _contributionsJs = require("./contributions.js");
parcelHelpers.exportAll(_contributionsJs, exports);
var _ownContributionsJs = require("./ownContributions.js");
parcelHelpers.exportAll(_ownContributionsJs, exports);

},{"./childKey.js":"6urWu","./contributions.js":"3xpuu","./ownContributions.js":"cq5Ha","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6urWu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "childKey", ()=>childKey);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _indexJs = require("../util/index.js");
function createChildKey(info) {
    return (0, _util.u8aToHex)((0, _util.u8aConcat)(":child_storage:default:", (0, _utilCrypto.blake2AsU8a)((0, _util.u8aConcat)("crowdloan", (info.fundIndex || info.trieIndex).toU8a()))));
}
function childKey(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (paraId)=>api.query.crowdloan.funds(paraId).pipe((0, _rxjs.map)((optInfo)=>optInfo.isSome ? createChildKey(optInfo.unwrap()) : null)));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3xpuu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "contributions", ()=>contributions);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
var _utilJs = require("./util.js");
const PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)
function _getUpdates(api, paraId) {
    let added = [];
    let removed = [];
    return api.query.system.events().pipe((0, _rxjs.switchMap)((events)=>{
        const changes = (0, _utilJs.extractContributed)(paraId, events);
        if (changes.added.length || changes.removed.length) {
            var _events$createdAtHash;
            added = added.concat(...changes.added);
            removed = removed.concat(...changes.removed);
            return (0, _rxjs.of)({
                added,
                addedDelta: changes.added,
                blockHash: ((_events$createdAtHash = events.createdAtHash) === null || _events$createdAtHash === void 0 ? void 0 : _events$createdAtHash.toHex()) || "-",
                removed,
                removedDelta: changes.removed
            });
        }
        return 0, _rxjs.EMPTY;
    }), (0, _rxjs.startWith)({
        added,
        addedDelta: [],
        blockHash: "-",
        removed,
        removedDelta: []
    }));
}
function _eventTriggerAll(api, paraId) {
    return api.query.system.events().pipe((0, _rxjs.switchMap)((events)=>{
        var _events$createdAtHash2;
        const items = events.filter(({ event: { data: [eventParaId] , method , section  }  })=>section === "crowdloan" && [
                "AllRefunded",
                "Dissolved",
                "PartiallyRefunded"
            ].includes(method) && eventParaId.eq(paraId));
        return items.length ? (0, _rxjs.of)(((_events$createdAtHash2 = events.createdAtHash) === null || _events$createdAtHash2 === void 0 ? void 0 : _events$createdAtHash2.toHex()) || "-") : (0, _rxjs.EMPTY);
    }), (0, _rxjs.startWith)("-"));
}
function _getKeysPaged(api, childKey) {
    const subject = new (0, _rxjs.BehaviorSubject)(undefined);
    return subject.pipe((0, _rxjs.switchMap)((startKey)=>api.rpc.childstate.getKeysPaged(childKey, "0x", PAGE_SIZE_K, startKey)), (0, _rxjs.tap)((keys)=>{
        (0, _util.nextTick)(()=>{
            keys.length === PAGE_SIZE_K ? subject.next(keys[PAGE_SIZE_K - 1].toHex()) : subject.complete();
        });
    }), (0, _rxjs.toArray)(), (0, _rxjs.map)((keyArr)=>(0, _util.arrayFlatten)(keyArr)));
}
function _getAll(api, paraId, childKey) {
    return _eventTriggerAll(api, paraId).pipe((0, _rxjs.switchMap)(()=>(0, _util.isFunction)(api.rpc.childstate.getKeysPaged) ? _getKeysPaged(api, childKey) : api.rpc.childstate.getKeys(childKey, "0x")), (0, _rxjs.map)((keys)=>keys.map((k)=>k.toHex())));
}
function _contributions(api, paraId, childKey) {
    return (0, _rxjs.combineLatest)([
        _getAll(api, paraId, childKey),
        _getUpdates(api, paraId)
    ]).pipe((0, _rxjs.map)(([keys, { added , blockHash , removed  }])=>{
        const contributorsMap = {};
        keys.forEach((k)=>{
            contributorsMap[k] = true;
        });
        added.forEach((k)=>{
            contributorsMap[k] = true;
        });
        removed.forEach((k)=>{
            delete contributorsMap[k];
        });
        return {
            blockHash,
            contributorsHex: Object.keys(contributorsMap)
        };
    }));
}
function contributions(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (paraId)=>api.derive.crowdloan.childKey(paraId).pipe((0, _rxjs.switchMap)((childKey)=>childKey ? _contributions(api, paraId, childKey) : (0, _rxjs.of)({
                blockHash: "-",
                contributorsHex: []
            }))));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","./util.js":"gqdGd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gqdGd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "extractContributed", ()=>extractContributed);
function extractContributed(paraId, events) {
    var _events$createdAtHash;
    const added = [];
    const removed = [];
    return events.filter(({ event: { data: [, eventParaId] , method , section  }  })=>section === "crowdloan" && [
            "Contributed",
            "Withdrew"
        ].includes(method) && eventParaId.eq(paraId)).reduce((result, { event: { data: [accountId] , method  }  })=>{
        if (method === "Contributed") result.added.push(accountId.toHex());
        else result.removed.push(accountId.toHex());
        return result;
    }, {
        added,
        blockHash: ((_events$createdAtHash = events.createdAtHash) === null || _events$createdAtHash === void 0 ? void 0 : _events$createdAtHash.toHex()) || "-",
        removed
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cq5Ha":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ownContributions", ()=>ownContributions);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _utilJs = require("./util.js");
function _getValues(api, childKey, keys) {
    // We actually would love to use multi-keys https://github.com/paritytech/substrate/issues/9203
    return (0, _rxjs.combineLatest)(keys.map((k)=>api.rpc.childstate.getStorage(childKey, k))).pipe((0, _rxjs.map)((values)=>values.map((v)=>api.registry.createType("Option<StorageData>", v)).map((o)=>o.isSome ? api.registry.createType("Balance", o.unwrap()) : api.registry.createType("Balance")).reduce((all, b, index)=>({
                ...all,
                [keys[index]]: b
            }), {})));
}
function _watchOwnChanges(api, paraId, childkey, keys) {
    return api.query.system.events().pipe((0, _rxjs.switchMap)((events)=>{
        const changes = (0, _utilJs.extractContributed)(paraId, events);
        const filtered = keys.filter((k)=>changes.added.includes(k) || changes.removed.includes(k));
        return filtered.length ? _getValues(api, childkey, filtered) : (0, _rxjs.EMPTY);
    }), (0, _rxjs.startWith)({}));
}
function _contributions(api, paraId, childKey, keys) {
    return (0, _rxjs.combineLatest)([
        _getValues(api, childKey, keys),
        _watchOwnChanges(api, paraId, childKey, keys)
    ]).pipe((0, _rxjs.map)(([all, latest])=>({
            ...all,
            ...latest
        })));
}
function ownContributions(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (paraId, keys)=>api.derive.crowdloan.childKey(paraId).pipe((0, _rxjs.switchMap)((childKey)=>childKey && keys.length ? _contributions(api, paraId, childKey, keys) : (0, _rxjs.of)({}))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./util.js":"gqdGd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"859YG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _dispatchQueueJs = require("./dispatchQueue.js");
parcelHelpers.exportAll(_dispatchQueueJs, exports);
var _locksJs = require("./locks.js");
parcelHelpers.exportAll(_locksJs, exports);
var _nextExternalJs = require("./nextExternal.js");
parcelHelpers.exportAll(_nextExternalJs, exports);
var _preimagesJs = require("./preimages.js");
parcelHelpers.exportAll(_preimagesJs, exports);
var _proposalsJs = require("./proposals.js");
parcelHelpers.exportAll(_proposalsJs, exports);
var _referendumIdsJs = require("./referendumIds.js");
parcelHelpers.exportAll(_referendumIdsJs, exports);
var _referendumsJs = require("./referendums.js");
parcelHelpers.exportAll(_referendumsJs, exports);
var _referendumsActiveJs = require("./referendumsActive.js");
parcelHelpers.exportAll(_referendumsActiveJs, exports);
var _referendumsFinishedJs = require("./referendumsFinished.js");
parcelHelpers.exportAll(_referendumsFinishedJs, exports);
var _referendumsInfoJs = require("./referendumsInfo.js");
parcelHelpers.exportAll(_referendumsInfoJs, exports);
var _sqrtElectorateJs = require("./sqrtElectorate.js");
parcelHelpers.exportAll(_sqrtElectorateJs, exports);

},{"./dispatchQueue.js":"2PdaQ","./locks.js":"eMq8o","./nextExternal.js":"2Ze4G","./preimages.js":"2VOl9","./proposals.js":"lUAgy","./referendumIds.js":"6Ocun","./referendums.js":"ejHyM","./referendumsActive.js":"eGTdF","./referendumsFinished.js":"52gBy","./referendumsInfo.js":"8vHzK","./sqrtElectorate.js":"lluEi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2PdaQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dispatchQueue", ()=>dispatchQueue);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _types = require("@polkadot/types");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
const DEMOCRACY_ID = (0, _util.stringToHex)("democrac");
function isMaybeHashed(call) {
    // check for enum
    return call instanceof (0, _types.Enum);
}
function queryQueue(api) {
    return api.query.democracy.dispatchQueue().pipe((0, _rxjs.switchMap)((dispatches)=>(0, _rxjs.combineLatest)([
            (0, _rxjs.of)(dispatches),
            api.derive.democracy.preimages(dispatches.map(([, hash])=>hash))
        ])), (0, _rxjs.map)(([dispatches, images])=>dispatches.map(([at, imageHash, index], dispatchIndex)=>({
                at,
                image: images[dispatchIndex],
                imageHash,
                index
            }))));
}
function schedulerEntries(api) {
    // We don't get entries, but rather we get the keys (triggered via finished referendums) and
    // the subscribe to those keys - this means we pickup when the schedulers actually executes
    // at a block, the entry for that block will become empty
    return api.derive.democracy.referendumsFinished().pipe((0, _rxjs.switchMap)(()=>api.query.scheduler.agenda.keys()), (0, _rxjs.switchMap)((keys)=>{
        const blockNumbers = keys.map(({ args: [blockNumber]  })=>blockNumber);
        return blockNumbers.length ? (0, _rxjs.combineLatest)([
            (0, _rxjs.of)(blockNumbers),
            // however we have had cases on Darwinia where the indices have moved around after an
            // upgrade, which results in invalid on-chain data
            api.query.scheduler.agenda.multi(blockNumbers).pipe((0, _rxjs.catchError)(()=>(0, _rxjs.of)(blockNumbers.map(()=>[]))))
        ]) : (0, _rxjs.of)([
            [],
            []
        ]);
    }));
}
function queryScheduler(api) {
    return schedulerEntries(api).pipe((0, _rxjs.switchMap)(([blockNumbers, agendas])=>{
        const result = [];
        blockNumbers.forEach((at, index)=>{
            (agendas[index] || []).filter((o)=>o.isSome).forEach((o)=>{
                const scheduled = o.unwrap();
                if (scheduled.maybeId.isSome) {
                    const id = scheduled.maybeId.unwrap().toHex();
                    if (id.startsWith(DEMOCRACY_ID)) {
                        const imageHash = isMaybeHashed(scheduled.call) ? scheduled.call.isHash ? scheduled.call.asHash : scheduled.call.asValue.args[0] : scheduled.call.args[0];
                        result.push({
                            at,
                            imageHash,
                            index: api.registry.createType("(u64, ReferendumIndex)", id)[1]
                        });
                    }
                }
            });
        });
        return (0, _rxjs.combineLatest)([
            (0, _rxjs.of)(result),
            result.length ? api.derive.democracy.preimages(result.map(({ imageHash  })=>imageHash)) : (0, _rxjs.of)([])
        ]);
    }), (0, _rxjs.map)(([infos, images])=>infos.map((info, index)=>({
                ...info,
                image: images[index]
            }))));
}
function dispatchQueue(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>{
        var _api$query$scheduler;
        return (0, _util.isFunction)((_api$query$scheduler = api.query.scheduler) === null || _api$query$scheduler === void 0 ? void 0 : _api$query$scheduler.agenda) ? queryScheduler(api) : api.query.democracy.dispatchQueue ? queryQueue(api) : (0, _rxjs.of)([]);
    });
}

},{"rxjs":"lLy7s","@polkadot/types":"fnDGk","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eMq8o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "locks", ()=>locks);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
const LOCKUPS = [
    0,
    1,
    2,
    4,
    8,
    16,
    32
];
function parseEnd(api, vote, { approved , end  }) {
    return [
        end,
        approved.isTrue && vote.isAye || approved.isFalse && vote.isNay ? end.add((api.consts.democracy.voteLockingPeriod || api.consts.democracy.enactmentPeriod).muln(LOCKUPS[vote.conviction.index])) : (0, _util.BN_ZERO)
    ];
}
function parseLock(api, [referendumId, accountVote], referendum) {
    const { balance , vote  } = accountVote.asStandard;
    const [referendumEnd, unlockAt] = referendum.isFinished ? parseEnd(api, vote, referendum.asFinished) : [
        (0, _util.BN_ZERO),
        (0, _util.BN_ZERO)
    ];
    return {
        balance,
        isDelegated: false,
        isFinished: referendum.isFinished,
        referendumEnd,
        referendumId,
        unlockAt,
        vote
    };
}
function delegateLocks(api, { balance , conviction , target  }) {
    return api.derive.democracy.locks(target).pipe((0, _rxjs.map)((available)=>available.map(({ isFinished , referendumEnd , referendumId , unlockAt , vote  })=>({
                balance,
                isDelegated: true,
                isFinished,
                referendumEnd,
                referendumId,
                unlockAt: unlockAt.isZero() ? unlockAt : referendumEnd.add((api.consts.democracy.voteLockingPeriod || api.consts.democracy.enactmentPeriod).muln(LOCKUPS[conviction.index])),
                vote: api.registry.createType("Vote", {
                    aye: vote.isAye,
                    conviction
                })
            }))));
}
function directLocks(api, { votes  }) {
    if (!votes.length) return (0, _rxjs.of)([]);
    return api.query.democracy.referendumInfoOf.multi(votes.map(([referendumId])=>referendumId)).pipe((0, _rxjs.map)((referendums)=>votes.map((vote, index)=>[
                vote,
                referendums[index].unwrapOr(null)
            ]).filter((item)=>!!item[1] && (0, _util.isUndefined)(item[1].end) && item[0][1].isStandard).map(([directVote, referendum])=>parseLock(api, directVote, referendum))));
}
function locks(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountId)=>api.query.democracy.votingOf ? api.query.democracy.votingOf(accountId).pipe((0, _rxjs.switchMap)((voting)=>voting.isDirect ? directLocks(api, voting.asDirect) : voting.isDelegating ? delegateLocks(api, voting.asDelegating) : (0, _rxjs.of)([]))) : (0, _rxjs.of)([]));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Ze4G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nextExternal", ()=>nextExternal);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function withImage(api, nextOpt) {
    if (nextOpt.isNone) return (0, _rxjs.of)(null);
    const [imageHash, threshold] = nextOpt.unwrap();
    return api.derive.democracy.preimage(imageHash).pipe((0, _rxjs.map)((image)=>({
            image,
            imageHash,
            threshold
        })));
}
function nextExternal(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>{
        var _api$query$democracy;
        return (_api$query$democracy = api.query.democracy) !== null && _api$query$democracy !== void 0 && _api$query$democracy.nextExternal ? api.query.democracy.nextExternal().pipe((0, _rxjs.switchMap)((nextOpt)=>withImage(api, nextOpt))) : (0, _rxjs.of)(null);
    });
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2VOl9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "preimages", ()=>preimages);
parcelHelpers.export(exports, "preimage", ()=>preimage);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function isDemocracyPreimage(api, imageOpt) {
    return !!imageOpt && !api.query.democracy.dispatchQueue;
}
function constructProposal(api, [bytes, proposer, balance, at]) {
    let proposal;
    try {
        proposal = api.registry.createType("Proposal", bytes.toU8a(true));
    } catch (error) {
        console.error(error);
    }
    return {
        at,
        balance,
        proposal,
        proposer
    };
}
function parseDemocracy(api, imageOpt) {
    if (imageOpt.isNone) return;
    if (isDemocracyPreimage(api, imageOpt)) {
        const status = imageOpt.unwrap();
        if (status.isMissing) return;
        const { data , deposit , provider , since  } = status.asAvailable;
        return constructProposal(api, [
            data,
            provider,
            deposit,
            since
        ]);
    }
    return constructProposal(api, imageOpt.unwrap());
}
function getDemocracyImages(api, hashes) {
    return api.query.democracy.preimages.multi(hashes).pipe((0, _rxjs.map)((images)=>images.map((imageOpt)=>parseDemocracy(api, imageOpt))));
}
function preimages(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (hashes)=>hashes.length ? (0, _util.isFunction)(api.query.democracy.preimages) ? getDemocracyImages(api, hashes) : (0, _rxjs.of)([]) : (0, _rxjs.of)([]));
}
const preimage = (0, _indexJs.firstMemo)((api, hash)=>api.derive.democracy.preimages([
        hash
    ]));

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lUAgy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "proposals", ()=>proposals);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function isNewDepositors(depositors) {
    // Detect balance...
    // eslint-disable-next-line @typescript-eslint/unbound-method
    return (0, _util.isFunction)(depositors[1].mul);
}
function parse([proposals, images, optDepositors]) {
    return proposals.filter(([, , proposer], index)=>{
        var _optDepositors$index;
        return !!((_optDepositors$index = optDepositors[index]) !== null && _optDepositors$index !== void 0 && _optDepositors$index.isSome) && !proposer.isEmpty;
    }).map(([index, imageHash, proposer], proposalIndex)=>{
        const depositors = optDepositors[proposalIndex].unwrap();
        return {
            ...isNewDepositors(depositors) ? {
                balance: depositors[1],
                seconds: depositors[0]
            } : {
                balance: depositors[0],
                seconds: depositors[1]
            },
            image: images[proposalIndex],
            imageHash,
            index,
            proposer
        };
    });
}
function proposals(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>{
        var _api$query$democracy, _api$query$democracy2;
        return (0, _util.isFunction)((_api$query$democracy = api.query.democracy) === null || _api$query$democracy === void 0 ? void 0 : _api$query$democracy.publicProps) && (0, _util.isFunction)((_api$query$democracy2 = api.query.democracy) === null || _api$query$democracy2 === void 0 ? void 0 : _api$query$democracy2.preimages) ? api.query.democracy.publicProps().pipe((0, _rxjs.switchMap)((proposals)=>proposals.length ? (0, _rxjs.combineLatest)([
                (0, _rxjs.of)(proposals),
                api.derive.democracy.preimages(proposals.map(([, hash])=>hash)),
                api.query.democracy.depositOf.multi(proposals.map(([index])=>index))
            ]) : (0, _rxjs.of)([
                [],
                [],
                []
            ])), (0, _rxjs.map)(parse)) : (0, _rxjs.of)([]);
    });
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Ocun":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "referendumIds", ()=>referendumIds);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function referendumIds(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>{
        var _api$query$democracy;
        return (_api$query$democracy = api.query.democracy) !== null && _api$query$democracy !== void 0 && _api$query$democracy.lowestUnbaked ? api.queryMulti([
            api.query.democracy.lowestUnbaked,
            api.query.democracy.referendumCount
        ]).pipe((0, _rxjs.map)(([first, total])=>total.gt(first) // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
             ? [
                ...Array(total.sub(first).toNumber())
            ].map((_, i)=>first.addn(i)) : [])) : (0, _rxjs.of)([]);
    });
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ejHyM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "referendums", ()=>referendums);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function referendums(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.derive.democracy.referendumsActive().pipe((0, _rxjs.switchMap)((referendums)=>referendums.length ? (0, _rxjs.combineLatest)([
                (0, _rxjs.of)(referendums),
                api.derive.democracy._referendumsVotes(referendums)
            ]) : (0, _rxjs.of)([
                [],
                []
            ])), (0, _rxjs.map)(([referendums, votes])=>referendums.map((referendum, index)=>({
                    ...referendum,
                    ...votes[index]
                })))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eGTdF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "referendumsActive", ()=>referendumsActive);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function referendumsActive(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.derive.democracy.referendumIds().pipe((0, _rxjs.switchMap)((ids)=>ids.length ? api.derive.democracy.referendumsInfo(ids) : (0, _rxjs.of)([]))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"52gBy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "referendumsFinished", ()=>referendumsFinished);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function referendumsFinished(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.derive.democracy.referendumIds().pipe((0, _rxjs.switchMap)((ids)=>api.query.democracy.referendumInfoOf.multi(ids)), (0, _rxjs.map)((infos)=>infos.map((o)=>o.unwrapOr(null)).filter((info)=>!!info && info.isFinished).map((info)=>info.asFinished))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8vHzK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_referendumVotes", ()=>_referendumVotes);
parcelHelpers.export(exports, "_referendumsVotes", ()=>_referendumsVotes);
parcelHelpers.export(exports, "_referendumInfo", ()=>_referendumInfo);
parcelHelpers.export(exports, "referendumsInfo", ()=>referendumsInfo);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
var _utilJs = require("./util.js");
function votesPrev(api, referendumId) {
    return api.query.democracy.votersFor(referendumId).pipe((0, _rxjs.switchMap)((votersFor)=>(0, _rxjs.combineLatest)([
            (0, _rxjs.of)(votersFor),
            votersFor.length ? api.query.democracy.voteOf.multi(votersFor.map((accountId)=>[
                    referendumId,
                    accountId
                ])) : (0, _rxjs.of)([]),
            api.derive.balances.votingBalances(votersFor)
        ])), (0, _rxjs.map)(([votersFor, votes, balances])=>votersFor.map((accountId, index)=>({
                accountId,
                balance: balances[index].votingBalance || api.registry.createType("Balance"),
                isDelegating: false,
                vote: votes[index] || api.registry.createType("Vote")
            }))));
}
function extractVotes(mapped, referendumId) {
    return mapped.filter(([, voting])=>voting.isDirect).map(([accountId, voting])=>[
            accountId,
            voting.asDirect.votes.filter(([idx])=>idx.eq(referendumId))
        ]).filter(([, directVotes])=>!!directVotes.length).reduce((result, [accountId, votes])=>votes.reduce((result, [, vote])=>{
            if (vote.isStandard) result.push({
                accountId,
                isDelegating: false,
                ...vote.asStandard
            });
            return result;
        }, result), []);
}
function votesCurr(api, referendumId) {
    return api.query.democracy.votingOf.entries().pipe((0, _rxjs.map)((allVoting)=>{
        const mapped = allVoting.map(([{ args: [accountId]  }, voting])=>[
                accountId,
                voting
            ]);
        const votes = extractVotes(mapped, referendumId);
        const delegations = mapped.filter(([, voting])=>voting.isDelegating).map(([accountId, voting])=>[
                accountId,
                voting.asDelegating
            ]); // add delegations
        delegations.forEach(([accountId, { balance , conviction , target  }])=>{
            // Are we delegating to a delegator
            const toDelegator = delegations.find(([accountId])=>accountId.eq(target));
            const to = votes.find(({ accountId  })=>accountId.eq(toDelegator ? toDelegator[0] : target)); // this delegation has a target
            if (to) votes.push({
                accountId,
                balance,
                isDelegating: true,
                vote: api.registry.createType("Vote", {
                    aye: to.vote.isAye,
                    conviction
                })
            });
        });
        return votes;
    }));
}
function _referendumVotes(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (referendum)=>(0, _rxjs.combineLatest)([
            api.derive.democracy.sqrtElectorate(),
            (0, _util.isFunction)(api.query.democracy.votingOf) ? votesCurr(api, referendum.index) : votesPrev(api, referendum.index)
        ]).pipe((0, _rxjs.map)(([sqrtElectorate, votes])=>(0, _utilJs.calcVotes)(sqrtElectorate, referendum, votes))));
}
function _referendumsVotes(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (referendums)=>referendums.length ? (0, _rxjs.combineLatest)(referendums.map((referendum)=>api.derive.democracy._referendumVotes(referendum))) : (0, _rxjs.of)([]));
}
function _referendumInfo(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (index, info)=>{
        const status = (0, _utilJs.getStatus)(info);
        return status ? api.derive.democracy.preimage(status.proposalHash).pipe((0, _rxjs.map)((image)=>({
                image,
                imageHash: status.proposalHash,
                index: api.registry.createType("ReferendumIndex", index),
                status
            }))) : (0, _rxjs.of)(null);
    });
}
function referendumsInfo(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (ids)=>ids.length ? api.query.democracy.referendumInfoOf.multi(ids).pipe((0, _rxjs.switchMap)((infos)=>(0, _rxjs.combineLatest)(ids.map((id, index)=>api.derive.democracy._referendumInfo(id, infos[index])))), (0, _rxjs.map)((infos)=>infos.filter((referendum)=>!!referendum))) : (0, _rxjs.of)([]));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","./util.js":"4iPp3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4iPp3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compareRationals", ()=>compareRationals);
parcelHelpers.export(exports, "calcPassing", ()=>calcPassing);
parcelHelpers.export(exports, "calcVotes", ()=>calcVotes);
parcelHelpers.export(exports, "getStatus", ()=>getStatus);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function isOldInfo(info) {
    return !!info.proposalHash;
}
function isCurrentStatus(status) {
    return !!status.tally;
}
function compareRationals(n1, d1, n2, d2) {
    while(true){
        const q1 = n1.div(d1);
        const q2 = n2.div(d2);
        if (q1.lt(q2)) return true;
        else if (q2.lt(q1)) return false;
        const r1 = n1.mod(d1);
        const r2 = n2.mod(d2);
        if (r2.isZero()) return false;
        else if (r1.isZero()) return true;
        n1 = d2;
        n2 = d1;
        d1 = r2;
        d2 = r1;
    }
}
function calcPassingOther(threshold, sqrtElectorate, { votedAye , votedNay , votedTotal  }) {
    const sqrtVoters = (0, _util.bnSqrt)(votedTotal);
    return sqrtVoters.isZero() ? false : threshold.isSuperMajorityApprove ? compareRationals(votedNay, sqrtVoters, votedAye, sqrtElectorate) : compareRationals(votedNay, sqrtElectorate, votedAye, sqrtVoters);
}
function calcPassing(threshold, sqrtElectorate, state) {
    return threshold.isSimpleMajority ? state.votedAye.gt(state.votedNay) : calcPassingOther(threshold, sqrtElectorate, state);
}
function calcVotesPrev(votesFor) {
    return votesFor.reduce((state, derived)=>{
        const { balance , vote  } = derived;
        const isDefault = vote.conviction.index === 0;
        const counted = balance.muln(isDefault ? 1 : vote.conviction.index).divn(isDefault ? 10 : 1);
        if (vote.isAye) {
            state.allAye.push(derived);
            state.voteCountAye++;
            state.votedAye.iadd(counted);
        } else {
            state.allNay.push(derived);
            state.voteCountNay++;
            state.votedNay.iadd(counted);
        }
        state.voteCount++;
        state.votedTotal.iadd(counted);
        return state;
    }, {
        allAye: [],
        allNay: [],
        voteCount: 0,
        voteCountAye: 0,
        voteCountNay: 0,
        votedAye: new (0, _util.BN)(0),
        votedNay: new (0, _util.BN)(0),
        votedTotal: new (0, _util.BN)(0)
    });
}
function calcVotesCurrent(tally, votes) {
    const allAye = [];
    const allNay = [];
    votes.forEach((derived)=>{
        if (derived.vote.isAye) allAye.push(derived);
        else allNay.push(derived);
    });
    return {
        allAye,
        allNay,
        voteCount: allAye.length + allNay.length,
        voteCountAye: allAye.length,
        voteCountNay: allNay.length,
        votedAye: tally.ayes,
        votedNay: tally.nays,
        votedTotal: tally.turnout
    };
}
function calcVotes(sqrtElectorate, referendum, votes) {
    const state = isCurrentStatus(referendum.status) ? calcVotesCurrent(referendum.status.tally, votes) : calcVotesPrev(votes);
    return {
        ...state,
        isPassing: calcPassing(referendum.status.threshold, sqrtElectorate, state),
        votes
    };
}
function getStatus(info) {
    if (info.isNone) return null;
    const unwrapped = info.unwrap();
    return isOldInfo(unwrapped) ? unwrapped : unwrapped.isOngoing ? unwrapped.asOngoing // done, we don't include it here... only currently active
     : null;
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lluEi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sqrtElectorate", ()=>sqrtElectorate);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function sqrtElectorate(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.query.balances.totalIssuance().pipe((0, _rxjs.map)((0, _util.bnSqrt))));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fNaCt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _infoJs = require("./info.js");
parcelHelpers.exportAll(_infoJs, exports);

},{"./info.js":"aozOV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aozOV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @name info
 * @returns An object containing the combined results of the storage queries for
 * all relevant election module properties.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.elections.info(({ members, candidates }) => {
 *   console.log(`There are currently ${members.length} council members and ${candidates.length} prospective council candidates.`);
 * });
 * ```
 */ parcelHelpers.export(exports, "info", ()=>info);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js"); // SeatHolder is current tuple is 2.x-era Substrate
function isSeatHolder(value) {
    return !Array.isArray(value);
}
function isCandidateTuple(value) {
    return Array.isArray(value);
}
function getAccountTuple(value) {
    return isSeatHolder(value) ? [
        value.who,
        value.stake
    ] : value;
}
function getCandidate(value) {
    return isCandidateTuple(value) ? value[0] : value;
}
function sortAccounts([, balanceA], [, balanceB]) {
    return balanceB.cmp(balanceA);
}
function getConstants(api, elections) {
    return elections ? {
        candidacyBond: api.consts[elections].candidacyBond,
        desiredRunnersUp: api.consts[elections].desiredRunnersUp,
        desiredSeats: api.consts[elections].desiredMembers,
        termDuration: api.consts[elections].termDuration,
        votingBond: api.consts[elections].votingBond
    } : {};
}
function getModules(api) {
    const [council] = api.registry.getModuleInstances(api.runtimeVersion.specName, "council") || [
        "council"
    ];
    const elections = api.query.phragmenElection ? "phragmenElection" : api.query.electionsPhragmen ? "electionsPhragmen" : api.query.elections ? "elections" : null;
    return [
        council,
        elections
    ];
}
function queryAll(api, council, elections) {
    return api.queryMulti([
        api.query[council].members,
        api.query[elections].candidates,
        api.query[elections].members,
        api.query[elections].runnersUp
    ]);
}
function queryCouncil(api, council) {
    return (0, _rxjs.combineLatest)([
        api.query[council].members(),
        (0, _rxjs.of)([]),
        (0, _rxjs.of)([]),
        (0, _rxjs.of)([])
    ]);
}
function info(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>{
        const [council, elections] = getModules(api);
        return (elections ? queryAll(api, council, elections) : queryCouncil(api, council)).pipe((0, _rxjs.map)(([councilMembers, candidates, members, runnersUp])=>({
                ...getConstants(api, elections),
                candidateCount: api.registry.createType("u32", candidates.length),
                candidates: candidates.map(getCandidate),
                members: members.length ? members.map(getAccountTuple).sort(sortAccounts) : councilMembers.map((a)=>[
                        a,
                        api.registry.createType("Balance")
                    ]),
                runnersUp: runnersUp.map(getAccountTuple).sort(sortAccounts)
            })));
    });
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kJWmI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _receivedHeartbeatsJs = require("./receivedHeartbeats.js");
parcelHelpers.exportAll(_receivedHeartbeatsJs, exports);

},{"./receivedHeartbeats.js":"cTGyA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cTGyA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Return a boolean array indicating whether the passed accounts had received heartbeats in the current session
 */ parcelHelpers.export(exports, "receivedHeartbeats", ()=>receivedHeartbeats);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function mapResult([result, validators, heartbeats, numBlocks]) {
    validators.forEach((validator, index)=>{
        const validatorId = validator.toString();
        const blockCount = numBlocks[index];
        const hasMessage = !heartbeats[index].isEmpty;
        const prev = result[validatorId];
        if (!prev || prev.hasMessage !== hasMessage || !prev.blockCount.eq(blockCount)) result[validatorId] = {
            blockCount,
            hasMessage,
            isOnline: hasMessage || blockCount.gt((0, _util.BN_ZERO))
        };
    });
    return result;
}
function receivedHeartbeats(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>{
        var _api$query$imOnline;
        return (_api$query$imOnline = api.query.imOnline) !== null && _api$query$imOnline !== void 0 && _api$query$imOnline.receivedHeartbeats ? api.derive.staking.overview().pipe((0, _rxjs.switchMap)(({ currentIndex , validators  })=>(0, _rxjs.combineLatest)([
                (0, _rxjs.of)({}),
                (0, _rxjs.of)(validators),
                api.query.imOnline.receivedHeartbeats.multi(validators.map((_address, index)=>[
                        currentIndex,
                        index
                    ])),
                api.query.imOnline.authoredBlocks.multi(validators.map((address)=>[
                        currentIndex,
                        address
                    ]))
            ])), (0, _rxjs.map)(mapResult)) : (0, _rxjs.of)({});
    });
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"61FaC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "members", ()=>members);
parcelHelpers.export(exports, "hasProposals", ()=>hasProposals);
parcelHelpers.export(exports, "proposal", ()=>proposal);
parcelHelpers.export(exports, "proposalCount", ()=>proposalCount);
parcelHelpers.export(exports, "proposalHashes", ()=>proposalHashes);
parcelHelpers.export(exports, "proposals", ()=>proposals);
parcelHelpers.export(exports, "prime", ()=>prime);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../collective/index.js");
const members = (0, _indexJs.members)("membership");
const hasProposals = (0, _indexJs.hasProposals)("membership");
const proposal = (0, _indexJs.proposal)("membership");
const proposalCount = (0, _indexJs.proposalCount)("membership");
const proposalHashes = (0, _indexJs.proposalHashes)("membership");
const proposals = (0, _indexJs.proposals)("membership");
const prime = (0, _indexJs.prime)("membership");

},{"../collective/index.js":"8aK0Q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bJVqc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _infoJs = require("./info.js");
parcelHelpers.exportAll(_infoJs, exports);
var _overviewJs = require("./overview.js");
parcelHelpers.exportAll(_overviewJs, exports);

},{"./info.js":"aQdgt","./overview.js":"aj0TU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aQdgt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "info", ()=>info);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _utilJs = require("./util.js");
function parseActive(id, active) {
    const found = active.find(([paraId])=>paraId === id);
    if (found && found[1].isSome) {
        const [collatorId, retriable] = found[1].unwrap();
        return {
            collatorId,
            ...retriable.isWithRetries ? {
                isRetriable: true,
                retries: retriable.asWithRetries.toNumber()
            } : {
                isRetriable: false,
                retries: 0
            }
        };
    }
    return null;
}
function parseCollators(id, collatorQueue) {
    return collatorQueue.map((queue)=>{
        const found = queue.find(([paraId])=>paraId === id);
        return found ? found[1] : null;
    });
}
function parse(id, [active, retryQueue, selectedThreads, didUpdate, info, pendingSwap, heads, relayDispatchQueue]) {
    if (info.isNone) return null;
    return {
        active: parseActive(id, active),
        didUpdate: (0, _utilJs.didUpdateToBool)(didUpdate, id),
        heads,
        id,
        info: {
            id,
            ...info.unwrap()
        },
        pendingSwapId: pendingSwap.unwrapOr(null),
        relayDispatchQueue,
        retryCollators: parseCollators(id, retryQueue),
        selectedCollators: parseCollators(id, selectedThreads)
    };
}
function info(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (id)=>api.query.registrar && api.query.parachains ? api.queryMulti([
            api.query.registrar.active,
            api.query.registrar.retryQueue,
            api.query.registrar.selectedThreads,
            api.query.parachains.didUpdate,
            [
                api.query.registrar.paras,
                id
            ],
            [
                api.query.registrar.pendingSwap,
                id
            ],
            [
                api.query.parachains.heads,
                id
            ],
            [
                api.query.parachains.relayDispatchQueue,
                id
            ]
        ]).pipe((0, _rxjs.map)((result)=>parse(api.registry.createType("ParaId", id), result))) : (0, _rxjs.of)(null));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./util.js":"bQchs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bQchs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "didUpdateToBool", ()=>didUpdateToBool);
function didUpdateToBool(didUpdate, id) {
    return didUpdate.isSome ? didUpdate.unwrap().some((paraId)=>paraId.eq(id)) : false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aj0TU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "overview", ()=>overview);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _utilJs = require("./util.js");
function parse([ids, didUpdate, infos, pendingSwaps, relayDispatchQueueSizes]) {
    return ids.map((id, index)=>({
            didUpdate: (0, _utilJs.didUpdateToBool)(didUpdate, id),
            id,
            info: {
                id,
                ...infos[index].unwrapOr(null)
            },
            pendingSwapId: pendingSwaps[index].unwrapOr(null),
            relayDispatchQueueSize: relayDispatchQueueSizes[index][0].toNumber()
        }));
}
function overview(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>{
        var _api$query$registrar;
        return (_api$query$registrar = api.query.registrar) !== null && _api$query$registrar !== void 0 && _api$query$registrar.parachains && api.query.parachains ? api.query.registrar.parachains().pipe((0, _rxjs.switchMap)((paraIds)=>(0, _rxjs.combineLatest)([
                (0, _rxjs.of)(paraIds),
                api.query.parachains.didUpdate(),
                api.query.registrar.paras.multi(paraIds),
                api.query.registrar.pendingSwap.multi(paraIds),
                api.query.parachains.relayDispatchQueueSize.multi(paraIds)
            ])), (0, _rxjs.map)(parse)) : (0, _rxjs.of)([]);
    });
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./util.js":"bQchs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9XXME":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexesJs = require("./indexes.js");
parcelHelpers.exportAll(_indexesJs, exports);
var _infoJs = require("./info.js");
parcelHelpers.exportAll(_infoJs, exports);
var _progressJs = require("./progress.js");
parcelHelpers.exportAll(_progressJs, exports);

},{"./indexes.js":"c5SUY","./info.js":"dovQI","./progress.js":"5CuQX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c5SUY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "indexes", ()=>indexes);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js"); // parse into Indexes
function parse([currentIndex, activeEra, activeEraStart, currentEra, validatorCount]) {
    return {
        activeEra,
        activeEraStart,
        currentEra,
        currentIndex,
        validatorCount
    };
} // query based on latest
function queryStaking(api) {
    return api.queryMulti([
        api.query.session.currentIndex,
        api.query.staking.activeEra,
        api.query.staking.currentEra,
        api.query.staking.validatorCount
    ]).pipe((0, _rxjs.map)(([currentIndex, activeOpt, currentEra, validatorCount])=>{
        const { index , start  } = activeOpt.unwrapOrDefault();
        return parse([
            currentIndex,
            index,
            start,
            currentEra.unwrapOrDefault(),
            validatorCount
        ]);
    }));
} // query based on latest
function querySession(api) {
    return api.query.session.currentIndex().pipe((0, _rxjs.map)((currentIndex)=>parse([
            currentIndex,
            api.registry.createType("EraIndex"),
            api.registry.createType("Option<Moment>"),
            api.registry.createType("EraIndex"),
            api.registry.createType("u32")
        ])));
} // empty set when none is available
function empty(api) {
    return (0, _rxjs.of)(parse([
        api.registry.createType("SessionIndex", 1),
        api.registry.createType("EraIndex"),
        api.registry.createType("Option<Moment>"),
        api.registry.createType("EraIndex"),
        api.registry.createType("u32")
    ]));
}
function indexes(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.query.session ? api.query.staking ? queryStaking(api) : querySession(api) : empty(api));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dovQI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Retrieves all the session and era query and calculates specific values on it as the length of the session and eras
 */ parcelHelpers.export(exports, "info", ()=>info);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function info(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.derive.session.indexes().pipe((0, _rxjs.map)((indexes)=>{
            var _api$consts, _api$consts$babe, _api$consts2, _api$consts2$staking;
            const sessionLength = ((_api$consts = api.consts) === null || _api$consts === void 0 ? void 0 : (_api$consts$babe = _api$consts.babe) === null || _api$consts$babe === void 0 ? void 0 : _api$consts$babe.epochDuration) || api.registry.createType("u64", 1);
            const sessionsPerEra = ((_api$consts2 = api.consts) === null || _api$consts2 === void 0 ? void 0 : (_api$consts2$staking = _api$consts2.staking) === null || _api$consts2$staking === void 0 ? void 0 : _api$consts2$staking.sessionsPerEra) || api.registry.createType("SessionIndex", 1);
            return {
                ...indexes,
                eraLength: api.registry.createType("BlockNumber", sessionsPerEra.mul(sessionLength)),
                isEpoch: !!api.query.babe,
                sessionLength,
                sessionsPerEra
            };
        })));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5CuQX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Retrieves all the session and era query and calculates specific values on it as the length of the session and eras
 */ parcelHelpers.export(exports, "progress", ()=>progress);
parcelHelpers.export(exports, "eraLength", ()=>eraLength);
parcelHelpers.export(exports, "eraProgress", ()=>eraProgress);
parcelHelpers.export(exports, "sessionProgress", ()=>sessionProgress);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function withProgressField(field) {
    return (instanceId, api)=>(0, _indexJs.memo)(instanceId, ()=>api.derive.session.progress().pipe((0, _rxjs.map)((info)=>info[field])));
}
function createDerive(api, info, [currentSlot, epochIndex, epochOrGenesisStartSlot, activeEraStartSessionIndex]) {
    const epochStartSlot = epochIndex.mul(info.sessionLength).iadd(epochOrGenesisStartSlot);
    const sessionProgress = currentSlot.sub(epochStartSlot);
    const eraProgress = info.currentIndex.sub(activeEraStartSessionIndex).imul(info.sessionLength).iadd(sessionProgress);
    return {
        ...info,
        eraProgress: api.registry.createType("BlockNumber", eraProgress),
        sessionProgress: api.registry.createType("BlockNumber", sessionProgress)
    };
}
function queryAura(api) {
    return api.derive.session.info().pipe((0, _rxjs.map)((info)=>({
            ...info,
            eraProgress: api.registry.createType("BlockNumber"),
            sessionProgress: api.registry.createType("BlockNumber")
        })));
}
function queryBabe(api) {
    return api.derive.session.info().pipe((0, _rxjs.switchMap)((info)=>{
        var _api$query$staking;
        return (0, _rxjs.combineLatest)([
            (0, _rxjs.of)(info),
            (_api$query$staking = api.query.staking) !== null && _api$query$staking !== void 0 && _api$query$staking.erasStartSessionIndex ? api.queryMulti([
                api.query.babe.currentSlot,
                api.query.babe.epochIndex,
                api.query.babe.genesisSlot,
                [
                    api.query.staking.erasStartSessionIndex,
                    info.activeEra
                ]
            ]) : api.queryMulti([
                api.query.babe.currentSlot,
                api.query.babe.epochIndex,
                api.query.babe.genesisSlot
            ])
        ]);
    }), (0, _rxjs.map)(([info, [currentSlot, epochIndex, genesisSlot, optStartIndex]])=>[
            info,
            [
                currentSlot,
                epochIndex,
                genesisSlot,
                optStartIndex && optStartIndex.isSome ? optStartIndex.unwrap() : api.registry.createType("SessionIndex", 1)
            ]
        ]));
}
function progress(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.query.babe ? queryBabe(api).pipe((0, _rxjs.map)(([info, slots])=>createDerive(api, info, slots))) : queryAura(api));
}
const eraLength = withProgressField("eraLength");
const eraProgress = withProgressField("eraProgress");
const sessionProgress = withProgressField("sessionProgress");

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Vl0X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _candidatesJs = require("./candidates.js");
parcelHelpers.exportAll(_candidatesJs, exports);
var _infoJs = require("./info.js");
parcelHelpers.exportAll(_infoJs, exports);
var _memberJs = require("./member.js");
parcelHelpers.exportAll(_memberJs, exports);
var _membersJs = require("./members.js");
parcelHelpers.exportAll(_membersJs, exports);

},{"./candidates.js":"91EbU","./info.js":"8i4AT","./member.js":"3MXLC","./members.js":"60Hl6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"91EbU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Get the candidate info for a society
 */ parcelHelpers.export(exports, "candidates", ()=>candidates);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function candidates(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.query.society.candidates().pipe((0, _rxjs.switchMap)((candidates)=>(0, _rxjs.combineLatest)([
                (0, _rxjs.of)(candidates),
                api.query.society.suspendedCandidates.multi(candidates.map(({ who  })=>who))
            ])), (0, _rxjs.map)(([candidates, suspended])=>candidates.map(({ kind , value , who  }, index)=>({
                    accountId: who,
                    isSuspended: suspended[index].isSome,
                    kind,
                    value
                })))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8i4AT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Get the overall info for a society
 */ parcelHelpers.export(exports, "info", ()=>info);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function info(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.queryMulti([
            api.query.society.bids,
            api.query.society.defender,
            api.query.society.founder,
            api.query.society.head,
            api.query.society.maxMembers,
            api.query.society.pot
        ]).pipe((0, _rxjs.map)(([bids, defender, founder, head, maxMembers, pot])=>({
                bids,
                defender: defender.unwrapOr(undefined),
                founder: founder.unwrapOr(undefined),
                hasDefender: defender.isSome && head.isSome && !head.eq(defender) || false,
                head: head.unwrapOr(undefined),
                maxMembers,
                pot
            }))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3MXLC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Get the member info for a society
 */ parcelHelpers.export(exports, "member", ()=>member);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function member(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountId)=>api.derive.society._members([
            accountId
        ]).pipe((0, _rxjs.map)(([result])=>result)));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"60Hl6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_members", ()=>_members);
/**
 * @description Get the member info for a society
 */ parcelHelpers.export(exports, "members", ()=>members);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function _members(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountIds)=>(0, _rxjs.combineLatest)([
            (0, _rxjs.of)(accountIds),
            api.query.society.payouts.multi(accountIds),
            api.query.society.strikes.multi(accountIds),
            api.query.society.defenderVotes.multi(accountIds),
            api.query.society.suspendedMembers.multi(accountIds),
            api.query.society.vouching.multi(accountIds)
        ]).pipe((0, _rxjs.map)(([accountIds, payouts, strikes, defenderVotes, suspended, vouching])=>accountIds.map((accountId, index)=>({
                    accountId,
                    isDefenderVoter: defenderVotes[index].isSome,
                    isSuspended: suspended[index].isTrue,
                    payouts: payouts[index],
                    strikes: strikes[index],
                    vote: defenderVotes[index].unwrapOr(undefined),
                    vouching: vouching[index].unwrapOr(undefined)
                })))));
}
function members(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.query.society.members().pipe((0, _rxjs.switchMap)((members)=>api.derive.society._members(members))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ZPwx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _accountJs = require("./account.js");
parcelHelpers.exportAll(_accountJs, exports);
var _currentPointsJs = require("./currentPoints.js");
parcelHelpers.exportAll(_currentPointsJs, exports);
var _erasExposureJs = require("./erasExposure.js");
parcelHelpers.exportAll(_erasExposureJs, exports);
var _erasHistoricJs = require("./erasHistoric.js");
parcelHelpers.exportAll(_erasHistoricJs, exports);
var _erasPointsJs = require("./erasPoints.js");
parcelHelpers.exportAll(_erasPointsJs, exports);
var _erasPrefsJs = require("./erasPrefs.js");
parcelHelpers.exportAll(_erasPrefsJs, exports);
var _erasRewardsJs = require("./erasRewards.js");
parcelHelpers.exportAll(_erasRewardsJs, exports);
var _erasSlashesJs = require("./erasSlashes.js");
parcelHelpers.exportAll(_erasSlashesJs, exports);
var _electedInfoJs = require("./electedInfo.js");
parcelHelpers.exportAll(_electedInfoJs, exports);
var _keysJs = require("./keys.js");
parcelHelpers.exportAll(_keysJs, exports);
var _overviewJs = require("./overview.js");
parcelHelpers.exportAll(_overviewJs, exports);
var _ownExposureJs = require("./ownExposure.js");
parcelHelpers.exportAll(_ownExposureJs, exports);
var _ownSlashesJs = require("./ownSlashes.js");
parcelHelpers.exportAll(_ownSlashesJs, exports);
var _queryJs = require("./query.js");
parcelHelpers.exportAll(_queryJs, exports);
var _stakerExposureJs = require("./stakerExposure.js");
parcelHelpers.exportAll(_stakerExposureJs, exports);
var _stakerPointsJs = require("./stakerPoints.js");
parcelHelpers.exportAll(_stakerPointsJs, exports);
var _stakerPrefsJs = require("./stakerPrefs.js");
parcelHelpers.exportAll(_stakerPrefsJs, exports);
var _stakerRewardsJs = require("./stakerRewards.js");
parcelHelpers.exportAll(_stakerRewardsJs, exports);
var _stakerSlashesJs = require("./stakerSlashes.js");
parcelHelpers.exportAll(_stakerSlashesJs, exports);
var _stashesJs = require("./stashes.js");
parcelHelpers.exportAll(_stashesJs, exports);
var _validatorsJs = require("./validators.js");
parcelHelpers.exportAll(_validatorsJs, exports);
var _waitingInfoJs = require("./waitingInfo.js");
parcelHelpers.exportAll(_waitingInfoJs, exports);

},{"./account.js":"j71Lj","./currentPoints.js":"bRsO3","./erasExposure.js":"djRll","./erasHistoric.js":"8mtwJ","./erasPoints.js":"epIv7","./erasPrefs.js":"fIU9A","./erasRewards.js":"a2qcT","./erasSlashes.js":"kQdGA","./electedInfo.js":"kBh5E","./keys.js":"dnGVX","./overview.js":"ixb2d","./ownExposure.js":"bLKlN","./ownSlashes.js":"eeIjB","./query.js":"5npVy","./stakerExposure.js":"kxCkY","./stakerPoints.js":"84zyw","./stakerPrefs.js":"LSzUF","./stakerRewards.js":"cQx06","./stakerSlashes.js":"5pEhQ","./stashes.js":"g06iW","./validators.js":"afojG","./waitingInfo.js":"e1Gl2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j71Lj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description From a list of stashes, fill in all the relevant staking details
 */ parcelHelpers.export(exports, "accounts", ()=>accounts);
parcelHelpers.export(exports, "account", ()=>account);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
const QUERY_OPTS = {
    withDestination: true,
    withLedger: true,
    withNominations: true,
    withPrefs: true
};
function groupByEra(list) {
    return list.reduce((map, { era , value  })=>{
        const key = era.toString();
        map[key] = (map[key] || (0, _util.BN_ZERO)).add(value.unwrap());
        return map;
    }, {});
}
function calculateUnlocking(api, stakingLedger, sessionInfo) {
    const results = Object.entries(groupByEra(((stakingLedger === null || stakingLedger === void 0 ? void 0 : stakingLedger.unlocking) || []).filter(({ era  })=>era.unwrap().gt(sessionInfo.activeEra)))).map(([eraString, value])=>({
            remainingEras: new (0, _util.BN)(eraString).isub(sessionInfo.activeEra),
            value: api.registry.createType("Balance", value)
        }));
    return results.length ? results : undefined;
}
function redeemableSum(api, stakingLedger, sessionInfo) {
    return api.registry.createType("Balance", ((stakingLedger === null || stakingLedger === void 0 ? void 0 : stakingLedger.unlocking) || []).reduce((total, { era , value  })=>{
        return sessionInfo.activeEra.gte(era.unwrap()) ? total.iadd(value.unwrap()) : total;
    }, new (0, _util.BN)(0)));
}
function parseResult(api, sessionInfo, keys, query) {
    return {
        ...keys,
        ...query,
        redeemable: redeemableSum(api, query.stakingLedger, sessionInfo),
        unlocking: calculateUnlocking(api, query.stakingLedger, sessionInfo)
    };
}
function accounts(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountIds, opts = QUERY_OPTS)=>api.derive.session.info().pipe((0, _rxjs.switchMap)((sessionInfo)=>(0, _rxjs.combineLatest)([
                api.derive.staking.keysMulti(accountIds),
                api.derive.staking.queryMulti(accountIds, opts)
            ]).pipe((0, _rxjs.map)(([keys, queries])=>queries.map((q, index)=>parseResult(api, sessionInfo, keys[index], q)))))));
}
const account = (0, _indexJs.firstMemo)((api, accountId, opts)=>api.derive.staking.accounts([
        accountId
    ], opts));

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bRsO3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Retrieve the staking overview, including elected and points earned
 */ parcelHelpers.export(exports, "currentPoints", ()=>currentPoints);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function currentPoints(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.derive.session.indexes().pipe((0, _rxjs.switchMap)(({ activeEra  })=>api.query.staking.erasRewardPoints(activeEra))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"djRll":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_eraExposure", ()=>_eraExposure);
parcelHelpers.export(exports, "eraExposure", ()=>eraExposure);
parcelHelpers.export(exports, "_erasExposure", ()=>_erasExposure);
parcelHelpers.export(exports, "erasExposure", ()=>erasExposure);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _cacheJs = require("./cache.js");
var _utilJs = require("./util.js");
const CACHE_KEY = "eraExposure";
function mapStakers(era, stakers) {
    const nominators = {};
    const validators = {};
    stakers.forEach(([key, exposure])=>{
        const validatorId = key.args[1].toString();
        validators[validatorId] = exposure;
        exposure.others.forEach(({ who  }, validatorIndex)=>{
            const nominatorId = who.toString();
            nominators[nominatorId] = nominators[nominatorId] || [];
            nominators[nominatorId].push({
                validatorId,
                validatorIndex
            });
        });
    });
    return {
        era,
        nominators,
        validators
    };
}
function _eraExposure(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (era, withActive = false)=>{
        const [cacheKey, cached] = (0, _cacheJs.getEraCache)(CACHE_KEY, era, withActive);
        return cached ? (0, _rxjs.of)(cached) : api.query.staking.erasStakersClipped.entries(era).pipe((0, _rxjs.map)((r)=>(0, _cacheJs.setEraCache)(cacheKey, withActive, mapStakers(era, r))));
    });
}
const eraExposure = (0, _utilJs.singleEra)("_eraExposure");
const _erasExposure = (0, _utilJs.combineEras)("_eraExposure");
const erasExposure = (0, _utilJs.erasHistoricApply)("_erasExposure");

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./cache.js":"gqSnj","./util.js":"e5Mnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gqSnj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getEraCache", ()=>getEraCache);
parcelHelpers.export(exports, "getEraMultiCache", ()=>getEraMultiCache);
parcelHelpers.export(exports, "setEraCache", ()=>setEraCache);
parcelHelpers.export(exports, "setEraMultiCache", ()=>setEraMultiCache);
parcelHelpers.export(exports, "filterCachedEras", ()=>filterCachedEras);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../util/index.js");
function getEraCache(CACHE_KEY, era, withActive) {
    const cacheKey = `${CACHE_KEY}-${era.toString()}`;
    return [
        cacheKey,
        withActive ? undefined : (0, _indexJs.deriveCache).get(cacheKey)
    ];
}
function getEraMultiCache(CACHE_KEY, eras, withActive) {
    const cached = withActive ? [] : eras.map((e)=>(0, _indexJs.deriveCache).get(`${CACHE_KEY}-${e.toString()}`)).filter((v)=>!!v);
    return cached;
}
function setEraCache(cacheKey, withActive, value) {
    !withActive && (0, _indexJs.deriveCache).set(cacheKey, value);
    return value;
}
function setEraMultiCache(CACHE_KEY, withActive, values) {
    !withActive && values.forEach((v)=>(0, _indexJs.deriveCache).set(`${CACHE_KEY}-${v.era.toString()}`, v));
    return values;
}
function filterCachedEras(eras, cached, query) {
    return eras.map((e)=>cached.find(({ era  })=>e.eq(era)) || query.find(({ era  })=>e.eq(era)));
}

},{"../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e5Mnf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterEras", ()=>filterEras);
parcelHelpers.export(exports, "erasHistoricApply", ()=>erasHistoricApply);
parcelHelpers.export(exports, "erasHistoricApplyAccount", ()=>erasHistoricApplyAccount);
parcelHelpers.export(exports, "singleEra", ()=>singleEra);
parcelHelpers.export(exports, "combineEras", ()=>combineEras);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
// only retrieve a maximum of 14 eras (84 / 6) at a time
// (This is not empirically calculated. Rather smaller sizes take longer
// time due to the serial nature, large sizes may tie up the RPCs)
const ERA_CHUNK_SIZE = 14;
function chunkEras(eras, fn) {
    const chunked = (0, _util.arrayChunk)(eras, ERA_CHUNK_SIZE);
    let index = 0;
    const subject = new (0, _rxjs.BehaviorSubject)(chunked[index]);
    return subject.pipe((0, _rxjs.switchMap)(fn), (0, _rxjs.tap)(()=>{
        (0, _util.nextTick)(()=>{
            index++;
            index === chunked.length ? subject.complete() : subject.next(chunked[index]);
        });
    }), (0, _rxjs.toArray)(), (0, _rxjs.map)((0, _util.arrayFlatten)));
}
function filterEras(eras, list) {
    return eras.filter((e)=>!list.some(({ era  })=>e.eq(era)));
}
function erasHistoricApply(fn) {
    return (instanceId, api)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return
        (0, _indexJs.memo)(instanceId, (withActive = false)=>api.derive.staking.erasHistoric(withActive).pipe((0, _rxjs.switchMap)((e)=>api.derive.staking[fn](e, withActive))));
}
function erasHistoricApplyAccount(fn) {
    return (instanceId, api)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return
        (0, _indexJs.memo)(instanceId, (accountId, withActive = false)=>api.derive.staking.erasHistoric(withActive).pipe((0, _rxjs.switchMap)((e)=>api.derive.staking[fn](accountId, e, withActive))));
}
function singleEra(fn) {
    return (instanceId, api)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return
        (0, _indexJs.memo)(instanceId, (era)=>api.derive.staking[fn](era, true));
}
function combineEras(fn) {
    return (instanceId, api)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return
        (0, _indexJs.memo)(instanceId, (eras, withActive)=>!eras.length ? (0, _rxjs.of)([]) : chunkEras(eras, (eras)=>(0, _rxjs.combineLatest)(eras.map((e)=>api.derive.staking[fn](e, withActive)))));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8mtwJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "erasHistoric", ()=>erasHistoric);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function erasHistoric(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (withActive)=>api.queryMulti([
            api.query.staking.activeEra,
            api.query.staking.historyDepth
        ]).pipe((0, _rxjs.map)(([activeEraOpt, historyDepth])=>{
            const result = [];
            const max = historyDepth.toNumber();
            const activeEra = activeEraOpt.unwrapOrDefault().index;
            let lastEra = activeEra;
            while(lastEra.gte((0, _util.BN_ZERO)) && result.length < max){
                if (lastEra !== activeEra || withActive === true) result.push(api.registry.createType("EraIndex", lastEra));
                lastEra = lastEra.sub((0, _util.BN_ONE));
            } // go from oldest to newest
            return result.reverse();
        })));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"epIv7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_erasPoints", ()=>_erasPoints);
parcelHelpers.export(exports, "erasPoints", ()=>erasPoints);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
var _cacheJs = require("./cache.js");
var _utilJs = require("./util.js");
const CACHE_KEY = "eraPoints";
function mapValidators({ individual  }) {
    return [
        ...individual.entries()
    ].filter(([, points])=>points.gt((0, _util.BN_ZERO))).reduce((result, [validatorId, points])=>{
        result[validatorId.toString()] = points;
        return result;
    }, {});
}
function mapPoints(eras, points) {
    return eras.map((era, index)=>({
            era,
            eraPoints: points[index].total,
            validators: mapValidators(points[index])
        }));
}
function _erasPoints(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (eras, withActive)=>{
        if (!eras.length) return (0, _rxjs.of)([]);
        const cached = (0, _cacheJs.getEraMultiCache)(CACHE_KEY, eras, withActive);
        const remaining = (0, _utilJs.filterEras)(eras, cached);
        return !remaining.length ? (0, _rxjs.of)(cached) : api.query.staking.erasRewardPoints.multi(remaining).pipe((0, _rxjs.map)((p)=>(0, _cacheJs.filterCachedEras)(eras, cached, (0, _cacheJs.setEraMultiCache)(CACHE_KEY, withActive, mapPoints(remaining, p)))));
    });
}
const erasPoints = (0, _utilJs.erasHistoricApply)("_erasPoints");

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","./cache.js":"gqSnj","./util.js":"e5Mnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fIU9A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_eraPrefs", ()=>_eraPrefs);
parcelHelpers.export(exports, "eraPrefs", ()=>eraPrefs);
parcelHelpers.export(exports, "_erasPrefs", ()=>_erasPrefs);
parcelHelpers.export(exports, "erasPrefs", ()=>erasPrefs);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _cacheJs = require("./cache.js");
var _utilJs = require("./util.js");
const CACHE_KEY = "eraPrefs";
function mapPrefs(era, all) {
    const validators = {};
    all.forEach(([key, prefs])=>{
        validators[key.args[1].toString()] = prefs;
    });
    return {
        era,
        validators
    };
}
function _eraPrefs(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (era, withActive)=>{
        const [cacheKey, cached] = (0, _cacheJs.getEraCache)(CACHE_KEY, era, withActive);
        return cached ? (0, _rxjs.of)(cached) : api.query.staking.erasValidatorPrefs.entries(era).pipe((0, _rxjs.map)((r)=>(0, _cacheJs.setEraCache)(cacheKey, withActive, mapPrefs(era, r))));
    });
}
const eraPrefs = (0, _utilJs.singleEra)("_eraPrefs");
const _erasPrefs = (0, _utilJs.combineEras)("_eraPrefs");
const erasPrefs = (0, _utilJs.erasHistoricApply)("_erasPrefs");

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./cache.js":"gqSnj","./util.js":"e5Mnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a2qcT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_erasRewards", ()=>_erasRewards);
parcelHelpers.export(exports, "erasRewards", ()=>erasRewards);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _cacheJs = require("./cache.js");
var _utilJs = require("./util.js");
const CACHE_KEY = "eraRewards";
function mapRewards(eras, optRewards) {
    return eras.map((era, index)=>({
            era,
            eraReward: optRewards[index].unwrapOrDefault()
        }));
}
function _erasRewards(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (eras, withActive)=>{
        if (!eras.length) return (0, _rxjs.of)([]);
        const cached = (0, _cacheJs.getEraMultiCache)(CACHE_KEY, eras, withActive);
        const remaining = (0, _utilJs.filterEras)(eras, cached);
        if (!remaining.length) return (0, _rxjs.of)(cached);
        return api.query.staking.erasValidatorReward.multi(remaining).pipe((0, _rxjs.map)((r)=>(0, _cacheJs.filterCachedEras)(eras, cached, (0, _cacheJs.setEraMultiCache)(CACHE_KEY, withActive, mapRewards(remaining, r)))));
    });
}
const erasRewards = (0, _utilJs.erasHistoricApply)("_erasRewards");

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./cache.js":"gqSnj","./util.js":"e5Mnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kQdGA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_eraSlashes", ()=>_eraSlashes);
parcelHelpers.export(exports, "eraSlashes", ()=>eraSlashes);
parcelHelpers.export(exports, "_erasSlashes", ()=>_erasSlashes);
parcelHelpers.export(exports, "erasSlashes", ()=>erasSlashes);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _cacheJs = require("./cache.js");
var _utilJs = require("./util.js");
const CACHE_KEY = "eraSlashes";
function mapSlashes(era, noms, vals) {
    const nominators = {};
    const validators = {};
    noms.forEach(([key, optBalance])=>{
        nominators[key.args[1].toString()] = optBalance.unwrap();
    });
    vals.forEach(([key, optRes])=>{
        validators[key.args[1].toString()] = optRes.unwrapOrDefault()[1];
    });
    return {
        era,
        nominators,
        validators
    };
}
function _eraSlashes(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (era, withActive)=>{
        const [cacheKey, cached] = (0, _cacheJs.getEraCache)(CACHE_KEY, era, withActive);
        return cached ? (0, _rxjs.of)(cached) : (0, _rxjs.combineLatest)([
            api.query.staking.nominatorSlashInEra.entries(era),
            api.query.staking.validatorSlashInEra.entries(era)
        ]).pipe((0, _rxjs.map)(([n, v])=>(0, _cacheJs.setEraCache)(cacheKey, withActive, mapSlashes(era, n, v))));
    });
}
const eraSlashes = (0, _utilJs.singleEra)("_eraSlashes");
const _erasSlashes = (0, _utilJs.combineEras)("_eraSlashes");
const erasSlashes = (0, _utilJs.erasHistoricApply)("_erasSlashes");

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./cache.js":"gqSnj","./util.js":"e5Mnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kBh5E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "electedInfo", ()=>electedInfo);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
const DEFAULT_FLAGS = {
    withController: true,
    withExposure: true,
    withPrefs: true
};
function combineAccounts(nextElected, validators) {
    return (0, _util.arrayFlatten)([
        nextElected,
        validators.filter((v)=>!nextElected.find((n)=>n.eq(v)))
    ]);
}
function electedInfo(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (flags = DEFAULT_FLAGS)=>api.derive.staking.validators().pipe((0, _rxjs.switchMap)(({ nextElected , validators  })=>api.derive.staking.queryMulti(combineAccounts(nextElected, validators), flags).pipe((0, _rxjs.map)((info)=>({
                    info,
                    nextElected,
                    validators
                }))))));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dnGVX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "keysMulti", ()=>keysMulti);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function extractsIds(stashId, queuedKeys, nextKeys) {
    const sessionIds = (queuedKeys.find(([currentId])=>currentId.eq(stashId)) || [
        undefined,
        []
    ])[1];
    const nextSessionIds = nextKeys.unwrapOr([]);
    return {
        nextSessionIds: Array.isArray(nextSessionIds) ? nextSessionIds : [
            ...nextSessionIds.values()
        ],
        sessionIds: Array.isArray(sessionIds) ? sessionIds : [
            ...sessionIds.values()
        ]
    };
}
const keys = (0, _indexJs.firstMemo)((api, stashId)=>api.derive.staking.keysMulti([
        stashId
    ]));
function keysMulti(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (stashIds)=>stashIds.length ? api.query.session.queuedKeys().pipe((0, _rxjs.switchMap)((queuedKeys)=>{
            var _api$consts$session;
            return (0, _rxjs.combineLatest)([
                (0, _rxjs.of)(queuedKeys),
                (_api$consts$session = api.consts.session) !== null && _api$consts$session !== void 0 && _api$consts$session.dedupKeyPrefix ? api.query.session.nextKeys.multi(stashIds.map((s)=>[
                        api.consts.session.dedupKeyPrefix,
                        s
                    ])) : (0, _rxjs.combineLatest)(stashIds.map((s)=>api.query.session.nextKeys(s)))
            ]);
        }), (0, _rxjs.map)(([queuedKeys, nextKeys])=>stashIds.map((stashId, index)=>extractsIds(stashId, queuedKeys, nextKeys[index])))) : (0, _rxjs.of)([]));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ixb2d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Retrieve the staking overview, including elected and points earned
 */ parcelHelpers.export(exports, "overview", ()=>overview);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function overview(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>(0, _rxjs.combineLatest)([
            api.derive.session.indexes(),
            api.derive.staking.validators()
        ]).pipe((0, _rxjs.map)(([indexes, { nextElected , validators  }])=>({
                ...indexes,
                nextElected,
                validators
            }))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bLKlN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_ownExposures", ()=>_ownExposures);
parcelHelpers.export(exports, "ownExposure", ()=>ownExposure);
parcelHelpers.export(exports, "ownExposures", ()=>ownExposures);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _utilJs = require("./util.js");
function _ownExposures(instanceId, api) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return (0, _indexJs.memo)(instanceId, (accountId, eras, _withActive)=>eras.length ? (0, _rxjs.combineLatest)([
            (0, _rxjs.combineLatest)(eras.map((e)=>api.query.staking.erasStakersClipped(e, accountId))),
            (0, _rxjs.combineLatest)(eras.map((e)=>api.query.staking.erasStakers(e, accountId)))
        ]).pipe((0, _rxjs.map)(([clp, exp])=>eras.map((era, index)=>({
                    clipped: clp[index],
                    era,
                    exposure: exp[index]
                })))) : (0, _rxjs.of)([]));
}
const ownExposure = (0, _indexJs.firstMemo)((api, accountId, era)=>api.derive.staking._ownExposures(accountId, [
        era
    ], true));
const ownExposures = (0, _utilJs.erasHistoricApplyAccount)("_ownExposures");

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./util.js":"e5Mnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eeIjB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_ownSlashes", ()=>_ownSlashes);
parcelHelpers.export(exports, "ownSlash", ()=>ownSlash);
parcelHelpers.export(exports, "ownSlashes", ()=>ownSlashes);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _utilJs = require("./util.js");
function _ownSlashes(instanceId, api) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return (0, _indexJs.memo)(instanceId, (accountId, eras, _withActive)=>eras.length ? (0, _rxjs.combineLatest)([
            (0, _rxjs.combineLatest)(eras.map((e)=>api.query.staking.validatorSlashInEra(e, accountId))),
            (0, _rxjs.combineLatest)(eras.map((e)=>api.query.staking.nominatorSlashInEra(e, accountId)))
        ]).pipe((0, _rxjs.map)(([vals, noms])=>eras.map((era, index)=>({
                    era,
                    total: vals[index].isSome ? vals[index].unwrap()[1] : noms[index].unwrapOrDefault()
                })))) : (0, _rxjs.of)([]));
}
const ownSlash = (0, _indexJs.firstMemo)((api, accountId, era)=>api.derive.staking._ownSlashes(accountId, [
        era
    ], true));
const ownSlashes = (0, _utilJs.erasHistoricApplyAccount)("_ownSlashes");

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./util.js":"e5Mnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5npVy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "query", ()=>query);
parcelHelpers.export(exports, "queryMulti", ()=>queryMulti);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, stakingLedgerOpt) {
    return {
        accountId: stashId,
        controllerId: controllerIdOpt && controllerIdOpt.unwrapOr(null),
        exposure,
        nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],
        rewardDestination,
        stakingLedger: stakingLedgerOpt.unwrapOrDefault(),
        stashId,
        validatorPrefs
    };
}
function getLedgers(api, optIds, { withLedger =false  }) {
    const ids = optIds.filter((o)=>withLedger && !!o && o.isSome).map((o)=>o.unwrap());
    const emptyLed = api.registry.createType("Option<StakingLedger>");
    return (ids.length ? (0, _rxjs.combineLatest)(ids.map((s)=>api.query.staking.ledger(s))) : (0, _rxjs.of)([])).pipe((0, _rxjs.map)((optLedgers)=>{
        let offset = -1;
        return optIds.map((o)=>o && o.isSome ? optLedgers[++offset] || emptyLed : emptyLed);
    }));
}
function getStashInfo(api, stashIds, activeEra, { withController , withDestination , withExposure , withLedger , withNominations , withPrefs  }) {
    const emptyNoms = api.registry.createType("Option<Nominations>");
    const emptyRewa = api.registry.createType("RewardDestination");
    const emptyExpo = api.registry.createType("Exposure");
    const emptyPrefs = api.registry.createType("ValidatorPrefs");
    return (0, _rxjs.combineLatest)([
        withController || withLedger ? (0, _rxjs.combineLatest)(stashIds.map((s)=>api.query.staking.bonded(s))) : (0, _rxjs.of)(stashIds.map(()=>null)),
        withNominations ? (0, _rxjs.combineLatest)(stashIds.map((s)=>api.query.staking.nominators(s))) : (0, _rxjs.of)(stashIds.map(()=>emptyNoms)),
        withDestination ? (0, _rxjs.combineLatest)(stashIds.map((s)=>api.query.staking.payee(s))) : (0, _rxjs.of)(stashIds.map(()=>emptyRewa)),
        withPrefs ? (0, _rxjs.combineLatest)(stashIds.map((s)=>api.query.staking.validators(s))) : (0, _rxjs.of)(stashIds.map(()=>emptyPrefs)),
        withExposure ? (0, _rxjs.combineLatest)(stashIds.map((s)=>api.query.staking.erasStakers(activeEra, s))) : (0, _rxjs.of)(stashIds.map(()=>emptyExpo))
    ]);
}
function getBatch(api, activeEra, stashIds, flags) {
    return getStashInfo(api, stashIds, activeEra, flags).pipe((0, _rxjs.switchMap)(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure])=>getLedgers(api, controllerIdOpt, flags).pipe((0, _rxjs.map)((stakingLedgerOpts)=>stashIds.map((stashId, index)=>parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]))))));
} //
const query = (0, _indexJs.firstMemo)((api, accountId, flags)=>api.derive.staking.queryMulti([
        accountId
    ], flags));
function queryMulti(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountIds, flags)=>accountIds.length ? api.derive.session.indexes().pipe((0, _rxjs.switchMap)(({ activeEra  })=>{
            const stashIds = accountIds.map((accountId)=>api.registry.createType("AccountId", accountId));
            return getBatch(api, activeEra, stashIds, flags);
        })) : (0, _rxjs.of)([]));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kxCkY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_stakerExposures", ()=>_stakerExposures);
parcelHelpers.export(exports, "stakerExposures", ()=>stakerExposures);
parcelHelpers.export(exports, "stakerExposure", ()=>stakerExposure);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function _stakerExposures(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountIds, eras, withActive = false)=>{
        const stakerIds = accountIds.map((a)=>api.registry.createType("AccountId", a).toString());
        return api.derive.staking._erasExposure(eras, withActive).pipe((0, _rxjs.map)((exposures)=>stakerIds.map((stakerId)=>exposures.map(({ era , nominators: allNominators , validators: allValidators  })=>{
                    const isValidator = !!allValidators[stakerId];
                    const validators = {};
                    const nominating = allNominators[stakerId] || [];
                    if (isValidator) validators[stakerId] = allValidators[stakerId];
                    else if (nominating) nominating.forEach(({ validatorId  })=>{
                        validators[validatorId] = allValidators[validatorId];
                    });
                    return {
                        era,
                        isEmpty: !Object.keys(validators).length,
                        isValidator,
                        nominating,
                        validators
                    };
                }))));
    });
}
function stakerExposures(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountIds, withActive = false)=>api.derive.staking.erasHistoric(withActive).pipe((0, _rxjs.switchMap)((eras)=>api.derive.staking._stakerExposures(accountIds, eras, withActive))));
}
const stakerExposure = (0, _indexJs.firstMemo)((api, accountId, withActive)=>api.derive.staking.stakerExposures([
        accountId
    ], withActive));

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"84zyw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_stakerPoints", ()=>_stakerPoints);
parcelHelpers.export(exports, "stakerPoints", ()=>stakerPoints);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _utilJs = require("./util.js");
function _stakerPoints(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountId, eras, withActive)=>{
        const stakerId = api.registry.createType("AccountId", accountId).toString();
        return api.derive.staking._erasPoints(eras, withActive).pipe((0, _rxjs.map)((points)=>points.map(({ era , eraPoints , validators  })=>({
                    era,
                    eraPoints,
                    points: validators[stakerId] || api.registry.createType("RewardPoint")
                }))));
    });
}
const stakerPoints = (0, _utilJs.erasHistoricApplyAccount)("_stakerPoints");

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./util.js":"e5Mnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"LSzUF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_stakerPrefs", ()=>_stakerPrefs);
parcelHelpers.export(exports, "stakerPrefs", ()=>stakerPrefs);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _utilJs = require("./util.js");
function _stakerPrefs(instanceId, api) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return (0, _indexJs.memo)(instanceId, (accountId, eras, _withActive)=>api.query.staking.erasValidatorPrefs.multi(eras.map((e)=>[
                e,
                accountId
            ])).pipe((0, _rxjs.map)((all)=>all.map((validatorPrefs, index)=>({
                    era: eras[index],
                    validatorPrefs
                })))));
}
const stakerPrefs = (0, _utilJs.erasHistoricApplyAccount)("_stakerPrefs");

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./util.js":"e5Mnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cQx06":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_stakerRewardsEras", ()=>_stakerRewardsEras);
parcelHelpers.export(exports, "_stakerRewards", ()=>_stakerRewards);
parcelHelpers.export(exports, "stakerRewards", ()=>stakerRewards);
parcelHelpers.export(exports, "stakerRewardsMultiEras", ()=>stakerRewardsMultiEras);
parcelHelpers.export(exports, "stakerRewardsMulti", ()=>stakerRewardsMulti);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
function parseRewards(api, stashId, [erasPoints, erasPrefs, erasRewards], exposures) {
    return exposures.map(({ era , isEmpty , isValidator , nominating , validators: eraValidators  })=>{
        const { eraPoints , validators: allValPoints  } = erasPoints.find((p)=>p.era.eq(era)) || {
            eraPoints: (0, _util.BN_ZERO),
            validators: {}
        };
        const { eraReward  } = erasRewards.find((r)=>r.era.eq(era)) || {
            eraReward: api.registry.createType("Balance")
        };
        const { validators: allValPrefs  } = erasPrefs.find((p)=>p.era.eq(era)) || {
            validators: {}
        };
        const validators = {};
        const stakerId = stashId.toString();
        Object.entries(eraValidators).forEach(([validatorId, exposure])=>{
            var _allValPrefs$validato, _exposure$total;
            const valPoints = allValPoints[validatorId] || (0, _util.BN_ZERO);
            const valComm = ((_allValPrefs$validato = allValPrefs[validatorId]) === null || _allValPrefs$validato === void 0 ? void 0 : _allValPrefs$validato.commission.unwrap()) || (0, _util.BN_ZERO);
            const expTotal = ((_exposure$total = exposure.total) === null || _exposure$total === void 0 ? void 0 : _exposure$total.unwrap()) || (0, _util.BN_ZERO);
            let avail = (0, _util.BN_ZERO);
            let value;
            if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {
                avail = eraReward.mul(valPoints).div(eraPoints);
                const valCut = valComm.mul(avail).div((0, _util.BN_BILLION));
                let staked;
                if (validatorId === stakerId) staked = exposure.own.unwrap();
                else {
                    const stakerExp = exposure.others.find(({ who  })=>who.eq(stakerId));
                    staked = stakerExp ? stakerExp.value.unwrap() : (0, _util.BN_ZERO);
                }
                value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : (0, _util.BN_ZERO));
            }
            validators[validatorId] = {
                total: api.registry.createType("Balance", avail),
                value: api.registry.createType("Balance", value)
            };
        });
        return {
            era,
            eraReward,
            isEmpty,
            isValidator,
            nominating,
            validators
        };
    });
}
function allUniqValidators(rewards) {
    return rewards.reduce(([all, perStash], rewards)=>{
        const uniq = [];
        perStash.push(uniq);
        rewards.forEach(({ validators  })=>Object.keys(validators).forEach((validatorId)=>{
                if (!uniq.includes(validatorId)) {
                    uniq.push(validatorId);
                    if (!all.includes(validatorId)) all.push(validatorId);
                }
            }));
        return [
            all,
            perStash
        ];
    }, [
        [],
        []
    ]);
}
function removeClaimed(validators, queryValidators, reward) {
    const rm = [];
    Object.keys(reward.validators).forEach((validatorId)=>{
        const index = validators.indexOf(validatorId);
        if (index !== -1) {
            const valLedger = queryValidators[index].stakingLedger;
            if (valLedger !== null && valLedger !== void 0 && valLedger.claimedRewards.some((e)=>reward.era.eq(e))) rm.push(validatorId);
        }
    });
    rm.forEach((validatorId)=>{
        delete reward.validators[validatorId];
    });
}
function filterRewards(eras, valInfo, { rewards , stakingLedger  }) {
    const filter = eras.filter((e)=>!stakingLedger.claimedRewards.some((s)=>s.eq(e)));
    const validators = valInfo.map(([v])=>v);
    const queryValidators = valInfo.map(([, q])=>q);
    return rewards.filter(({ isEmpty  })=>!isEmpty).filter((reward)=>{
        if (!filter.some((e)=>reward.era.eq(e))) return false;
        removeClaimed(validators, queryValidators, reward);
        return true;
    }).filter(({ validators  })=>Object.keys(validators).length !== 0).map((reward)=>({
            ...reward,
            nominators: reward.nominating.filter((n)=>reward.validators[n.validatorId])
        }));
}
function _stakerRewardsEras(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (eras, withActive = false)=>(0, _rxjs.combineLatest)([
            api.derive.staking._erasPoints(eras, withActive),
            api.derive.staking._erasPrefs(eras, withActive),
            api.derive.staking._erasRewards(eras, withActive)
        ]));
}
function _stakerRewards(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountIds, eras, withActive = false)=>(0, _rxjs.combineLatest)([
            api.derive.staking.queryMulti(accountIds, {
                withLedger: true
            }),
            api.derive.staking._stakerExposures(accountIds, eras, withActive),
            api.derive.staking._stakerRewardsEras(eras, withActive)
        ]).pipe((0, _rxjs.switchMap)(([queries, exposures, erasResult])=>{
            const allRewards = queries.map(({ stakingLedger , stashId  }, index)=>!stashId || !stakingLedger ? [] : parseRewards(api, stashId, erasResult, exposures[index]));
            if (withActive) return (0, _rxjs.of)(allRewards);
            const [allValidators, stashValidators] = allUniqValidators(allRewards);
            return api.derive.staking.queryMulti(allValidators, {
                withLedger: true
            }).pipe((0, _rxjs.map)((queriedVals)=>queries.map(({ stakingLedger  }, index)=>filterRewards(eras, stashValidators[index].map((validatorId)=>[
                            validatorId,
                            queriedVals.find((q)=>q.accountId.eq(validatorId))
                        ]), {
                        rewards: allRewards[index],
                        stakingLedger
                    }))));
        })));
}
const stakerRewards = (0, _indexJs.firstMemo)((api, accountId, withActive)=>api.derive.staking.erasHistoric(withActive).pipe((0, _rxjs.switchMap)((eras)=>api.derive.staking._stakerRewards([
            accountId
        ], eras, withActive))));
function stakerRewardsMultiEras(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountIds, eras)=>accountIds.length && eras.length ? api.derive.staking._stakerRewards(accountIds, eras, false) : (0, _rxjs.of)([]));
}
function stakerRewardsMulti(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountIds, withActive = false)=>api.derive.staking.erasHistoric(withActive).pipe((0, _rxjs.switchMap)((eras)=>api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5pEhQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_stakerSlashes", ()=>_stakerSlashes);
parcelHelpers.export(exports, "stakerSlashes", ()=>stakerSlashes);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
var _utilJs = require("./util.js");
function _stakerSlashes(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (accountId, eras, withActive)=>{
        const stakerId = api.registry.createType("AccountId", accountId).toString();
        return api.derive.staking._erasSlashes(eras, withActive).pipe((0, _rxjs.map)((slashes)=>slashes.map(({ era , nominators , validators  })=>({
                    era,
                    total: nominators[stakerId] || validators[stakerId] || api.registry.createType("Balance")
                }))));
    });
}
const stakerSlashes = (0, _utilJs.erasHistoricApplyAccount)("_stakerSlashes");

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","./util.js":"e5Mnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g06iW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Retrieve the list of all validator stashes
 */ parcelHelpers.export(exports, "stashes", ()=>stashes);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function onBondedEvent(api) {
    let current = Date.now();
    return api.query.system.events().pipe((0, _rxjs.map)((events)=>{
        current = events.filter(({ event , phase  })=>{
            try {
                return phase.isApplyExtrinsic && event.section === "staking" && event.method === "Bonded";
            } catch  {
                return false;
            }
        }) ? Date.now() : current;
        return current;
    }), (0, _rxjs.startWith)(current), (0, _indexJs.drr)({
        skipTimeout: true
    }));
}
function stashes(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>onBondedEvent(api).pipe((0, _rxjs.switchMap)(()=>api.query.staking.validators.keys()), (0, _rxjs.map)((keys)=>keys.map(({ args: [v]  })=>v).filter((a)=>a))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"afojG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nextElected", ()=>nextElected);
/**
 * @description Retrieve latest list of validators
 */ parcelHelpers.export(exports, "validators", ()=>validators);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function nextElected(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.query.staking.erasStakers ? api.derive.session.indexes().pipe(// subscriptions, so we need a trigger - currentIndex acts as that trigger to refresh
        (0, _rxjs.switchMap)(({ currentEra  })=>api.query.staking.erasStakers.keys(currentEra)), (0, _rxjs.map)((keys)=>keys.map(({ args: [, accountId]  })=>accountId))) : api.query.staking.currentElected());
}
function validators(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>// in all actual real-world deployed chains, it does create some confusion for limited template chains
        (0, _rxjs.combineLatest)([
            api.query.session ? api.query.session.validators() : (0, _rxjs.of)([]),
            api.query.staking ? api.derive.staking.nextElected() : (0, _rxjs.of)([])
        ]).pipe((0, _rxjs.map)(([validators, nextElected])=>({
                nextElected: nextElected.length ? nextElected : validators,
                validators
            }))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e1Gl2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "waitingInfo", ()=>waitingInfo);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
const DEFAULT_FLAGS = {
    withController: true,
    withPrefs: true
};
function waitingInfo(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (flags = DEFAULT_FLAGS)=>(0, _rxjs.combineLatest)([
            api.derive.staking.validators(),
            api.derive.staking.stashes()
        ]).pipe((0, _rxjs.switchMap)(([{ nextElected  }, stashes])=>{
            const elected = nextElected.map((a)=>a.toString());
            const waiting = stashes.filter((v)=>!elected.includes(v.toString()));
            return api.derive.staking.queryMulti(waiting, flags).pipe((0, _rxjs.map)((info)=>({
                    info,
                    waiting
                })));
        })));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1wdIE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "members", ()=>members);
parcelHelpers.export(exports, "hasProposals", ()=>hasProposals);
parcelHelpers.export(exports, "proposal", ()=>proposal);
parcelHelpers.export(exports, "proposalCount", ()=>proposalCount);
parcelHelpers.export(exports, "proposalHashes", ()=>proposalHashes);
parcelHelpers.export(exports, "proposals", ()=>proposals);
parcelHelpers.export(exports, "prime", ()=>prime);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _indexJs = require("../collective/index.js");
const members = (0, _indexJs.members)("technicalCommittee");
const hasProposals = (0, _indexJs.hasProposals)("technicalCommittee");
const proposal = (0, _indexJs.proposal)("technicalCommittee");
const proposalCount = (0, _indexJs.proposalCount)("technicalCommittee");
const proposalHashes = (0, _indexJs.proposalHashes)("technicalCommittee");
const proposals = (0, _indexJs.proposals)("technicalCommittee");
const prime = (0, _indexJs.prime)("technicalCommittee");

},{"../collective/index.js":"8aK0Q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d9FCT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _proposalsJs = require("./proposals.js");
parcelHelpers.exportAll(_proposalsJs, exports);

},{"./proposals.js":"epjul","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"epjul":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Retrieve all active and approved treasury proposals, along with their info
 */ parcelHelpers.export(exports, "proposals", ()=>proposals);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function parseResult(api, { allIds , allProposals , approvalIds , councilProposals , proposalCount  }) {
    const approvals = [];
    const proposals = [];
    const councilTreasury = councilProposals.filter(({ proposal  })=>proposal && (api.tx.treasury.approveProposal.is(proposal) || api.tx.treasury.rejectProposal.is(proposal)));
    allIds.forEach((id, index)=>{
        if (allProposals[index].isSome) {
            const council = councilTreasury.filter(({ proposal  })=>proposal && id.eq(proposal.args[0])).sort((a, b)=>a.proposal && b.proposal ? a.proposal.method.localeCompare(b.proposal.method) : a.proposal ? -1 : 1);
            const isApproval = approvalIds.some((approvalId)=>approvalId.eq(id));
            const derived = {
                council,
                id,
                proposal: allProposals[index].unwrap()
            };
            if (isApproval) approvals.push(derived);
            else proposals.push(derived);
        }
    });
    return {
        approvals,
        proposalCount,
        proposals
    };
}
function retrieveProposals(api, proposalCount, approvalIds) {
    const proposalIds = [];
    const count = proposalCount.toNumber();
    for(let index = 0; index < count; index++)if (!approvalIds.some((id)=>id.eqn(index))) proposalIds.push(api.registry.createType("ProposalIndex", index));
    const allIds = [
        ...proposalIds,
        ...approvalIds
    ];
    return (0, _rxjs.combineLatest)([
        api.query.treasury.proposals.multi(allIds),
        api.derive.council ? api.derive.council.proposals() : (0, _rxjs.of)([])
    ]).pipe((0, _rxjs.map)(([allProposals, councilProposals])=>parseResult(api, {
            allIds,
            allProposals,
            approvalIds,
            councilProposals,
            proposalCount
        })));
}
function proposals(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, ()=>api.query.treasury ? (0, _rxjs.combineLatest)([
            api.query.treasury.proposalCount(),
            api.query.treasury.approvals()
        ]).pipe((0, _rxjs.switchMap)(([proposalCount, approvalIds])=>retrieveProposals(api, proposalCount, approvalIds))) : (0, _rxjs.of)({
            approvals: [],
            proposalCount: api.registry.createType("ProposalIndex"),
            proposals: []
        }));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3OoHL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _eventsJs = require("./events.js");
parcelHelpers.exportAll(_eventsJs, exports);
var _signingInfoJs = require("./signingInfo.js");
parcelHelpers.exportAll(_signingInfoJs, exports);

},{"./events.js":"heRv0","./signingInfo.js":"5Dmzx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"heRv0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "events", ()=>events);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _indexJs = require("../util/index.js");
function events(instanceId, api) {
    return (0, _indexJs.memo)(instanceId, (blockHash)=>(0, _rxjs.combineLatest)([
            api.rpc.chain.getBlock(blockHash),
            api.queryAt(blockHash).pipe((0, _rxjs.switchMap)((queryAt)=>queryAt.system.events()))
        ]).pipe((0, _rxjs.map)(([block, events])=>({
                block,
                events
            }))));
}

},{"rxjs":"lLy7s","../util/index.js":"cN7tY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Dmzx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signingInfo", ()=>signingInfo);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../util/index.js");
var _constantsJs = require("./constants.js");
function latestNonce(api, address) {
    return api.derive.balances.account(address).pipe((0, _rxjs.map)(({ accountNonce  })=>accountNonce));
}
function nextNonce(api, address) {
    var _api$rpc$system;
    return (_api$rpc$system = api.rpc.system) !== null && _api$rpc$system !== void 0 && _api$rpc$system.accountNextIndex ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);
}
function signingHeader(api) {
    return (0, _rxjs.combineLatest)([
        api.rpc.chain.getHeader().pipe((0, _rxjs.switchMap)((header)=>// we do need to allow transactions at chain start (also dev/seal chains)
            header.parentHash.isEmpty ? (0, _rxjs.of)(header) // in the case of the current block, we use the parent to minimize the
             : api.rpc.chain.getHeader(header.parentHash))),
        api.rpc.chain.getFinalizedHead().pipe((0, _rxjs.switchMap)((hash)=>api.rpc.chain.getHeader(hash)))
    ]).pipe((0, _rxjs.map)(([current, finalized])=>(0, _indexJs.unwrapBlockNumber)(current).sub((0, _indexJs.unwrapBlockNumber)(finalized)).gt((0, _constantsJs.MAX_FINALITY_LAG)) ? current : finalized));
}
function signingInfo(_instanceId, api) {
    // no memo, we want to do this fresh on each run
    return (address, nonce, era)=>(0, _rxjs.combineLatest)([
            (0, _util.isUndefined)(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : (0, _rxjs.of)(api.registry.createType("Index", nonce)),
            (0, _util.isUndefined)(era) || (0, _util.isNumber)(era) && era > 0 ? signingHeader(api) : (0, _rxjs.of)(null)
        ]).pipe((0, _rxjs.map)(([nonce, header])=>{
            var _api$consts$system, _api$consts$system$bl, _api$consts$babe, _api$consts$timestamp;
            return {
                header,
                mortalLength: Math.min(((_api$consts$system = api.consts.system) === null || _api$consts$system === void 0 ? void 0 : (_api$consts$system$bl = _api$consts$system.blockHashCount) === null || _api$consts$system$bl === void 0 ? void 0 : _api$consts$system$bl.toNumber()) || (0, _constantsJs.FALLBACK_MAX_HASH_COUNT), (0, _constantsJs.MORTAL_PERIOD).div(((_api$consts$babe = api.consts.babe) === null || _api$consts$babe === void 0 ? void 0 : _api$consts$babe.expectedBlockTime) || ((_api$consts$timestamp = api.consts.timestamp) === null || _api$consts$timestamp === void 0 ? void 0 : _api$consts$timestamp.minimumPeriod.muln(2)) || (0, _constantsJs.FALLBACK_PERIOD)).iadd((0, _constantsJs.MAX_FINALITY_LAG)).toNumber()),
                nonce
            };
        }));
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../util/index.js":"cN7tY","./constants.js":"9rYUA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9rYUA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FALLBACK_MAX_HASH_COUNT", ()=>FALLBACK_MAX_HASH_COUNT);
parcelHelpers.export(exports, "FALLBACK_PERIOD", ()=>FALLBACK_PERIOD);
parcelHelpers.export(exports, "MAX_FINALITY_LAG", ()=>MAX_FINALITY_LAG);
parcelHelpers.export(exports, "MORTAL_PERIOD", ()=>MORTAL_PERIOD);
// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const FALLBACK_MAX_HASH_COUNT = 250; // default here to 5 min eras, adjusted based on the actual blocktime
const FALLBACK_PERIOD = new (0, _util.BN)(6000);
const MAX_FINALITY_LAG = new (0, _util.BN)(5);
const MORTAL_PERIOD = new (0, _util.BN)(300000);

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a7ljv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterEvents", ()=>filterEvents);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _loggingJs = require("./logging.js");
function filterEvents(txHash, { block: { extrinsics , header  }  }, allEvents, status) {
    // extrinsics to hashes
    for (const [txIndex, x] of extrinsics.entries()){
        if (x.hash.eq(txHash)) return {
            events: allEvents.filter(({ phase  })=>phase.isApplyExtrinsic && phase.asApplyExtrinsic.eqn(txIndex)),
            txIndex
        };
    } // if we do get the block after finalized, it _should_ be there
    // only warn on filtering with isInBlock (finalization finalizes after)
    if (status.isInBlock) {
        const allHashes = extrinsics.map((x)=>x.hash.toHex());
        (0, _loggingJs.l).warn(`block ${header.hash.toHex()}: Unable to find extrinsic ${txHash.toHex()} inside ${allHashes.join(", ")}`);
    }
    return {};
}

},{"./logging.js":"fpxQ9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fpxQ9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "l", ()=>l);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const l = (0, _util.logger)("api/util");

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"zbWpQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isKeyringPair", ()=>isKeyringPair);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function isKeyringPair(account) {
    return (0, _util.isFunction)(account.sign);
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFTVd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SubmittableResult", ()=>SubmittableResult);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
const recordIdentity = (record)=>record;
function filterAndApply(events, section, methods, onFound) {
    return events.filter(({ event  })=>section === event.section && methods.includes(event.method)).map((record)=>onFound(record));
}
function getDispatchError({ event: { data: [dispatchError]  }  }) {
    return dispatchError;
}
function getDispatchInfo({ event: { data , method  }  }) {
    return method === "ExtrinsicSuccess" ? data[0] : data[1];
}
function extractError(events = []) {
    return filterAndApply(events, "system", [
        "ExtrinsicFailed"
    ], getDispatchError)[0];
}
function extractInfo(events = []) {
    return filterAndApply(events, "system", [
        "ExtrinsicFailed",
        "ExtrinsicSuccess"
    ], getDispatchInfo)[0];
}
class SubmittableResult {
    constructor({ dispatchError , dispatchInfo , events , internalError , status , txHash , txIndex  }){
        this.dispatchError = dispatchError || extractError(events);
        this.dispatchInfo = dispatchInfo || extractInfo(events);
        this.events = events || [];
        this.internalError = internalError;
        this.status = status;
        this.txHash = txHash;
        this.txIndex = txIndex;
    }
    get isCompleted() {
        return this.isError || this.status.isInBlock || this.status.isFinalized;
    }
    get isError() {
        return this.status.isDropped || this.status.isFinalityTimeout || this.status.isInvalid || this.status.isUsurped;
    }
    get isFinalized() {
        return this.status.isFinalized;
    }
    get isInBlock() {
        return this.status.isInBlock;
    }
    get isWarning() {
        return this.status.isRetracted;
    }
    /**
   * @description Filters EventRecords for the specified method & section (there could be multiple)
   */ filterRecords(section, method) {
        return filterAndApply(this.events, section, Array.isArray(method) ? method : [
            method
        ], recordIdentity);
    }
    /**
   * @description Finds an EventRecord for the specified method & section
   */ findRecord(section, method) {
        return this.filterRecords(section, method)[0];
    }
    /**
   * @description Creates a human representation of the output
   */ toHuman(isExtended) {
        var _this$dispatchError, _this$dispatchInfo, _this$internalError;
        return {
            dispatchError: (_this$dispatchError = this.dispatchError) === null || _this$dispatchError === void 0 ? void 0 : _this$dispatchError.toHuman(),
            dispatchInfo: (_this$dispatchInfo = this.dispatchInfo) === null || _this$dispatchInfo === void 0 ? void 0 : _this$dispatchInfo.toHuman(),
            events: this.events.map((e)=>e.toHuman(isExtended)),
            internalError: (_this$internalError = this.internalError) === null || _this$internalError === void 0 ? void 0 : _this$internalError.message.toString(),
            status: this.status.toHuman(isExtended)
        };
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7tNjd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "ApiPromise", ()=>(0, _apiJs.ApiPromise));
parcelHelpers.export(exports, "toPromiseMethod", ()=>(0, _decorateMethodJs.toPromiseMethod));
var _apiJs = require("./Api.js");
var _decorateMethodJs = require("./decorateMethod.js");

},{"./Api.js":"cNZEW","./decorateMethod.js":"d0NEl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cNZEW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * # @polkadot/api/promise
 *
 * ## Overview
 *
 * @name ApiPromise
 * @description
 * ApiPromise is a standard JavaScript wrapper around the RPC and interfaces on the Polkadot network. As a full Promise-based, all interface calls return Promises, including the static `.create(...)`. Subscription calls utilise `(value) => {}` callbacks to pass through the latest values.
 *
 * The API is well suited to real-time applications where either the single-shot state is needed or use is to be made of the subscription-based features of Polkadot (and Substrate) clients.
 *
 * @see [[ApiRx]]
 *
 * ## Usage
 *
 * Making rpc calls -
 * <BR>
 *
 * ```javascript
 * import ApiPromise from '@polkadot/api/promise';
 *
 * // initialise via static create
 * const api = await ApiPromise.create();
 *
 * // make a subscription to the network head
 * api.rpc.chain.subscribeNewHeads((header) => {
 *   console.log(`Chain is at #${header.number}`);
 * });
 * ```
 * <BR>
 *
 * Subscribing to chain state -
 * <BR>
 *
 * ```javascript
 * import { ApiPromise, WsProvider } from '@polkadot/api';
 *
 * // initialise a provider with a specific endpoint
 * const provider = new WsProvider('wss://example.com:9944')
 *
 * // initialise via isReady & new with specific provider
 * const api = await new ApiPromise({ provider }).isReady;
 *
 * // retrieve the block target time
 * const blockPeriod = await api.query.timestamp.blockPeriod().toNumber();
 * let last = 0;
 *
 * // subscribe to the current block timestamp, updates automatically (callback provided)
 * api.query.timestamp.now((timestamp) => {
 *   const elapsed = last
 *     ? `, ${timestamp.toNumber() - last}s since last`
 *     : '';
 *
 *   last = timestamp.toNumber();
 *   console.log(`timestamp ${timestamp}${elapsed} (${blockPeriod}s target)`);
 * });
 * ```
 * <BR>
 *
 * Submitting a transaction -
 * <BR>
 *
 * ```javascript
 * import ApiPromise from '@polkadot/api/promise';
 *
 * ApiPromise.create().then((api) => {
 *   const [nonce] = await api.query.system.account(keyring.alice.address);
 *
 *   api.tx.balances
 *     // create transfer
 *     transfer(keyring.bob.address, 12345)
 *     // sign the transcation
 *     .sign(keyring.alice, { nonce })
 *     // send the transaction (optional status callback)
 *     .send((status) => {
 *       console.log(`current status ${status.type}`);
 *     })
 *     // retrieve the submitted extrinsic hash
 *     .then((hash) => {
 *       console.log(`submitted with hash ${hash}`);
 *     });
 * });
 * ```
 */ parcelHelpers.export(exports, "ApiPromise", ()=>ApiPromise);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("../base/index.js");
var _combinatorJs = require("./Combinator.js");
var _decorateMethodJs = require("./decorateMethod.js");
class ApiPromise extends (0, _indexJs.ApiBase) {
    #isReadyPromise;
    #isReadyOrErrorPromise;
    /**
   * @description Creates an instance of the ApiPromise class
   * @param options Options to create an instance. This can be either [[ApiOptions]] or
   * an [[WsProvider]].
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * new Api().isReady.then((api) => {
   *   api.rpc.subscribeNewHeads((header) => {
   *     console.log(`new block #${header.number.toNumber()}`);
   *   });
   * });
   * ```
   */ constructor(options){
        super(options, "promise", (0, _decorateMethodJs.toPromiseMethod));
        this.#isReadyPromise = new Promise((resolve)=>{
            super.once("ready", ()=>resolve(this));
        });
        this.#isReadyOrErrorPromise = new Promise((resolve, reject)=>{
            const tracker = (0, _decorateMethodJs.promiseTracker)(resolve, reject);
            super.once("ready", ()=>tracker.resolve(this));
            super.once("error", (error)=>tracker.reject(error));
        });
    }
    /**
   * @description Creates an ApiPromise instance using the supplied provider. Returns an Promise containing the actual Api instance.
   * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or a
   * provider (see the constructor arguments)
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * Api.create().then(async (api) => {
   *   const timestamp = await api.query.timestamp.now();
   *
   *   console.log(`lastest block timestamp ${timestamp}`);
   * });
   * ```
   */ static create(options) {
        const instance = new ApiPromise(options);
        if (options && options.throwOnConnect) return instance.isReadyOrError;
         // Swallow any rejections on isReadyOrError
        // (in Node 15.x this creates issues, when not being looked at)
        instance.isReadyOrError.catch(()=>{});
        return instance.isReady;
    }
    /**
   * @description Promise that resolves the first time we are connected and loaded
   */ get isReady() {
        return this.#isReadyPromise;
    }
    /**
   * @description Promise that resolves if we can connect, or reject if there is an error
   */ get isReadyOrError() {
        return this.#isReadyOrErrorPromise;
    }
    /**
   * @description Returns a clone of this ApiPromise instance (new underlying provider connection)
   */ clone() {
        return new ApiPromise((0, _util.objectSpread)({}, this._options, {
            source: this
        }));
    }
    /**
   * @description Creates a combinator that can be used to combine the latest results from multiple subscriptions
   * @param fns An array of function to combine, each in the form of `(cb: (value: void)) => void`
   * @param callback A callback that will return an Array of all the values this combinator has been applied to
   * @example
   * <BR>
   *
   * ```javascript
   * const address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFacT7';
   *
   * // combines values from balance & nonce as it updates
   * api.combineLatest([
   *   api.rpc.chain.subscribeNewHeads,
   *   (cb) => api.query.system.account(address, cb)
   * ], ([head, [balance, nonce]]) => {
   *   console.log(`#${head.number}: You have ${balance.free} units, with ${nonce} transactions sent`);
   * });
   * ```
   */ // eslint-disable-next-line @typescript-eslint/require-await
    async combineLatest(fns, callback) {
        const combinator = new (0, _combinatorJs.Combinator)(fns, callback);
        return ()=>{
            combinator.unsubscribe();
        };
    }
}

},{"@polkadot/util":"3HnHw","../base/index.js":"6OpH1","./Combinator.js":"2zQtY","./decorateMethod.js":"d0NEl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6OpH1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ApiBase", ()=>ApiBase);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _gettersJs = require("./Getters.js");
class ApiBase extends (0, _gettersJs.Getters) {
    /**
   * @description Create an instance of the class
   *
   * @param options Options object to create API instance or a Provider instance
   *
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * const api = new Api().isReady();
   *
   * api.rpc.subscribeNewHeads((header) => {
   *   console.log(`new block #${header.number.toNumber()}`);
   * });
   * ```
   */ constructor(options = {}, type, decorateMethod){
        super(options, type, decorateMethod);
    }
    /**
   * @description Connect from the underlying provider, halting all network traffic
   */ connect() {
        return this._rpcCore.connect();
    }
    /**
   * @description Disconnect from the underlying provider, halting all network traffic
   */ disconnect() {
        this._unsubscribe();
        return this._rpcCore.disconnect();
    }
    /**
   * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair
   */ setSigner(signer) {
        this._rx.signer = signer;
    }
    /**
   * @description Signs a raw signer payload, string or Uint8Array
   */ async sign(address, data, { signer  } = {}) {
        if ((0, _util.isString)(address)) {
            const _signer = signer || this._rx.signer;
            if (!_signer || !_signer.signRaw) throw new Error("No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.");
            return (await _signer.signRaw((0, _util.objectSpread)({
                type: "bytes"
            }, data, {
                address
            }))).signature;
        }
        return (0, _util.u8aToHex)(address.sign((0, _util.u8aToU8a)(data.data)));
    }
}

},{"@polkadot/util":"3HnHw","./Getters.js":"c8fYP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c8fYP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Getters", ()=>Getters);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfoJs = require("../packageInfo.js");
var _findJs = require("./find.js");
var _initJs = require("./Init.js");
function assertResult(value) {
    if (value === undefined) throw new Error("Api interfaces needs to be initialized before using, wait for 'isReady'");
    return value;
}
class Getters extends (0, _initJs.Init) {
    /**
   * @description Runtime call interfaces (currently untyped, only decorated via API options)
   */ get call() {
        return assertResult(this._call);
    }
    /**
   * @description Contains the parameter types (constants) of all modules.
   *
   * The values are instances of the appropriate type and are accessible using `section`.`constantName`,
   *
   * @example
   * <BR>
   *
   * ```javascript
   * console.log(api.consts.democracy.enactmentPeriod.toString())
   * ```
   */ get consts() {
        return assertResult(this._consts);
    }
    /**
   * @description Derived results that are injected into the API, allowing for combinations of various query results.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.derive.chain.bestNumber((number) => {
   *   console.log('best number', number);
   * });
   * ```
   */ get derive() {
        return assertResult(this._derive);
    }
    /**
   * @description Errors from metadata
   */ get errors() {
        return assertResult(this._errors);
    }
    /**
   * @description Events from metadata
   */ get events() {
        return assertResult(this._events);
    }
    /**
   * @description  Returns the version of extrinsics in-use on this chain
   */ get extrinsicVersion() {
        return this._extrinsicType;
    }
    /**
   * @description Contains the genesis Hash of the attached chain. Apart from being useful to determine the actual chain, it can also be used to sign immortal transactions.
   */ get genesisHash() {
        return assertResult(this._genesisHash);
    }
    /**
   * @description true is the underlying provider is connected
   */ get isConnected() {
        return this._isConnected.getValue();
    }
    /**
   * @description The library information name & version (from package.json)
   */ get libraryInfo() {
        return `${(0, _packageInfoJs.packageInfo).name} v${(0, _packageInfoJs.packageInfo).version}`;
    }
    /**
   * @description Contains all the chain state modules and their subsequent methods in the API. These are attached dynamically from the runtime metadata.
   *
   * All calls inside the namespace, is denoted by `section`.`method` and may take an optional query parameter. As an example, `api.query.timestamp.now()` (current block timestamp) does not take parameters, while `api.query.system.account(<accountId>)` (retrieving the associated nonce & balances for an account), takes the `AccountId` as a parameter.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.query.system.account(<accountId>, ([nonce, balance]) => {
   *   console.log('new free balance', balance.free, 'new nonce', nonce);
   * });
   * ```
   */ get query() {
        return assertResult(this._query);
    }
    /**
   * @description Allows for the querying of multiple storage entries and the combination thereof into a single result. This is a very optimal way to make multiple queries since it only makes a single connection to the node and retrieves the data over one subscription.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const unsub = await api.queryMulti(
   *   [
   *     // you can include the storage without any parameters
   *     api.query.balances.totalIssuance,
   *     // or you can pass parameters to the storage query
   *     [api.query.system.account, '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY']
   *   ],
   *   ([existential, [, { free }]]) => {
   *     console.log(`You have ${free.sub(existential)} more than the existential deposit`);
   *
   *     unsub();
   *   }
   * );
   * ```
   */ get queryMulti() {
        return assertResult(this._queryMulti);
    }
    /**
   * @description Contains all the raw rpc sections and their subsequent methods in the API as defined by the jsonrpc interface definitions. Unlike the dynamic `api.query` and `api.tx` sections, these methods are fixed (although extensible with node upgrades) and not determined by the runtime.
   *
   * RPC endpoints available here allow for the query of chain, node and system information, in addition to providing interfaces for the raw queries of state (using known keys) and the submission of transactions.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.rpc.chain.subscribeNewHeads((header) => {
   *   console.log('new header', header);
   * });
   * ```
   */ get rpc() {
        return assertResult(this._rpc);
    }
    /**
   * @description Contains the chain information for the current node.
   */ get runtimeChain() {
        return assertResult(this._runtimeChain);
    }
    /**
   * @description Yields the current attached runtime metadata. Generally this is only used to construct extrinsics & storage, but is useful for current runtime inspection.
   */ get runtimeMetadata() {
        return assertResult(this._runtimeMetadata);
    }
    /**
   * @description Contains the version information for the current runtime.
   */ get runtimeVersion() {
        return assertResult(this._runtimeVersion);
    }
    /**
   * @description The underlying Rx API interface
   */ get rx() {
        return assertResult(this._rx);
    }
    /**
   * @description Returns the underlying provider stats
   */ get stats() {
        return this._rpcCore.provider.stats;
    }
    /**
   * @description The type of this API instance, either 'rxjs' or 'promise'
   */ get type() {
        return this._type;
    }
    /**
   * @description Contains all the extrinsic modules and their subsequent methods in the API. It allows for the construction of transactions and the submission thereof. These are attached dynamically from the runtime metadata.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.tx.balances
   *   .transfer(<recipientId>, <balance>)
   *   .signAndSend(<keyPair>, ({status}) => {
   *     console.log('tx status', status.asFinalized.toHex());
   *   });
   * ```
   */ get tx() {
        return assertResult(this._extrinsics);
    }
    /**
   * @description Finds the definition for a specific [[CallFunction]] based on the index supplied
   */ findCall(callIndex) {
        return (0, _findJs.findCall)(this.registry, callIndex);
    }
    /**
   * @description Finds the definition for a specific [[RegistryError]] based on the index supplied
   */ findError(errorIndex) {
        return (0, _findJs.findError)(this.registry, errorIndex);
    }
}

},{"../packageInfo.js":"1czuv","./find.js":"kXUDO","./Init.js":"iyjrQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXUDO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "findCall", ()=>findCall);
parcelHelpers.export(exports, "findError", ()=>findError);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function findCall(registry, callIndex) {
    return registry.findMetaCall((0, _util.u8aToU8a)(callIndex));
}
function findError(registry, errorIndex) {
    return registry.findMetaError((0, _util.u8aToU8a)(errorIndex));
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iyjrQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Init", ()=>Init);
var _classPrivateFieldLooseBase = require("@babel/runtime/helpers/esm/classPrivateFieldLooseBase");
var _classPrivateFieldLooseBaseDefault = parcelHelpers.interopDefault(_classPrivateFieldLooseBase);
var _classPrivateFieldLooseKey = require("@babel/runtime/helpers/esm/classPrivateFieldLooseKey");
var _classPrivateFieldLooseKeyDefault = parcelHelpers.interopDefault(_classPrivateFieldLooseKey);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _types = require("@polkadot/types");
var _typesKnown = require("@polkadot/types-known");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _decorateJs = require("./Decorate.js");
const KEEPALIVE_INTERVAL = 10000;
const l = (0, _util.logger)("api/init");
function textToString(t) {
    return t.toString();
}
var _healthTimer = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("healthTimer");
var _registries = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("registries");
var _updateSub = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("updateSub");
var _waitingRegistries = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("waitingRegistries");
var _onProviderConnect = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("onProviderConnect");
var _onProviderDisconnect = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("onProviderDisconnect");
var _onProviderError = /*#__PURE__*/ (0, _classPrivateFieldLooseKeyDefault.default)("onProviderError");
class Init extends (0, _decorateJs.Decorate) {
    constructor(options, type, decorateMethod){
        super(options, type, decorateMethod); // all injected types added to the registry for overrides
        Object.defineProperty(this, _onProviderError, {
            value: _onProviderError2
        });
        Object.defineProperty(this, _onProviderDisconnect, {
            value: _onProviderDisconnect2
        });
        Object.defineProperty(this, _onProviderConnect, {
            value: _onProviderConnect2
        });
        Object.defineProperty(this, _healthTimer, {
            writable: true,
            value: null
        });
        Object.defineProperty(this, _registries, {
            writable: true,
            value: []
        });
        Object.defineProperty(this, _updateSub, {
            writable: true,
            value: null
        });
        Object.defineProperty(this, _waitingRegistries, {
            writable: true,
            value: {}
        });
        this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.
        // Do right up-front, so we get in the user types before we are actually
        // doing anything on-chain, this ensures we have the overrides in-place
        if (!options.source) this.registerTypes(options.types);
        else (0, _classPrivateFieldLooseBaseDefault.default)(this, _registries)[_registries] = (0, _classPrivateFieldLooseBaseDefault.default)(options.source, _registries)[_registries];
        this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);
        this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);
        if (this.supportMulti) {
            this._queryMulti = this._decorateMulti(this._decorateMethod);
            this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);
        }
        this._rx.signer = options.signer;
        this._rpcCore.setRegistrySwap((blockHash)=>this.getBlockRegistry(blockHash));
        this._rpcCore.setResolveBlockHash((blockNumber)=>(0, _rxjs.firstValueFrom)(this._rpcCore.chain.getBlockHash(blockNumber)));
        if (this.hasSubscriptions) {
            this._rpcCore.provider.on("disconnected", ()=>(0, _classPrivateFieldLooseBaseDefault.default)(this, _onProviderDisconnect)[_onProviderDisconnect]());
            this._rpcCore.provider.on("error", (e)=>(0, _classPrivateFieldLooseBaseDefault.default)(this, _onProviderError)[_onProviderError](e));
            this._rpcCore.provider.on("connected", ()=>(0, _classPrivateFieldLooseBaseDefault.default)(this, _onProviderConnect)[_onProviderConnect]());
        } else l.warn("Api will be available in a limited mode since the provider does not support subscriptions");
         // If the provider was instantiated earlier, and has already emitted a
        // 'connected' event, then the `on('connected')` won't fire anymore. To
        // cater for this case, we call manually `this._onProviderConnect`.
        if (this._rpcCore.provider.isConnected) // eslint-disable-next-line @typescript-eslint/no-floating-promises
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _onProviderConnect)[_onProviderConnect]();
    }
    /**
   * @description Decorates a registry based on the runtime version
   */ _initRegistry(registry, chain, version, metadata, chainProps) {
        registry.clearCache();
        registry.setChainProperties(chainProps || this.registry.getChainProperties());
        registry.setKnownTypes(this._options);
        registry.register((0, _typesKnown.getSpecTypes)(registry, chain, version.specName, version.specVersion));
        registry.setHasher((0, _typesKnown.getSpecHasher)(registry, chain, version.specName)); // for bundled types, pull through the aliases defined
        if (registry.knownTypes.typesBundle) registry.knownTypes.typesAlias = (0, _typesKnown.getSpecAlias)(registry, chain, version.specName);
        registry.setMetadata(metadata, undefined, (0, _util.objectSpread)({}, (0, _typesKnown.getSpecExtensions)(registry, chain, version.specName), this._options.signedExtensions));
    }
    /**
   * @description Returns the default versioned registry
   */ _getDefaultRegistry() {
        return (0, _util.assertReturn)((0, _classPrivateFieldLooseBaseDefault.default)(this, _registries)[_registries].find(({ isDefault  })=>isDefault), "Initialization error, cannot find the default registry");
    }
    /**
   * @description Returns a decorated API instance at a specific point in time
   */ async at(blockHash, knownVersion) {
        const u8aHash = (0, _util.u8aToU8a)(blockHash);
        const registry = await this.getBlockRegistry(u8aHash, knownVersion); // always create a new decoration - since we are pointing to a specific hash, this
        // means that all queries needs to use that hash (not a previous one already existing)
        return this._createDecorated(registry, true, null, u8aHash).decoratedApi;
    }
    async _createBlockRegistry(blockHash, header, version) {
        const registry = new (0, _types.TypeRegistry)(blockHash);
        const metadata = new (0, _types.Metadata)(registry, await (0, _rxjs.firstValueFrom)(this._rpcCore.state.getMetadata.raw(header.parentHash)));
        this._initRegistry(registry, this._runtimeChain, version, metadata); // add our new registry
        const result = {
            lastBlockHash: blockHash,
            metadata,
            registry,
            runtimeVersion: version
        };
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _registries)[_registries].push(result);
        return result;
    }
    _cacheBlockRegistryProgress(key, creator) {
        // look for waiting resolves
        let waiting = (0, _classPrivateFieldLooseBaseDefault.default)(this, _waitingRegistries)[_waitingRegistries][key];
        if ((0, _util.isUndefined)(waiting)) // nothing waiting, construct new
        waiting = (0, _classPrivateFieldLooseBaseDefault.default)(this, _waitingRegistries)[_waitingRegistries][key] = new Promise((resolve, reject)=>{
            creator().then((registry)=>{
                delete (0, _classPrivateFieldLooseBaseDefault.default)(this, _waitingRegistries)[_waitingRegistries][key];
                resolve(registry);
            }).catch((error)=>{
                delete (0, _classPrivateFieldLooseBaseDefault.default)(this, _waitingRegistries)[_waitingRegistries][key];
                reject(error);
            });
        });
        return waiting;
    }
    _getBlockRegistryViaVersion(blockHash, version) {
        if (version) {
            // check for pre-existing registries. We also check specName, e.g. it
            // could be changed like in Westmint with upgrade from shell -> westmint
            const existingViaVersion = (0, _classPrivateFieldLooseBaseDefault.default)(this, _registries)[_registries].find(({ runtimeVersion: { specName , specVersion  }  })=>specName.eq(version.specName) && specVersion.eq(version.specVersion));
            if (existingViaVersion) {
                existingViaVersion.lastBlockHash = blockHash;
                return existingViaVersion;
            }
        }
        return null;
    }
    async _getBlockRegistryViaHash(blockHash) {
        // ensure we have everything required
        if (!this._genesisHash || !this._runtimeVersion) throw new Error("Cannot retrieve data on an uninitialized chain");
         // We have to assume that on the RPC layer the calls used here does not call back into
        // the registry swap, so getHeader & getRuntimeVersion should not be historic
        const header = this.registry.createType("HeaderPartial", this._genesisHash.eq(blockHash) ? {
            number: (0, _util.BN_ZERO),
            parentHash: this._genesisHash
        } : await (0, _rxjs.firstValueFrom)(this._rpcCore.chain.getHeader.raw(blockHash)));
        if (header.parentHash.isEmpty) throw new Error("Unable to retrieve header and parent from supplied hash");
         // get the runtime version, either on-chain or via an known upgrade history
        const [firstVersion, lastVersion] = (0, _typesKnown.getUpgradeVersion)(this._genesisHash, header.number);
        const version = this.registry.createType("RuntimeVersionPartial", firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {
            specName: this._runtimeVersion.specName,
            specVersion: firstVersion.specVersion
        } : await (0, _rxjs.firstValueFrom)(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));
        return this._getBlockRegistryViaVersion(blockHash, version) || await this._cacheBlockRegistryProgress(version.toHex(), ()=>this._createBlockRegistry(blockHash, header, version));
    }
    /**
   * @description Sets up a registry based on the block hash defined
   */ async getBlockRegistry(blockHash, knownVersion) {
        return (0, _classPrivateFieldLooseBaseDefault.default)(this, _registries)[_registries].find(({ lastBlockHash  })=>lastBlockHash && (0, _util.u8aEq)(lastBlockHash, blockHash)) || this._getBlockRegistryViaVersion(blockHash, knownVersion) || await this._cacheBlockRegistryProgress((0, _util.u8aToHex)(blockHash), ()=>this._getBlockRegistryViaHash(blockHash));
    }
    async _loadMeta() {
        var _this$_options$source;
        // on re-connection to the same chain, we don't want to re-do everything from chain again
        if (this._isReady) return true;
        this._unsubscribeUpdates(); // only load from on-chain if we are not a clone (default path), alternatively
        // just use the values from the source instance provided
        [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);
        return this._initFromMeta(this._runtimeMetadata);
    }
    async _metaFromSource(source) {
        this._extrinsicType = source.extrinsicVersion;
        this._runtimeChain = source.runtimeChain;
        this._runtimeVersion = source.runtimeVersion; // manually build a list of all available methods in this RPC, we are
        // going to filter on it to align the cloned RPC without making a call
        const sections = Object.keys(source.rpc);
        const rpcs = [];
        for(let s = 0; s < sections.length; s++){
            const section = sections[s];
            const methods = Object.keys(source.rpc[section]);
            for(let m = 0; m < methods.length; m++)rpcs.push(`${section}_${methods[m]}`);
        }
        this._filterRpc(rpcs, (0, _typesKnown.getSpecRpc)(this.registry, source.runtimeChain, source.runtimeVersion.specName));
        return [
            source.genesisHash,
            source.runtimeMetadata
        ];
    }
    _subscribeUpdates() {
        if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _updateSub)[_updateSub] || !this.hasSubscriptions) return;
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe((0, _rxjs.switchMap)((version)=>{
            var _this$_runtimeVersion;
            return (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? (0, _rxjs.of)(false) : this._rpcCore.state.getMetadata().pipe((0, _rxjs.map)((metadata)=>{
                l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);
                this._runtimeMetadata = metadata;
                this._runtimeVersion = version;
                this._rx.runtimeVersion = version; // update the default registry version
                const thisRegistry = this._getDefaultRegistry(); // setup the data as per the current versions
                thisRegistry.metadata = metadata;
                thisRegistry.runtimeVersion = version;
                this._initRegistry(this.registry, this._runtimeChain, version, metadata);
                this._injectMetadata(thisRegistry, true);
                return true;
            }));
        })).subscribe();
    }
    async _metaFromChain(optMetadata) {
        const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([
            (0, _rxjs.firstValueFrom)(this._rpcCore.chain.getBlockHash(0)),
            (0, _rxjs.firstValueFrom)(this._rpcCore.state.getRuntimeVersion()),
            (0, _rxjs.firstValueFrom)(this._rpcCore.system.chain()),
            (0, _rxjs.firstValueFrom)(this._rpcCore.system.properties()),
            (0, _rxjs.firstValueFrom)(this._rpcCore.rpc.methods()),
            optMetadata ? Promise.resolve(null) : (0, _rxjs.firstValueFrom)(this._rpcCore.state.getMetadata())
        ]); // set our chain version & genesisHash as returned
        this._runtimeChain = chain;
        this._runtimeVersion = runtimeVersion;
        this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options
        const metadataKey = `${genesisHash.toHex() || "0x"}-${runtimeVersion.specVersion.toString()}`;
        const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new (0, _types.Metadata)(this.registry, optMetadata[metadataKey]) : await (0, _rxjs.firstValueFrom)(this._rpcCore.state.getMetadata())); // initializes the registry & RPC
        this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);
        this._filterRpc(rpcMethods.methods.map(textToString), (0, _typesKnown.getSpecRpc)(this.registry, chain, runtimeVersion.specName));
        this._subscribeUpdates(); // setup the initial registry, when we have none
        if (!(0, _classPrivateFieldLooseBaseDefault.default)(this, _registries)[_registries].length) (0, _classPrivateFieldLooseBaseDefault.default)(this, _registries)[_registries].push({
            isDefault: true,
            metadata,
            registry: this.registry,
            runtimeVersion
        });
         // get unique types & validate
        metadata.getUniqTypes(this._options.throwOnUnknown || false);
        return [
            genesisHash,
            metadata
        ];
    }
    _initFromMeta(metadata) {
        this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();
        this._rx.extrinsicType = this._extrinsicType;
        this._rx.genesisHash = this._genesisHash;
        this._rx.runtimeVersion = this._runtimeVersion; // must be set here
        // inject metadata and adjust the types as detected
        this._injectMetadata(this._getDefaultRegistry(), true); // derive is last, since it uses the decorated rx
        this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);
        this._derive = this._decorateDerive(this._decorateMethod);
        return true;
    }
    _subscribeHealth() {
        // Only enable the health keepalive on WS, not needed on HTTP
        (0, _classPrivateFieldLooseBaseDefault.default)(this, _healthTimer)[_healthTimer] = this.hasSubscriptions ? setInterval(()=>{
            (0, _rxjs.firstValueFrom)(this._rpcCore.system.health.raw()).catch(()=>undefined);
        }, KEEPALIVE_INTERVAL) : null;
    }
    _unsubscribeHealth() {
        if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _healthTimer)[_healthTimer]) {
            clearInterval((0, _classPrivateFieldLooseBaseDefault.default)(this, _healthTimer)[_healthTimer]);
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _healthTimer)[_healthTimer] = null;
        }
    }
    _unsubscribeUpdates() {
        if ((0, _classPrivateFieldLooseBaseDefault.default)(this, _updateSub)[_updateSub]) {
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _updateSub)[_updateSub].unsubscribe();
            (0, _classPrivateFieldLooseBaseDefault.default)(this, _updateSub)[_updateSub] = null;
        }
    }
    _unsubscribe() {
        this._unsubscribeHealth();
        this._unsubscribeUpdates();
    }
}
async function _onProviderConnect2() {
    this._isConnected.next(true);
    this.emit("connected");
    try {
        const cryptoReady = this._options.initWasm === false ? true : await (0, _utilCrypto.cryptoWaitReady)();
        const hasMeta = await this._loadMeta();
        this._subscribeHealth();
        if (hasMeta && !this._isReady && cryptoReady) {
            this._isReady = true;
            this.emit("ready", this);
        }
    } catch (_error) {
        const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);
        l.error(error);
        this.emit("error", error);
    }
}
function _onProviderDisconnect2() {
    this._isConnected.next(false);
    this._unsubscribeHealth();
    this.emit("disconnected");
}
function _onProviderError2(error) {
    this.emit("error", error);
}

},{"@babel/runtime/helpers/esm/classPrivateFieldLooseBase":"gHEjb","@babel/runtime/helpers/esm/classPrivateFieldLooseKey":"90V54","rxjs":"lLy7s","@polkadot/types":"fnDGk","@polkadot/types-known":"fbgSe","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","./Decorate.js":"kF4Em","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fbgSe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _detectPackageJs = require("./detectPackage.js");
var _bundleJs = require("./bundle.js");
parcelHelpers.exportAll(_bundleJs, exports);

},{"./detectPackage.js":"kTGlx","./bundle.js":"3UCr0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kTGlx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Do not edit, auto-generated by @polkadot/dev
var _util = require("@polkadot/util");
var _detectOtherJs = require("./detectOther.js");
var _detectOtherJsDefault = parcelHelpers.interopDefault(_detectOtherJs);
var _packageInfoJs = require("./packageInfo.js");
(0, _util.detectPackage)((0, _packageInfoJs.packageInfo), null, (0, _detectOtherJsDefault.default));

},{"@polkadot/util":"3HnHw","./detectOther.js":"duZLI","./packageInfo.js":"kiObO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"duZLI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _packageInfo = require("@polkadot/types/packageInfo");
exports.default = [
    (0, _packageInfo.packageInfo)
];

},{"@polkadot/types/packageInfo":"cIucp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3UCr0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "mapXcmTypes", ()=>(0, _typesCreate.mapXcmTypes));
parcelHelpers.export(exports, "packageInfo", ()=>(0, _packageInfoJs.packageInfo));
var _typesCreate = require("@polkadot/types-create");
var _packageInfoJs = require("./packageInfo.js");
var _utilJs = require("./util.js");
parcelHelpers.exportAll(_utilJs, exports);

},{"@polkadot/types-create":"cr6lO","./packageInfo.js":"kiObO","./util.js":"3j83B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3j83B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Based on the chain and runtimeVersion, get the applicable signed extensions (ready for registration)
 */ parcelHelpers.export(exports, "getSpecExtensions", ()=>getSpecExtensions);
/**
 * @description Based on the chain and runtimeVersion, get the applicable types (ready for registration)
 */ parcelHelpers.export(exports, "getSpecTypes", ()=>getSpecTypes);
parcelHelpers.export(exports, "getSpecHasher", ()=>getSpecHasher);
/**
 * @description Based on the chain and runtimeVersion, get the applicable rpc definitions (ready for registration)
 */ parcelHelpers.export(exports, "getSpecRpc", ()=>getSpecRpc);
/**
 * @description Based on the chain and runtimeVersion, get the applicable runtime definitions (ready for registration)
 */ parcelHelpers.export(exports, "getSpecRuntime", ()=>getSpecRuntime);
/**
 * @description Based on the chain and runtimeVersion, get the applicable alias definitions (ready for registration)
 */ parcelHelpers.export(exports, "getSpecAlias", ()=>getSpecAlias);
/**
 * @description Returns a version record for known chains where upgrades are being tracked
 */ parcelHelpers.export(exports, "getUpgradeVersion", ()=>getUpgradeVersion);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
var _indexJs = require("./chain/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./spec/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("./upgrades/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
function withNames(chainName, specName, fn) {
    return fn(chainName.toString(), specName.toString());
} // flatten a VersionedType[] into a Record<string, string>
/** @internal */ function filterVersions(versions = [], specVersion) {
    return versions.filter(({ minmax: [min, max]  })=>(min === undefined || min === null || specVersion >= min) && (max === undefined || max === null || specVersion <= max)).reduce((result, { types  })=>(0, _util.objectSpread)(result, types), {});
}
function getSpecExtensions({ knownTypes  }, chainName, specName) {
    return withNames(chainName, specName, (c, s)=>{
        var _knownTypes$typesBund, _knownTypes$typesBund2, _knownTypes$typesBund3, _knownTypes$typesBund4, _knownTypes$typesBund5, _knownTypes$typesBund6;
        return (0, _util.objectSpread)({}, (_knownTypes$typesBund = knownTypes.typesBundle) === null || _knownTypes$typesBund === void 0 ? void 0 : (_knownTypes$typesBund2 = _knownTypes$typesBund.spec) === null || _knownTypes$typesBund2 === void 0 ? void 0 : (_knownTypes$typesBund3 = _knownTypes$typesBund2[s]) === null || _knownTypes$typesBund3 === void 0 ? void 0 : _knownTypes$typesBund3.signedExtensions, (_knownTypes$typesBund4 = knownTypes.typesBundle) === null || _knownTypes$typesBund4 === void 0 ? void 0 : (_knownTypes$typesBund5 = _knownTypes$typesBund4.chain) === null || _knownTypes$typesBund5 === void 0 ? void 0 : (_knownTypes$typesBund6 = _knownTypes$typesBund5[c]) === null || _knownTypes$typesBund6 === void 0 ? void 0 : _knownTypes$typesBund6.signedExtensions);
    });
}
function getSpecTypes({ knownTypes  }, chainName, specName, specVersion) {
    const _specVersion = (0, _util.bnToBn)(specVersion).toNumber();
    return withNames(chainName, specName, (c, s)=>{
        var _knownTypes$typesBund7, _knownTypes$typesBund8, _knownTypes$typesBund9, _knownTypes$typesBund10, _knownTypes$typesBund11, _knownTypes$typesBund12, _knownTypes$typesSpec, _knownTypes$typesChai;
        return(//   - spec then chain
        //   - typesBundle takes higher precedence
        //   - types is the final catch-all override
        (0, _util.objectSpread)({}, filterVersions((0, _indexJsDefault1.default)[s], _specVersion), filterVersions((0, _indexJsDefault.default)[c], _specVersion), filterVersions((_knownTypes$typesBund7 = knownTypes.typesBundle) === null || _knownTypes$typesBund7 === void 0 ? void 0 : (_knownTypes$typesBund8 = _knownTypes$typesBund7.spec) === null || _knownTypes$typesBund8 === void 0 ? void 0 : (_knownTypes$typesBund9 = _knownTypes$typesBund8[s]) === null || _knownTypes$typesBund9 === void 0 ? void 0 : _knownTypes$typesBund9.types, _specVersion), filterVersions((_knownTypes$typesBund10 = knownTypes.typesBundle) === null || _knownTypes$typesBund10 === void 0 ? void 0 : (_knownTypes$typesBund11 = _knownTypes$typesBund10.chain) === null || _knownTypes$typesBund11 === void 0 ? void 0 : (_knownTypes$typesBund12 = _knownTypes$typesBund11[c]) === null || _knownTypes$typesBund12 === void 0 ? void 0 : _knownTypes$typesBund12.types, _specVersion), (_knownTypes$typesSpec = knownTypes.typesSpec) === null || _knownTypes$typesSpec === void 0 ? void 0 : _knownTypes$typesSpec[s], (_knownTypes$typesChai = knownTypes.typesChain) === null || _knownTypes$typesChai === void 0 ? void 0 : _knownTypes$typesChai[c], knownTypes.types));
    });
}
function getSpecHasher({ knownTypes  }, chainName, specName) {
    return withNames(chainName, specName, (c, s)=>{
        var _knownTypes$typesBund13, _knownTypes$typesBund14, _knownTypes$typesBund15, _knownTypes$typesBund16, _knownTypes$typesBund17, _knownTypes$typesBund18;
        return knownTypes.hasher || ((_knownTypes$typesBund13 = knownTypes.typesBundle) === null || _knownTypes$typesBund13 === void 0 ? void 0 : (_knownTypes$typesBund14 = _knownTypes$typesBund13.chain) === null || _knownTypes$typesBund14 === void 0 ? void 0 : (_knownTypes$typesBund15 = _knownTypes$typesBund14[c]) === null || _knownTypes$typesBund15 === void 0 ? void 0 : _knownTypes$typesBund15.hasher) || ((_knownTypes$typesBund16 = knownTypes.typesBundle) === null || _knownTypes$typesBund16 === void 0 ? void 0 : (_knownTypes$typesBund17 = _knownTypes$typesBund16.spec) === null || _knownTypes$typesBund17 === void 0 ? void 0 : (_knownTypes$typesBund18 = _knownTypes$typesBund17[s]) === null || _knownTypes$typesBund18 === void 0 ? void 0 : _knownTypes$typesBund18.hasher) || null;
    });
}
function getSpecRpc({ knownTypes  }, chainName, specName) {
    return withNames(chainName, specName, (c, s)=>{
        var _knownTypes$typesBund19, _knownTypes$typesBund20, _knownTypes$typesBund21, _knownTypes$typesBund22, _knownTypes$typesBund23, _knownTypes$typesBund24;
        return (0, _util.objectSpread)({}, (_knownTypes$typesBund19 = knownTypes.typesBundle) === null || _knownTypes$typesBund19 === void 0 ? void 0 : (_knownTypes$typesBund20 = _knownTypes$typesBund19.spec) === null || _knownTypes$typesBund20 === void 0 ? void 0 : (_knownTypes$typesBund21 = _knownTypes$typesBund20[s]) === null || _knownTypes$typesBund21 === void 0 ? void 0 : _knownTypes$typesBund21.rpc, (_knownTypes$typesBund22 = knownTypes.typesBundle) === null || _knownTypes$typesBund22 === void 0 ? void 0 : (_knownTypes$typesBund23 = _knownTypes$typesBund22.chain) === null || _knownTypes$typesBund23 === void 0 ? void 0 : (_knownTypes$typesBund24 = _knownTypes$typesBund23[c]) === null || _knownTypes$typesBund24 === void 0 ? void 0 : _knownTypes$typesBund24.rpc);
    });
}
function getSpecRuntime({ knownTypes  }, chainName, specName) {
    return withNames(chainName, specName, (c, s)=>{
        var _knownTypes$typesBund25, _knownTypes$typesBund26, _knownTypes$typesBund27, _knownTypes$typesBund28, _knownTypes$typesBund29, _knownTypes$typesBund30;
        return (0, _util.objectSpread)({}, (_knownTypes$typesBund25 = knownTypes.typesBundle) === null || _knownTypes$typesBund25 === void 0 ? void 0 : (_knownTypes$typesBund26 = _knownTypes$typesBund25.spec) === null || _knownTypes$typesBund26 === void 0 ? void 0 : (_knownTypes$typesBund27 = _knownTypes$typesBund26[s]) === null || _knownTypes$typesBund27 === void 0 ? void 0 : _knownTypes$typesBund27.runtime, (_knownTypes$typesBund28 = knownTypes.typesBundle) === null || _knownTypes$typesBund28 === void 0 ? void 0 : (_knownTypes$typesBund29 = _knownTypes$typesBund28.chain) === null || _knownTypes$typesBund29 === void 0 ? void 0 : (_knownTypes$typesBund30 = _knownTypes$typesBund29[c]) === null || _knownTypes$typesBund30 === void 0 ? void 0 : _knownTypes$typesBund30.runtime);
    });
}
function getSpecAlias({ knownTypes  }, chainName, specName) {
    return withNames(chainName, specName, (c, s)=>{
        var _knownTypes$typesBund31, _knownTypes$typesBund32, _knownTypes$typesBund33, _knownTypes$typesBund34, _knownTypes$typesBund35, _knownTypes$typesBund36;
        return (0, _util.objectSpread)({}, (_knownTypes$typesBund31 = knownTypes.typesBundle) === null || _knownTypes$typesBund31 === void 0 ? void 0 : (_knownTypes$typesBund32 = _knownTypes$typesBund31.spec) === null || _knownTypes$typesBund32 === void 0 ? void 0 : (_knownTypes$typesBund33 = _knownTypes$typesBund32[s]) === null || _knownTypes$typesBund33 === void 0 ? void 0 : _knownTypes$typesBund33.alias, (_knownTypes$typesBund34 = knownTypes.typesBundle) === null || _knownTypes$typesBund34 === void 0 ? void 0 : (_knownTypes$typesBund35 = _knownTypes$typesBund34.chain) === null || _knownTypes$typesBund35 === void 0 ? void 0 : (_knownTypes$typesBund36 = _knownTypes$typesBund35[c]) === null || _knownTypes$typesBund36 === void 0 ? void 0 : _knownTypes$typesBund36.alias, knownTypes.typesAlias);
    });
}
function getUpgradeVersion(genesisHash, blockNumber) {
    const known = (0, _indexJsDefault2.default).find((u)=>genesisHash.eq(u.genesisHash));
    return known ? [
        known.versions.reduce((last, version)=>{
            return blockNumber.gt(version.blockNumber) ? version : last;
        }, undefined),
        known.versions.find((version)=>blockNumber.lte(version.blockNumber))
    ] : [
        undefined,
        undefined
    ];
}

},{"@polkadot/util":"3HnHw","./chain/index.js":"7W81h","./spec/index.js":"99lmI","./upgrades/index.js":"iSqVl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7W81h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Type overrides based on specific nodes
const typesChain = {};
exports.default = typesChain;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"99lmI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _centrifugeChainJs = require("./centrifuge-chain.js");
var _centrifugeChainJsDefault = parcelHelpers.interopDefault(_centrifugeChainJs);
var _kusamaJs = require("./kusama.js");
var _kusamaJsDefault = parcelHelpers.interopDefault(_kusamaJs);
var _nodeJs = require("./node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
var _nodeTemplateJs = require("./node-template.js");
var _nodeTemplateJsDefault = parcelHelpers.interopDefault(_nodeTemplateJs);
var _polkadotJs = require("./polkadot.js");
var _polkadotJsDefault = parcelHelpers.interopDefault(_polkadotJs);
var _rococoJs = require("./rococo.js");
var _rococoJsDefault = parcelHelpers.interopDefault(_rococoJs);
var _shellJs = require("./shell.js");
var _shellJsDefault = parcelHelpers.interopDefault(_shellJs);
var _statemintJs = require("./statemint.js");
var _statemintJsDefault = parcelHelpers.interopDefault(_statemintJs);
var _westendJs = require("./westend.js"); // Type overrides for specific spec types & versions as given in runtimeVersion
var _westendJsDefault = parcelHelpers.interopDefault(_westendJs);
const typesSpec = {
    "centrifuge-chain": (0, _centrifugeChainJsDefault.default),
    kusama: (0, _kusamaJsDefault.default),
    node: (0, _nodeJsDefault.default),
    "node-template": (0, _nodeTemplateJsDefault.default),
    polkadot: (0, _polkadotJsDefault.default),
    rococo: (0, _rococoJsDefault.default),
    shell: (0, _shellJsDefault.default),
    statemine: (0, _statemintJsDefault.default),
    statemint: (0, _statemintJsDefault.default),
    westend: (0, _westendJsDefault.default),
    westmint: (0, _statemintJsDefault.default)
};
exports.default = typesSpec;

},{"./centrifuge-chain.js":"UOC4w","./kusama.js":"c62FZ","./node.js":"gFgCK","./node-template.js":"h3wFW","./polkadot.js":"ixV3R","./rococo.js":"2DzYu","./shell.js":"bXurS","./statemint.js":"1B6U1","./westend.js":"hh9FZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"UOC4w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable sort-keys */ var _util = require("@polkadot/util");
const sharedTypes = {
    // Anchor
    AnchorData: {
        anchoredBlock: "u64",
        docRoot: "H256",
        id: "H256"
    },
    DispatchErrorModule: "DispatchErrorModuleU8",
    PreCommitData: {
        expirationBlock: "u64",
        identity: "H256",
        signingRoot: "H256"
    },
    // Fees
    Fee: {
        key: "Hash",
        price: "Balance"
    },
    // MultiAccount
    MultiAccountData: {
        deposit: "Balance",
        depositor: "AccountId",
        signatories: "Vec<AccountId>",
        threshold: "u16"
    },
    // Bridge
    ChainId: "u8",
    DepositNonce: "u64",
    ResourceId: "[u8; 32]",
    "chainbridge::ChainId": "u8",
    // NFT
    RegistryId: "H160",
    TokenId: "U256",
    AssetId: {
        registryId: "RegistryId",
        tokenId: "TokenId"
    },
    AssetInfo: {
        metadata: "Bytes"
    },
    MintInfo: {
        anchorId: "Hash",
        proofs: "Vec<ProofMint>",
        staticHashes: "[Hash; 3]"
    },
    Proof: {
        leafHash: "H256",
        sortedHashes: "H256"
    },
    ProofMint: {
        hashes: "Vec<Hash>",
        property: "Bytes",
        salt: "[u8; 32]",
        value: "Bytes"
    },
    RegistryInfo: {
        fields: "Vec<Bytes>",
        ownerCanBurn: "bool"
    },
    ProxyType: {
        _enum: [
            "Any",
            "NonTransfer",
            "Governance",
            "Staking",
            "NonProxy"
        ]
    }
};
const standaloneTypes = (0, _util.objectSpread)({}, sharedTypes, {
    AccountInfo: "AccountInfoWithRefCount",
    Address: "LookupSource",
    LookupSource: "IndicesLookupSource",
    Multiplier: "Fixed64",
    RefCount: "RefCountTo259"
});
const versioned = [
    {
        minmax: [
            240,
            243
        ],
        types: (0, _util.objectSpread)({}, standaloneTypes, {
            ProxyType: {
                _enum: [
                    "Any",
                    "NonTransfer",
                    "Governance",
                    "Staking",
                    "Vesting"
                ]
            }
        })
    },
    {
        minmax: [
            244,
            999
        ],
        types: (0, _util.objectSpread)({}, standaloneTypes)
    },
    {
        minmax: [
            1000,
            undefined
        ],
        types: (0, _util.objectSpread)({}, sharedTypes)
    }
];
exports.default = versioned;

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c62FZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable sort-keys */ var _typesCreate = require("@polkadot/types-create");
var _util = require("@polkadot/util");
const sharedTypes = {
    CompactAssignments: "CompactAssignmentsWith24",
    DispatchErrorModule: "DispatchErrorModuleU8",
    RawSolution: "RawSolutionWith24",
    Keys: "SessionKeys6",
    ProxyType: {
        _enum: [
            "Any",
            "NonTransfer",
            "Governance",
            "Staking",
            "IdentityJudgement",
            "CancelProxy",
            "Auction"
        ]
    }
};
const addrIndicesTypes = {
    AccountInfo: "AccountInfoWithRefCount",
    Address: "LookupSource",
    CompactAssignments: "CompactAssignmentsWith16",
    DispatchErrorModule: "DispatchErrorModuleU8",
    RawSolution: "RawSolutionWith16",
    Keys: "SessionKeys5",
    LookupSource: "IndicesLookupSource",
    ValidatorPrefs: "ValidatorPrefsWithCommission"
};
const addrAccountIdTypes = {
    AccountInfo: "AccountInfoWithRefCount",
    Address: "AccountId",
    CompactAssignments: "CompactAssignmentsWith16",
    DispatchErrorModule: "DispatchErrorModuleU8",
    RawSolution: "RawSolutionWith16",
    Keys: "SessionKeys5",
    LookupSource: "AccountId",
    ValidatorPrefs: "ValidatorPrefsWithCommission"
};
const versioned = [
    {
        // 1020 is first CC3
        minmax: [
            1019,
            1031
        ],
        types: (0, _util.objectSpread)({}, addrIndicesTypes, {
            BalanceLock: "BalanceLockTo212",
            CompactAssignments: "CompactAssignmentsTo257",
            DispatchError: "DispatchErrorTo198",
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            IdentityInfo: "IdentityInfoTo198",
            Keys: "SessionKeys5",
            Multiplier: "Fixed64",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259",
            ReferendumInfo: "ReferendumInfoTo239",
            SlashingSpans: "SlashingSpansTo204",
            StakingLedger: "StakingLedgerTo223",
            Votes: "VotesTo230",
            Weight: "u32"
        })
    },
    {
        minmax: [
            1032,
            1042
        ],
        types: (0, _util.objectSpread)({}, addrIndicesTypes, {
            BalanceLock: "BalanceLockTo212",
            CompactAssignments: "CompactAssignmentsTo257",
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            Keys: "SessionKeys5",
            Multiplier: "Fixed64",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259",
            ReferendumInfo: "ReferendumInfoTo239",
            SlashingSpans: "SlashingSpansTo204",
            StakingLedger: "StakingLedgerTo223",
            Votes: "VotesTo230",
            Weight: "u32"
        })
    },
    {
        // actual at 1045 (1043-1044 is dev)
        minmax: [
            1043,
            1045
        ],
        types: (0, _util.objectSpread)({}, addrIndicesTypes, {
            BalanceLock: "BalanceLockTo212",
            CompactAssignments: "CompactAssignmentsTo257",
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            Keys: "SessionKeys5",
            Multiplier: "Fixed64",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259",
            ReferendumInfo: "ReferendumInfoTo239",
            StakingLedger: "StakingLedgerTo223",
            Votes: "VotesTo230",
            Weight: "u32"
        })
    },
    {
        minmax: [
            1046,
            1050
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            Multiplier: "Fixed64",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259",
            ReferendumInfo: "ReferendumInfoTo239",
            StakingLedger: "StakingLedgerTo223",
            Weight: "u32"
        })
    },
    {
        minmax: [
            1051,
            1054
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            Multiplier: "Fixed64",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259",
            ReferendumInfo: "ReferendumInfoTo239",
            StakingLedger: "StakingLedgerTo240",
            Weight: "u32"
        })
    },
    {
        minmax: [
            1055,
            1056
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            Multiplier: "Fixed64",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259",
            StakingLedger: "StakingLedgerTo240",
            Weight: "u32"
        })
    },
    {
        minmax: [
            1057,
            1061
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259"
        })
    },
    {
        minmax: [
            1062,
            2012
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259"
        })
    },
    {
        minmax: [
            2013,
            2022
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            RefCount: "RefCountTo259"
        })
    },
    {
        minmax: [
            2023,
            2024
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            RefCount: "RefCountTo259"
        })
    },
    {
        minmax: [
            2025,
            2027
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes)
    },
    {
        minmax: [
            2028,
            2029
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, {
            AccountInfo: "AccountInfoWithDualRefCount",
            CompactAssignments: "CompactAssignmentsWith16",
            RawSolution: "RawSolutionWith16"
        })
    },
    {
        minmax: [
            2030,
            9000
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, {
            CompactAssignments: "CompactAssignmentsWith16",
            RawSolution: "RawSolutionWith16"
        })
    },
    {
        minmax: [
            9010,
            9099
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, (0, _typesCreate.mapXcmTypes)("V0"))
    },
    {
        // jump from 9100 to 9110, however align with Rococo
        minmax: [
            9100,
            9105
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, (0, _typesCreate.mapXcmTypes)("V1"))
    },
    {
        // metadata v14
        minmax: [
            9106,
            undefined
        ],
        types: {}
    }
];
exports.default = versioned;

},{"@polkadot/types-create":"cr6lO","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gFgCK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable sort-keys */ const versioned = [
    {
        minmax: [
            0,
            undefined
        ],
        types: {}
    }
];
exports.default = versioned;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h3wFW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable sort-keys */ const versioned = [
    {
        minmax: [
            0,
            undefined
        ],
        types: {}
    }
];
exports.default = versioned;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ixV3R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable sort-keys */ var _util = require("@polkadot/util");
const sharedTypes = {
    CompactAssignments: "CompactAssignmentsWith16",
    DispatchErrorModule: "DispatchErrorModuleU8",
    RawSolution: "RawSolutionWith16",
    Keys: "SessionKeys6",
    ProxyType: {
        _enum: {
            Any: 0,
            NonTransfer: 1,
            Governance: 2,
            Staking: 3,
            UnusedSudoBalances: 4,
            IdentityJudgement: 5,
            CancelProxy: 6,
            Auction: 7
        }
    }
};
const addrAccountIdTypes = {
    AccountInfo: "AccountInfoWithRefCount",
    Address: "AccountId",
    DispatchErrorModule: "DispatchErrorModuleU8",
    Keys: "SessionKeys5",
    LookupSource: "AccountId",
    ValidatorPrefs: "ValidatorPrefsWithCommission"
}; // these are override types for Polkadot
const versioned = [
    {
        minmax: [
            0,
            12
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259"
        })
    },
    {
        minmax: [
            13,
            22
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            RefCount: "RefCountTo259"
        })
    },
    {
        minmax: [
            23,
            24
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            RefCount: "RefCountTo259"
        })
    },
    {
        minmax: [
            25,
            27
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes)
    },
    {
        minmax: [
            28,
            29
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, {
            AccountInfo: "AccountInfoWithDualRefCount"
        })
    },
    {
        minmax: [
            30,
            9109
        ],
        types: (0, _util.objectSpread)({}, sharedTypes)
    },
    {
        // metadata v14
        minmax: [
            9110,
            undefined
        ],
        types: {}
    }
];
exports.default = versioned;

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2DzYu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable sort-keys */ var _typesCreate = require("@polkadot/types-create");
var _util = require("@polkadot/util"); // structs need to be in order
/* eslint-disable sort-keys */ const sharedTypes = {
    DispatchErrorModule: "DispatchErrorModuleU8",
    FullIdentification: "()",
    // No staking, only session (as per config)
    Keys: "SessionKeys7B"
};
const versioned = [
    {
        minmax: [
            0,
            200
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, {
            AccountInfo: "AccountInfoWithDualRefCount",
            Address: "AccountId",
            LookupSource: "AccountId"
        })
    },
    {
        minmax: [
            201,
            214
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, {
            AccountInfo: "AccountInfoWithDualRefCount"
        })
    },
    {
        minmax: [
            215,
            228
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, {
            Keys: "SessionKeys6"
        })
    },
    {
        minmax: [
            229,
            9099
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, (0, _typesCreate.mapXcmTypes)("V0"))
    },
    {
        minmax: [
            9100,
            9105
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, (0, _typesCreate.mapXcmTypes)("V1"))
    },
    {
        // metadata v14
        minmax: [
            9106,
            undefined
        ],
        types: {}
    }
];
exports.default = versioned;

},{"@polkadot/types-create":"cr6lO","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bXurS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable sort-keys */ const versioned = [
    {
        minmax: [
            0,
            undefined
        ],
        types: {}
    }
];
exports.default = versioned;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1B6U1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable sort-keys */ var _typesCreate = require("@polkadot/types-create");
var _util = require("@polkadot/util");
const sharedTypes = {
    DispatchErrorModule: "DispatchErrorModuleU8",
    TAssetBalance: "u128",
    ProxyType: {
        _enum: [
            "Any",
            "NonTransfer",
            "CancelProxy",
            "Assets",
            "AssetOwner",
            "AssetManager",
            "Staking"
        ]
    }
}; // these are override types for Statemine, Statemint, Westmint
const versioned = [
    {
        minmax: [
            0,
            3
        ],
        types: (0, _util.objectSpread)({
            // Enum was modified mid-flight -
            // https://github.com/paritytech/substrate/pull/10382/files#diff-e4e016b33a82268b6208dc974eea841bad47597865a749fee2f937eb6fdf67b4R498
            DispatchError: "DispatchErrorPre6First"
        }, sharedTypes, (0, _typesCreate.mapXcmTypes)("V0"))
    },
    {
        minmax: [
            4,
            5
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, (0, _typesCreate.mapXcmTypes)("V1"))
    },
    {
        // metadata V14
        minmax: [
            500,
            undefined
        ],
        types: {}
    }
];
exports.default = versioned;

},{"@polkadot/types-create":"cr6lO","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hh9FZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
/* eslint-disable sort-keys */ var _typesCreate = require("@polkadot/types-create");
var _util = require("@polkadot/util");
const sharedTypes = {
    // 16 validators
    CompactAssignments: "CompactAssignmentsWith16",
    DispatchErrorModule: "DispatchErrorModuleU8",
    RawSolution: "RawSolutionWith16",
    // general
    Keys: "SessionKeys6",
    ProxyType: {
        _enum: [
            "Any",
            "NonTransfer",
            "Staking",
            "SudoBalances",
            "IdentityJudgement",
            "CancelProxy"
        ]
    }
};
const addrAccountIdTypes = {
    AccountInfo: "AccountInfoWithRefCount",
    Address: "AccountId",
    CompactAssignments: "CompactAssignmentsWith16",
    DispatchErrorModule: "DispatchErrorModuleU8",
    LookupSource: "AccountId",
    Keys: "SessionKeys5",
    RawSolution: "RawSolutionWith16",
    ValidatorPrefs: "ValidatorPrefsWithCommission"
};
const versioned = [
    {
        minmax: [
            1,
            2
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            Multiplier: "Fixed64",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259",
            Weight: "u32"
        })
    },
    {
        minmax: [
            3,
            22
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            OpenTip: "OpenTipTo225",
            RefCount: "RefCountTo259"
        })
    },
    {
        minmax: [
            23,
            42
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            CompactAssignments: "CompactAssignmentsTo257",
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            RefCount: "RefCountTo259"
        })
    },
    {
        minmax: [
            43,
            44
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes, {
            DispatchInfo: "DispatchInfoTo244",
            Heartbeat: "HeartbeatTo244",
            RefCount: "RefCountTo259"
        })
    },
    {
        minmax: [
            45,
            47
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, addrAccountIdTypes)
    },
    {
        minmax: [
            48,
            49
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, {
            AccountInfo: "AccountInfoWithDualRefCount"
        })
    },
    {
        minmax: [
            50,
            9099
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, (0, _typesCreate.mapXcmTypes)("V0"))
    },
    {
        minmax: [
            9100,
            9105
        ],
        types: (0, _util.objectSpread)({}, sharedTypes, (0, _typesCreate.mapXcmTypes)("V1"))
    },
    {
        // metadata v14
        minmax: [
            9106,
            undefined
        ],
        types: {}
    }
];
exports.default = versioned;

},{"@polkadot/types-create":"cr6lO","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iSqVl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _networks = require("@polkadot/networks");
var _util = require("@polkadot/util");
var _kusamaJs = require("./kusama.js");
var _kusamaJsDefault = parcelHelpers.interopDefault(_kusamaJs);
var _polkadotJs = require("./polkadot.js");
var _polkadotJsDefault = parcelHelpers.interopDefault(_polkadotJs);
var _westendJs = require("./westend.js");
var _westendJsDefault = parcelHelpers.interopDefault(_westendJs);
const allKnown = {
    kusama: (0, _kusamaJsDefault.default),
    polkadot: (0, _polkadotJsDefault.default),
    westend: (0, _westendJsDefault.default)
}; // testnets are not available in the networks map
const NET_EXTRA = {
    westend: {
        genesisHash: [
            "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"
        ]
    }
};
/** @internal */ function checkOrder(network, versions) {
    const ooo = versions.filter((curr, index)=>{
        const prev = versions[index - 1];
        return index === 0 ? false : curr[0] <= prev[0] || curr[1] <= prev[1];
    });
    if (ooo.length) throw new Error(`${network}: Mismatched upgrade ordering: ${(0, _util.stringify)(ooo)}`);
    return versions;
}
/** @internal */ function mapRaw([network, versions]) {
    const chain = (0, _networks.selectableNetworks).find((n)=>n.network === network) || NET_EXTRA[network];
    if (!chain) throw new Error(`Unable to find info for chain ${network}`);
    return {
        genesisHash: (0, _util.hexToU8a)(chain.genesisHash[0]),
        network,
        versions: checkOrder(network, versions).map(([blockNumber, specVersion])=>({
                blockNumber: new (0, _util.BN)(blockNumber),
                specVersion: new (0, _util.BN)(specVersion)
            }))
    };
} // Type overrides for specific spec types & versions as given in runtimeVersion
const upgrades = Object.entries(allKnown).map(mapRaw);
exports.default = upgrades;

},{"@polkadot/networks":"1v38R","@polkadot/util":"3HnHw","./kusama.js":"4pIt5","./polkadot.js":"561jC","./westend.js":"c2PBV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4pIt5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const upgrades = [
    [
        0,
        1020
    ],
    [
        26669,
        1021
    ],
    [
        38245,
        1022
    ],
    [
        54248,
        1023
    ],
    [
        59659,
        1024
    ],
    [
        67651,
        1025
    ],
    [
        82191,
        1027
    ],
    [
        83238,
        1028
    ],
    [
        101503,
        1029
    ],
    [
        203466,
        1030
    ],
    [
        295787,
        1031
    ],
    [
        461692,
        1032
    ],
    [
        504329,
        1033
    ],
    [
        569327,
        1038
    ],
    [
        587687,
        1039
    ],
    [
        653183,
        1040
    ],
    [
        693488,
        1042
    ],
    [
        901442,
        1045
    ],
    [
        1375086,
        1050
    ],
    [
        1445458,
        1051
    ],
    [
        1472960,
        1052
    ],
    [
        1475648,
        1053
    ],
    [
        1491596,
        1054
    ],
    [
        1574408,
        1055
    ],
    [
        2064961,
        1058
    ],
    [
        2201991,
        1062
    ],
    [
        2671528,
        2005
    ],
    [
        2704202,
        2007
    ],
    [
        2728002,
        2008
    ],
    [
        2832534,
        2011
    ],
    [
        2962294,
        2012
    ],
    [
        3240000,
        2013
    ],
    [
        3274408,
        2015
    ],
    [
        3323565,
        2019
    ],
    [
        3534175,
        2022
    ],
    [
        3860281,
        2023
    ],
    [
        4143129,
        2024
    ],
    [
        4401242,
        2025
    ],
    [
        4841367,
        2026
    ],
    [
        5961600,
        2027
    ],
    [
        6137912,
        2028
    ],
    [
        6561855,
        2029
    ],
    [
        7100891,
        2030
    ],
    [
        7468792,
        9010
    ],
    [
        7668600,
        9030
    ],
    [
        7812476,
        9040
    ],
    [
        8010981,
        9050
    ],
    [
        8073833,
        9070
    ],
    [
        8555825,
        9080
    ],
    [
        8945245,
        9090
    ],
    [
        9611377,
        9100
    ],
    [
        9625129,
        9111
    ],
    [
        9866422,
        9122
    ],
    [
        10403784,
        9130
    ],
    [
        10960765,
        9150
    ],
    [
        11006614,
        9151
    ],
    [
        11404482,
        9160
    ],
    [
        11601803,
        9170
    ],
    [
        12008022,
        9180
    ],
    [
        12405451,
        9190
    ],
    [
        12665416,
        9200
    ],
    [
        12909508,
        9220
    ],
    [
        13109752,
        9230
    ],
    [
        13555777,
        9250
    ]
];
exports.default = upgrades;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"561jC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const upgrades = [
    [
        0,
        0
    ],
    [
        29231,
        1
    ],
    [
        188836,
        5
    ],
    [
        199405,
        6
    ],
    [
        214264,
        7
    ],
    [
        244358,
        8
    ],
    [
        303079,
        9
    ],
    [
        314201,
        10
    ],
    [
        342400,
        11
    ],
    [
        443963,
        12
    ],
    [
        528470,
        13
    ],
    [
        687751,
        14
    ],
    [
        746085,
        15
    ],
    [
        787923,
        16
    ],
    [
        799302,
        17
    ],
    [
        1205128,
        18
    ],
    [
        1603423,
        23
    ],
    [
        1733218,
        24
    ],
    [
        2005673,
        25
    ],
    [
        2436698,
        26
    ],
    [
        3613564,
        27
    ],
    [
        3899547,
        28
    ],
    [
        4345767,
        29
    ],
    [
        4876134,
        30
    ],
    [
        5661442,
        9050
    ],
    [
        6321619,
        9080
    ],
    [
        6713249,
        9090
    ],
    [
        7217907,
        9100
    ],
    [
        7229126,
        9110
    ],
    [
        7560558,
        9122
    ],
    [
        8115869,
        9140
    ],
    [
        8638103,
        9151
    ],
    [
        9280179,
        9170
    ],
    [
        9738717,
        9180
    ],
    [
        10156856,
        9190
    ],
    [
        10458576,
        9200
    ],
    [
        10655116,
        9220
    ]
];
exports.default = upgrades;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c2PBV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const upgrades = [
    [
        214356,
        4
    ],
    [
        392764,
        7
    ],
    [
        409740,
        8
    ],
    [
        809976,
        20
    ],
    [
        877581,
        24
    ],
    [
        879238,
        25
    ],
    [
        889472,
        26
    ],
    [
        902937,
        27
    ],
    [
        932751,
        28
    ],
    [
        991142,
        29
    ],
    [
        1030162,
        31
    ],
    [
        1119657,
        32
    ],
    [
        1199282,
        33
    ],
    [
        1342534,
        34
    ],
    [
        1392263,
        35
    ],
    [
        1431703,
        36
    ],
    [
        1433369,
        37
    ],
    [
        1490972,
        41
    ],
    [
        2087397,
        43
    ],
    [
        2316688,
        44
    ],
    [
        2549864,
        45
    ],
    [
        3925782,
        46
    ],
    [
        3925843,
        47
    ],
    [
        4207800,
        48
    ],
    [
        4627944,
        49
    ],
    [
        5124076,
        50
    ],
    [
        5478664,
        900
    ],
    [
        5482450,
        9000
    ],
    [
        5584305,
        9010
    ],
    [
        5784566,
        9030
    ],
    [
        5879822,
        9031
    ],
    [
        5896856,
        9032
    ],
    [
        5897316,
        9033
    ],
    [
        6117927,
        9050
    ],
    [
        6210274,
        9070
    ],
    [
        6379314,
        9080
    ],
    [
        6979141,
        9090
    ],
    [
        7568453,
        9100
    ],
    [
        7766394,
        9111
    ],
    [
        7911691,
        9120
    ],
    [
        7968866,
        9121
    ],
    [
        7982889,
        9122
    ],
    [
        8514322,
        9130
    ],
    [
        9091726,
        9140
    ],
    [
        9091774,
        9150
    ],
    [
        9406726,
        9160
    ],
    [
        9921066,
        9170
    ],
    [
        10007115,
        9180
    ],
    [
        10480973,
        9190
    ],
    [
        10578091,
        9200
    ],
    [
        10678509,
        9210
    ],
    [
        10811001,
        9220
    ],
    [
        11096116,
        9230
    ],
    [
        11409279,
        9250
    ]
];
exports.default = upgrades;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kF4Em":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Decorate", ()=>Decorate);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _apiDerive = require("@polkadot/api-derive");
var _rpcCore = require("@polkadot/rpc-core");
var _rpcProvider = require("@polkadot/rpc-provider");
var _types = require("@polkadot/types");
var _typesKnown = require("@polkadot/types-known");
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _indexJs = require("../submittable/index.js");
var _augmentObjectJs = require("../util/augmentObject.js");
var _decorateJs = require("../util/decorate.js");
var _validateJs = require("../util/validate.js");
var _eventsJs = require("./Events.js");
var _findJs = require("./find.js");
// the max amount of keys/values that we will retrieve at once
const PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)
const PAGE_SIZE_V = 250; // limited since the data may be > 16MB (e.g. misfiring elections)
const PAGE_SIZE_Q = 50; // queue of pending storage queries (mapped together, next tick)
const l = (0, _util.logger)("api/init");
let instanceCounter = 0;
function getAtQueryFn(api, { method , section  }) {
    return (0, _util.assertReturn)(api.rx.query[section] && api.rx.query[section][method], ()=>`query.${section}.${method} is not available in this version of the metadata`);
}
class Decorate extends (0, _eventsJs.Events) {
    #instanceId;
    #registry;
    #storageGetQ = [];
    #storageSubQ = [];
    __phantom = new (0, _util.BN)(0);
    _call = {};
    _consts = {};
    _errors = {};
    _events = {};
    _extrinsicType = 4;
    _isReady = false;
    _query = {};
    _runtimeMap = {};
    _rx = {
        consts: {},
        query: {},
        tx: {}
    };
    /**
   * @description Create an instance of the class
   *
   * @param options Options object to create API instance or a Provider instance
   *
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * const api = new Api().isReady();
   *
   * api.rpc.subscribeNewHeads((header) => {
   *   console.log(`new block #${header.number.toNumber()}`);
   * });
   * ```
   */ constructor(options, type, decorateMethod){
        var _options$source;
        super();
        this.#instanceId = `${++instanceCounter}`;
        this.#registry = ((_options$source = options.source) === null || _options$source === void 0 ? void 0 : _options$source.registry) || options.registry || new (0, _types.TypeRegistry)();
        this._rx.queryAt = (blockHash, knownVersion)=>(0, _rxjs.from)(this.at(blockHash, knownVersion)).pipe((0, _rxjs.map)((a)=>a.rx.query));
        this._rx.registry = this.#registry;
        const thisProvider = options.source ? options.source._rpcCore.provider.clone() : options.provider || new (0, _rpcProvider.WsProvider)();
        this._decorateMethod = decorateMethod;
        this._options = options;
        this._type = type; // The RPC interface decorates the known interfaces on init
        this._rpcCore = new (0, _rpcCore.RpcCore)(this.#instanceId, this.#registry, thisProvider, this._options.rpc);
        this._isConnected = new (0, _rxjs.BehaviorSubject)(this._rpcCore.provider.isConnected);
        this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;
    }
    /**
   * @description Return the current used registry
   */ get registry() {
        return this.#registry;
    }
    /**
   * @description Creates an instance of a type as registered
   */ createType(type, ...params) {
        return this.#registry.createType(type, ...params);
    }
    /**
   * @description Register additional user-defined of chain-specific types in the type registry
   */ registerTypes(types) {
        types && this.#registry.register(types);
    }
    /**
   * @returns `true` if the API operates with subscriptions
   */ get hasSubscriptions() {
        return this._rpcCore.provider.hasSubscriptions;
    }
    /**
   * @returns `true` if the API decorate multi-key queries
   */ get supportMulti() {
        return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;
    }
    _emptyDecorated(registry, blockHash) {
        return {
            call: {},
            consts: {},
            errors: {},
            events: {},
            query: {},
            registry,
            rx: {
                query: {}
            },
            tx: (0, _indexJs.createSubmittable)(this._type, this._rx, this._decorateMethod, registry, blockHash)
        };
    }
    _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {
        if (!decoratedApi) decoratedApi = this._emptyDecorated(registry.registry, blockHash);
        if (fromEmpty || !registry.decoratedMeta) registry.decoratedMeta = (0, _types.expandMetadata)(registry.registry, registry.metadata);
        const runtime = this._decorateCalls(registry, this._decorateMethod, blockHash);
        const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);
        const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);
        (0, _augmentObjectJs.augmentObject)("consts", registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);
        (0, _augmentObjectJs.augmentObject)("errors", registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);
        (0, _augmentObjectJs.augmentObject)("events", registry.decoratedMeta.events, decoratedApi.events, fromEmpty);
        (0, _augmentObjectJs.augmentObject)("query", storage, decoratedApi.query, fromEmpty);
        (0, _augmentObjectJs.augmentObject)("query", storageRx, decoratedApi.rx.query, fromEmpty);
        (0, _augmentObjectJs.augmentObject)("call", runtime, decoratedApi.call, fromEmpty);
        decoratedApi.findCall = (callIndex)=>(0, _findJs.findCall)(registry.registry, callIndex);
        decoratedApi.findError = (errorIndex)=>(0, _findJs.findError)(registry.registry, errorIndex);
        decoratedApi.queryMulti = blockHash ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash) : this._decorateMulti(this._decorateMethod);
        decoratedApi.runtimeVersion = registry.runtimeVersion;
        return {
            decoratedApi,
            decoratedMeta: registry.decoratedMeta
        };
    }
    _injectMetadata(registry, fromEmpty = false) {
        // clear the decoration, we are redoing it here
        if (fromEmpty || !registry.decoratedApi) registry.decoratedApi = this._emptyDecorated(registry.registry);
        const { decoratedApi , decoratedMeta  } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);
        this._call = decoratedApi.call;
        this._consts = decoratedApi.consts;
        this._errors = decoratedApi.errors;
        this._events = decoratedApi.events;
        this._query = decoratedApi.query;
        this._rx.query = decoratedApi.rx.query;
        const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);
        const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);
        if (fromEmpty || !this._extrinsics) {
            this._extrinsics = tx;
            this._rx.tx = rxtx;
        } else {
            (0, _augmentObjectJs.augmentObject)("tx", tx, this._extrinsics, false);
            (0, _augmentObjectJs.augmentObject)(null, rxtx, this._rx.tx, false);
        }
        (0, _augmentObjectJs.augmentObject)(null, decoratedMeta.consts, this._rx.consts, fromEmpty);
        this.emit("decorated");
    }
    /**
   * @deprecated
   * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)
   */ injectMetadata(metadata, fromEmpty, registry) {
        this._injectMetadata({
            metadata,
            registry: registry || this.#registry,
            runtimeVersion: this.#registry.createType("RuntimeVersionPartial")
        }, fromEmpty);
    }
    _decorateFunctionMeta(input, output) {
        output.meta = input.meta;
        output.method = input.method;
        output.section = input.section;
        output.toJSON = input.toJSON;
        if (input.callIndex) output.callIndex = input.callIndex;
        return output;
    }
    // manner to cater for both old and new:
    //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)
    //   - when non-zero, remove anything that is not in the array (we don't do this)
    _filterRpc(methods, additional) {
        // add any specific user-base RPCs
        if (Object.keys(additional).length !== 0) {
            this._rpcCore.addUserInterfaces(additional); // re-decorate, only adding any new additional interfaces
            this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);
            this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);
        } // extract the actual sections from the methods (this is useful when
        // we try and create mappings to runtime names via a hash mapping)
        const sectionMap = {};
        for(let i = 0; i < methods.length; i++){
            const [section] = methods[i].split("_");
            sectionMap[section] = true;
        } // convert the actual section names into an easy name lookup
        const sections = Object.keys(sectionMap);
        for(let i1 = 0; i1 < sections.length; i1++){
            const nameA = (0, _util.stringUpperFirst)(sections[i1]);
            const nameB = `${nameA}Api`;
            this._runtimeMap[(0, _utilCrypto.blake2AsHex)(nameA, 64)] = nameA;
            this._runtimeMap[(0, _utilCrypto.blake2AsHex)(nameB, 64)] = nameB;
        } // finally we filter the actual methods to expose
        this._filterRpcMethods(methods);
    }
    _filterRpcMethods(exposed) {
        const hasResults = exposed.length !== 0;
        const allKnown = [
            ...this._rpcCore.mapping.entries()
        ];
        const allKeys = [];
        for(let i = 0; i < allKnown.length; i++){
            const [, { alias , endpoint , method , pubsub , section  }] = allKnown[i];
            allKeys.push(`${section}_${method}`);
            if (pubsub) {
                allKeys.push(`${section}_${pubsub[1]}`);
                allKeys.push(`${section}_${pubsub[2]}`);
            }
            if (alias) allKeys.push(...alias);
            if (endpoint) allKeys.push(endpoint);
        }
        const filterKey = (k)=>!allKeys.includes(k);
        const unknown = exposed.filter(filterKey);
        if (unknown.length) l.warn(`RPC methods not decorated: ${unknown.join(", ")}`);
         // loop through all entries we have (populated in decorate) and filter as required
        // only remove when we have results and method missing, or with no results if optional
        for(let i1 = 0; i1 < allKnown.length; i1++){
            const [k, { method: method1 , section: section1  }] = allKnown[i1];
            if (hasResults && !exposed.includes(k) && k !== "rpc_methods") {
                if (this._rpc[section1]) {
                    delete this._rpc[section1][method1];
                    delete this._rx.rpc[section1][method1];
                }
            }
        }
    }
    _decorateRpc(rpc, decorateMethod, input = {}) {
        const out = input;
        const decorateFn = (section, method)=>{
            const source = rpc[section][method];
            const fn = decorateMethod(source, {
                methodName: method
            });
            fn.meta = source.meta;
            fn.raw = decorateMethod(source.raw, {
                methodName: method
            });
            return fn;
        };
        for(let s = 0; s < rpc.sections.length; s++){
            const section = rpc.sections[s];
            if (!Object.prototype.hasOwnProperty.call(out, section)) {
                const methods = Object.keys(rpc[section]);
                const decorateInternal = (method)=>decorateFn(section, method);
                for(let m = 0; m < methods.length; m++){
                    const method = methods[m]; //  skip subscriptions where we have a non-subscribe interface
                    if (this.hasSubscriptions || !(method.startsWith("subscribe") || method.startsWith("unsubscribe"))) {
                        if (!Object.prototype.hasOwnProperty.call(out, section)) out[section] = {};
                        (0, _util.lazyMethod)(out[section], method, decorateInternal);
                    }
                }
            }
        }
        return out;
    }
    _addRuntimeDef(result, additional) {
        if (!additional) return;
        const entries = Object.entries(additional);
        for(let j = 0; j < entries.length; j++){
            const [key, defs] = entries[j];
            if (result[key]) // we have this one already, step through for new versions or
            // new methods and add those as applicable
            for(let k = 0; k < defs.length; k++){
                const def = defs[k];
                const prev = result[key].find(({ version  })=>def.version === version);
                if (prev) // interleave the new methods with the old - last definition wins
                (0, _util.objectSpread)(prev.methods, def.methods);
                else // we don't have this specific version, add it
                result[key].push(def);
            }
            else // we don't have this runtime definition, add it as-is
            result[key] = defs;
        }
    }
    _getRuntimeDefs(registry, specName, chain = "") {
        const result = {};
        const defValues = Object.values((0, _types.typeDefinitions)); // options > chain/spec > built-in, apply in reverse order with
        // methods overriding previous definitions (or interleave missing)
        for(let i = 0; i < defValues.length; i++)this._addRuntimeDef(result, defValues[i].runtime);
        this._addRuntimeDef(result, (0, _typesKnown.getSpecRuntime)(registry, chain, specName));
        this._addRuntimeDef(result, this._options.runtime);
        return Object.entries(result);
    }
    _decorateCalls({ registry , runtimeVersion: { apis , specName  }  }, decorateMethod, blockHash) {
        const result = {};
        const named = {};
        const hashes = {};
        const sections = this._getRuntimeDefs(registry, specName, this._runtimeChain);
        const older = [];
        for(let i = 0; i < sections.length; i++){
            const [_section, secs] = sections[i];
            const sectionHash = (0, _utilCrypto.blake2AsHex)(_section, 64);
            const rtApi = apis.find(([a])=>a.eq(sectionHash));
            hashes[sectionHash] = true;
            if (rtApi) {
                const all = secs.map(({ version  })=>version).sort();
                const sec = secs.find(({ version  })=>rtApi[1].eq(version));
                if (sec) {
                    const section = (0, _util.stringCamelCase)(_section);
                    const methods = Object.entries(sec.methods);
                    if (methods.length) {
                        if (!named[section]) named[section] = {};
                        for(let m = 0; m < methods.length; m++){
                            const [_method, def] = methods[m];
                            const method = (0, _util.stringCamelCase)(_method);
                            named[section][method] = (0, _util.objectSpread)({
                                method,
                                name: `${_section}_${_method}`,
                                section,
                                sectionHash
                            }, def);
                        }
                    }
                } else older.push(`${_section}/${rtApi[1].toString()} (${all.join("/")} known)`);
            }
        } // find the runtimes that we don't have hashes for
        const notFound = apis.map(([a, v])=>[
                a.toHex(),
                v.toString()
            ]).filter(([a])=>!hashes[a]).map(([a, v])=>`${this._runtimeMap[a] || a}/${v}`);
        if (older.length) l.warn(`Not decorating runtime apis without matching versions: ${older.join(", ")}`);
        if (notFound.length) l.warn(`Not decorating unknown runtime apis: ${notFound.join(", ")}`);
        const stateCall = blockHash ? (name, bytes)=>this._rpcCore.state.call(name, bytes, blockHash) : (name, bytes)=>this._rpcCore.state.call(name, bytes);
        const lazySection = (section)=>(0, _util.lazyMethods)({}, Object.keys(named[section]), (method)=>this._decorateCall(registry, named[section][method], stateCall, decorateMethod));
        const modules = Object.keys(named);
        for(let i1 = 0; i1 < modules.length; i1++)(0, _util.lazyMethod)(result, modules[i1], lazySection);
        return result;
    }
    _decorateCall(registry, def, stateCall, decorateMethod) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const decorated = decorateMethod((...args)=>{
            if (args.length !== def.params.length) throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);
            const bytes = registry.createType("Raw", (0, _util.u8aConcatStrict)(args.map((a, i)=>registry.createTypeUnsafe(def.params[i].type, [
                    a
                ]).toU8a())));
            return stateCall(def.name, bytes).pipe((0, _rxjs.map)((r)=>registry.createTypeUnsafe(def.type, [
                    r
                ])));
        });
        decorated.meta = def; // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorated;
    }
    _decorateMulti(decorateMethod) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorateMethod((keys)=>(this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(keys.map((args)=>Array.isArray(args) ? args[0].creator.meta.type.isPlain ? [
                    args[0].creator
                ] : args[0].creator.meta.type.asMap.hashers.length === 1 ? [
                    args[0].creator,
                    args.slice(1)
                ] : [
                    args[0].creator,
                    ...args.slice(1)
                ] : [
                    args.creator
                ])));
    }
    _decorateMultiAt(atApi, decorateMethod, blockHash) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorateMethod((calls)=>this._rpcCore.state.queryStorageAt(calls.map((args)=>{
                if (Array.isArray(args)) {
                    const { creator  } = getAtQueryFn(atApi, args[0].creator);
                    return creator.meta.type.isPlain ? [
                        creator
                    ] : creator.meta.type.asMap.hashers.length === 1 ? [
                        creator,
                        args.slice(1)
                    ] : [
                        creator,
                        ...args.slice(1)
                    ];
                }
                return [
                    getAtQueryFn(atApi, args.creator).creator
                ];
            }), blockHash));
    }
    _decorateExtrinsics({ tx  }, decorateMethod) {
        const result = (0, _indexJs.createSubmittable)(this._type, this._rx, decorateMethod);
        const lazySection = (section)=>(0, _util.lazyMethods)({}, Object.keys(tx[section]), (method)=>method.startsWith("$") ? tx[section][method] : this._decorateExtrinsicEntry(tx[section][method], result));
        const sections = Object.keys(tx);
        for(let i = 0; i < sections.length; i++)(0, _util.lazyMethod)(result, sections[i], lazySection);
        return result;
    }
    _decorateExtrinsicEntry(method, creator) {
        const decorated = (...params)=>creator(method(...params)); // pass through the `.is`
        decorated.is = (other)=>method.is(other); // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this._decorateFunctionMeta(method, decorated);
    }
    _decorateStorage({ query , registry  }, decorateMethod, blockHash) {
        const result = {};
        const lazySection = (section)=>(0, _util.lazyMethods)({}, Object.keys(query[section]), (method)=>blockHash ? this._decorateStorageEntryAt(registry, query[section][method], decorateMethod, blockHash) : this._decorateStorageEntry(query[section][method], decorateMethod));
        const sections = Object.keys(query);
        for(let i = 0; i < sections.length; i++)(0, _util.lazyMethod)(result, sections[i], lazySection);
        return result;
    }
    _decorateStorageEntry(creator, decorateMethod) {
        const getArgs = (args, registry)=>(0, _validateJs.extractStorageArgs)(registry || this.#registry, creator, args);
        const getQueryAt = (blockHash)=>(0, _rxjs.from)(this.at(blockHash)).pipe((0, _rxjs.map)((api)=>getAtQueryFn(api, creator))); // Disable this where it occurs for each field we are decorating
        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */ const decorated = this._decorateStorageCall(creator, decorateMethod);
        decorated.creator = creator;
        decorated.at = decorateMethod((blockHash, ...args)=>getQueryAt(blockHash).pipe((0, _rxjs.switchMap)((q)=>q(...args))));
        decorated.hash = decorateMethod((...args)=>this._rpcCore.state.getStorageHash(getArgs(args)));
        decorated.is = (key)=>key.section === creator.section && key.method === creator.method;
        decorated.key = (...args)=>(0, _util.u8aToHex)((0, _util.compactStripLength)(creator(...args))[1]);
        decorated.keyPrefix = (...args)=>(0, _util.u8aToHex)(creator.keyPrefix(...args));
        decorated.range = decorateMethod((range, ...args)=>this._decorateStorageRange(decorated, args, range));
        decorated.size = decorateMethod((...args)=>this._rpcCore.state.getStorageSize(getArgs(args)));
        decorated.sizeAt = decorateMethod((blockHash, ...args)=>getQueryAt(blockHash).pipe((0, _rxjs.switchMap)((q)=>this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash)))); // .keys() & .entries() only available on map types
        if (creator.iterKey && creator.meta.type.isMap) {
            decorated.entries = decorateMethod((0, _rpcCore.memo)(this.#instanceId, (...args)=>this._retrieveMapEntries(creator, null, args)));
            decorated.entriesAt = decorateMethod((0, _rpcCore.memo)(this.#instanceId, (blockHash, ...args)=>getQueryAt(blockHash).pipe((0, _rxjs.switchMap)((q)=>this._retrieveMapEntries(q.creator, blockHash, args)))));
            decorated.entriesPaged = decorateMethod((0, _rpcCore.memo)(this.#instanceId, (opts)=>this._retrieveMapEntriesPaged(creator, undefined, opts)));
            decorated.keys = decorateMethod((0, _rpcCore.memo)(this.#instanceId, (...args)=>this._retrieveMapKeys(creator, null, args)));
            decorated.keysAt = decorateMethod((0, _rpcCore.memo)(this.#instanceId, (blockHash, ...args)=>getQueryAt(blockHash).pipe((0, _rxjs.switchMap)((q)=>this._retrieveMapKeys(q.creator, blockHash, args)))));
            decorated.keysPaged = decorateMethod((0, _rpcCore.memo)(this.#instanceId, (opts)=>this._retrieveMapKeysPaged(creator, undefined, opts)));
        }
        if (this.supportMulti && creator.meta.type.isMap) // When using double map storage function, user need to pass double map key as an array
        decorated.multi = decorateMethod((args)=>creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map((a)=>[
                    creator,
                    [
                        a
                    ]
                ])) : this._retrieveMulti(args.map((a)=>[
                    creator,
                    a
                ])));
        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */ return this._decorateFunctionMeta(creator, decorated);
    }
    _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {
        const getArgs = (args)=>(0, _validateJs.extractStorageArgs)(registry, creator, args); // Disable this where it occurs for each field we are decorating
        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */ const decorated = decorateMethod((...args)=>this._rpcCore.state.getStorage(getArgs(args), blockHash));
        decorated.creator = creator;
        decorated.hash = decorateMethod((...args)=>this._rpcCore.state.getStorageHash(getArgs(args), blockHash));
        decorated.is = (key)=>key.section === creator.section && key.method === creator.method;
        decorated.key = (...args)=>(0, _util.u8aToHex)((0, _util.compactStripLength)(creator(creator.meta.type.isPlain ? undefined : args))[1]);
        decorated.keyPrefix = (...keys)=>(0, _util.u8aToHex)(creator.keyPrefix(...keys));
        decorated.size = decorateMethod((...args)=>this._rpcCore.state.getStorageSize(getArgs(args), blockHash)); // .keys() & .entries() only available on map types
        if (creator.iterKey && creator.meta.type.isMap) {
            decorated.entries = decorateMethod((0, _rpcCore.memo)(this.#instanceId, (...args)=>this._retrieveMapEntries(creator, blockHash, args)));
            decorated.entriesPaged = decorateMethod((0, _rpcCore.memo)(this.#instanceId, (opts)=>this._retrieveMapEntriesPaged(creator, blockHash, opts)));
            decorated.keys = decorateMethod((0, _rpcCore.memo)(this.#instanceId, (...args)=>this._retrieveMapKeys(creator, blockHash, args)));
            decorated.keysPaged = decorateMethod((0, _rpcCore.memo)(this.#instanceId, (opts)=>this._retrieveMapKeysPaged(creator, blockHash, opts)));
        }
        if (this.supportMulti && creator.meta.type.isMap) // When using double map storage function, user need to pass double map key as an array
        decorated.multi = decorateMethod((args)=>creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map((a)=>[
                    creator,
                    [
                        a
                    ]
                ]), blockHash) : this._retrieveMulti(args.map((a)=>[
                    creator,
                    a
                ]), blockHash));
        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */ return this._decorateFunctionMeta(creator, decorated);
    }
    _queueStorage(call, queue) {
        const query = queue === this.#storageSubQ ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
        let queueIdx = queue.length - 1;
        let valueIdx = 0;
        let valueObs;
        if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {
            queueIdx++;
            valueObs = (0, _rxjs.from)(// however since we return a value here, we don't re-use what is there
            Promise.resolve().then(()=>{
                const calls = queue[queueIdx][1];
                delete queue[queueIdx];
                return calls;
            })).pipe((0, _rxjs.switchMap)((calls)=>query(calls)));
            queue.push([
                valueObs,
                [
                    call
                ]
            ]);
        } else {
            valueObs = queue[queueIdx][0];
            valueIdx = queue[queueIdx][1].length;
            queue[queueIdx][1].push(call);
        }
        return valueObs.pipe((0, _rxjs.map)((values)=>values[valueIdx]));
    }
    // we make a subscription, alternatively we push this through a single-shot query
    _decorateStorageCall(creator, decorateMethod) {
        return decorateMethod((...args)=>{
            const call = (0, _validateJs.extractStorageArgs)(this.#registry, creator, args);
            if (!this.hasSubscriptions) return this._rpcCore.state.getStorage(call);
            return this._queueStorage(call, this.#storageSubQ);
        }, {
            methodName: creator.method,
            overrideNoSub: (...args)=>this._queueStorage((0, _validateJs.extractStorageArgs)(this.#registry, creator, args), this.#storageGetQ)
        });
    }
    _decorateStorageRange(decorated, args, range) {
        const outputType = (0, _types.unwrapStorageType)(this.#registry, decorated.creator.meta.type, decorated.creator.meta.modifier.isOptional);
        return this._rpcCore.state.queryStorage([
            decorated.key(...args)
        ], ...range).pipe((0, _rxjs.map)((result)=>result.map(([blockHash, [value]])=>[
                    blockHash,
                    this.createType(outputType, value.isSome ? value.unwrap().toHex() : undefined)
                ])));
    }
    _retrieveMulti(keys, blockHash) {
        if (!keys.length) return (0, _rxjs.of)([]);
        const query = this.hasSubscriptions && !blockHash ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
        if (keys.length <= PAGE_SIZE_V) return blockHash ? query(keys, blockHash) : query(keys);
        return (0, _rxjs.combineLatest)((0, _util.arrayChunk)(keys, PAGE_SIZE_V).map((k)=>blockHash ? query(k, blockHash) : query(k))).pipe((0, _rxjs.map)((0, _util.arrayFlatten)));
    }
    _retrieveMapKeys({ iterKey , meta , method , section  }, at, args) {
        if (!iterKey || !meta.type.isMap) throw new Error("keys can only be retrieved on maps");
        const headKey = iterKey(...args).toHex();
        const startSubject = new (0, _rxjs.BehaviorSubject)(headKey);
        const query = at ? (startKey)=>this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at) : (startKey)=>this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);
        const setMeta = (key)=>key.setMeta(meta, section, method);
        return startSubject.pipe((0, _rxjs.switchMap)(query), (0, _rxjs.map)((keys)=>keys.map(setMeta)), (0, _rxjs.tap)((keys)=>(0, _util.nextTick)(()=>{
                keys.length === PAGE_SIZE_K ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex()) : startSubject.complete();
            })), (0, _rxjs.toArray)(), (0, _rxjs.map)((0, _util.arrayFlatten)));
    }
    _retrieveMapKeysPaged({ iterKey , meta , method , section  }, at, opts) {
        if (!iterKey || !meta.type.isMap) throw new Error("keys can only be retrieved on maps");
        const setMeta = (key)=>key.setMeta(meta, section, method);
        const query = at ? (headKey)=>this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at) : (headKey)=>this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);
        return query(iterKey(...opts.args).toHex()).pipe((0, _rxjs.map)((keys)=>keys.map(setMeta)));
    }
    _retrieveMapEntries(entry, at, args) {
        const query = at ? (keys)=>this._rpcCore.state.queryStorageAt(keys, at) : (keys)=>this._rpcCore.state.queryStorageAt(keys);
        return this._retrieveMapKeys(entry, at, args).pipe((0, _rxjs.switchMap)((keys)=>keys.length ? (0, _rxjs.combineLatest)((0, _util.arrayChunk)(keys, PAGE_SIZE_V).map(query)).pipe((0, _rxjs.map)((valsArr)=>(0, _util.arrayFlatten)(valsArr).map((value, index)=>[
                        keys[index],
                        value
                    ]))) : (0, _rxjs.of)([])));
    }
    _retrieveMapEntriesPaged(entry, at, opts) {
        const query = at ? (keys)=>this._rpcCore.state.queryStorageAt(keys, at) : (keys)=>this._rpcCore.state.queryStorageAt(keys);
        return this._retrieveMapKeysPaged(entry, at, opts).pipe((0, _rxjs.switchMap)((keys)=>keys.length ? query(keys).pipe((0, _rxjs.map)((valsArr)=>valsArr.map((value, index)=>[
                        keys[index],
                        value
                    ]))) : (0, _rxjs.of)([])));
    }
    _decorateDeriveRx(decorateMethod) {
        var _this$_runtimeVersion, _this$_options$typesB, _this$_options$typesB2, _this$_options$typesB3;
        const specName = (_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specName.toString(); // Pull in derive from api-derive
        const available = (0, _apiDerive.getAvailableDerives)(this.#instanceId, this._rx, (0, _util.objectSpread)({}, this._options.derives, (_this$_options$typesB = this._options.typesBundle) === null || _this$_options$typesB === void 0 ? void 0 : (_this$_options$typesB2 = _this$_options$typesB.spec) === null || _this$_options$typesB2 === void 0 ? void 0 : (_this$_options$typesB3 = _this$_options$typesB2[specName || ""]) === null || _this$_options$typesB3 === void 0 ? void 0 : _this$_options$typesB3.derives));
        return (0, _decorateJs.decorateDeriveSections)(decorateMethod, available);
    }
    _decorateDerive(decorateMethod) {
        return (0, _decorateJs.decorateDeriveSections)(decorateMethod, this._rx.derive);
    }
    /**
   * Put the `this.onCall` function of ApiRx here, because it is needed by
   * `api._rx`.
   */ _rxDecorateMethod = (method)=>{
        return method;
    };
}

},{"rxjs":"lLy7s","@polkadot/api-derive":"5hNo3","@polkadot/rpc-core":"8DbiP","@polkadot/rpc-provider":"bvUtj","@polkadot/types":"fnDGk","@polkadot/types-known":"fbgSe","@polkadot/util":"3HnHw","@polkadot/util-crypto":"f2ofx","../submittable/index.js":"IVbyl","../util/augmentObject.js":"jgmuZ","../util/decorate.js":"dOghB","../util/validate.js":"1FcRj","./Events.js":"1r5Te","./find.js":"kXUDO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jgmuZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is
 * already available, but rather just adds new missing items into the result object.
 * @internal
 */ parcelHelpers.export(exports, "augmentObject", ()=>augmentObject);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
const l = (0, _util.logger)("api/augment");
function logLength(type, values, and = []) {
    return values.length ? ` ${values.length} ${type}${and.length ? " and" : ""}` : "";
}
function logValues(type, values) {
    return values.length ? `\n\t${type.padStart(7)}: ${values.sort().join(", ")}` : "";
} // log details to console
function warn(prefix, type, [added, removed]) {
    if (added.length || removed.length) l.warn(`api.${prefix}: Found${logLength("added", added, removed)}${logLength("removed", removed)} ${type}:${logValues("added", added)}${logValues("removed", removed)}`);
}
function findSectionExcludes(a, b) {
    return a.filter((s)=>!b.includes(s));
}
function findSectionIncludes(a, b) {
    return a.filter((s)=>b.includes(s));
}
function extractSections(src, dst) {
    const srcSections = Object.keys(src);
    const dstSections = Object.keys(dst);
    return [
        findSectionExcludes(srcSections, dstSections),
        findSectionExcludes(dstSections, srcSections)
    ];
}
function findMethodExcludes(src, dst) {
    const srcSections = Object.keys(src);
    const dstSections = findSectionIncludes(Object.keys(dst), srcSections);
    const excludes = [];
    for(let s = 0; s < dstSections.length; s++){
        const section = dstSections[s];
        const srcMethods = Object.keys(src[section]);
        const dstMethods = Object.keys(dst[section]);
        excludes.push(...dstMethods.filter((m)=>!srcMethods.includes(m)).map((m)=>`${section}.${m}`));
    }
    return excludes;
}
function extractMethods(src, dst) {
    return [
        findMethodExcludes(dst, src),
        findMethodExcludes(src, dst)
    ];
}
function lazySection(src, dst) {
    const creator = (m)=>src[m];
    const methods = Object.keys(src);
    for(let i = 0; i < methods.length; i++){
        const method = methods[i]; // We use hasOwnproperty here to only check for the existence of the key,
        // instead of reading dst[section][method] which will evaluate when already
        // set as a lazy value previously
        if (!Object.prototype.hasOwnProperty.call(dst, method)) (0, _util.lazyMethod)(dst, method, creator);
    }
}
function augmentObject(prefix, src, dst, fromEmpty = false) {
    fromEmpty && (0, _util.objectClear)(dst); // NOTE: This part is slightly problematic since it will get the
    // values for at least all the sections and the names of the methods
    // (Since methods won't be decorated before lazy, this _may_ be ok)
    if (prefix && Object.keys(dst).length) {
        warn(prefix, "modules", extractSections(src, dst));
        warn(prefix, "calls", extractMethods(src, dst));
    }
    const sections = Object.keys(src);
    for(let i = 0; i < sections.length; i++){
        const section = sections[i]; // We don't set here with a lazy interface, we decorate based
        // on the top-level structure (this bypasses adding lazy onto lazy)
        if (!dst[section]) dst[section] = {};
        lazySection(src[section], dst[section]);
    }
    return dst;
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1FcRj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// call. Additionally, it verifies that the correct number of arguments have been passed
parcelHelpers.export(exports, "extractStorageArgs", ()=>extractStorageArgs);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
function sig({ lookup  }, { method , section  }, args) {
    return `${section}.${method}(${args.map((a)=>lookup.getTypeDef(a).type).join(", ")})`;
} // sets up the arguments in the form of [creator, args] ready to be used in a storage
function extractStorageArgs(registry, creator, _args) {
    const args = _args.filter((a)=>!(0, _util.isUndefined)(a));
    if (creator.meta.type.isPlain) {
        if (args.length !== 0) throw new Error(`${sig(registry, creator, [])} does not take any arguments, ${args.length} found`);
    } else {
        const { hashers , key  } = creator.meta.type.asMap;
        const keys = hashers.length === 1 ? [
            key
        ] : registry.lookup.getSiType(key).def.asTuple.map((t)=>t);
        if (args.length !== keys.length) throw new Error(`${sig(registry, creator, keys)} is a map, requiring ${keys.length} arguments, ${args.length} found`);
    } // pass as tuple
    return [
        creator,
        args
    ];
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1r5Te":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Events", ()=>Events);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _eventemitter3 = require("eventemitter3");
var _eventemitter3Default = parcelHelpers.interopDefault(_eventemitter3);
class Events {
    #eventemitter = new (0, _eventemitter3Default.default)();
    emit(type, ...args) {
        return this.#eventemitter.emit(type, ...args);
    }
    /**
   * @description Attach an eventemitter handler to listen to a specific event
   *
   * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.on('connected', (): void => {
   *   console.log('API has been connected to the endpoint');
   * });
   *
   * api.on('disconnected', (): void => {
   *   console.log('API has been disconnected from the endpoint');
   * });
   * ```
   */ on(type, handler) {
        this.#eventemitter.on(type, handler);
        return this;
    }
    /**
   * @description Remove the given eventemitter handler
   *
   * @param type The type of event the callback was attached to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to unregister.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const handler = (): void => {
   *  console.log('Connected !);
   * };
   *
   * // Start listening
   * api.on('connected', handler);
   *
   * // Stop listening
   * api.off('connected', handler);
   * ```
   */ off(type, handler) {
        this.#eventemitter.removeListener(type, handler);
        return this;
    }
    /**
   * @description Attach an one-time eventemitter handler to listen to a specific event
   *
   * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.once('connected', (): void => {
   *   console.log('API has been connected to the endpoint');
   * });
   *
   * api.once('disconnected', (): void => {
   *   console.log('API has been disconnected from the endpoint');
   * });
   * ```
   */ once(type, handler) {
        this.#eventemitter.once(type, handler);
        return this;
    }
}

},{"eventemitter3":"3fnfh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2zQtY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Combinator", ()=>Combinator);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _util = require("@polkadot/util");
class Combinator {
    #allHasFired = false;
    #callback;
    #fired = [];
    #fns = [];
    #isActive = true;
    #results = [];
    #subscriptions = [];
    constructor(fns, callback){
        this.#callback = callback; // eslint-disable-next-line @typescript-eslint/require-await
        this.#subscriptions = fns.map(async (input, index)=>{
            const [fn, ...args] = Array.isArray(input) ? input : [
                input
            ];
            this.#fired.push(false);
            this.#fns.push(fn); // Not quite 100% how to have a variable number at the front here
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/ban-types
            return fn(...args, this._createCallback(index));
        });
    }
    _allHasFired() {
        this.#allHasFired || (this.#allHasFired = this.#fired.filter((hasFired)=>!hasFired).length === 0);
        return this.#allHasFired;
    }
    _createCallback(index) {
        return (value)=>{
            this.#fired[index] = true;
            this.#results[index] = value;
            this._triggerUpdate();
        };
    }
    _triggerUpdate() {
        if (!this.#isActive || !(0, _util.isFunction)(this.#callback) || !this._allHasFired()) return;
        try {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.#callback(this.#results);
        } catch (error) {}
    }
    unsubscribe() {
        if (!this.#isActive) return;
        this.#isActive = false; // eslint-disable-next-line @typescript-eslint/no-misused-promises
        this.#subscriptions.forEach(async (subscription)=>{
            try {
                const unsubscribe = await subscription;
                if ((0, _util.isFunction)(unsubscribe)) unsubscribe();
            } catch (error) {}
        });
    }
}

},{"@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d0NEl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// a Promise completion tracker, wrapping an isComplete variable that ensures
// that the promise only resolves once
parcelHelpers.export(exports, "promiseTracker", ()=>promiseTracker) // extract the arguments and callback params from a value array possibly containing a callback
;
/**
 * @description Decorate method for ApiPromise, where the results are converted to the Promise equivalent
 */ parcelHelpers.export(exports, "toPromiseMethod", ()=>toPromiseMethod);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
function promiseTracker(resolve, reject) {
    let isCompleted = false;
    return {
        reject: (error)=>{
            if (!isCompleted) {
                isCompleted = true;
                reject(error);
            }
            return 0, _rxjs.EMPTY;
        },
        resolve: (value)=>{
            if (!isCompleted) {
                isCompleted = true;
                resolve(value);
            }
        }
    };
}
function extractArgs(args, needsCallback) {
    const actualArgs = args.slice(); // If the last arg is a function, we pop it, put it into callback.
    // actualArgs will then hold the actual arguments to be passed to `method`
    const callback = args.length && (0, _util.isFunction)(args[args.length - 1]) ? actualArgs.pop() : undefined; // When we need a subscription, ensure that a valid callback is actually passed
    if (needsCallback && !(0, _util.isFunction)(callback)) throw new Error("Expected a callback to be passed with subscriptions");
    return [
        actualArgs,
        callback
    ];
} // Decorate a call for a single-shot result - retrieve and then immediate unsubscribe
function decorateCall(method, args) {
    return new Promise((resolve, reject)=>{
        // single result tracker - either reject with Error or resolve with Codec result
        const tracker = promiseTracker(resolve, reject); // encoding errors reject immediately, any result unsubscribes and resolves
        const subscription = method(...args).pipe((0, _rxjs.catchError)((error)=>tracker.reject(error))).subscribe((result)=>{
            tracker.resolve(result);
            (0, _util.nextTick)(()=>subscription.unsubscribe());
        });
    });
} // Decorate a subscription where we have a result callback specified
function decorateSubscribe(method, args, resultCb) {
    return new Promise((resolve, reject)=>{
        // either reject with error or resolve with unsubscribe callback
        const tracker = promiseTracker(resolve, reject); // errors reject immediately, the first result resolves with an unsubscribe promise, all results via callback
        const subscription = method(...args).pipe((0, _rxjs.catchError)((error)=>tracker.reject(error)), (0, _rxjs.tap)(()=>tracker.resolve(()=>subscription.unsubscribe()))).subscribe((result)=>{
            // queue result (back of queue to clear current)
            (0, _util.nextTick)(()=>resultCb(result));
        });
    });
}
function toPromiseMethod(method, options) {
    const needsCallback = !!(options && options.methodName && options.methodName.includes("subscribe"));
    return function(...args) {
        const [actualArgs, resultCb] = extractArgs(args, needsCallback);
        return resultCb ? decorateSubscribe(method, actualArgs, resultCb) : decorateCall((options === null || options === void 0 ? void 0 : options.overrideNoSub) || method, actualArgs);
    };
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Nj2E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "ApiRx", ()=>(0, _apiJs.ApiRx));
parcelHelpers.export(exports, "toRxMethod", ()=>(0, _decorateMethodJs.toRxMethod));
var _apiJs = require("./Api.js");
var _decorateMethodJs = require("./decorateMethod.js");

},{"./Api.js":"jezRi","./decorateMethod.js":"5j2EJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jezRi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * # @polkadot/api/rx
 *
 *  ## Overview
 *
 * @name ApiRx
 *
 * @description
 * ApiRx is a powerful RxJS Observable wrapper around the RPC and interfaces on the Polkadot network. As a full Observable API, all interface calls return RxJS Observables, including the static `.create(...)`. In the same fashion and subscription-based methods return long-running Observables that update with the latest values.
 *
 * The API is well suited to real-time applications where the latest state is needed, unlocking the subscription-based features of Polkadot (and Substrate) clients. Some familiarity with RxJS is a requirement to use the API, however just understanding `.subscribe` and `.pipe` on Observables will unlock full-scale use thereof.
 *
 * @see [[ApiPromise]]
 *
 * ## Usage
 *
 * Making rpc calls -
 * <BR>
 *
 * ```javascript
 * import ApiRx from '@polkadot/api/rx';
 *
 * // initialize via Promise & static create
 * const api = await ApiRx.create().toPromise();
 *
 * // make a call to retrieve the current network head
 * api.rpc.chain.subscribeNewHeads().subscribe((header) => {
 *   console.log(`Chain is at #${header.number}`);
 * });
 * ```
 * <BR>
 *
 * Subscribing to chain state -
 * <BR>
 *
 * ```javascript
 * import { combineLatest, pairwise, switchMap } from 'rxjs';
 * import { ApiRx, WsProvider } from '@polkadot/api';
 *
 *
 * // initialize a provider with a specific endpoint
 * const provider = new WsProvider('wss://example.com:9944')
 *
 * // initialize via isReady & new with specific provider
 * new ApiRx({ provider })
 *   .isReady
 *   .pipe(
 *     switchMap((api) =>
 *       combineLatest([
 *         api.query.timestamp.blockPeriod(),
 *         api.query.timestamp.now().pipe(pairwise())
 *       ])
 *     )
 *   )
 *   .subscribe(([blockPeriod, timestamp]) => {
 *      const elapsed = timestamp[1].toNumber() - timestamp[0].toNumber();
 *      console.log(`timestamp ${timestamp[1]} \nelapsed ${elapsed} \n(${blockPeriod}s target)`);
 *   });
 * ```
 * <BR>
 *
 * Submitting a transaction -
 * <BR>
 *
 * ```javascript
 * import { first, switchMap } from 'rxjs';
 * import ApiRx from '@polkadot/api/rx';
 *
 * // import the test keyring (already has dev keys for Alice, Bob, Charlie, Eve & Ferdie)
 * import testingPairs from '@polkadot/keyring/testingPairs';
 * const keyring = testingPairs();
 *
 * // get api via Promise
 * const api = await ApiRx.create().toPromise();
 *
 * // retrieve nonce for the account
 * api.query.system
 *   .account(keyring.alice.address)
 *   .pipe(
 *      first(),
 *      // pipe nonce into transfer
 *      switchMap(([nonce]) =>
 *        api.tx.balances
 *          // create transfer
 *          .transfer(keyring.bob.address, 12345)
 *          // sign the transaction
 *          .sign(keyring.alice, { nonce })
 *          // send the transaction
 *          .send()
 *      )
 *   )
 *   // subscribe to overall result
 *   .subscribe(({ status }) => {
 *     if (status.isInBlock) {
 *       console.log('Completed at block hash', status.asFinalized.toHex());
 *     }
 *   });
 * ```
 */ parcelHelpers.export(exports, "ApiRx", ()=>ApiRx);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _indexJs = require("../base/index.js");
var _decorateMethodJs = require("./decorateMethod.js");
class ApiRx extends (0, _indexJs.ApiBase) {
    #isReadyRx;
    /**
   * @description Create an instance of the ApiRx class
   * @param options Options to create an instance. Can be either [[ApiOptions]] or [[WsProvider]]
   * @example
   * <BR>
   *
   * ```javascript
   * import { switchMap } from 'rxjs';
   * import Api from '@polkadot/api/rx';
   *
   * new Api().isReady
   *   .pipe(
   *     switchMap((api) =>
   *       api.rpc.chain.subscribeNewHeads()
   *   ))
   *   .subscribe((header) => {
   *     console.log(`new block #${header.number.toNumber()}`);
   *   });
   * ```
   */ constructor(options){
        super(options, "rxjs", (0, _decorateMethodJs.toRxMethod));
        this.#isReadyRx = (0, _rxjs.from)(new Promise((resolve)=>{
            super.on("ready", ()=>resolve(this));
        }));
    }
    /**
   * @description Creates an ApiRx instance using the supplied provider. Returns an Observable containing the actual Api instance.
   * @param options options that is passed to the class constructor. Can be either [[ApiOptions]] or [[WsProvider]]
   * @example
   * <BR>
   *
   * ```javascript
   * import { switchMap } from 'rxjs';
   * import Api from '@polkadot/api/rx';
   *
   * Api.create()
   *   .pipe(
   *     switchMap((api) =>
   *       api.rpc.chain.subscribeNewHeads()
   *   ))
   *   .subscribe((header) => {
   *     console.log(`new block #${header.number.toNumber()}`);
   *   });
   * ```
   */ static create(options) {
        return new ApiRx(options).isReady;
    }
    /**
   * @description Observable that returns the first time we are connected and loaded
   */ get isReady() {
        return this.#isReadyRx;
    }
    /**
   * @description Returns a clone of this ApiRx instance (new underlying provider connection)
   */ clone() {
        return new ApiRx((0, _util.objectSpread)({}, this._options, {
            source: this
        }));
    }
}

},{"rxjs":"lLy7s","@polkadot/util":"3HnHw","../base/index.js":"6OpH1","./decorateMethod.js":"5j2EJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5j2EJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Copyright 2017-2022 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
parcelHelpers.export(exports, "toRxMethod", ()=>toRxMethod);
function toRxMethod(method) {
    return method;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cxe8j":[function(require,module,exports) {
/**
 * Copyright (c) 2016-2022, The Cytoscape Consortium.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the ‚ÄúSoftware‚Äù), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */ "use strict";
var debounce = require("lodash/debounce");
var Heap = require("heap");
var get = require("lodash/get");
var set = require("lodash/set");
var toPath = require("lodash/toPath");
function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {
        "default": e
    };
}
var debounce__default = /*#__PURE__*/ _interopDefaultLegacy(debounce);
var Heap__default = /*#__PURE__*/ _interopDefaultLegacy(Heap);
var get__default = /*#__PURE__*/ _interopDefaultLegacy(get);
var set__default = /*#__PURE__*/ _interopDefaultLegacy(set);
var toPath__default = /*#__PURE__*/ _interopDefaultLegacy(toPath);
function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var window$1 = typeof window === "undefined" ? null : window; // eslint-disable-line no-undef
var navigator = window$1 ? window$1.navigator : null;
window$1 && window$1.document;
var typeofstr = _typeof("");
var typeofobj = _typeof({});
var typeoffn = _typeof(function() {});
var typeofhtmlele = typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement);
var instanceStr = function instanceStr(obj) {
    return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;
};
var string = function string(obj) {
    return obj != null && _typeof(obj) == typeofstr;
};
var fn$6 = function fn(obj) {
    return obj != null && _typeof(obj) === typeoffn;
};
var array = function array(obj) {
    return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);
};
var plainObject = function plainObject(obj) {
    return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;
};
var object = function object(obj) {
    return obj != null && _typeof(obj) === typeofobj;
};
var number$1 = function number(obj) {
    return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);
};
var integer = function integer(obj) {
    return number$1(obj) && Math.floor(obj) === obj;
};
var htmlElement = function htmlElement(obj) {
    if ("undefined" === typeofhtmlele) return undefined;
    else return null != obj && obj instanceof HTMLElement;
};
var elementOrCollection = function elementOrCollection(obj) {
    return element(obj) || collection(obj);
};
var element = function element(obj) {
    return instanceStr(obj) === "collection" && obj._private.single;
};
var collection = function collection(obj) {
    return instanceStr(obj) === "collection" && !obj._private.single;
};
var core = function core(obj) {
    return instanceStr(obj) === "core";
};
var stylesheet = function stylesheet(obj) {
    return instanceStr(obj) === "stylesheet";
};
var event = function event(obj) {
    return instanceStr(obj) === "event";
};
var emptyString = function emptyString(obj) {
    if (obj === undefined || obj === null) // null is empty
    return true;
    else if (obj === "" || obj.match(/^\s+$/)) return true; // empty string is empty
    return false; // otherwise, we don't know what we've got
};
var domElement = function domElement(obj) {
    if (typeof HTMLElement === "undefined") return false; // we're not in a browser so it doesn't matter
    else return obj instanceof HTMLElement;
};
var boundingBox = function boundingBox(obj) {
    return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);
};
var promise = function promise(obj) {
    return object(obj) && fn$6(obj.then);
};
var ms = function ms() {
    return navigator && navigator.userAgent.match(/msie|trident|edge/i);
}; // probably a better way to detect this...
var memoize = function memoize(fn, keyFn) {
    if (!keyFn) keyFn = function keyFn() {
        if (arguments.length === 1) return arguments[0];
        else if (arguments.length === 0) return "undefined";
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        return args.join("$");
    };
    var memoizedFn = function memoizedFn() {
        var self = this;
        var args = arguments;
        var ret;
        var k = keyFn.apply(self, args);
        var cache = memoizedFn.cache;
        if (!(ret = cache[k])) ret = cache[k] = fn.apply(self, args);
        return ret;
    };
    memoizedFn.cache = {};
    return memoizedFn;
};
var camel2dash = memoize(function(str) {
    return str.replace(/([A-Z])/g, function(v) {
        return "-" + v.toLowerCase();
    });
});
var dash2camel = memoize(function(str) {
    return str.replace(/(-\w)/g, function(v) {
        return v[1].toUpperCase();
    });
});
var prependCamel = memoize(function(prefix, str) {
    return prefix + str[0].toUpperCase() + str.substring(1);
}, function(prefix, str) {
    return prefix + "$" + str;
});
var capitalize = function capitalize(str) {
    if (emptyString(str)) return str;
    return str.charAt(0).toUpperCase() + str.substring(1);
};
var number = "(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))";
var rgba = "rgb[a]?\\((" + number + "[%]?)\\s*,\\s*(" + number + "[%]?)\\s*,\\s*(" + number + "[%]?)(?:\\s*,\\s*(" + number + "))?\\)";
var rgbaNoBackRefs = "rgb[a]?\\((?:" + number + "[%]?)\\s*,\\s*(?:" + number + "[%]?)\\s*,\\s*(?:" + number + "[%]?)(?:\\s*,\\s*(?:" + number + "))?\\)";
var hsla = "hsl[a]?\\((" + number + ")\\s*,\\s*(" + number + "[%])\\s*,\\s*(" + number + "[%])(?:\\s*,\\s*(" + number + "))?\\)";
var hslaNoBackRefs = "hsl[a]?\\((?:" + number + ")\\s*,\\s*(?:" + number + "[%])\\s*,\\s*(?:" + number + "[%])(?:\\s*,\\s*(?:" + number + "))?\\)";
var hex3 = "\\#[0-9a-fA-F]{3}";
var hex6 = "\\#[0-9a-fA-F]{6}";
var ascending = function ascending(a, b) {
    if (a < b) return -1;
    else if (a > b) return 1;
    else return 0;
};
var descending = function descending(a, b) {
    return -1 * ascending(a, b);
};
var extend = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {
    var args = arguments;
    for(var i = 1; i < args.length; i++){
        var obj = args[i];
        if (obj == null) continue;
        var keys = Object.keys(obj);
        for(var j = 0; j < keys.length; j++){
            var k = keys[j];
            tgt[k] = obj[k];
        }
    }
    return tgt;
};
var hex2tuple = function hex2tuple(hex) {
    if (!(hex.length === 4 || hex.length === 7) || hex[0] !== "#") return;
    var shortHex = hex.length === 4;
    var r, g, b;
    var base = 16;
    if (shortHex) {
        r = parseInt(hex[1] + hex[1], base);
        g = parseInt(hex[2] + hex[2], base);
        b = parseInt(hex[3] + hex[3], base);
    } else {
        r = parseInt(hex[1] + hex[2], base);
        g = parseInt(hex[3] + hex[4], base);
        b = parseInt(hex[5] + hex[6], base);
    }
    return [
        r,
        g,
        b
    ];
}; // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
var hsl2tuple = function hsl2tuple(hsl) {
    var ret;
    var h, s, l, a, r, g, b;
    function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 0.5) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
    }
    var m1 = new RegExp("^" + hsla + "$").exec(hsl);
    if (m1) {
        // get hue
        h = parseInt(m1[1]);
        if (h < 0) h = (360 - -1 * h % 360) % 360;
        else if (h > 360) h = h % 360;
        h /= 360; // normalise on [0, 1]
        s = parseFloat(m1[2]);
        if (s < 0 || s > 100) return;
         // saturation is [0, 100]
        s = s / 100; // normalise on [0, 1]
        l = parseFloat(m1[3]);
        if (l < 0 || l > 100) return;
         // lightness is [0, 100]
        l = l / 100; // normalise on [0, 1]
        a = m1[4];
        if (a !== undefined) {
            a = parseFloat(a);
            if (a < 0 || a > 1) return;
             // alpha is [0, 1]
        } // now, convert to rgb
        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
        if (s === 0) r = g = b = Math.round(l * 255); // achromatic
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));
            g = Math.round(255 * hue2rgb(p, q, h));
            b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));
        }
        ret = [
            r,
            g,
            b,
            a
        ];
    }
    return ret;
}; // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
var rgb2tuple = function rgb2tuple(rgb) {
    var ret;
    var m1 = new RegExp("^" + rgba + "$").exec(rgb);
    if (m1) {
        ret = [];
        var isPct = [];
        for(var i = 1; i <= 3; i++){
            var channel = m1[i];
            if (channel[channel.length - 1] === "%") isPct[i] = true;
            channel = parseFloat(channel);
            if (isPct[i]) channel = channel / 100 * 255; // normalise to [0, 255]
            if (channel < 0 || channel > 255) return;
             // invalid channel value
            ret.push(Math.floor(channel));
        }
        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
        var allArePct = isPct[1] && isPct[2] && isPct[3];
        if (atLeastOneIsPct && !allArePct) return;
         // must all be percent values if one is
        var alpha = m1[4];
        if (alpha !== undefined) {
            alpha = parseFloat(alpha);
            if (alpha < 0 || alpha > 1) return;
             // invalid alpha value
            ret.push(alpha);
        }
    }
    return ret;
};
var colorname2tuple = function colorname2tuple(color) {
    return colors[color.toLowerCase()];
};
var color2tuple = function color2tuple(color) {
    return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);
};
var colors = {
    // special colour names
    transparent: [
        0,
        0,
        0,
        0
    ],
    // NB alpha === 0
    // regular colours
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    grey: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
};
var setMap = function setMap(options) {
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    for(var i = 0; i < l; i++){
        var key = keys[i];
        if (plainObject(key)) throw Error("Tried to set map with object key");
        if (i < keys.length - 1) {
            // extend the map if necessary
            if (obj[key] == null) obj[key] = {};
            obj = obj[key];
        } else // set the value
        obj[key] = options.value;
    }
}; // gets the value in a map even if it's not built in places
var getMap = function getMap(options) {
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    for(var i = 0; i < l; i++){
        var key = keys[i];
        if (plainObject(key)) throw Error("Tried to get map with object key");
        obj = obj[key];
        if (obj == null) return obj;
    }
    return obj;
}; // deletes the entry in the map
var performance = window$1 ? window$1.performance : null;
var pnow = performance && performance.now ? function() {
    return performance.now();
} : function() {
    return Date.now();
};
var raf = function() {
    if (window$1) {
        if (window$1.requestAnimationFrame) return function(fn) {
            window$1.requestAnimationFrame(fn);
        };
        else if (window$1.mozRequestAnimationFrame) return function(fn) {
            window$1.mozRequestAnimationFrame(fn);
        };
        else if (window$1.webkitRequestAnimationFrame) return function(fn) {
            window$1.webkitRequestAnimationFrame(fn);
        };
        else if (window$1.msRequestAnimationFrame) return function(fn) {
            window$1.msRequestAnimationFrame(fn);
        };
    }
    return function(fn) {
        if (fn) setTimeout(function() {
            fn(pnow());
        }, 1000 / 60);
    };
}();
var requestAnimationFrame = function requestAnimationFrame(fn) {
    return raf(fn);
};
var performanceNow = pnow;
var DEFAULT_HASH_SEED = 9261;
var K = 65599; // 37 also works pretty well
var DEFAULT_HASH_SEED_ALT = 5381;
var hashIterableInts = function hashIterableInts(iterator) {
    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;
    // sdbm/string-hash
    var hash = seed;
    var entry;
    for(;;){
        entry = iterator.next();
        if (entry.done) break;
        hash = hash * K + entry.value | 0;
    }
    return hash;
};
var hashInt = function hashInt(num) {
    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;
    // sdbm/string-hash
    return seed * K + num | 0;
};
var hashIntAlt = function hashIntAlt(num) {
    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;
    // djb2/string-hash
    return (seed << 5) + seed + num | 0;
};
var combineHashes = function combineHashes(hash1, hash2) {
    return hash1 * 0x200000 + hash2;
};
var combineHashesArray = function combineHashesArray(hashes) {
    return hashes[0] * 0x200000 + hashes[1];
};
var hashArrays = function hashArrays(hashes1, hashes2) {
    return [
        hashInt(hashes1[0], hashes2[0]),
        hashIntAlt(hashes1[1], hashes2[1])
    ];
};
var hashIntsArray = function hashIntsArray(ints, seed) {
    var entry = {
        value: 0,
        done: false
    };
    var i = 0;
    var length = ints.length;
    var iterator = {
        next: function next() {
            if (i < length) entry.value = ints[i++];
            else entry.done = true;
            return entry;
        }
    };
    return hashIterableInts(iterator, seed);
};
var hashString = function hashString(str, seed) {
    var entry = {
        value: 0,
        done: false
    };
    var i = 0;
    var length = str.length;
    var iterator = {
        next: function next() {
            if (i < length) entry.value = str.charCodeAt(i++);
            else entry.done = true;
            return entry;
        }
    };
    return hashIterableInts(iterator, seed);
};
var hashStrings = function hashStrings() {
    return hashStringsArray(arguments);
};
var hashStringsArray = function hashStringsArray(strs) {
    var hash;
    for(var i = 0; i < strs.length; i++){
        var str = strs[i];
        if (i === 0) hash = hashString(str);
        else hash = hashString(str, hash);
    }
    return hash;
};
/*global console */ var warningsEnabled = true;
var warnSupported = console.warn != null; // eslint-disable-line no-console
var traceSupported = console.trace != null; // eslint-disable-line no-console
var MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
var trueify = function trueify() {
    return true;
};
var falsify = function falsify() {
    return false;
};
var zeroify = function zeroify() {
    return 0;
};
var noop$1 = function noop() {};
var error = function error(msg) {
    throw new Error(msg);
};
var warnings = function warnings(enabled) {
    if (enabled !== undefined) warningsEnabled = !!enabled;
    else return warningsEnabled;
};
var warn = function warn(msg) {
    /* eslint-disable no-console */ if (!warnings()) return;
    if (warnSupported) console.warn(msg);
    else {
        console.log(msg);
        if (traceSupported) console.trace();
    }
};
/* eslint-enable */ var clone = function clone(obj) {
    return extend({}, obj);
}; // gets a shallow copy of the argument
var copy = function copy(obj) {
    if (obj == null) return obj;
    if (array(obj)) return obj.slice();
    else if (plainObject(obj)) return clone(obj);
    else return obj;
};
var copyArray = function copyArray(arr) {
    return arr.slice();
};
var uuid = function uuid(a, b) {
    for(b = a = ""; a++ < 36; b += a * 51 & 52 // if "a" is not 9 or 14 or 19 or 24
     ? (a ^ 15 // if "a" is not 15
     ? 8 ^ Math.random() * (a ^ 20 ? 16 : 4 // unless "a" is 20, in which case a random number from 8 to 11
    ) : 4 //  otherwise 4
    ).toString(16) : "-" //  in other cases (if "a" is 9,14,19,24) insert "-"
    );
    return b;
};
var _staticEmptyObject = {};
var staticEmptyObject = function staticEmptyObject() {
    return _staticEmptyObject;
};
var defaults$g = function defaults(_defaults) {
    var keys = Object.keys(_defaults);
    return function(opts) {
        var filledOpts = {};
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            var optVal = opts == null ? undefined : opts[key];
            filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;
        }
        return filledOpts;
    };
};
var removeFromArray = function removeFromArray(arr, ele, oneCopy) {
    for(var i = arr.length - 1; i >= 0; i--)if (arr[i] === ele) {
        arr.splice(i, 1);
        if (oneCopy) break;
    }
};
var clearArray = function clearArray(arr) {
    arr.splice(0, arr.length);
};
var push = function push(arr, otherArr) {
    for(var i = 0; i < otherArr.length; i++){
        var el = otherArr[i];
        arr.push(el);
    }
};
var getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {
    if (prefix) propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
    return obj[propName];
};
var setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {
    if (prefix) propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
    obj[propName] = value;
};
/* global Map */ var ObjectMap = /*#__PURE__*/ function() {
    function ObjectMap() {
        _classCallCheck(this, ObjectMap);
        this._obj = {};
    }
    _createClass(ObjectMap, [
        {
            key: "set",
            value: function set(key, val) {
                this._obj[key] = val;
                return this;
            }
        },
        {
            key: "delete",
            value: function _delete(key) {
                this._obj[key] = undefined;
                return this;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this._obj = {};
            }
        },
        {
            key: "has",
            value: function has(key) {
                return this._obj[key] !== undefined;
            }
        },
        {
            key: "get",
            value: function get(key) {
                return this._obj[key];
            }
        }
    ]);
    return ObjectMap;
}();
var Map$1 = typeof Map !== "undefined" ? Map : ObjectMap;
/* global Set */ var undef = "undefined";
var ObjectSet = /*#__PURE__*/ function() {
    function ObjectSet(arrayOrObjectSet) {
        _classCallCheck(this, ObjectSet);
        this._obj = Object.create(null);
        this.size = 0;
        if (arrayOrObjectSet != null) {
            var arr;
            if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) arr = arrayOrObjectSet.toArray();
            else arr = arrayOrObjectSet;
            for(var i = 0; i < arr.length; i++)this.add(arr[i]);
        }
    }
    _createClass(ObjectSet, [
        {
            key: "instanceString",
            value: function instanceString() {
                return "set";
            }
        },
        {
            key: "add",
            value: function add(val) {
                var o = this._obj;
                if (o[val] !== 1) {
                    o[val] = 1;
                    this.size++;
                }
            }
        },
        {
            key: "delete",
            value: function _delete(val) {
                var o = this._obj;
                if (o[val] === 1) {
                    o[val] = 0;
                    this.size--;
                }
            }
        },
        {
            key: "clear",
            value: function clear() {
                this._obj = Object.create(null);
            }
        },
        {
            key: "has",
            value: function has(val) {
                return this._obj[val] === 1;
            }
        },
        {
            key: "toArray",
            value: function toArray() {
                var _this = this;
                return Object.keys(this._obj).filter(function(key) {
                    return _this.has(key);
                });
            }
        },
        {
            key: "forEach",
            value: function forEach(callback, thisArg) {
                return this.toArray().forEach(callback, thisArg);
            }
        }
    ]);
    return ObjectSet;
}();
var Set$1 = (typeof Set === "undefined" ? "undefined" : _typeof(Set)) !== undef ? Set : ObjectSet;
var Element = function Element(cy, params) {
    var restore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (cy === undefined || params === undefined || !core(cy)) {
        error("An element must have a core reference and parameters set");
        return;
    }
    var group = params.group; // try to automatically infer the group if unspecified
    if (group == null) {
        if (params.data && params.data.source != null && params.data.target != null) group = "edges";
        else group = "nodes";
    } // validate group
    if (group !== "nodes" && group !== "edges") {
        error("An element must be of type `nodes` or `edges`; you specified `" + group + "`");
        return;
    } // make the element array-like, just like a collection
    this.length = 1;
    this[0] = this; // NOTE: when something is added here, add also to ele.json()
    var _p = this._private = {
        cy: cy,
        single: true,
        // indicates this is an element
        data: params.data || {},
        // data object
        position: params.position || {
            x: 0,
            y: 0
        },
        // (x, y) position pair
        autoWidth: undefined,
        // width and height of nodes calculated by the renderer when set to special 'auto' value
        autoHeight: undefined,
        autoPadding: undefined,
        compoundBoundsClean: false,
        // whether the compound dimensions need to be recalculated the next time dimensions are read
        listeners: [],
        // array of bound listeners
        group: group,
        // string; 'nodes' or 'edges'
        style: {},
        // properties as set by the style
        rstyle: {},
        // properties for style sent from the renderer to the core
        styleCxts: [],
        // applied style contexts from the styler
        styleKeys: {},
        // per-group keys of style property values
        removed: true,
        // whether it's inside the vis; true if removed (set true here since we call restore)
        selected: params.selected ? true : false,
        // whether it's selected
        selectable: params.selectable === undefined ? true : params.selectable ? true : false,
        // whether it's selectable
        locked: params.locked ? true : false,
        // whether the element is locked (cannot be moved)
        grabbed: false,
        // whether the element is grabbed by the mouse; renderer sets this privately
        grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,
        // whether the element can be grabbed
        pannable: params.pannable === undefined ? group === "edges" ? true : false : params.pannable ? true : false,
        // whether the element has passthrough panning enabled
        active: false,
        // whether the element is active from user interaction
        classes: new Set$1(),
        // map ( className => true )
        animation: {
            // object for currently-running animations
            current: [],
            queue: []
        },
        rscratch: {},
        // object in which the renderer can store information
        scratch: params.scratch || {},
        // scratch objects
        edges: [],
        // array of connected edges
        children: [],
        // array of children
        parent: null,
        // parent ref
        traversalCache: {},
        // cache of output of traversal functions
        backgrounding: false,
        // whether background images are loading
        bbCache: null,
        // cache of the current bounding box
        bbCacheShift: {
            x: 0,
            y: 0
        },
        // shift applied to cached bb to be applied on next get
        bodyBounds: null,
        // bounds cache of element body, w/o overlay
        overlayBounds: null,
        // bounds cache of element body, including overlay
        labelBounds: {
            // bounds cache of labels
            all: null,
            source: null,
            target: null,
            main: null
        },
        arrowBounds: {
            // bounds cache of edge arrows
            source: null,
            target: null,
            "mid-source": null,
            "mid-target": null
        }
    };
    if (_p.position.x == null) _p.position.x = 0;
    if (_p.position.y == null) _p.position.y = 0;
     // renderedPosition overrides if specified
    if (params.renderedPosition) {
        var rpos = params.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();
        _p.position = {
            x: (rpos.x - pan.x) / zoom,
            y: (rpos.y - pan.y) / zoom
        };
    }
    var classes = [];
    if (array(params.classes)) classes = params.classes;
    else if (string(params.classes)) classes = params.classes.split(/\s+/);
    for(var i = 0, l = classes.length; i < l; i++){
        var cls = classes[i];
        if (!cls || cls === "") continue;
        _p.classes.add(cls);
    }
    this.createEmitter();
    var bypass = params.style || params.css;
    if (bypass) {
        warn("Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.");
        this.style(bypass);
    }
    if (restore === undefined || restore) this.restore();
};
var defineSearch = function defineSearch(params) {
    params = {
        bfs: params.bfs || !params.dfs,
        dfs: params.dfs || !params.bfs
    }; // from pseudocode on wikipedia
    return function searchFn(roots, fn, directed) {
        var options;
        if (plainObject(roots) && !elementOrCollection(roots)) {
            options = roots;
            roots = options.roots || options.root;
            fn = options.visit;
            directed = options.directed;
        }
        directed = arguments.length === 2 && !fn$6(fn) ? fn : directed;
        fn = fn$6(fn) ? fn : function() {};
        var cy = this._private.cy;
        var v = roots = string(roots) ? this.filter(roots) : roots;
        var Q = [];
        var connectedNodes = [];
        var connectedBy = {};
        var id2depth = {};
        var V = {};
        var j = 0;
        var found;
        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges; // enqueue v
        for(var i = 0; i < v.length; i++){
            var vi = v[i];
            var viId = vi.id();
            if (vi.isNode()) {
                Q.unshift(vi);
                if (params.bfs) {
                    V[viId] = true;
                    connectedNodes.push(vi);
                }
                id2depth[viId] = 0;
            }
        }
        var _loop = function _loop() {
            var v = params.bfs ? Q.shift() : Q.pop();
            var vId = v.id();
            if (params.dfs) {
                if (V[vId]) return "continue";
                V[vId] = true;
                connectedNodes.push(v);
            }
            var depth = id2depth[vId];
            var prevEdge = connectedBy[vId];
            var src = prevEdge != null ? prevEdge.source() : null;
            var tgt = prevEdge != null ? prevEdge.target() : null;
            var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];
            var ret = void 0;
            ret = fn(v, prevEdge, prevNode, j++, depth);
            if (ret === true) {
                found = v;
                return "break";
            }
            if (ret === false) return "break";
            var vwEdges = v.connectedEdges().filter(function(e) {
                return (!directed || e.source().same(v)) && edges.has(e);
            });
            for(var _i2 = 0; _i2 < vwEdges.length; _i2++){
                var e = vwEdges[_i2];
                var w = e.connectedNodes().filter(function(n) {
                    return !n.same(v) && nodes.has(n);
                });
                var wId = w.id();
                if (w.length !== 0 && !V[wId]) {
                    w = w[0];
                    Q.push(w);
                    if (params.bfs) {
                        V[wId] = true;
                        connectedNodes.push(w);
                    }
                    connectedBy[wId] = e;
                    id2depth[wId] = id2depth[vId] + 1;
                }
            }
        };
        while(Q.length !== 0){
            var _ret = _loop();
            if (_ret === "continue") continue;
            if (_ret === "break") break;
        }
        var connectedEles = cy.collection();
        for(var _i = 0; _i < connectedNodes.length; _i++){
            var node = connectedNodes[_i];
            var edge = connectedBy[node.id()];
            if (edge != null) connectedEles.push(edge);
            connectedEles.push(node);
        }
        return {
            path: cy.collection(connectedEles),
            found: cy.collection(found)
        };
    };
}; // search, spanning trees, etc
var elesfn$v = {
    breadthFirstSearch: defineSearch({
        bfs: true
    }),
    depthFirstSearch: defineSearch({
        dfs: true
    })
}; // nice, short mathemathical alias
elesfn$v.bfs = elesfn$v.breadthFirstSearch;
elesfn$v.dfs = elesfn$v.depthFirstSearch;
var dijkstraDefaults = defaults$g({
    root: null,
    weight: function weight(edge) {
        return 1;
    },
    directed: false
});
var elesfn$u = {
    dijkstra: function dijkstra(options) {
        if (!plainObject(options)) {
            var args = arguments;
            options = {
                root: args[0],
                weight: args[1],
                directed: args[2]
            };
        }
        var _dijkstraDefaults = dijkstraDefaults(options), root = _dijkstraDefaults.root, weight = _dijkstraDefaults.weight, directed = _dijkstraDefaults.directed;
        var eles = this;
        var weightFn = weight;
        var source = string(root) ? this.filter(root)[0] : root[0];
        var dist = {};
        var prev = {};
        var knownDist = {};
        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;
        edges.unmergeBy(function(ele) {
            return ele.isLoop();
        });
        var getDist = function getDist(node) {
            return dist[node.id()];
        };
        var setDist = function setDist(node, d) {
            dist[node.id()] = d;
            Q.updateItem(node);
        };
        var Q = new Heap__default["default"](function(a, b) {
            return getDist(a) - getDist(b);
        });
        for(var i = 0; i < nodes.length; i++){
            var node = nodes[i];
            dist[node.id()] = node.same(source) ? 0 : Infinity;
            Q.push(node);
        }
        var distBetween = function distBetween(u, v) {
            var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);
            var smallestDistance = Infinity;
            var smallestEdge;
            for(var _i = 0; _i < uvs.length; _i++){
                var edge = uvs[_i];
                var _weight = weightFn(edge);
                if (_weight < smallestDistance || !smallestEdge) {
                    smallestDistance = _weight;
                    smallestEdge = edge;
                }
            }
            return {
                edge: smallestEdge,
                dist: smallestDistance
            };
        };
        while(Q.size() > 0){
            var u = Q.pop();
            var smalletsDist = getDist(u);
            var uid = u.id();
            knownDist[uid] = smalletsDist;
            if (smalletsDist === Infinity) continue;
            var neighbors = u.neighborhood().intersect(nodes);
            for(var _i2 = 0; _i2 < neighbors.length; _i2++){
                var v = neighbors[_i2];
                var vid = v.id();
                var vDist = distBetween(u, v);
                var alt = smalletsDist + vDist.dist;
                if (alt < getDist(v)) {
                    setDist(v, alt);
                    prev[vid] = {
                        node: u,
                        edge: vDist.edge
                    };
                }
            } // for
        } // while
        return {
            distanceTo: function distanceTo(node) {
                var target = string(node) ? nodes.filter(node)[0] : node[0];
                return knownDist[target.id()];
            },
            pathTo: function pathTo(node) {
                var target = string(node) ? nodes.filter(node)[0] : node[0];
                var S = [];
                var u = target;
                var uid = u.id();
                if (target.length > 0) {
                    S.unshift(target);
                    while(prev[uid]){
                        var p = prev[uid];
                        S.unshift(p.edge);
                        S.unshift(p.node);
                        u = p.node;
                        uid = u.id();
                    }
                }
                return eles.spawn(S);
            }
        };
    }
};
var elesfn$t = {
    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
    // implemented from pseudocode from wikipedia
    kruskal: function kruskal(weightFn) {
        weightFn = weightFn || function(edge) {
            return 1;
        };
        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;
        var numNodes = nodes.length;
        var forest = new Array(numNodes);
        var A = nodes; // assumes byGroup() creates new collections that can be safely mutated
        var findSetIndex = function findSetIndex(ele) {
            for(var i = 0; i < forest.length; i++){
                var eles = forest[i];
                if (eles.has(ele)) return i;
            }
        }; // start with one forest per node
        for(var i = 0; i < numNodes; i++)forest[i] = this.spawn(nodes[i]);
        var S = edges.sort(function(a, b) {
            return weightFn(a) - weightFn(b);
        });
        for(var _i = 0; _i < S.length; _i++){
            var edge = S[_i];
            var u = edge.source()[0];
            var v = edge.target()[0];
            var setUIndex = findSetIndex(u);
            var setVIndex = findSetIndex(v);
            var setU = forest[setUIndex];
            var setV = forest[setVIndex];
            if (setUIndex !== setVIndex) {
                A.merge(edge); // combine forests for u and v
                setU.merge(setV);
                forest.splice(setVIndex, 1);
            }
        }
        return A;
    }
};
var aStarDefaults = defaults$g({
    root: null,
    goal: null,
    weight: function weight(edge) {
        return 1;
    },
    heuristic: function heuristic(edge) {
        return 0;
    },
    directed: false
});
var elesfn$s = {
    // Implemented from pseudocode from wikipedia
    aStar: function aStar(options) {
        var cy = this.cy();
        var _aStarDefaults = aStarDefaults(options), root = _aStarDefaults.root, goal = _aStarDefaults.goal, heuristic = _aStarDefaults.heuristic, directed = _aStarDefaults.directed, weight = _aStarDefaults.weight;
        root = cy.collection(root)[0];
        goal = cy.collection(goal)[0];
        var sid = root.id();
        var tid = goal.id();
        var gScore = {};
        var fScore = {};
        var closedSetIds = {};
        var openSet = new Heap__default["default"](function(a, b) {
            return fScore[a.id()] - fScore[b.id()];
        });
        var openSetIds = new Set$1();
        var cameFrom = {};
        var cameFromEdge = {};
        var addToOpenSet = function addToOpenSet(ele, id) {
            openSet.push(ele);
            openSetIds.add(id);
        };
        var cMin, cMinId;
        var popFromOpenSet = function popFromOpenSet() {
            cMin = openSet.pop();
            cMinId = cMin.id();
            openSetIds["delete"](cMinId);
        };
        var isInOpenSet = function isInOpenSet(id) {
            return openSetIds.has(id);
        };
        addToOpenSet(root, sid);
        gScore[sid] = 0;
        fScore[sid] = heuristic(root); // Counter
        var steps = 0; // Main loop
        while(openSet.size() > 0){
            popFromOpenSet();
            steps++; // If we've found our goal, then we are done
            if (cMinId === tid) {
                var path = [];
                var pathNode = goal;
                var pathNodeId = tid;
                var pathEdge = cameFromEdge[pathNodeId];
                for(;;){
                    path.unshift(pathNode);
                    if (pathEdge != null) path.unshift(pathEdge);
                    pathNode = cameFrom[pathNodeId];
                    if (pathNode == null) break;
                    pathNodeId = pathNode.id();
                    pathEdge = cameFromEdge[pathNodeId];
                }
                return {
                    found: true,
                    distance: gScore[cMinId],
                    path: this.spawn(path),
                    steps: steps
                };
            } // Add cMin to processed nodes
            closedSetIds[cMinId] = true; // Update scores for neighbors of cMin
            // Take into account if graph is directed or not
            var vwEdges = cMin._private.edges;
            for(var i = 0; i < vwEdges.length; i++){
                var e = vwEdges[i]; // edge must be in set of calling eles
                if (!this.hasElementWithId(e.id())) continue;
                 // cMin must be the source of edge if directed
                if (directed && e.data("source") !== cMinId) continue;
                var wSrc = e.source();
                var wTgt = e.target();
                var w = wSrc.id() !== cMinId ? wSrc : wTgt;
                var wid = w.id(); // node must be in set of calling eles
                if (!this.hasElementWithId(wid)) continue;
                 // if node is in closedSet, ignore it
                if (closedSetIds[wid]) continue;
                 // New tentative score for node w
                var tempScore = gScore[cMinId] + weight(e); // Update gScore for node w if:
                //   w not present in openSet
                // OR
                //   tentative gScore is less than previous value
                // w not in openSet
                if (!isInOpenSet(wid)) {
                    gScore[wid] = tempScore;
                    fScore[wid] = tempScore + heuristic(w);
                    addToOpenSet(w, wid);
                    cameFrom[wid] = cMin;
                    cameFromEdge[wid] = e;
                    continue;
                } // w already in openSet, but with greater gScore
                if (tempScore < gScore[wid]) {
                    gScore[wid] = tempScore;
                    fScore[wid] = tempScore + heuristic(w);
                    cameFrom[wid] = cMin;
                    cameFromEdge[wid] = e;
                }
            } // End of neighbors update
        } // End of main loop
        // If we've reached here, then we've not reached our goal
        return {
            found: false,
            distance: undefined,
            path: undefined,
            steps: steps
        };
    }
}; // elesfn
var floydWarshallDefaults = defaults$g({
    weight: function weight(edge) {
        return 1;
    },
    directed: false
});
var elesfn$r = {
    // Implemented from pseudocode from wikipedia
    floydWarshall: function floydWarshall(options) {
        var cy = this.cy();
        var _floydWarshallDefault = floydWarshallDefaults(options), weight = _floydWarshallDefault.weight, directed = _floydWarshallDefault.directed;
        var weightFn = weight;
        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;
        var N = nodes.length;
        var Nsq = N * N;
        var indexOf = function indexOf(node) {
            return nodes.indexOf(node);
        };
        var atIndex = function atIndex(i) {
            return nodes[i];
        }; // Initialize distance matrix
        var dist = new Array(Nsq);
        for(var n = 0; n < Nsq; n++){
            var j = n % N;
            var i = (n - j) / N;
            if (i === j) dist[n] = 0;
            else dist[n] = Infinity;
        } // Initialize matrix used for path reconstruction
        // Initialize distance matrix
        var next = new Array(Nsq);
        var edgeNext = new Array(Nsq); // Process edges
        for(var _i = 0; _i < edges.length; _i++){
            var edge = edges[_i];
            var src = edge.source()[0];
            var tgt = edge.target()[0];
            if (src === tgt) continue;
             // exclude loops
            var s = indexOf(src);
            var t = indexOf(tgt);
            var st = s * N + t; // source to target index
            var _weight = weightFn(edge); // Check if already process another edge between same 2 nodes
            if (dist[st] > _weight) {
                dist[st] = _weight;
                next[st] = t;
                edgeNext[st] = edge;
            } // If undirected graph, process 'reversed' edge
            if (!directed) {
                var ts = t * N + s; // target to source index
                if (!directed && dist[ts] > _weight) {
                    dist[ts] = _weight;
                    next[ts] = s;
                    edgeNext[ts] = edge;
                }
            }
        } // Main loop
        for(var k = 0; k < N; k++)for(var _i2 = 0; _i2 < N; _i2++){
            var ik = _i2 * N + k;
            for(var _j = 0; _j < N; _j++){
                var ij = _i2 * N + _j;
                var kj = k * N + _j;
                if (dist[ik] + dist[kj] < dist[ij]) {
                    dist[ij] = dist[ik] + dist[kj];
                    next[ij] = next[ik];
                }
            }
        }
        var getArgEle = function getArgEle(ele) {
            return (string(ele) ? cy.filter(ele) : ele)[0];
        };
        var indexOfArgEle = function indexOfArgEle(ele) {
            return indexOf(getArgEle(ele));
        };
        var res = {
            distance: function distance(from, to) {
                var i = indexOfArgEle(from);
                var j = indexOfArgEle(to);
                return dist[i * N + j];
            },
            path: function path(from, to) {
                var i = indexOfArgEle(from);
                var j = indexOfArgEle(to);
                var fromNode = atIndex(i);
                if (i === j) return fromNode.collection();
                if (next[i * N + j] == null) return cy.collection();
                var path = cy.collection();
                var prev = i;
                var edge;
                path.merge(fromNode);
                while(i !== j){
                    prev = i;
                    i = next[i * N + j];
                    edge = edgeNext[prev * N + i];
                    path.merge(edge);
                    path.merge(atIndex(i));
                }
                return path;
            }
        };
        return res;
    } // floydWarshall
}; // elesfn
var bellmanFordDefaults = defaults$g({
    weight: function weight(edge) {
        return 1;
    },
    directed: false,
    root: null
});
var elesfn$q = {
    // Implemented from pseudocode from wikipedia
    bellmanFord: function bellmanFord(options) {
        var _this = this;
        var _bellmanFordDefaults = bellmanFordDefaults(options), weight = _bellmanFordDefaults.weight, directed = _bellmanFordDefaults.directed, root = _bellmanFordDefaults.root;
        var weightFn = weight;
        var eles = this;
        var cy = this.cy();
        var _this$byGroup = this.byGroup(), edges = _this$byGroup.edges, nodes = _this$byGroup.nodes;
        var numNodes = nodes.length;
        var infoMap = new Map$1();
        var hasNegativeWeightCycle = false;
        var negativeWeightCycles = [];
        root = cy.collection(root)[0]; // in case selector passed
        edges.unmergeBy(function(edge) {
            return edge.isLoop();
        });
        var numEdges = edges.length;
        var getInfo = function getInfo(node) {
            var obj = infoMap.get(node.id());
            if (!obj) {
                obj = {};
                infoMap.set(node.id(), obj);
            }
            return obj;
        };
        var getNodeFromTo = function getNodeFromTo(to) {
            return (string(to) ? cy.$(to) : to)[0];
        };
        var distanceTo = function distanceTo(to) {
            return getInfo(getNodeFromTo(to)).dist;
        };
        var pathTo = function pathTo(to) {
            var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;
            var end = getNodeFromTo(to);
            var path = [];
            var node = end;
            for(;;){
                if (node == null) return _this.spawn();
                var _getInfo = getInfo(node), edge = _getInfo.edge, pred = _getInfo.pred;
                path.unshift(node[0]);
                if (node.same(thisStart) && path.length > 0) break;
                if (edge != null) path.unshift(edge);
                node = pred;
            }
            return eles.spawn(path);
        }; // Initializations { dist, pred, edge }
        for(var i = 0; i < numNodes; i++){
            var node = nodes[i];
            var info = getInfo(node);
            if (node.same(root)) info.dist = 0;
            else info.dist = Infinity;
            info.pred = null;
            info.edge = null;
        } // Edges relaxation
        var replacedEdge = false;
        var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {
            var dist = info1.dist + weight;
            if (dist < info2.dist && !edge.same(info1.edge)) {
                info2.dist = dist;
                info2.pred = node1;
                info2.edge = edge;
                replacedEdge = true;
            }
        };
        for(var _i = 1; _i < numNodes; _i++){
            replacedEdge = false;
            for(var e = 0; e < numEdges; e++){
                var edge = edges[e];
                var src = edge.source();
                var tgt = edge.target();
                var _weight = weightFn(edge);
                var srcInfo = getInfo(src);
                var tgtInfo = getInfo(tgt);
                checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight); // If undirected graph, we need to take into account the 'reverse' edge
                if (!directed) checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);
            }
            if (!replacedEdge) break;
        }
        if (replacedEdge) {
            // Check for negative weight cycles
            var negativeWeightCycleIds = [];
            for(var _e = 0; _e < numEdges; _e++){
                var _edge = edges[_e];
                var _src = _edge.source();
                var _tgt = _edge.target();
                var _weight2 = weightFn(_edge);
                var srcDist = getInfo(_src).dist;
                var tgtDist = getInfo(_tgt).dist;
                if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {
                    if (!hasNegativeWeightCycle) {
                        warn("Graph contains a negative weight cycle for Bellman-Ford");
                        hasNegativeWeightCycle = true;
                    }
                    if (options.findNegativeWeightCycles !== false) {
                        var negativeNodes = [];
                        if (srcDist + _weight2 < tgtDist) negativeNodes.push(_src);
                        if (!directed && tgtDist + _weight2 < srcDist) negativeNodes.push(_tgt);
                        var numNegativeNodes = negativeNodes.length;
                        for(var n = 0; n < numNegativeNodes; n++){
                            var start = negativeNodes[n];
                            var cycle = [
                                start
                            ];
                            cycle.push(getInfo(start).edge);
                            var _node = getInfo(start).pred;
                            while(cycle.indexOf(_node) === -1){
                                cycle.push(_node);
                                cycle.push(getInfo(_node).edge);
                                _node = getInfo(_node).pred;
                            }
                            cycle = cycle.slice(cycle.indexOf(_node));
                            var smallestId = cycle[0].id();
                            var smallestIndex = 0;
                            for(var c = 2; c < cycle.length; c += 2)if (cycle[c].id() < smallestId) {
                                smallestId = cycle[c].id();
                                smallestIndex = c;
                            }
                            cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));
                            cycle.push(cycle[0]);
                            var cycleId = cycle.map(function(el) {
                                return el.id();
                            }).join(",");
                            if (negativeWeightCycleIds.indexOf(cycleId) === -1) {
                                negativeWeightCycles.push(eles.spawn(cycle));
                                negativeWeightCycleIds.push(cycleId);
                            }
                        }
                    } else break;
                }
            }
        }
        return {
            distanceTo: distanceTo,
            pathTo: pathTo,
            hasNegativeWeightCycle: hasNegativeWeightCycle,
            negativeWeightCycles: negativeWeightCycles
        };
    } // bellmanFord
}; // elesfn
var sqrt2 = Math.sqrt(2); // Function which colapses 2 (meta) nodes into one
// Updates the remaining edge lists
// Receives as a paramater the edge which causes the collapse
var collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {
    if (remainingEdges.length === 0) error("Karger-Stein must be run on a connected (sub)graph");
    var edgeInfo = remainingEdges[edgeIndex];
    var sourceIn = edgeInfo[1];
    var targetIn = edgeInfo[2];
    var partition1 = nodeMap[sourceIn];
    var partition2 = nodeMap[targetIn];
    var newEdges = remainingEdges; // re-use array
    // Delete all edges between partition1 and partition2
    for(var i = newEdges.length - 1; i >= 0; i--){
        var edge = newEdges[i];
        var src = edge[1];
        var tgt = edge[2];
        if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) newEdges.splice(i, 1);
    } // All edges pointing to partition2 should now point to partition1
    for(var _i = 0; _i < newEdges.length; _i++){
        var _edge = newEdges[_i];
        if (_edge[1] === partition2) {
            // Check source
            newEdges[_i] = _edge.slice(); // copy
            newEdges[_i][1] = partition1;
        } else if (_edge[2] === partition2) {
            // Check target
            newEdges[_i] = _edge.slice(); // copy
            newEdges[_i][2] = partition1;
        }
    } // Move all nodes from partition2 to partition1
    for(var _i2 = 0; _i2 < nodeMap.length; _i2++)if (nodeMap[_i2] === partition2) nodeMap[_i2] = partition1;
    return newEdges;
}; // Contracts a graph until we reach a certain number of meta nodes
var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {
    while(size > sizeLimit){
        // Choose an edge randomly
        var edgeIndex = Math.floor(Math.random() * remainingEdges.length); // Collapse graph based on edge
        remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);
        size--;
    }
    return remainingEdges;
};
var elesfn$p = {
    // Computes the minimum cut of an undirected graph
    // Returns the correct answer with high probability
    kargerStein: function kargerStein() {
        var _this = this;
        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;
        edges.unmergeBy(function(edge) {
            return edge.isLoop();
        });
        var numNodes = nodes.length;
        var numEdges = edges.length;
        var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
        var stopSize = Math.floor(numNodes / sqrt2);
        if (numNodes < 2) {
            error("At least 2 nodes are required for Karger-Stein algorithm");
            return undefined;
        } // Now store edge destination as indexes
        // Format for each edge (edge index, source node index, target node index)
        var edgeIndexes = [];
        for(var i = 0; i < numEdges; i++){
            var e = edges[i];
            edgeIndexes.push([
                i,
                nodes.indexOf(e.source()),
                nodes.indexOf(e.target())
            ]);
        } // We will store the best cut found here
        var minCutSize = Infinity;
        var minCutEdgeIndexes = [];
        var minCutNodeMap = new Array(numNodes); // Initial meta node partition
        var metaNodeMap = new Array(numNodes);
        var metaNodeMap2 = new Array(numNodes);
        var copyNodesMap = function copyNodesMap(from, to) {
            for(var _i3 = 0; _i3 < numNodes; _i3++)to[_i3] = from[_i3];
        }; // Main loop
        for(var iter = 0; iter <= numIter; iter++){
            // Reset meta node partition
            for(var _i4 = 0; _i4 < numNodes; _i4++)metaNodeMap[_i4] = _i4;
             // Contract until stop point (stopSize nodes)
            var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);
            var edgesState2 = edgesState.slice(); // copy
            // Create a copy of the colapsed nodes state
            copyNodesMap(metaNodeMap, metaNodeMap2); // Run 2 iterations starting in the stop state
            var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
            var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2); // Is any of the 2 results the best cut so far?
            if (res1.length <= res2.length && res1.length < minCutSize) {
                minCutSize = res1.length;
                minCutEdgeIndexes = res1;
                copyNodesMap(metaNodeMap, minCutNodeMap);
            } else if (res2.length <= res1.length && res2.length < minCutSize) {
                minCutSize = res2.length;
                minCutEdgeIndexes = res2;
                copyNodesMap(metaNodeMap2, minCutNodeMap);
            }
        } // end of main loop
        // Construct result
        var cut = this.spawn(minCutEdgeIndexes.map(function(e) {
            return edges[e[0]];
        }));
        var partition1 = this.spawn();
        var partition2 = this.spawn(); // traverse metaNodeMap for best cut
        var witnessNodePartition = minCutNodeMap[0];
        for(var _i5 = 0; _i5 < minCutNodeMap.length; _i5++){
            var partitionId = minCutNodeMap[_i5];
            var node = nodes[_i5];
            if (partitionId === witnessNodePartition) partition1.merge(node);
            else partition2.merge(node);
        } // construct components corresponding to each disjoint subset of nodes
        var constructComponent = function constructComponent(subset) {
            var component = _this.spawn();
            subset.forEach(function(node) {
                component.merge(node);
                node.connectedEdges().forEach(function(edge) {
                    // ensure edge is within calling collection and edge is not in cut
                    if (_this.contains(edge) && !cut.contains(edge)) component.merge(edge);
                });
            });
            return component;
        };
        var components = [
            constructComponent(partition1),
            constructComponent(partition2)
        ];
        var ret = {
            cut: cut,
            components: components,
            // n.b. partitions are included to be compatible with the old api spec
            // (could be removed in a future major version)
            partition1: partition1,
            partition2: partition2
        };
        return ret;
    }
}; // elesfn
var copyPosition = function copyPosition(p) {
    return {
        x: p.x,
        y: p.y
    };
};
var modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {
    return {
        x: p.x * zoom + pan.x,
        y: p.y * zoom + pan.y
    };
};
var renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {
    return {
        x: (p.x - pan.x) / zoom,
        y: (p.y - pan.y) / zoom
    };
};
var array2point = function array2point(arr) {
    return {
        x: arr[0],
        y: arr[1]
    };
};
var min = function min(arr) {
    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
    var min = Infinity;
    for(var i = begin; i < end; i++){
        var val = arr[i];
        if (isFinite(val)) min = Math.min(val, min);
    }
    return min;
};
var max = function max(arr) {
    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
    var max = -Infinity;
    for(var i = begin; i < end; i++){
        var val = arr[i];
        if (isFinite(val)) max = Math.max(val, max);
    }
    return max;
};
var mean = function mean(arr) {
    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
    var total = 0;
    var n = 0;
    for(var i = begin; i < end; i++){
        var val = arr[i];
        if (isFinite(val)) {
            total += val;
            n++;
        }
    }
    return total / n;
};
var median = function median(arr) {
    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
    var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    if (copy) arr = arr.slice(begin, end);
    else {
        if (end < arr.length) arr.splice(end, arr.length - end);
        if (begin > 0) arr.splice(0, begin);
    } // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start
    var off = 0; // offset from non-finite values
    for(var i = arr.length - 1; i >= 0; i--){
        var v = arr[i];
        if (includeHoles) {
            if (!isFinite(v)) {
                arr[i] = -Infinity;
                off++;
            }
        } else // just remove it if we don't want to consider holes
        arr.splice(i, 1);
    }
    if (sort) arr.sort(function(a, b) {
        return a - b;
    }); // requires copy = true if you don't want to change the orig
    var len = arr.length;
    var mid = Math.floor(len / 2);
    if (len % 2 !== 0) return arr[mid + 1 + off];
    else return (arr[mid - 1 + off] + arr[mid + off]) / 2;
};
var deg2rad = function deg2rad(deg) {
    return Math.PI * deg / 180;
};
var getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {
    return Math.atan2(dispY, dispX) - Math.PI / 2;
};
var log2 = Math.log2 || function(n) {
    return Math.log(n) / Math.log(2);
};
var signum = function signum(x) {
    if (x > 0) return 1;
    else if (x < 0) return -1;
    else return 0;
};
var dist = function dist(p1, p2) {
    return Math.sqrt(sqdist(p1, p2));
};
var sqdist = function sqdist(p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    return dx * dx + dy * dy;
};
var inPlaceSumNormalize = function inPlaceSumNormalize(v) {
    var length = v.length; // First, get sum of all elements
    var total = 0;
    for(var i = 0; i < length; i++)total += v[i];
     // Now, divide each by the sum of all elements
    for(var _i = 0; _i < length; _i++)v[_i] = v[_i] / total;
    return v;
};
var qbezierAt = function qbezierAt(p0, p1, p2, t) {
    return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
};
var qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {
    return {
        x: qbezierAt(p0.x, p1.x, p2.x, t),
        y: qbezierAt(p0.y, p1.y, p2.y, t)
    };
};
var lineAt = function lineAt(p0, p1, t, d) {
    var vec = {
        x: p1.x - p0.x,
        y: p1.y - p0.y
    };
    var vecDist = dist(p0, p1);
    var normVec = {
        x: vec.x / vecDist,
        y: vec.y / vecDist
    };
    t = t == null ? 0 : t;
    d = d != null ? d : t * vecDist;
    return {
        x: p0.x + normVec.x * d,
        y: p0.y + normVec.y * d
    };
};
var bound = function bound(min, val, max) {
    return Math.max(min, Math.min(max, val));
}; // makes a full bb (x1, y1, x2, y2, w, h) from implicit params
var makeBoundingBox = function makeBoundingBox(bb) {
    if (bb == null) return {
        x1: Infinity,
        y1: Infinity,
        x2: -Infinity,
        y2: -Infinity,
        w: 0,
        h: 0
    };
    else if (bb.x1 != null && bb.y1 != null) {
        if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x2,
            y2: bb.y2,
            w: bb.x2 - bb.x1,
            h: bb.y2 - bb.y1
        };
        else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x1 + bb.w,
            y2: bb.y1 + bb.h,
            w: bb.w,
            h: bb.h
        };
    }
};
var copyBoundingBox = function copyBoundingBox(bb) {
    return {
        x1: bb.x1,
        x2: bb.x2,
        w: bb.w,
        y1: bb.y1,
        y2: bb.y2,
        h: bb.h
    };
};
var clearBoundingBox = function clearBoundingBox(bb) {
    bb.x1 = Infinity;
    bb.y1 = Infinity;
    bb.x2 = -Infinity;
    bb.y2 = -Infinity;
    bb.w = 0;
    bb.h = 0;
};
var updateBoundingBox = function updateBoundingBox(bb1, bb2) {
    // update bb1 with bb2 bounds
    bb1.x1 = Math.min(bb1.x1, bb2.x1);
    bb1.x2 = Math.max(bb1.x2, bb2.x2);
    bb1.w = bb1.x2 - bb1.x1;
    bb1.y1 = Math.min(bb1.y1, bb2.y1);
    bb1.y2 = Math.max(bb1.y2, bb2.y2);
    bb1.h = bb1.y2 - bb1.y1;
};
var expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {
    bb.x1 = Math.min(bb.x1, x);
    bb.x2 = Math.max(bb.x2, x);
    bb.w = bb.x2 - bb.x1;
    bb.y1 = Math.min(bb.y1, y);
    bb.y2 = Math.max(bb.y2, y);
    bb.h = bb.y2 - bb.y1;
};
var expandBoundingBox = function expandBoundingBox(bb) {
    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    bb.x1 -= padding;
    bb.x2 += padding;
    bb.y1 -= padding;
    bb.y2 += padding;
    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
    return bb;
};
var expandBoundingBoxSides = function expandBoundingBoxSides(bb) {
    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [
        0
    ];
    var top, right, bottom, left;
    if (padding.length === 1) top = right = bottom = left = padding[0];
    else if (padding.length === 2) {
        top = bottom = padding[0];
        left = right = padding[1];
    } else if (padding.length === 4) {
        var _padding = _slicedToArray(padding, 4);
        top = _padding[0];
        right = _padding[1];
        bottom = _padding[2];
        left = _padding[3];
    }
    bb.x1 -= left;
    bb.x2 += right;
    bb.y1 -= top;
    bb.y2 += bottom;
    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
    return bb;
};
var assignBoundingBox = function assignBoundingBox(bb1, bb2) {
    bb1.x1 = bb2.x1;
    bb1.y1 = bb2.y1;
    bb1.x2 = bb2.x2;
    bb1.y2 = bb2.y2;
    bb1.w = bb1.x2 - bb1.x1;
    bb1.h = bb1.y2 - bb1.y1;
};
var boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {
    // case: one bb to right of other
    if (bb1.x1 > bb2.x2) return false;
    if (bb2.x1 > bb1.x2) return false;
     // case: one bb to left of other
    if (bb1.x2 < bb2.x1) return false;
    if (bb2.x2 < bb1.x1) return false;
     // case: one bb above other
    if (bb1.y2 < bb2.y1) return false;
    if (bb2.y2 < bb1.y1) return false;
     // case: one bb below other
    if (bb1.y1 > bb2.y2) return false;
    if (bb2.y1 > bb1.y2) return false;
     // otherwise, must have some overlap
    return true;
};
var inBoundingBox = function inBoundingBox(bb, x, y) {
    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};
var pointInBoundingBox = function pointInBoundingBox(bb, pt) {
    return inBoundingBox(bb, pt.x, pt.y);
};
var boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {
    return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);
};
var roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {
    var cornerRadius = getRoundRectangleRadius(width, height);
    var halfWidth = width / 2;
    var halfHeight = height / 2; // Check intersections with straight line segments
    var straightLineIntersections; // Top segment, left to right
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
    if (straightLineIntersections.length > 0) return straightLineIntersections;
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);
    if (straightLineIntersections.length > 0) return straightLineIntersections;
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);
    if (straightLineIntersections.length > 0) return straightLineIntersections;
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);
    if (straightLineIntersections.length > 0) return straightLineIntersections;
    var arcIntersections; // Top Left
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) return [
        arcIntersections[0],
        arcIntersections[1]
    ];
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) return [
        arcIntersections[0],
        arcIntersections[1]
    ];
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) return [
        arcIntersections[0],
        arcIntersections[1]
    ];
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) return [
        arcIntersections[0],
        arcIntersections[1]
    ];
    return []; // if nothing
};
var inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {
    var t = tolerance;
    var x1 = Math.min(lx1, lx2);
    var x2 = Math.max(lx1, lx2);
    var y1 = Math.min(ly1, ly2);
    var y2 = Math.max(ly1, ly2);
    return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
};
var inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {
    var bb = {
        x1: Math.min(x1, x3, x2) - tolerance,
        x2: Math.max(x1, x3, x2) + tolerance,
        y1: Math.min(y1, y3, y2) - tolerance,
        y2: Math.max(y1, y3, y2) + tolerance
    }; // if outside the rough bounding box for the bezier, then it can't be a hit
    if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) // console.log('bezier out of rough bb')
    return false;
    else // console.log('do more expensive check');
    return true;
};
var solveQuadratic = function solveQuadratic(a, b, c, val) {
    c -= val;
    var r = b * b - 4 * a * c;
    if (r < 0) return [];
    var sqrtR = Math.sqrt(r);
    var denom = 2 * a;
    var root1 = (-b + sqrtR) / denom;
    var root2 = (-b - sqrtR) / denom;
    return [
        root1,
        root2
    ];
};
var solveCubic = function solveCubic(a, b, c, d, result) {
    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
    // r is the real component, i is the imaginary component
    // An implementation of the Cardano method from the year 1545
    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots
    var epsilon = 0.00001; // avoid division by zero while keeping the overall expression close in value
    if (a === 0) a = epsilon;
    b /= a;
    c /= a;
    d /= a;
    var discriminant, q, r, dum1, s, t, term1, r13;
    q = (3.0 * c - b * b) / 9.0;
    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
    r /= 54.0;
    discriminant = q * q * q + r * r;
    result[1] = 0;
    term1 = b / 3.0;
    if (discriminant > 0) {
        s = r + Math.sqrt(discriminant);
        s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);
        t = r - Math.sqrt(discriminant);
        t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);
        result[0] = -term1 + s + t;
        term1 += (s + t) / 2.0;
        result[4] = result[2] = -term1;
        term1 = Math.sqrt(3.0) * (-t + s) / 2;
        result[3] = term1;
        result[5] = -term1;
        return;
    }
    result[5] = result[3] = 0;
    if (discriminant === 0) {
        r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);
        result[0] = -term1 + 2.0 * r13;
        result[4] = result[2] = -(r13 + term1);
        return;
    }
    q = -q;
    dum1 = q * q * q;
    dum1 = Math.acos(r / Math.sqrt(dum1));
    r13 = 2.0 * Math.sqrt(q);
    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
    return;
};
var sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {
    // Find minimum distance by using the minimum of the distance
    // function between the given point and the curve
    // This gives the coefficients of the resulting cubic equation
    // whose roots tell us where a possible minimum is
    // (Coefficients are divided by 4)
    var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;
    var b = 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;
    var c = 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;
    var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y; // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);
    var roots = []; // Use the cubic solving algorithm
    solveCubic(a, b, c, d, roots);
    var zeroThreshold = 0.0000001;
    var params = [];
    for(var index = 0; index < 6; index += 2)if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) params.push(roots[index]);
    params.push(1.0);
    params.push(0.0);
    var minDistanceSquared = -1;
    var curX, curY, distSquared;
    for(var i = 0; i < params.length; i++){
        curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;
        curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;
        distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2); // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
        if (minDistanceSquared >= 0) {
            if (distSquared < minDistanceSquared) minDistanceSquared = distSquared;
        } else minDistanceSquared = distSquared;
    }
    return minDistanceSquared;
};
var sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {
    var offset = [
        x - x1,
        y - y1
    ];
    var line = [
        x2 - x1,
        y2 - y1
    ];
    var lineSq = line[0] * line[0] + line[1] * line[1];
    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
    var dotProduct = offset[0] * line[0] + offset[1] * line[1];
    var adjSq = dotProduct * dotProduct / lineSq;
    if (dotProduct < 0) return hypSq;
    if (adjSq > lineSq) return (x - x2) * (x - x2) + (y - y2) * (y - y2);
    return hypSq - adjSq;
};
var pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {
    var x1, y1, x2, y2;
    var y3; // Intersect with vertical line through (x, y)
    var up = 0; // let down = 0;
    for(var i = 0; i < points.length / 2; i++){
        x1 = points[i * 2];
        y1 = points[i * 2 + 1];
        if (i + 1 < points.length / 2) {
            x2 = points[(i + 1) * 2];
            y2 = points[(i + 1) * 2 + 1];
        } else {
            x2 = points[(i + 1 - points.length / 2) * 2];
            y2 = points[(i + 1 - points.length / 2) * 2 + 1];
        }
        if (x1 == x && x2 == x) ;
        else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {
            y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;
            if (y3 > y) up++;
             // if( y3 < y ){
        // down++;
        // }
        } else continue;
    }
    if (up % 2 === 0) return false;
    else return true;
};
var pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {
    var transformedPoints = new Array(basePoints.length); // Gives negative angle
    var angle;
    if (direction[0] != null) {
        angle = Math.atan(direction[1] / direction[0]);
        if (direction[0] < 0) angle = angle + Math.PI / 2;
        else angle = -angle - Math.PI / 2;
    } else angle = direction;
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle); //    console.log("base: " + basePoints);
    for(var i = 0; i < transformedPoints.length / 2; i++){
        transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);
        transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);
        transformedPoints[i * 2] += centerX;
        transformedPoints[i * 2 + 1] += centerY;
    }
    var points;
    if (padding > 0) {
        var expandedLineSet = expandPolygon(transformedPoints, -padding);
        points = joinLines(expandedLineSet);
    } else points = transformedPoints;
    return pointInsidePolygonPoints(x, y, points);
};
var pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height) {
    var cutPolygonPoints = new Array(basePoints.length);
    var halfW = width / 2;
    var halfH = height / 2;
    var cornerRadius = getRoundPolygonRadius(width, height);
    var squaredCornerRadius = cornerRadius * cornerRadius;
    for(var i = 0; i < basePoints.length / 4; i++){
        var sourceUv = void 0, destUv = void 0;
        if (i === 0) sourceUv = basePoints.length - 2;
        else sourceUv = i * 4 - 2;
        destUv = i * 4 + 2;
        var px = centerX + halfW * basePoints[i * 4];
        var py = centerY + halfH * basePoints[i * 4 + 1];
        var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
        var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
        var cp0x = px - offset * basePoints[sourceUv];
        var cp0y = py - offset * basePoints[sourceUv + 1];
        var cp1x = px + offset * basePoints[destUv];
        var cp1y = py + offset * basePoints[destUv + 1];
        cutPolygonPoints[i * 4] = cp0x;
        cutPolygonPoints[i * 4 + 1] = cp0y;
        cutPolygonPoints[i * 4 + 2] = cp1x;
        cutPolygonPoints[i * 4 + 3] = cp1y;
        var orthx = basePoints[sourceUv + 1];
        var orthy = -basePoints[sourceUv];
        var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];
        if (cosAlpha < 0) {
            orthx *= -1;
            orthy *= -1;
        }
        var cx = cp0x + orthx * cornerRadius;
        var cy = cp0y + orthy * cornerRadius;
        var squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);
        if (squaredDistance <= squaredCornerRadius) return true;
    }
    return pointInsidePolygonPoints(x, y, cutPolygonPoints);
};
var joinLines = function joinLines(lineSet) {
    var vertices = new Array(lineSet.length / 2);
    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;
    for(var i = 0; i < lineSet.length / 4; i++){
        currentLineStartX = lineSet[i * 4];
        currentLineStartY = lineSet[i * 4 + 1];
        currentLineEndX = lineSet[i * 4 + 2];
        currentLineEndY = lineSet[i * 4 + 3];
        if (i < lineSet.length / 4 - 1) {
            nextLineStartX = lineSet[(i + 1) * 4];
            nextLineStartY = lineSet[(i + 1) * 4 + 1];
            nextLineEndX = lineSet[(i + 1) * 4 + 2];
            nextLineEndY = lineSet[(i + 1) * 4 + 3];
        } else {
            nextLineStartX = lineSet[0];
            nextLineStartY = lineSet[1];
            nextLineEndX = lineSet[2];
            nextLineEndY = lineSet[3];
        }
        var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);
        vertices[i * 2] = intersection[0];
        vertices[i * 2 + 1] = intersection[1];
    }
    return vertices;
};
var expandPolygon = function expandPolygon(points, pad) {
    var expandedLineSet = new Array(points.length * 2);
    var currentPointX, currentPointY, nextPointX, nextPointY;
    for(var i = 0; i < points.length / 2; i++){
        currentPointX = points[i * 2];
        currentPointY = points[i * 2 + 1];
        if (i < points.length / 2 - 1) {
            nextPointX = points[(i + 1) * 2];
            nextPointY = points[(i + 1) * 2 + 1];
        } else {
            nextPointX = points[0];
            nextPointY = points[1];
        } // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
        // Assume CCW polygon winding
        var offsetX = nextPointY - currentPointY;
        var offsetY = -(nextPointX - currentPointX); // Normalize
        var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
        var normalizedOffsetX = offsetX / offsetLength;
        var normalizedOffsetY = offsetY / offsetLength;
        expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
        expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
        expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
        expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
    }
    return expandedLineSet;
};
var intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
    var dispX = centerX - x;
    var dispY = centerY - y;
    dispX /= ellipseWradius;
    dispY /= ellipseHradius;
    var len = Math.sqrt(dispX * dispX + dispY * dispY);
    var newLength = len - 1;
    if (newLength < 0) return [];
    var lenProportion = newLength / len;
    return [
        (centerX - x) * lenProportion + x,
        (centerY - y) * lenProportion + y
    ];
};
var checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {
    x -= centerX;
    y -= centerY;
    x /= width / 2 + padding;
    y /= height / 2 + padding;
    return x * x + y * y <= 1;
}; // Returns intersections of increasing distance from line's start point
var intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {
    // Calculate d, direction vector of line
    var d = [
        x2 - x1,
        y2 - y1
    ]; // Direction vector of line
    var f = [
        x1 - centerX,
        y1 - centerY
    ];
    var a = d[0] * d[0] + d[1] * d[1];
    var b = 2 * (f[0] * d[0] + f[1] * d[1]);
    var c = f[0] * f[0] + f[1] * f[1] - radius * radius;
    var discriminant = b * b - 4 * a * c;
    if (discriminant < 0) return [];
    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
    var tMin = Math.min(t1, t2);
    var tMax = Math.max(t1, t2);
    var inRangeParams = [];
    if (tMin >= 0 && tMin <= 1) inRangeParams.push(tMin);
    if (tMax >= 0 && tMax <= 1) inRangeParams.push(tMax);
    if (inRangeParams.length === 0) return [];
    var nearIntersectionX = inRangeParams[0] * d[0] + x1;
    var nearIntersectionY = inRangeParams[0] * d[1] + y1;
    if (inRangeParams.length > 1) {
        if (inRangeParams[0] == inRangeParams[1]) return [
            nearIntersectionX,
            nearIntersectionY
        ];
        else {
            var farIntersectionX = inRangeParams[1] * d[0] + x1;
            var farIntersectionY = inRangeParams[1] * d[1] + y1;
            return [
                nearIntersectionX,
                nearIntersectionY,
                farIntersectionX,
                farIntersectionY
            ];
        }
    } else return [
        nearIntersectionX,
        nearIntersectionY
    ];
};
var midOfThree = function midOfThree(a, b, c) {
    if (b <= a && a <= c || c <= a && a <= b) return a;
    else if (a <= b && b <= c || c <= b && b <= a) return b;
    else return c;
}; // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)
var finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
    var dx13 = x1 - x3;
    var dx21 = x2 - x1;
    var dx43 = x4 - x3;
    var dy13 = y1 - y3;
    var dy21 = y2 - y1;
    var dy43 = y4 - y3;
    var ua_t = dx43 * dy13 - dy43 * dx13;
    var ub_t = dx21 * dy13 - dy21 * dx13;
    var u_b = dy43 * dx21 - dx43 * dy21;
    if (u_b !== 0) {
        var ua = ua_t / u_b;
        var ub = ub_t / u_b;
        var flptThreshold = 0.001;
        var _min = 0 - flptThreshold;
        var _max = 1 + flptThreshold;
        if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) return [
            x1 + ua * dx21,
            y1 + ua * dy21
        ];
        else {
            if (!infiniteLines) return [];
            else return [
                x1 + ua * dx21,
                y1 + ua * dy21
            ];
        }
    } else {
        if (ua_t === 0 || ub_t === 0) {
            // Parallel, coincident lines. Check if overlap
            // Check endpoint of second line
            if (midOfThree(x1, x2, x4) === x4) return [
                x4,
                y4
            ];
             // Check start point of second line
            if (midOfThree(x1, x2, x3) === x3) return [
                x3,
                y3
            ];
             // Endpoint of first line
            if (midOfThree(x3, x4, x2) === x2) return [
                x2,
                y2
            ];
            return [];
        } else // Parallel, non-coincident
        return [];
    }
}; // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
// intersect a node polygon (pts transformed)
//
// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
// intersect the points (no transform)
var polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
    var intersections = [];
    var intersection;
    var transformedPoints = new Array(basePoints.length);
    var doTransform = true;
    if (width == null) doTransform = false;
    var points;
    if (doTransform) {
        for(var i = 0; i < transformedPoints.length / 2; i++){
            transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
            transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
        }
        if (padding > 0) {
            var expandedLineSet = expandPolygon(transformedPoints, -padding);
            points = joinLines(expandedLineSet);
        } else points = transformedPoints;
    } else points = basePoints;
    var currentX, currentY, nextX, nextY;
    for(var _i2 = 0; _i2 < points.length / 2; _i2++){
        currentX = points[_i2 * 2];
        currentY = points[_i2 * 2 + 1];
        if (_i2 < points.length / 2 - 1) {
            nextX = points[(_i2 + 1) * 2];
            nextY = points[(_i2 + 1) * 2 + 1];
        } else {
            nextX = points[0];
            nextY = points[1];
        }
        intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);
        if (intersection.length !== 0) intersections.push(intersection[0], intersection[1]);
    }
    return intersections;
};
var roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
    var intersections = [];
    var intersection;
    var lines = new Array(basePoints.length);
    var halfW = width / 2;
    var halfH = height / 2;
    var cornerRadius = getRoundPolygonRadius(width, height);
    for(var i = 0; i < basePoints.length / 4; i++){
        var sourceUv = void 0, destUv = void 0;
        if (i === 0) sourceUv = basePoints.length - 2;
        else sourceUv = i * 4 - 2;
        destUv = i * 4 + 2;
        var px = centerX + halfW * basePoints[i * 4];
        var py = centerY + halfH * basePoints[i * 4 + 1];
        var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
        var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
        var cp0x = px - offset * basePoints[sourceUv];
        var cp0y = py - offset * basePoints[sourceUv + 1];
        var cp1x = px + offset * basePoints[destUv];
        var cp1y = py + offset * basePoints[destUv + 1];
        if (i === 0) {
            lines[basePoints.length - 2] = cp0x;
            lines[basePoints.length - 1] = cp0y;
        } else {
            lines[i * 4 - 2] = cp0x;
            lines[i * 4 - 1] = cp0y;
        }
        lines[i * 4] = cp1x;
        lines[i * 4 + 1] = cp1y;
        var orthx = basePoints[sourceUv + 1];
        var orthy = -basePoints[sourceUv];
        var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];
        if (cosAlpha < 0) {
            orthx *= -1;
            orthy *= -1;
        }
        var cx = cp0x + orthx * cornerRadius;
        var cy = cp0y + orthy * cornerRadius;
        intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);
        if (intersection.length !== 0) intersections.push(intersection[0], intersection[1]);
    }
    for(var _i3 = 0; _i3 < lines.length / 4; _i3++){
        intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);
        if (intersection.length !== 0) intersections.push(intersection[0], intersection[1]);
    }
    if (intersections.length > 2) {
        var lowestIntersection = [
            intersections[0],
            intersections[1]
        ];
        var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);
        for(var _i4 = 1; _i4 < intersections.length / 2; _i4++){
            var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);
            if (squaredDistance <= lowestSquaredDistance) {
                lowestIntersection[0] = intersections[_i4 * 2];
                lowestIntersection[1] = intersections[_i4 * 2 + 1];
                lowestSquaredDistance = squaredDistance;
            }
        }
        return lowestIntersection;
    }
    return intersections;
};
var shortenIntersection = function shortenIntersection(intersection, offset, amount) {
    var disp = [
        intersection[0] - offset[0],
        intersection[1] - offset[1]
    ];
    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
    var lenRatio = (length - amount) / length;
    if (lenRatio < 0) lenRatio = 0.00001;
    return [
        offset[0] + lenRatio * disp[0],
        offset[1] + lenRatio * disp[1]
    ];
};
var generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {
    var points = generateUnitNgonPoints(sides, rotationRadians);
    points = fitPolygonToSquare(points);
    return points;
};
var fitPolygonToSquare = function fitPolygonToSquare(points) {
    var x, y;
    var sides = points.length / 2;
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for(var i = 0; i < sides; i++){
        x = points[2 * i];
        y = points[2 * i + 1];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
    } // stretch factors
    var sx = 2 / (maxX - minX);
    var sy = 2 / (maxY - minY);
    for(var _i5 = 0; _i5 < sides; _i5++){
        x = points[2 * _i5] = points[2 * _i5] * sx;
        y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
    }
    if (minY < -1) for(var _i6 = 0; _i6 < sides; _i6++)y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);
    return points;
};
var generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {
    var increment = 1.0 / sides * 2 * Math.PI;
    var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
    startAngle += rotationRadians;
    var points = new Array(sides * 2);
    var currentAngle;
    for(var i = 0; i < sides; i++){
        currentAngle = i * increment + startAngle;
        points[2 * i] = Math.cos(currentAngle); // x
        points[2 * i + 1] = Math.sin(-currentAngle); // y
    }
    return points;
}; // Set the default radius, unless half of width or height is smaller than default
var getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {
    return Math.min(width / 4, height / 4, 8);
}; // Set the default radius
var getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {
    return Math.min(width / 10, height / 10, 8);
};
var getCutRectangleCornerLength = function getCutRectangleCornerLength() {
    return 8;
};
var bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {
    return [
        p0 - 2 * p1 + p2,
        2 * (p1 - p0),
        p0
    ];
}; // get curve width, height, and control point position offsets as a percentage of node height / width
var getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {
    return {
        heightOffset: Math.min(15, 0.05 * height),
        widthOffset: Math.min(100, 0.25 * width),
        ctrlPtOffsetPct: 0.05
    };
};
var pageRankDefaults = defaults$g({
    dampingFactor: 0.8,
    precision: 0.000001,
    iterations: 200,
    weight: function weight(edge) {
        return 1;
    }
});
var elesfn$o = {
    pageRank: function pageRank(options) {
        var _pageRankDefaults = pageRankDefaults(options), dampingFactor = _pageRankDefaults.dampingFactor, precision = _pageRankDefaults.precision, iterations = _pageRankDefaults.iterations, weight = _pageRankDefaults.weight;
        var cy = this._private.cy;
        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;
        var numNodes = nodes.length;
        var numNodesSqd = numNodes * numNodes;
        var numEdges = edges.length; // Construct transposed adjacency matrix
        // First lets have a zeroed matrix of the right size
        // We'll also keep track of the sum of each column
        var matrix = new Array(numNodesSqd);
        var columnSum = new Array(numNodes);
        var additionalProb = (1 - dampingFactor) / numNodes; // Create null matrix
        for(var i = 0; i < numNodes; i++){
            for(var j = 0; j < numNodes; j++){
                var n = i * numNodes + j;
                matrix[n] = 0;
            }
            columnSum[i] = 0;
        } // Now, process edges
        for(var _i = 0; _i < numEdges; _i++){
            var edge = edges[_i];
            var srcId = edge.data("source");
            var tgtId = edge.data("target"); // Don't include loops in the matrix
            if (srcId === tgtId) continue;
            var s = nodes.indexOfId(srcId);
            var t = nodes.indexOfId(tgtId);
            var w = weight(edge);
            var _n = t * numNodes + s; // Update matrix
            matrix[_n] += w; // Update column sum
            columnSum[s] += w;
        } // Add additional probability based on damping factor
        // Also, take into account columns that have sum = 0
        var p = 1.0 / numNodes + additionalProb; // Shorthand
        // Traverse matrix, column by column
        for(var _j = 0; _j < numNodes; _j++){
            if (columnSum[_j] === 0) // No 'links' out from node jth, assume equal probability for each possible node
            for(var _i2 = 0; _i2 < numNodes; _i2++){
                var _n2 = _i2 * numNodes + _j;
                matrix[_n2] = p;
            }
            else // Node jth has outgoing link, compute normalized probabilities
            for(var _i3 = 0; _i3 < numNodes; _i3++){
                var _n3 = _i3 * numNodes + _j;
                matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;
            }
        } // Compute dominant eigenvector using power method
        var eigenvector = new Array(numNodes);
        var temp = new Array(numNodes);
        var previous; // Start with a vector of all 1's
        // Also, initialize a null vector which will be used as shorthand
        for(var _i4 = 0; _i4 < numNodes; _i4++)eigenvector[_i4] = 1;
        for(var iter = 0; iter < iterations; iter++){
            // Temp array with all 0's
            for(var _i5 = 0; _i5 < numNodes; _i5++)temp[_i5] = 0;
             // Multiply matrix with previous result
            for(var _i6 = 0; _i6 < numNodes; _i6++)for(var _j2 = 0; _j2 < numNodes; _j2++){
                var _n4 = _i6 * numNodes + _j2;
                temp[_i6] += matrix[_n4] * eigenvector[_j2];
            }
            inPlaceSumNormalize(temp);
            previous = eigenvector;
            eigenvector = temp;
            temp = previous;
            var diff = 0; // Compute difference (squared module) of both vectors
            for(var _i7 = 0; _i7 < numNodes; _i7++){
                var delta = previous[_i7] - eigenvector[_i7];
                diff += delta * delta;
            } // If difference is less than the desired threshold, stop iterating
            if (diff < precision) break;
        } // Construct result
        var res = {
            rank: function rank(node) {
                node = cy.collection(node)[0];
                return eigenvector[nodes.indexOf(node)];
            }
        };
        return res;
    } // pageRank
}; // elesfn
var defaults$f = defaults$g({
    root: null,
    weight: function weight(edge) {
        return 1;
    },
    directed: false,
    alpha: 0
});
var elesfn$n = {
    degreeCentralityNormalized: function degreeCentralityNormalized(options) {
        options = defaults$f(options);
        var cy = this.cy();
        var nodes = this.nodes();
        var numNodes = nodes.length;
        if (!options.directed) {
            var degrees = {};
            var maxDegree = 0;
            for(var i = 0; i < numNodes; i++){
                var node = nodes[i]; // add current node to the current options object and call degreeCentrality
                options.root = node;
                var currDegree = this.degreeCentrality(options);
                if (maxDegree < currDegree.degree) maxDegree = currDegree.degree;
                degrees[node.id()] = currDegree.degree;
            }
            return {
                degree: function degree(node) {
                    if (maxDegree === 0) return 0;
                    if (string(node)) // from is a selector string
                    node = cy.filter(node);
                    return degrees[node.id()] / maxDegree;
                }
            };
        } else {
            var indegrees = {};
            var outdegrees = {};
            var maxIndegree = 0;
            var maxOutdegree = 0;
            for(var _i = 0; _i < numNodes; _i++){
                var _node = nodes[_i];
                var id = _node.id(); // add current node to the current options object and call degreeCentrality
                options.root = _node;
                var _currDegree = this.degreeCentrality(options);
                if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;
                if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;
                indegrees[id] = _currDegree.indegree;
                outdegrees[id] = _currDegree.outdegree;
            }
            return {
                indegree: function indegree(node) {
                    if (maxIndegree == 0) return 0;
                    if (string(node)) // from is a selector string
                    node = cy.filter(node);
                    return indegrees[node.id()] / maxIndegree;
                },
                outdegree: function outdegree(node) {
                    if (maxOutdegree === 0) return 0;
                    if (string(node)) // from is a selector string
                    node = cy.filter(node);
                    return outdegrees[node.id()] / maxOutdegree;
                }
            };
        }
    },
    // degreeCentralityNormalized
    // Implemented from the algorithm in Opsahl's paper
    // "Node centrality in weighted networks: Generalizing degree and shortest paths"
    // check the heading 2 "Degree"
    degreeCentrality: function degreeCentrality(options) {
        options = defaults$f(options);
        var cy = this.cy();
        var callingEles = this;
        var _options = options, root = _options.root, weight = _options.weight, directed = _options.directed, alpha = _options.alpha;
        root = cy.collection(root)[0];
        if (!directed) {
            var connEdges = root.connectedEdges().intersection(callingEles);
            var k = connEdges.length;
            var s = 0; // Now, sum edge weights
            for(var i = 0; i < connEdges.length; i++)s += weight(connEdges[i]);
            return {
                degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
            };
        } else {
            var edges = root.connectedEdges();
            var incoming = edges.filter(function(edge) {
                return edge.target().same(root) && callingEles.has(edge);
            });
            var outgoing = edges.filter(function(edge) {
                return edge.source().same(root) && callingEles.has(edge);
            });
            var k_in = incoming.length;
            var k_out = outgoing.length;
            var s_in = 0;
            var s_out = 0; // Now, sum incoming edge weights
            for(var _i2 = 0; _i2 < incoming.length; _i2++)s_in += weight(incoming[_i2]);
             // Now, sum outgoing edge weights
            for(var _i3 = 0; _i3 < outgoing.length; _i3++)s_out += weight(outgoing[_i3]);
            return {
                indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
                outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
            };
        }
    } // degreeCentrality
}; // elesfn
// nice, short mathemathical alias
elesfn$n.dc = elesfn$n.degreeCentrality;
elesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;
var defaults$e = defaults$g({
    harmonic: true,
    weight: function weight() {
        return 1;
    },
    directed: false,
    root: null
});
var elesfn$m = {
    closenessCentralityNormalized: function closenessCentralityNormalized(options) {
        var _defaults = defaults$e(options), harmonic = _defaults.harmonic, weight = _defaults.weight, directed = _defaults.directed;
        var cy = this.cy();
        var closenesses = {};
        var maxCloseness = 0;
        var nodes = this.nodes();
        var fw = this.floydWarshall({
            weight: weight,
            directed: directed
        }); // Compute closeness for every node and find the maximum closeness
        for(var i = 0; i < nodes.length; i++){
            var currCloseness = 0;
            var node_i = nodes[i];
            for(var j = 0; j < nodes.length; j++)if (i !== j) {
                var d = fw.distance(node_i, nodes[j]);
                if (harmonic) currCloseness += 1 / d;
                else currCloseness += d;
            }
            if (!harmonic) currCloseness = 1 / currCloseness;
            if (maxCloseness < currCloseness) maxCloseness = currCloseness;
            closenesses[node_i.id()] = currCloseness;
        }
        return {
            closeness: function closeness(node) {
                if (maxCloseness == 0) return 0;
                if (string(node)) // from is a selector string
                node = cy.filter(node)[0].id();
                else // from is a node
                node = node.id();
                return closenesses[node] / maxCloseness;
            }
        };
    },
    // Implemented from pseudocode from wikipedia
    closenessCentrality: function closenessCentrality(options) {
        var _defaults2 = defaults$e(options), root = _defaults2.root, weight = _defaults2.weight, directed = _defaults2.directed, harmonic = _defaults2.harmonic;
        root = this.filter(root)[0]; // we need distance from this node to every other node
        var dijkstra = this.dijkstra({
            root: root,
            weight: weight,
            directed: directed
        });
        var totalDistance = 0;
        var nodes = this.nodes();
        for(var i = 0; i < nodes.length; i++){
            var n = nodes[i];
            if (!n.same(root)) {
                var d = dijkstra.distanceTo(n);
                if (harmonic) totalDistance += 1 / d;
                else totalDistance += d;
            }
        }
        return harmonic ? totalDistance : 1 / totalDistance;
    } // closenessCentrality
}; // elesfn
// nice, short mathemathical alias
elesfn$m.cc = elesfn$m.closenessCentrality;
elesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;
var defaults$d = defaults$g({
    weight: null,
    directed: false
});
var elesfn$l = {
    // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
    betweennessCentrality: function betweennessCentrality(options) {
        var _defaults = defaults$d(options), directed = _defaults.directed, weight = _defaults.weight;
        var weighted = weight != null;
        var cy = this.cy(); // starting
        var V = this.nodes();
        var A = {};
        var _C = {};
        var max = 0;
        var C = {
            set: function set(key, val) {
                _C[key] = val;
                if (val > max) max = val;
            },
            get: function get(key) {
                return _C[key];
            }
        }; // A contains the neighborhoods of every node
        for(var i = 0; i < V.length; i++){
            var v = V[i];
            var vid = v.id();
            if (directed) A[vid] = v.outgoers().nodes(); // get outgoers of every node
            else A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node
            C.set(vid, 0);
        }
        var _loop = function _loop(s) {
            var sid = V[s].id();
            var S = []; // stack
            var P = {};
            var g = {};
            var d = {};
            var Q = new Heap__default["default"](function(a, b) {
                return d[a] - d[b];
            }); // queue
            // init dictionaries
            for(var _i = 0; _i < V.length; _i++){
                var _vid = V[_i].id();
                P[_vid] = [];
                g[_vid] = 0;
                d[_vid] = Infinity;
            }
            g[sid] = 1; // sigma
            d[sid] = 0; // distance to s
            Q.push(sid);
            while(!Q.empty()){
                var _v = Q.pop();
                S.push(_v);
                if (weighted) for(var j = 0; j < A[_v].length; j++){
                    var w = A[_v][j];
                    var vEle = cy.getElementById(_v);
                    var edge = void 0;
                    if (vEle.edgesTo(w).length > 0) edge = vEle.edgesTo(w)[0];
                    else edge = w.edgesTo(vEle)[0];
                    var edgeWeight = weight(edge);
                    w = w.id();
                    if (d[w] > d[_v] + edgeWeight) {
                        d[w] = d[_v] + edgeWeight;
                        if (Q.nodes.indexOf(w) < 0) //if w is not in Q
                        Q.push(w);
                        else // update position if w is in Q
                        Q.updateItem(w);
                        g[w] = 0;
                        P[w] = [];
                    }
                    if (d[w] == d[_v] + edgeWeight) {
                        g[w] = g[w] + g[_v];
                        P[w].push(_v);
                    }
                }
                else for(var _j = 0; _j < A[_v].length; _j++){
                    var _w = A[_v][_j].id();
                    if (d[_w] == Infinity) {
                        Q.push(_w);
                        d[_w] = d[_v] + 1;
                    }
                    if (d[_w] == d[_v] + 1) {
                        g[_w] = g[_w] + g[_v];
                        P[_w].push(_v);
                    }
                }
            }
            var e = {};
            for(var _i2 = 0; _i2 < V.length; _i2++)e[V[_i2].id()] = 0;
            while(S.length > 0){
                var _w2 = S.pop();
                for(var _j2 = 0; _j2 < P[_w2].length; _j2++){
                    var _v2 = P[_w2][_j2];
                    e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);
                }
                if (_w2 != V[s].id()) C.set(_w2, C.get(_w2) + e[_w2]);
            }
        };
        for(var s = 0; s < V.length; s++)_loop(s);
        var ret = {
            betweenness: function betweenness(node) {
                var id = cy.collection(node).id();
                return C.get(id);
            },
            betweennessNormalized: function betweennessNormalized(node) {
                if (max == 0) return 0;
                var id = cy.collection(node).id();
                return C.get(id) / max;
            }
        }; // alias
        ret.betweennessNormalised = ret.betweennessNormalized;
        return ret;
    } // betweennessCentrality
}; // elesfn
// nice, short mathemathical alias
elesfn$l.bc = elesfn$l.betweennessCentrality;
// Implemented by Zoe Xi @zoexi for GSOC 2016
/* eslint-disable no-unused-vars */ var defaults$c = defaults$g({
    expandFactor: 2,
    // affects time of computation and cluster granularity to some extent: M * M
    inflateFactor: 2,
    // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)
    multFactor: 1,
    // optional self loops for each node. Use a neutral value to improve cluster computations.
    maxIterations: 20,
    // maximum number of iterations of the MCL algorithm in a single run
    attributes: [
        function(edge) {
            return 1;
        }
    ]
});
/* eslint-enable */ var setOptions$3 = function setOptions(options) {
    return defaults$c(options);
};
/* eslint-enable */ var getSimilarity$1 = function getSimilarity(edge, attributes) {
    var total = 0;
    for(var i = 0; i < attributes.length; i++)total += attributes[i](edge);
    return total;
};
var addLoops = function addLoops(M, n, val) {
    for(var i = 0; i < n; i++)M[i * n + i] = val;
};
var normalize = function normalize(M, n) {
    var sum;
    for(var col = 0; col < n; col++){
        sum = 0;
        for(var row = 0; row < n; row++)sum += M[row * n + col];
        for(var _row = 0; _row < n; _row++)M[_row * n + col] = M[_row * n + col] / sum;
    }
}; // TODO: blocked matrix multiplication?
var mmult = function mmult(A, B, n) {
    var C = new Array(n * n);
    for(var i = 0; i < n; i++){
        for(var j = 0; j < n; j++)C[i * n + j] = 0;
        for(var k = 0; k < n; k++)for(var _j = 0; _j < n; _j++)C[i * n + _j] += A[i * n + k] * B[k * n + _j];
    }
    return C;
};
var expand = function expand(M, n, expandFactor) {
    var _M = M.slice(0);
    for(var p = 1; p < expandFactor; p++)M = mmult(M, _M, n);
    return M;
};
var inflate = function inflate(M, n, inflateFactor) {
    var _M = new Array(n * n); // M(i,j) ^ inflatePower
    for(var i = 0; i < n * n; i++)_M[i] = Math.pow(M[i], inflateFactor);
    normalize(_M, n);
    return _M;
};
var hasConverged = function hasConverged(M, _M, n2, roundFactor) {
    // Check that both matrices have the same elements (i,j)
    for(var i = 0; i < n2; i++){
        var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places
        var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);
        if (v1 !== v2) return false;
    }
    return true;
};
var assign$2 = function assign(M, n, nodes, cy) {
    var clusters = [];
    for(var i = 0; i < n; i++){
        var cluster = [];
        for(var j = 0; j < n; j++)// Row-wise attractors and elements that they attract belong in same cluster
        if (Math.round(M[i * n + j] * 1000) / 1000 > 0) cluster.push(nodes[j]);
        if (cluster.length !== 0) clusters.push(cy.collection(cluster));
    }
    return clusters;
};
var isDuplicate = function isDuplicate(c1, c2) {
    for(var i = 0; i < c1.length; i++){
        if (!c2[i] || c1[i].id() !== c2[i].id()) return false;
    }
    return true;
};
var removeDuplicates = function removeDuplicates(clusters) {
    for(var i = 0; i < clusters.length; i++){
        for(var j = 0; j < clusters.length; j++)if (i != j && isDuplicate(clusters[i], clusters[j])) clusters.splice(j, 1);
    }
    return clusters;
};
var markovClustering = function markovClustering(options) {
    var nodes = this.nodes();
    var edges = this.edges();
    var cy = this.cy(); // Set parameters of algorithm:
    var opts = setOptions$3(options); // Map each node to its position in node array
    var id2position = {};
    for(var i = 0; i < nodes.length; i++)id2position[nodes[i].id()] = i;
     // Generate stochastic matrix M from input graph G (should be symmetric/undirected)
    var n = nodes.length, n2 = n * n;
    var M = new Array(n2), _M;
    for(var _i = 0; _i < n2; _i++)M[_i] = 0;
    for(var e = 0; e < edges.length; e++){
        var edge = edges[e];
        var _i2 = id2position[edge.source().id()];
        var j = id2position[edge.target().id()];
        var sim = getSimilarity$1(edge, opts.attributes);
        M[_i2 * n + j] += sim; // G should be symmetric and undirected
        M[j * n + _i2] += sim;
    } // Begin Markov cluster algorithm
    // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal
    addLoops(M, n, opts.multFactor); // Step 2: M = normalize( M );
    normalize(M, n);
    var isStillMoving = true;
    var iterations = 0;
    while(isStillMoving && iterations < opts.maxIterations){
        isStillMoving = false; // Step 3:
        _M = expand(M, n, opts.expandFactor); // Step 4:
        M = inflate(_M, n, opts.inflateFactor); // Step 5: check to see if ~steady state has been reached
        if (!hasConverged(M, _M, n2, 4)) isStillMoving = true;
        iterations++;
    } // Build clusters from matrix
    var clusters = assign$2(M, n, nodes, cy); // Remove duplicate clusters due to symmetry of graph and M matrix
    clusters = removeDuplicates(clusters);
    return clusters;
};
var markovClustering$1 = {
    markovClustering: markovClustering,
    mcl: markovClustering
};
// Common distance metrics for clustering algorithms
var identity = function identity(x) {
    return x;
};
var absDiff = function absDiff(p, q) {
    return Math.abs(q - p);
};
var addAbsDiff = function addAbsDiff(total, p, q) {
    return total + absDiff(p, q);
};
var addSquaredDiff = function addSquaredDiff(total, p, q) {
    return total + Math.pow(q - p, 2);
};
var sqrt = function sqrt(x) {
    return Math.sqrt(x);
};
var maxAbsDiff = function maxAbsDiff(currentMax, p, q) {
    return Math.max(currentMax, absDiff(p, q));
};
var getDistance = function getDistance(length, getP, getQ, init, visit) {
    var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;
    var ret = init;
    var p, q;
    for(var dim = 0; dim < length; dim++){
        p = getP(dim);
        q = getQ(dim);
        ret = visit(ret, p, q);
    }
    return post(ret);
};
var distances = {
    euclidean: function euclidean(length, getP, getQ) {
        if (length >= 2) return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);
        else // for single attr case, more efficient to avoid sqrt
        return getDistance(length, getP, getQ, 0, addAbsDiff);
    },
    squaredEuclidean: function squaredEuclidean(length, getP, getQ) {
        return getDistance(length, getP, getQ, 0, addSquaredDiff);
    },
    manhattan: function manhattan(length, getP, getQ) {
        return getDistance(length, getP, getQ, 0, addAbsDiff);
    },
    max: function max(length, getP, getQ) {
        return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);
    }
}; // in case the user accidentally doesn't use camel case
distances["squared-euclidean"] = distances["squaredEuclidean"];
distances["squaredeuclidean"] = distances["squaredEuclidean"];
function clusteringDistance(method, length, getP, getQ, nodeP, nodeQ) {
    var impl;
    if (fn$6(method)) impl = method;
    else impl = distances[method] || distances.euclidean;
    if (length === 0 && fn$6(method)) return impl(nodeP, nodeQ);
    else return impl(length, getP, getQ, nodeP, nodeQ);
}
var defaults$b = defaults$g({
    k: 2,
    m: 2,
    sensitivityThreshold: 0.0001,
    distance: "euclidean",
    maxIterations: 10,
    attributes: [],
    testMode: false,
    testCentroids: null
});
var setOptions$2 = function setOptions(options) {
    return defaults$b(options);
};
/* eslint-enable */ var getDist = function getDist(type, node, centroid, attributes, mode) {
    var noNodeP = mode !== "kMedoids";
    var getP = noNodeP ? function(i) {
        return centroid[i];
    } : function(i) {
        return attributes[i](centroid);
    };
    var getQ = function getQ(i) {
        return attributes[i](node);
    };
    var nodeP = centroid;
    var nodeQ = node;
    return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);
};
var randomCentroids = function randomCentroids(nodes, k, attributes) {
    var ndim = attributes.length;
    var min = new Array(ndim);
    var max = new Array(ndim);
    var centroids = new Array(k);
    var centroid = null; // Find min, max values for each attribute dimension
    for(var i = 0; i < ndim; i++){
        min[i] = nodes.min(attributes[i]).value;
        max[i] = nodes.max(attributes[i]).value;
    } // Build k centroids, each represented as an n-dim feature vector
    for(var c = 0; c < k; c++){
        centroid = [];
        for(var _i = 0; _i < ndim; _i++)centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value
        centroids[c] = centroid;
    }
    return centroids;
};
var classify = function classify(node, centroids, distance, attributes, type) {
    var min = Infinity;
    var index = 0;
    for(var i = 0; i < centroids.length; i++){
        var dist = getDist(distance, node, centroids[i], attributes, type);
        if (dist < min) {
            min = dist;
            index = i;
        }
    }
    return index;
};
var buildCluster = function buildCluster(centroid, nodes, assignment) {
    var cluster = [];
    var node = null;
    for(var n = 0; n < nodes.length; n++){
        node = nodes[n];
        if (assignment[node.id()] === centroid) //console.log("Node " + node.id() + " is associated with medoid #: " + m);
        cluster.push(node);
    }
    return cluster;
};
var haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {
    return Math.abs(v2 - v1) <= sensitivityThreshold;
};
var haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {
    for(var i = 0; i < v1.length; i++)for(var j = 0; j < v1[i].length; j++){
        var diff = Math.abs(v1[i][j] - v2[i][j]);
        if (diff > sensitivityThreshold) return false;
    }
    return true;
};
var seenBefore = function seenBefore(node, medoids, n) {
    for(var i = 0; i < n; i++){
        if (node === medoids[i]) return true;
    }
    return false;
};
var randomMedoids = function randomMedoids(nodes, k) {
    var medoids = new Array(k); // For small data sets, the probability of medoid conflict is greater,
    // so we need to check to see if we've already seen or chose this node before.
    if (nodes.length < 50) // Randomly select k medoids from the n nodes
    for(var i = 0; i < k; i++){
        var node = nodes[Math.floor(Math.random() * nodes.length)]; // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).
        // Instead choose a different random node.
        while(seenBefore(node, medoids, i))node = nodes[Math.floor(Math.random() * nodes.length)];
        medoids[i] = node;
    }
    else // Relatively large data set, so pretty safe to not check and just select random nodes
    for(var _i2 = 0; _i2 < k; _i2++)medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];
    return medoids;
};
var findCost = function findCost(potentialNewMedoid, cluster, attributes) {
    var cost = 0;
    for(var n = 0; n < cluster.length; n++)cost += getDist("manhattan", cluster[n], potentialNewMedoid, attributes, "kMedoids");
    return cost;
};
var kMeans = function kMeans(options) {
    var cy = this.cy();
    var nodes = this.nodes();
    var node = null; // Set parameters of algorithm: # of clusters, distance metric, etc.
    var opts = setOptions$2(options); // Begin k-means algorithm
    var clusters = new Array(opts.k);
    var assignment = {};
    var centroids; // Step 1: Initialize centroid positions
    if (opts.testMode) {
        if (typeof opts.testCentroids === "number") {
            // TODO: implement a seeded random number generator.
            opts.testCentroids;
            centroids = randomCentroids(nodes, opts.k, opts.attributes);
        } else if (_typeof(opts.testCentroids) === "object") centroids = opts.testCentroids;
        else centroids = randomCentroids(nodes, opts.k, opts.attributes);
    } else centroids = randomCentroids(nodes, opts.k, opts.attributes);
    var isStillMoving = true;
    var iterations = 0;
    while(isStillMoving && iterations < opts.maxIterations){
        // Step 2: Assign nodes to the nearest centroid
        for(var n = 0; n < nodes.length; n++){
            node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #
            assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, "kMeans");
        } // Step 3: For each of the k clusters, update its centroid
        isStillMoving = false;
        for(var c = 0; c < opts.k; c++){
            // Get all nodes that belong to this cluster
            var cluster = buildCluster(c, nodes, assignment);
            if (cluster.length === 0) continue;
             // Update centroids by calculating avg of all nodes within the cluster.
            var ndim = opts.attributes.length;
            var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]
            var newCentroid = new Array(ndim);
            var sum = new Array(ndim);
            for(var d = 0; d < ndim; d++){
                sum[d] = 0.0;
                for(var i = 0; i < cluster.length; i++){
                    node = cluster[i];
                    sum[d] += opts.attributes[d](node);
                }
                newCentroid[d] = sum[d] / cluster.length; // Check to see if algorithm has converged, i.e. when centroids no longer change
                if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) isStillMoving = true;
            }
            centroids[c] = newCentroid;
            clusters[c] = cy.collection(cluster);
        }
        iterations++;
    }
    return clusters;
};
var kMedoids = function kMedoids(options) {
    var cy = this.cy();
    var nodes = this.nodes();
    var node = null;
    var opts = setOptions$2(options); // Begin k-medoids algorithm
    var clusters = new Array(opts.k);
    var medoids;
    var assignment = {};
    var curCost;
    var minCosts = new Array(opts.k); // minimum cost configuration for each cluster
    // Step 1: Initialize k medoids
    if (opts.testMode) {
        if (typeof opts.testCentroids === "number") ;
        else if (_typeof(opts.testCentroids) === "object") medoids = opts.testCentroids;
        else medoids = randomMedoids(nodes, opts.k);
    } else medoids = randomMedoids(nodes, opts.k);
    var isStillMoving = true;
    var iterations = 0;
    while(isStillMoving && iterations < opts.maxIterations){
        // Step 2: Assign nodes to the nearest medoid
        for(var n = 0; n < nodes.length; n++){
            node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #
            assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, "kMedoids");
        }
        isStillMoving = false; // Step 3: For each medoid m, and for each node assciated with mediod m,
        // select the node with the lowest configuration cost as new medoid.
        for(var m1 = 0; m1 < medoids.length; m1++){
            // Get all nodes that belong to this medoid
            var cluster = buildCluster(m1, nodes, assignment);
            if (cluster.length === 0) continue;
            minCosts[m1] = findCost(medoids[m1], cluster, opts.attributes); // original cost
            // Select different medoid if its configuration has the lowest cost
            for(var _n = 0; _n < cluster.length; _n++){
                curCost = findCost(cluster[_n], cluster, opts.attributes);
                if (curCost < minCosts[m1]) {
                    minCosts[m1] = curCost;
                    medoids[m1] = cluster[_n];
                    isStillMoving = true;
                }
            }
            clusters[m1] = cy.collection(cluster);
        }
        iterations++;
    }
    return clusters;
};
var updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {
    var numerator, denominator;
    for(var n = 0; n < nodes.length; n++)for(var c = 0; c < centroids.length; c++)weight[n][c] = Math.pow(U[n][c], opts.m);
    for(var _c = 0; _c < centroids.length; _c++)for(var dim = 0; dim < opts.attributes.length; dim++){
        numerator = 0;
        denominator = 0;
        for(var _n2 = 0; _n2 < nodes.length; _n2++){
            numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);
            denominator += weight[_n2][_c];
        }
        centroids[_c][dim] = numerator / denominator;
    }
};
var updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {
    // Save previous step
    for(var i = 0; i < U.length; i++)_U[i] = U[i].slice();
    var sum, numerator, denominator;
    var pow = 2 / (opts.m - 1);
    for(var c = 0; c < centroids.length; c++)for(var n = 0; n < nodes.length; n++){
        sum = 0;
        for(var k = 0; k < centroids.length; k++){
            // against all other centroids
            numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, "cmeans");
            denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, "cmeans");
            sum += Math.pow(numerator / denominator, pow);
        }
        U[n][c] = 1 / sum;
    }
};
var assign$1 = function assign(nodes, U, opts, cy) {
    var clusters = new Array(opts.k);
    for(var c = 0; c < clusters.length; c++)clusters[c] = [];
    var max;
    var index;
    for(var n = 0; n < U.length; n++){
        // for each node (U is N x C matrix)
        max = -Infinity;
        index = -1; // Determine which cluster the node is most likely to belong in
        for(var _c2 = 0; _c2 < U[0].length; _c2++)if (U[n][_c2] > max) {
            max = U[n][_c2];
            index = _c2;
        }
        clusters[index].push(nodes[n]);
    } // Turn every array into a collection of nodes
    for(var _c3 = 0; _c3 < clusters.length; _c3++)clusters[_c3] = cy.collection(clusters[_c3]);
    return clusters;
};
var fuzzyCMeans = function fuzzyCMeans(options) {
    var cy = this.cy();
    var nodes = this.nodes();
    var opts = setOptions$2(options); // Begin fuzzy c-means algorithm
    var clusters;
    var centroids;
    var U;
    var _U;
    var weight; // Step 1: Initialize letiables.
    _U = new Array(nodes.length);
    for(var i = 0; i < nodes.length; i++)// N x C matrix
    _U[i] = new Array(opts.k);
    U = new Array(nodes.length);
    for(var _i3 = 0; _i3 < nodes.length; _i3++)// N x C matrix
    U[_i3] = new Array(opts.k);
    for(var _i4 = 0; _i4 < nodes.length; _i4++){
        var total = 0;
        for(var j = 0; j < opts.k; j++){
            U[_i4][j] = Math.random();
            total += U[_i4][j];
        }
        for(var _j = 0; _j < opts.k; _j++)U[_i4][_j] = U[_i4][_j] / total;
    }
    centroids = new Array(opts.k);
    for(var _i5 = 0; _i5 < opts.k; _i5++)centroids[_i5] = new Array(opts.attributes.length);
    weight = new Array(nodes.length);
    for(var _i6 = 0; _i6 < nodes.length; _i6++)// N x C matrix
    weight[_i6] = new Array(opts.k);
     // end init FCM
    var isStillMoving = true;
    var iterations = 0;
    while(isStillMoving && iterations < opts.maxIterations){
        isStillMoving = false; // Step 2: Calculate the centroids for each step.
        updateCentroids(centroids, nodes, U, weight, opts); // Step 3: Update the partition matrix U.
        updateMembership(U, _U, centroids, nodes, opts); // Step 4: Check for convergence.
        if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) isStillMoving = true;
        iterations++;
    } // Assign nodes to clusters with highest probability.
    clusters = assign$1(nodes, U, opts, cy);
    return {
        clusters: clusters,
        degreeOfMembership: U
    };
};
var kClustering = {
    kMeans: kMeans,
    kMedoids: kMedoids,
    fuzzyCMeans: fuzzyCMeans,
    fcm: fuzzyCMeans
};
// Implemented by Zoe Xi @zoexi for GSOC 2016
var defaults$a = defaults$g({
    distance: "euclidean",
    // distance metric to compare nodes
    linkage: "min",
    // linkage criterion : how to determine the distance between clusters of nodes
    mode: "threshold",
    // mode:'threshold' => clusters must be threshold distance apart
    threshold: Infinity,
    // the distance threshold
    // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters
    addDendrogram: false,
    // whether to add the dendrogram to the graph for viz
    dendrogramDepth: 0,
    // depth at which dendrogram branches are merged into the returned clusters
    attributes: [] // array of attr functions
});
var linkageAliases = {
    "single": "min",
    "complete": "max"
};
var setOptions$1 = function setOptions(options) {
    var opts = defaults$a(options);
    var preferredAlias = linkageAliases[opts.linkage];
    if (preferredAlias != null) opts.linkage = preferredAlias;
    return opts;
};
var mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {
    // Find two closest clusters from cached mins
    var minKey = 0;
    var min = Infinity;
    var dist;
    var attrs = opts.attributes;
    var getDist = function getDist(n1, n2) {
        return clusteringDistance(opts.distance, attrs.length, function(i) {
            return attrs[i](n1);
        }, function(i) {
            return attrs[i](n2);
        }, n1, n2);
    };
    for(var i = 0; i < clusters.length; i++){
        var key = clusters[i].key;
        var _dist = dists[key][mins[key]];
        if (_dist < min) {
            minKey = key;
            min = _dist;
        }
    }
    if (opts.mode === "threshold" && min >= opts.threshold || opts.mode === "dendrogram" && clusters.length === 1) return false;
    var c1 = index[minKey];
    var c2 = index[mins[minKey]];
    var merged; // Merge two closest clusters
    if (opts.mode === "dendrogram") merged = {
        left: c1,
        right: c2,
        key: c1.key
    };
    else merged = {
        value: c1.value.concat(c2.value),
        key: c1.key
    };
    clusters[c1.index] = merged;
    clusters.splice(c2.index, 1);
    index[c1.key] = merged; // Update distances with new merged cluster
    for(var _i = 0; _i < clusters.length; _i++){
        var cur = clusters[_i];
        if (c1.key === cur.key) dist = Infinity;
        else if (opts.linkage === "min") {
            dist = dists[c1.key][cur.key];
            if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) dist = dists[c2.key][cur.key];
        } else if (opts.linkage === "max") {
            dist = dists[c1.key][cur.key];
            if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) dist = dists[c2.key][cur.key];
        } else if (opts.linkage === "mean") dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);
        else if (opts.mode === "dendrogram") dist = getDist(cur.value, c1.value);
        else dist = getDist(cur.value[0], c1.value[0]);
        dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric
    } // Update cached mins
    for(var _i2 = 0; _i2 < clusters.length; _i2++){
        var key1 = clusters[_i2].key;
        if (mins[key1] === c1.key || mins[key1] === c2.key) {
            var _min = key1;
            for(var j = 0; j < clusters.length; j++){
                var key2 = clusters[j].key;
                if (dists[key1][key2] < dists[key1][_min]) _min = key2;
            }
            mins[key1] = _min;
        }
        clusters[_i2].index = _i2;
    } // Clean up meta data used for clustering
    c1.key = c2.key = c1.index = c2.index = null;
    return true;
};
var getAllChildren = function getAllChildren(root, arr, cy) {
    if (!root) return;
    if (root.value) arr.push(root.value);
    else {
        if (root.left) getAllChildren(root.left, arr);
        if (root.right) getAllChildren(root.right, arr);
    }
};
var buildDendrogram = function buildDendrogram(root, cy) {
    if (!root) return "";
    if (root.left && root.right) {
        var leftStr = buildDendrogram(root.left, cy);
        var rightStr = buildDendrogram(root.right, cy);
        var node = cy.add({
            group: "nodes",
            data: {
                id: leftStr + "," + rightStr
            }
        });
        cy.add({
            group: "edges",
            data: {
                source: leftStr,
                target: node.id()
            }
        });
        cy.add({
            group: "edges",
            data: {
                source: rightStr,
                target: node.id()
            }
        });
        return node.id();
    } else if (root.value) return root.value.id();
};
var buildClustersFromTree = function buildClustersFromTree(root, k, cy) {
    if (!root) return [];
    var left = [], right = [], leaves = [];
    if (k === 0) {
        // don't cut tree, simply return all nodes as 1 single cluster
        if (root.left) getAllChildren(root.left, left);
        if (root.right) getAllChildren(root.right, right);
        leaves = left.concat(right);
        return [
            cy.collection(leaves)
        ];
    } else if (k === 1) {
        // cut at root
        if (root.value) // leaf node
        return [
            cy.collection(root.value)
        ];
        else {
            if (root.left) getAllChildren(root.left, left);
            if (root.right) getAllChildren(root.right, right);
            return [
                cy.collection(left),
                cy.collection(right)
            ];
        }
    } else {
        if (root.value) return [
            cy.collection(root.value)
        ];
        else {
            if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);
            if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);
            return left.concat(right);
        }
    }
};
/* eslint-enable */ var hierarchicalClustering = function hierarchicalClustering(options) {
    var cy = this.cy();
    var nodes = this.nodes(); // Set parameters of algorithm: linkage type, distance metric, etc.
    var opts = setOptions$1(options);
    var attrs = opts.attributes;
    var getDist = function getDist(n1, n2) {
        return clusteringDistance(opts.distance, attrs.length, function(i) {
            return attrs[i](n1);
        }, function(i) {
            return attrs[i](n2);
        }, n1, n2);
    }; // Begin hierarchical algorithm
    var clusters = [];
    var dists = []; // distances between each pair of clusters
    var mins = []; // closest cluster for each cluster
    var index = []; // hash of all clusters by key
    // In agglomerative (bottom-up) clustering, each node starts as its own cluster
    for(var n = 0; n < nodes.length; n++){
        var cluster = {
            value: opts.mode === "dendrogram" ? nodes[n] : [
                nodes[n]
            ],
            key: n,
            index: n
        };
        clusters[n] = cluster;
        index[n] = cluster;
        dists[n] = [];
        mins[n] = 0;
    } // Calculate the distance between each pair of clusters
    for(var i = 0; i < clusters.length; i++)for(var j = 0; j <= i; j++){
        var dist = void 0;
        if (opts.mode === "dendrogram") // modes store cluster values differently
        dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);
        else dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);
        dists[i][j] = dist;
        dists[j][i] = dist;
        if (dist < dists[i][mins[i]]) mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j
    }
     // Find the closest pair of clusters and merge them into a single cluster.
    // Update distances between new cluster and each of the old clusters, and loop until threshold reached.
    var merged = mergeClosest(clusters, index, dists, mins, opts);
    while(merged)merged = mergeClosest(clusters, index, dists, mins, opts);
    var retClusters; // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges
    // in addition to returning the clusters.
    if (opts.mode === "dendrogram") {
        retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);
        if (opts.addDendrogram) buildDendrogram(clusters[0], cy);
    } else {
        // Regular mode simply returns the clusters
        retClusters = new Array(clusters.length);
        clusters.forEach(function(cluster, i) {
            // Clean up meta data used for clustering
            cluster.key = cluster.index = null;
            retClusters[i] = cy.collection(cluster.value);
        });
    }
    return retClusters;
};
var hierarchicalClustering$1 = {
    hierarchicalClustering: hierarchicalClustering,
    hca: hierarchicalClustering
};
// Implemented by Zoe Xi @zoexi for GSOC 2016
var defaults$9 = defaults$g({
    distance: "euclidean",
    // distance metric to compare attributes between two nodes
    preference: "median",
    // suitability of a data point to serve as an exemplar
    damping: 0.8,
    // damping factor between [0.5, 1)
    maxIterations: 1000,
    // max number of iterations to run
    minIterations: 100,
    // min number of iterations to run in order for clustering to stop
    attributes: []
});
var setOptions = function setOptions(options) {
    var dmp = options.damping;
    var pref = options.preference;
    if (!(0.5 <= dmp && dmp < 1)) error("Damping must range on [0.5, 1).  Got: ".concat(dmp));
    var validPrefs = [
        "median",
        "mean",
        "min",
        "max"
    ];
    if (!(validPrefs.some(function(v) {
        return v === pref;
    }) || number$1(pref))) error("Preference must be one of [".concat(validPrefs.map(function(p) {
        return "'".concat(p, "'");
    }).join(", "), "] or a number.  Got: ").concat(pref));
    return defaults$9(options);
};
/* eslint-enable */ var getSimilarity = function getSimilarity(type, n1, n2, attributes) {
    var attr = function attr(n, i) {
        return attributes[i](n);
    }; // nb negative because similarity should have an inverse relationship to distance
    return -clusteringDistance(type, attributes.length, function(i) {
        return attr(n1, i);
    }, function(i) {
        return attr(n2, i);
    }, n1, n2);
};
var getPreference = function getPreference(S, preference) {
    // larger preference = greater # of clusters
    var p = null;
    if (preference === "median") p = median(S);
    else if (preference === "mean") p = mean(S);
    else if (preference === "min") p = min(S);
    else if (preference === "max") p = max(S);
    else // Custom preference number, as set by user
    p = preference;
    return p;
};
var findExemplars = function findExemplars(n, R, A) {
    var indices = [];
    for(var i = 0; i < n; i++)if (R[i * n + i] + A[i * n + i] > 0) indices.push(i);
    return indices;
};
var assignClusters = function assignClusters(n, S, exemplars) {
    var clusters = [];
    for(var i = 0; i < n; i++){
        var index = -1;
        var max = -Infinity;
        for(var ei = 0; ei < exemplars.length; ei++){
            var e = exemplars[ei];
            if (S[i * n + e] > max) {
                index = e;
                max = S[i * n + e];
            }
        }
        if (index > 0) clusters.push(index);
    }
    for(var _ei = 0; _ei < exemplars.length; _ei++)clusters[exemplars[_ei]] = exemplars[_ei];
    return clusters;
};
var assign = function assign(n, S, exemplars) {
    var clusters = assignClusters(n, S, exemplars);
    for(var ei = 0; ei < exemplars.length; ei++){
        var ii = [];
        for(var c = 0; c < clusters.length; c++)if (clusters[c] === exemplars[ei]) ii.push(c);
        var maxI = -1;
        var maxSum = -Infinity;
        for(var i = 0; i < ii.length; i++){
            var sum = 0;
            for(var j = 0; j < ii.length; j++)sum += S[ii[j] * n + ii[i]];
            if (sum > maxSum) {
                maxI = i;
                maxSum = sum;
            }
        }
        exemplars[ei] = ii[maxI];
    }
    clusters = assignClusters(n, S, exemplars);
    return clusters;
};
var affinityPropagation = function affinityPropagation(options) {
    var cy = this.cy();
    var nodes = this.nodes();
    var opts = setOptions(options); // Map each node to its position in node array
    var id2position = {};
    for(var i = 0; i < nodes.length; i++)id2position[nodes[i].id()] = i;
     // Begin affinity propagation algorithm
    var n; // number of data points
    var n2; // size of matrices
    var S; // similarity matrix (1D array)
    var p; // preference/suitability of a data point to serve as an exemplar
    var R; // responsibility matrix (1D array)
    var A; // availability matrix (1D array)
    n = nodes.length;
    n2 = n * n; // Initialize and build S similarity matrix
    S = new Array(n2);
    for(var _i = 0; _i < n2; _i++)S[_i] = -Infinity; // for cases where two data points shouldn't be linked together
    for(var _i2 = 0; _i2 < n; _i2++){
        for(var j = 0; j < n; j++)if (_i2 !== j) S[_i2 * n + j] = getSimilarity(opts.distance, nodes[_i2], nodes[j], opts.attributes);
    } // Place preferences on the diagonal of S
    p = getPreference(S, opts.preference);
    for(var _i3 = 0; _i3 < n; _i3++)S[_i3 * n + _i3] = p;
     // Initialize R responsibility matrix
    R = new Array(n2);
    for(var _i4 = 0; _i4 < n2; _i4++)R[_i4] = 0.0;
     // Initialize A availability matrix
    A = new Array(n2);
    for(var _i5 = 0; _i5 < n2; _i5++)A[_i5] = 0.0;
    var old = new Array(n);
    var Rp = new Array(n);
    var se = new Array(n);
    for(var _i6 = 0; _i6 < n; _i6++){
        old[_i6] = 0.0;
        Rp[_i6] = 0.0;
        se[_i6] = 0;
    }
    var e = new Array(n * opts.minIterations);
    for(var _i7 = 0; _i7 < e.length; _i7++)e[_i7] = 0;
    var iter;
    for(iter = 0; iter < opts.maxIterations; iter++){
        // main algorithmic loop
        // Update R responsibility matrix
        for(var _i8 = 0; _i8 < n; _i8++){
            var max = -Infinity, max2 = -Infinity, maxI = -1, AS = 0.0;
            for(var _j = 0; _j < n; _j++){
                old[_j] = R[_i8 * n + _j];
                AS = A[_i8 * n + _j] + S[_i8 * n + _j];
                if (AS >= max) {
                    max2 = max;
                    max = AS;
                    maxI = _j;
                } else if (AS > max2) max2 = AS;
            }
            for(var _j2 = 0; _j2 < n; _j2++)R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];
            R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];
        } // Update A availability matrix
        for(var _i9 = 0; _i9 < n; _i9++){
            var sum = 0;
            for(var _j3 = 0; _j3 < n; _j3++){
                old[_j3] = A[_j3 * n + _i9];
                Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);
                sum += Rp[_j3];
            }
            sum -= Rp[_i9];
            Rp[_i9] = R[_i9 * n + _i9];
            sum += Rp[_i9];
            for(var _j4 = 0; _j4 < n; _j4++)A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];
            A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];
        } // Check for convergence
        var K = 0;
        for(var _i10 = 0; _i10 < n; _i10++){
            var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;
            e[iter % opts.minIterations * n + _i10] = E;
            K += E;
        }
        if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {
            var _sum = 0;
            for(var _i11 = 0; _i11 < n; _i11++){
                se[_i11] = 0;
                for(var _j5 = 0; _j5 < opts.minIterations; _j5++)se[_i11] += e[_j5 * n + _i11];
                if (se[_i11] === 0 || se[_i11] === opts.minIterations) _sum++;
            }
            if (_sum === n) break;
        }
    } // Identify exemplars (cluster centers)
    var exemplarsIndices = findExemplars(n, R, A); // Assign nodes to clusters
    var clusterIndices = assign(n, S, exemplarsIndices);
    var clusters = {};
    for(var c = 0; c < exemplarsIndices.length; c++)clusters[exemplarsIndices[c]] = [];
    for(var _i12 = 0; _i12 < nodes.length; _i12++){
        var pos = id2position[nodes[_i12].id()];
        var clusterIndex = clusterIndices[pos];
        if (clusterIndex != null) // the node may have not been assigned a cluster if no valid attributes were specified
        clusters[clusterIndex].push(nodes[_i12]);
    }
    var retClusters = new Array(exemplarsIndices.length);
    for(var _c = 0; _c < exemplarsIndices.length; _c++)retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);
    return retClusters;
};
var affinityPropagation$1 = {
    affinityPropagation: affinityPropagation,
    ap: affinityPropagation
};
var hierholzerDefaults = defaults$g({
    root: undefined,
    directed: false
});
var elesfn$k = {
    hierholzer: function hierholzer(options) {
        if (!plainObject(options)) {
            var args = arguments;
            options = {
                root: args[0],
                directed: args[1]
            };
        }
        var _hierholzerDefaults = hierholzerDefaults(options), root = _hierholzerDefaults.root, directed = _hierholzerDefaults.directed;
        var eles = this;
        var dflag = false;
        var oddIn;
        var oddOut;
        var startVertex;
        if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();
        var nodes = {};
        var edges = {};
        if (directed) eles.forEach(function(ele) {
            var id = ele.id();
            if (ele.isNode()) {
                var ind = ele.indegree(true);
                var outd = ele.outdegree(true);
                var d1 = ind - outd;
                var d2 = outd - ind;
                if (d1 == 1) {
                    if (oddIn) dflag = true;
                    else oddIn = id;
                } else if (d2 == 1) {
                    if (oddOut) dflag = true;
                    else oddOut = id;
                } else if (d2 > 1 || d1 > 1) dflag = true;
                nodes[id] = [];
                ele.outgoers().forEach(function(e) {
                    if (e.isEdge()) nodes[id].push(e.id());
                });
            } else edges[id] = [
                undefined,
                ele.target().id()
            ];
        });
        else eles.forEach(function(ele) {
            var id = ele.id();
            if (ele.isNode()) {
                var d = ele.degree(true);
                if (d % 2) {
                    if (!oddIn) oddIn = id;
                    else if (!oddOut) oddOut = id;
                    else dflag = true;
                }
                nodes[id] = [];
                ele.connectedEdges().forEach(function(e) {
                    return nodes[id].push(e.id());
                });
            } else edges[id] = [
                ele.source().id(),
                ele.target().id()
            ];
        });
        var result = {
            found: false,
            trail: undefined
        };
        if (dflag) return result;
        else if (oddOut && oddIn) {
            if (directed) {
                if (startVertex && oddOut != startVertex) return result;
                startVertex = oddOut;
            } else {
                if (startVertex && oddOut != startVertex && oddIn != startVertex) return result;
                else if (!startVertex) startVertex = oddOut;
            }
        } else if (!startVertex) startVertex = eles[0].id();
        var walk = function walk(v) {
            var currentNode = v;
            var subtour = [
                v
            ];
            var adj, adjTail, adjHead;
            while(nodes[currentNode].length){
                adj = nodes[currentNode].shift();
                adjTail = edges[adj][0];
                adjHead = edges[adj][1];
                if (currentNode != adjHead) {
                    nodes[adjHead] = nodes[adjHead].filter(function(e) {
                        return e != adj;
                    });
                    currentNode = adjHead;
                } else if (!directed && currentNode != adjTail) {
                    nodes[adjTail] = nodes[adjTail].filter(function(e) {
                        return e != adj;
                    });
                    currentNode = adjTail;
                }
                subtour.unshift(adj);
                subtour.unshift(currentNode);
            }
            return subtour;
        };
        var trail = [];
        var subtour = [];
        subtour = walk(startVertex);
        while(subtour.length != 1)if (nodes[subtour[0]].length == 0) {
            trail.unshift(eles.getElementById(subtour.shift()));
            trail.unshift(eles.getElementById(subtour.shift()));
        } else subtour = walk(subtour.shift()).concat(subtour);
        trail.unshift(eles.getElementById(subtour.shift())); // final node
        for(var d in nodes){
            if (nodes[d].length) return result;
        }
        result.found = true;
        result.trail = this.spawn(trail, true);
        return result;
    }
};
var hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {
    var eles = this;
    var nodes = {};
    var id = 0;
    var edgeCount = 0;
    var components = [];
    var stack = [];
    var visitedEdges = {};
    var buildComponent = function buildComponent(x, y) {
        var i = stack.length - 1;
        var cutset = [];
        var component = eles.spawn();
        while(stack[i].x != x || stack[i].y != y){
            cutset.push(stack.pop().edge);
            i--;
        }
        cutset.push(stack.pop().edge);
        cutset.forEach(function(edge) {
            var connectedNodes = edge.connectedNodes().intersection(eles);
            component.merge(edge);
            connectedNodes.forEach(function(node) {
                var nodeId = node.id();
                var connectedEdges = node.connectedEdges().intersection(eles);
                component.merge(node);
                if (!nodes[nodeId].cutVertex) component.merge(connectedEdges);
                else component.merge(connectedEdges.filter(function(edge) {
                    return edge.isLoop();
                }));
            });
        });
        components.push(component);
    };
    var biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {
        if (root === parent) edgeCount += 1;
        nodes[currentNode] = {
            id: id,
            low: id++,
            cutVertex: false
        };
        var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);
        if (edges.size() === 0) components.push(eles.spawn(eles.getElementById(currentNode)));
        else {
            var sourceId, targetId, otherNodeId, edgeId;
            edges.forEach(function(edge) {
                sourceId = edge.source().id();
                targetId = edge.target().id();
                otherNodeId = sourceId === currentNode ? targetId : sourceId;
                if (otherNodeId !== parent) {
                    edgeId = edge.id();
                    if (!visitedEdges[edgeId]) {
                        visitedEdges[edgeId] = true;
                        stack.push({
                            x: currentNode,
                            y: otherNodeId,
                            edge: edge
                        });
                    }
                    if (!(otherNodeId in nodes)) {
                        biconnectedSearch(root, otherNodeId, currentNode);
                        nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);
                        if (nodes[currentNode].id <= nodes[otherNodeId].low) {
                            nodes[currentNode].cutVertex = true;
                            buildComponent(currentNode, otherNodeId);
                        }
                    } else nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);
                }
            });
        }
    };
    eles.forEach(function(ele) {
        if (ele.isNode()) {
            var nodeId = ele.id();
            if (!(nodeId in nodes)) {
                edgeCount = 0;
                biconnectedSearch(nodeId, nodeId);
                nodes[nodeId].cutVertex = edgeCount > 1;
            }
        }
    });
    var cutVertices = Object.keys(nodes).filter(function(id) {
        return nodes[id].cutVertex;
    }).map(function(id) {
        return eles.getElementById(id);
    });
    return {
        cut: eles.spawn(cutVertices),
        components: components
    };
};
var hopcroftTarjanBiconnected$1 = {
    hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,
    htbc: hopcroftTarjanBiconnected,
    htb: hopcroftTarjanBiconnected,
    hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected
};
var tarjanStronglyConnected = function tarjanStronglyConnected() {
    var eles = this;
    var nodes = {};
    var index = 0;
    var components = [];
    var stack = [];
    var cut = eles.spawn(eles);
    var stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {
        stack.push(sourceNodeId);
        nodes[sourceNodeId] = {
            index: index,
            low: index++,
            explored: false
        };
        var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);
        connectedEdges.forEach(function(edge) {
            var targetNodeId = edge.target().id();
            if (targetNodeId !== sourceNodeId) {
                if (!(targetNodeId in nodes)) stronglyConnectedSearch(targetNodeId);
                if (!nodes[targetNodeId].explored) nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);
            }
        });
        if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {
            var componentNodes = eles.spawn();
            for(;;){
                var nodeId = stack.pop();
                componentNodes.merge(eles.getElementById(nodeId));
                nodes[nodeId].low = nodes[sourceNodeId].index;
                nodes[nodeId].explored = true;
                if (nodeId === sourceNodeId) break;
            }
            var componentEdges = componentNodes.edgesWith(componentNodes);
            var component = componentNodes.merge(componentEdges);
            components.push(component);
            cut = cut.difference(component);
        }
    };
    eles.forEach(function(ele) {
        if (ele.isNode()) {
            var nodeId = ele.id();
            if (!(nodeId in nodes)) stronglyConnectedSearch(nodeId);
        }
    });
    return {
        cut: cut,
        components: components
    };
};
var tarjanStronglyConnected$1 = {
    tarjanStronglyConnected: tarjanStronglyConnected,
    tsc: tarjanStronglyConnected,
    tscc: tarjanStronglyConnected,
    tarjanStronglyConnectedComponents: tarjanStronglyConnected
};
var elesfn$j = {};
[
    elesfn$v,
    elesfn$u,
    elesfn$t,
    elesfn$s,
    elesfn$r,
    elesfn$q,
    elesfn$p,
    elesfn$o,
    elesfn$n,
    elesfn$m,
    elesfn$l,
    markovClustering$1,
    kClustering,
    hierarchicalClustering$1,
    affinityPropagation$1,
    elesfn$k,
    hopcroftTarjanBiconnected$1,
    tarjanStronglyConnected$1
].forEach(function(props) {
    extend(elesfn$j, props);
});
/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/ /*  promise states [Promises/A+ 2.1]  */ var STATE_PENDING = 0;
/*  [Promises/A+ 2.1.1]  */ var STATE_FULFILLED = 1;
/*  [Promises/A+ 2.1.2]  */ var STATE_REJECTED = 2;
/*  [Promises/A+ 2.1.3]  */ /*  promise object constructor  */ var api = function api(executor) {
    /*  optionally support non-constructor/plain-function call  */ if (!(this instanceof api)) return new api(executor);
    /*  initialize object  */ this.id = "Thenable/1.0.7";
    this.state = STATE_PENDING;
    /*  initial state  */ this.fulfillValue = undefined;
    /*  initial value  */ /*  [Promises/A+ 1.3, 2.1.2.2]  */ this.rejectReason = undefined;
    /*  initial reason */ /*  [Promises/A+ 1.5, 2.1.3.2]  */ this.onFulfilled = [];
    /*  initial handlers  */ this.onRejected = [];
    /*  initial handlers  */ /*  provide optional information-hiding proxy  */ this.proxy = {
        then: this.then.bind(this)
    };
    /*  support optional executor function  */ if (typeof executor === "function") executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
};
/*  promise API methods  */ api.prototype = {
    /*  promise resolving methods  */ fulfill: function fulfill(value) {
        return deliver(this, STATE_FULFILLED, "fulfillValue", value);
    },
    reject: function reject(value) {
        return deliver(this, STATE_REJECTED, "rejectReason", value);
    },
    /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */ then: function then(onFulfilled, onRejected) {
        var curr = this;
        var next = new api();
        /*  [Promises/A+ 2.2.7]  */ curr.onFulfilled.push(resolver(onFulfilled, next, "fulfill"));
        /*  [Promises/A+ 2.2.2/2.2.6]  */ curr.onRejected.push(resolver(onRejected, next, "reject"));
        /*  [Promises/A+ 2.2.3/2.2.6]  */ execute(curr);
        return next.proxy;
    /*  [Promises/A+ 2.2.7, 3.3]  */ }
};
/*  deliver an action  */ var deliver = function deliver(curr, state, name, value) {
    if (curr.state === STATE_PENDING) {
        curr.state = state;
        /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */ curr[name] = value;
        /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */ execute(curr);
    }
    return curr;
};
/*  execute all handlers  */ var execute = function execute(curr) {
    if (curr.state === STATE_FULFILLED) execute_handlers(curr, "onFulfilled", curr.fulfillValue);
    else if (curr.state === STATE_REJECTED) execute_handlers(curr, "onRejected", curr.rejectReason);
};
/*  execute particular set of handlers  */ var execute_handlers = function execute_handlers(curr, name, value) {
    /* global setImmediate: true */ /* global setTimeout: true */ /*  short-circuit processing  */ if (curr[name].length === 0) return;
    /*  iterate over all handlers, exactly once  */ var handlers = curr[name];
    curr[name] = [];
    /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */ var func = function func() {
        for(var i = 0; i < handlers.length; i++)handlers[i](value);
    /*  [Promises/A+ 2.2.5]  */ };
    /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */ if (typeof setImmediate === "function") setImmediate(func);
    else setTimeout(func, 0);
};
/*  generate a resolver function  */ var resolver = function resolver(cb, next, method) {
    return function(value) {
        if (typeof cb !== "function") /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */ next[method].call(next, value);
        else {
            var result;
            try {
                result = cb(value);
            } /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */ catch (e) {
                next.reject(e);
                /*  [Promises/A+ 2.2.7.2]  */ return;
            }
            resolve(next, result);
        /*  [Promises/A+ 2.2.7.1]  */ }
    };
};
/*  "Promise Resolution Procedure"  */ /*  [Promises/A+ 2.3]  */ var resolve = function resolve(promise, x) {
    /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */ if (promise === x || promise.proxy === x) {
        promise.reject(new TypeError("cannot resolve promise with itself"));
        return;
    }
    /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */ var then;
    if (_typeof(x) === "object" && x !== null || typeof x === "function") try {
        then = x.then;
    } /*  [Promises/A+ 2.3.3.1, 3.5]  */ catch (e) {
        promise.reject(e);
        /*  [Promises/A+ 2.3.3.2]  */ return;
    }
    /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */ if (typeof then === "function") {
        var resolved = false;
        try {
            /*  call retrieved "then" method */ /*  [Promises/A+ 2.3.3.3]  */ then.call(x, /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */ function(y) {
                if (resolved) return;
                resolved = true;
                /*  [Promises/A+ 2.3.3.3.3]  */ if (y === x) /*  [Promises/A+ 3.6]  */ promise.reject(new TypeError("circular thenable chain"));
                else resolve(promise, y);
            }, /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */ function(r) {
                if (resolved) return;
                resolved = true;
                /*  [Promises/A+ 2.3.3.3.3]  */ promise.reject(r);
            });
        } catch (e1) {
            if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */ promise.reject(e1);
        /*  [Promises/A+ 2.3.3.3.4]  */ }
        return;
    }
    /*  handle other values  */ promise.fulfill(x);
/*  [Promises/A+ 2.3.4, 2.3.3.4]  */ }; // so we always have Promise.all()
api.all = function(ps) {
    return new api(function(resolveAll, rejectAll) {
        var vals = new Array(ps.length);
        var doneCount = 0;
        var fulfill = function fulfill(i, val) {
            vals[i] = val;
            doneCount++;
            if (doneCount === ps.length) resolveAll(vals);
        };
        for(var i = 0; i < ps.length; i++)(function(i) {
            var p = ps[i];
            var isPromise = p != null && p.then != null;
            if (isPromise) p.then(function(val) {
                fulfill(i, val);
            }, function(err) {
                rejectAll(err);
            });
            else {
                var val = p;
                fulfill(i, val);
            }
        })(i);
    });
};
api.resolve = function(val) {
    return new api(function(resolve, reject) {
        resolve(val);
    });
};
api.reject = function(val) {
    return new api(function(resolve, reject) {
        reject(val);
    });
};
var Promise$1 = typeof Promise !== "undefined" ? Promise : api; // eslint-disable-line no-undef
var Animation = function Animation(target, opts, opts2) {
    var isCore = core(target);
    var isEle = !isCore;
    var _p = this._private = extend({
        duration: 1000
    }, opts, opts2);
    _p.target = target;
    _p.style = _p.style || _p.css;
    _p.started = false;
    _p.playing = false;
    _p.hooked = false;
    _p.applying = false;
    _p.progress = 0;
    _p.completes = [];
    _p.frames = [];
    if (_p.complete && fn$6(_p.complete)) _p.completes.push(_p.complete);
    if (isEle) {
        var pos = target.position();
        _p.startPosition = _p.startPosition || {
            x: pos.x,
            y: pos.y
        };
        _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);
    }
    if (isCore) {
        var pan = target.pan();
        _p.startPan = {
            x: pan.x,
            y: pan.y
        };
        _p.startZoom = target.zoom();
    } // for future timeline/animations impl
    this.length = 1;
    this[0] = this;
};
var anifn = Animation.prototype;
extend(anifn, {
    instanceString: function instanceString() {
        return "animation";
    },
    hook: function hook() {
        var _p = this._private;
        if (!_p.hooked) {
            // add to target's animation queue
            var q;
            var tAni = _p.target._private.animation;
            if (_p.queue) q = tAni.queue;
            else q = tAni.current;
            q.push(this); // add to the animation loop pool
            if (elementOrCollection(_p.target)) _p.target.cy().addToAnimationPool(_p.target);
            _p.hooked = true;
        }
        return this;
    },
    play: function play() {
        var _p = this._private; // autorewind
        if (_p.progress === 1) _p.progress = 0;
        _p.playing = true;
        _p.started = false; // needs to be started by animation loop
        _p.stopped = false;
        this.hook(); // the animation loop will start the animation...
        return this;
    },
    playing: function playing() {
        return this._private.playing;
    },
    apply: function apply() {
        var _p = this._private;
        _p.applying = true;
        _p.started = false; // needs to be started by animation loop
        _p.stopped = false;
        this.hook(); // the animation loop will apply the animation at this progress
        return this;
    },
    applying: function applying() {
        return this._private.applying;
    },
    pause: function pause() {
        var _p = this._private;
        _p.playing = false;
        _p.started = false;
        return this;
    },
    stop: function stop() {
        var _p = this._private;
        _p.playing = false;
        _p.started = false;
        _p.stopped = true; // to be removed from animation queues
        return this;
    },
    rewind: function rewind() {
        return this.progress(0);
    },
    fastforward: function fastforward() {
        return this.progress(1);
    },
    time: function time(t) {
        var _p = this._private;
        if (t === undefined) return _p.progress * _p.duration;
        else return this.progress(t / _p.duration);
    },
    progress: function progress(p) {
        var _p = this._private;
        var wasPlaying = _p.playing;
        if (p === undefined) return _p.progress;
        else {
            if (wasPlaying) this.pause();
            _p.progress = p;
            _p.started = false;
            if (wasPlaying) this.play();
        }
        return this;
    },
    completed: function completed() {
        return this._private.progress === 1;
    },
    reverse: function reverse() {
        var _p = this._private;
        var wasPlaying = _p.playing;
        if (wasPlaying) this.pause();
        _p.progress = 1 - _p.progress;
        _p.started = false;
        var swap = function swap(a, b) {
            var _pa = _p[a];
            if (_pa == null) return;
            _p[a] = _p[b];
            _p[b] = _pa;
        };
        swap("zoom", "startZoom");
        swap("pan", "startPan");
        swap("position", "startPosition"); // swap styles
        if (_p.style) for(var i = 0; i < _p.style.length; i++){
            var prop = _p.style[i];
            var name = prop.name;
            var startStyleProp = _p.startStyle[name];
            _p.startStyle[name] = prop;
            _p.style[i] = startStyleProp;
        }
        if (wasPlaying) this.play();
        return this;
    },
    promise: function promise(type) {
        var _p = this._private;
        var arr;
        switch(type){
            case "frame":
                arr = _p.frames;
                break;
            default:
            case "complete":
            case "completed":
                arr = _p.completes;
        }
        return new Promise$1(function(resolve, reject) {
            arr.push(function() {
                resolve();
            });
        });
    }
});
anifn.complete = anifn.completed;
anifn.run = anifn.play;
anifn.running = anifn.playing;
var define$3 = {
    animated: function animated() {
        return function animatedImpl() {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [
                self
            ]; // put in array if not array-like
            var cy = this._private.cy || this;
            if (!cy.styleEnabled()) return false;
            var ele = all[0];
            if (ele) return ele._private.animation.current.length > 0;
        };
    },
    // animated
    clearQueue: function clearQueue() {
        return function clearQueueImpl() {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [
                self
            ]; // put in array if not array-like
            var cy = this._private.cy || this;
            if (!cy.styleEnabled()) return this;
            for(var i = 0; i < all.length; i++){
                var ele = all[i];
                ele._private.animation.queue = [];
            }
            return this;
        };
    },
    // clearQueue
    delay: function delay() {
        return function delayImpl(time, complete) {
            var cy = this._private.cy || this;
            if (!cy.styleEnabled()) return this;
            return this.animate({
                delay: time,
                duration: time,
                complete: complete
            });
        };
    },
    // delay
    delayAnimation: function delayAnimation() {
        return function delayAnimationImpl(time, complete) {
            var cy = this._private.cy || this;
            if (!cy.styleEnabled()) return this;
            return this.animation({
                delay: time,
                duration: time,
                complete: complete
            });
        };
    },
    // delay
    animation: function animation() {
        return function animationImpl(properties, params) {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [
                self
            ]; // put in array if not array-like
            var cy = this._private.cy || this;
            var isCore = !selfIsArrayLike;
            var isEles = !isCore;
            if (!cy.styleEnabled()) return this;
            var style = cy.style();
            properties = extend({}, properties, params);
            var propertiesEmpty = Object.keys(properties).length === 0;
            if (propertiesEmpty) return new Animation(all[0], properties); // nothing to animate
            if (properties.duration === undefined) properties.duration = 400;
            switch(properties.duration){
                case "slow":
                    properties.duration = 600;
                    break;
                case "fast":
                    properties.duration = 200;
                    break;
            }
            if (isEles) {
                properties.style = style.getPropsList(properties.style || properties.css);
                properties.css = undefined;
            }
            if (isEles && properties.renderedPosition != null) {
                var rpos = properties.renderedPosition;
                var pan = cy.pan();
                var zoom = cy.zoom();
                properties.position = renderedToModelPosition(rpos, zoom, pan);
            } // override pan w/ panBy if set
            if (isCore && properties.panBy != null) {
                var panBy = properties.panBy;
                var cyPan = cy.pan();
                properties.pan = {
                    x: cyPan.x + panBy.x,
                    y: cyPan.y + panBy.y
                };
            } // override pan w/ center if set
            var center = properties.center || properties.centre;
            if (isCore && center != null) {
                var centerPan = cy.getCenterPan(center.eles, properties.zoom);
                if (centerPan != null) properties.pan = centerPan;
            } // override pan & zoom w/ fit if set
            if (isCore && properties.fit != null) {
                var fit = properties.fit;
                var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);
                if (fitVp != null) {
                    properties.pan = fitVp.pan;
                    properties.zoom = fitVp.zoom;
                }
            } // override zoom (& potentially pan) w/ zoom obj if set
            if (isCore && plainObject(properties.zoom)) {
                var vp = cy.getZoomedViewport(properties.zoom);
                if (vp != null) {
                    if (vp.zoomed) properties.zoom = vp.zoom;
                    if (vp.panned) properties.pan = vp.pan;
                } else properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed
            }
            return new Animation(all[0], properties);
        };
    },
    // animate
    animate: function animate() {
        return function animateImpl(properties, params) {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [
                self
            ]; // put in array if not array-like
            var cy = this._private.cy || this;
            if (!cy.styleEnabled()) return this;
            if (params) properties = extend({}, properties, params);
             // manually hook and run the animation
            for(var i = 0; i < all.length; i++){
                var ele = all[i];
                var queue = ele.animated() && (properties.queue === undefined || properties.queue);
                var ani = ele.animation(properties, queue ? {
                    queue: true
                } : undefined);
                ani.play();
            }
            return this; // chaining
        };
    },
    // animate
    stop: function stop() {
        return function stopImpl(clearQueue, jumpToEnd) {
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [
                self
            ]; // put in array if not array-like
            var cy = this._private.cy || this;
            if (!cy.styleEnabled()) return this;
            for(var i = 0; i < all.length; i++){
                var ele = all[i];
                var _p = ele._private;
                var anis = _p.animation.current;
                for(var j = 0; j < anis.length; j++){
                    var ani = anis[j];
                    var ani_p = ani._private;
                    if (jumpToEnd) // next iteration of the animation loop, the animation
                    // will go straight to the end and be removed
                    ani_p.duration = 0;
                } // clear the queue of future animations
                if (clearQueue) _p.animation.queue = [];
                if (!jumpToEnd) _p.animation.current = [];
            } // we have to notify (the animation loop doesn't do it for us on `stop`)
            cy.notify("draw");
            return this;
        };
    } // stop
}; // define
var define$2 = {
    // access data field
    data: function data(params) {
        var defaults = {
            field: "data",
            bindingEvent: "data",
            allowBinding: false,
            allowSetting: false,
            allowGetting: false,
            settingEvent: "data",
            settingTriggersEvent: false,
            triggerFnName: "trigger",
            immutableKeys: {},
            // key => true if immutable
            updateStyle: false,
            beforeGet: function beforeGet(self) {},
            beforeSet: function beforeSet(self, obj) {},
            onSet: function onSet(self) {},
            canSet: function canSet(self) {
                return true;
            }
        };
        params = extend({}, defaults, params);
        return function dataImpl(name, value) {
            var p = params;
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [
                self
            ]; // put in array if not array-like
            var single = selfIsArrayLike ? self[0] : self; // .data('foo', ...)
            if (string(name)) {
                // set or get property
                var isPathLike = name.indexOf(".") !== -1; // there might be a normal field with a dot 
                var path = isPathLike && toPath__default["default"](name); // .data('foo')
                if (p.allowGetting && value === undefined) {
                    // get
                    var ret;
                    if (single) {
                        p.beforeGet(single); // check if it's path and a field with the same name doesn't exist
                        if (path && single._private[p.field][name] === undefined) ret = get__default["default"](single._private[p.field], path);
                        else ret = single._private[p.field][name];
                    }
                    return ret; // .data('foo', 'bar')
                } else if (p.allowSetting && value !== undefined) {
                    // set
                    var valid = !p.immutableKeys[name];
                    if (valid) {
                        var change = _defineProperty({}, name, value);
                        p.beforeSet(self, change);
                        for(var i = 0, l = all.length; i < l; i++){
                            var ele = all[i];
                            if (p.canSet(ele)) {
                                if (path && single._private[p.field][name] === undefined) set__default["default"](ele._private[p.field], path, value);
                                else ele._private[p.field][name] = value;
                            }
                        } // update mappers if asked
                        if (p.updateStyle) self.updateStyle();
                         // call onSet callback
                        p.onSet(self);
                        if (p.settingTriggersEvent) self[p.triggerFnName](p.settingEvent);
                    }
                } // .data({ 'foo': 'bar' })
            } else if (p.allowSetting && plainObject(name)) {
                // extend
                var obj = name;
                var k, v;
                var keys = Object.keys(obj);
                p.beforeSet(self, obj);
                for(var _i = 0; _i < keys.length; _i++){
                    k = keys[_i];
                    v = obj[k];
                    var _valid = !p.immutableKeys[k];
                    if (_valid) for(var j = 0; j < all.length; j++){
                        var _ele = all[j];
                        if (p.canSet(_ele)) _ele._private[p.field][k] = v;
                    }
                } // update mappers if asked
                if (p.updateStyle) self.updateStyle();
                 // call onSet callback
                p.onSet(self);
                if (p.settingTriggersEvent) self[p.triggerFnName](p.settingEvent);
                 // .data(function(){ ... })
            } else if (p.allowBinding && fn$6(name)) {
                // bind to event
                var fn = name;
                self.on(p.bindingEvent, fn); // .data()
            } else if (p.allowGetting && name === undefined) {
                // get whole object
                var _ret;
                if (single) {
                    p.beforeGet(single);
                    _ret = single._private[p.field];
                }
                return _ret;
            }
            return self; // maintain chainability
        }; // function
    },
    // data
    // remove data field
    removeData: function removeData(params) {
        var defaults = {
            field: "data",
            event: "data",
            triggerFnName: "trigger",
            triggerEvent: false,
            immutableKeys: {} // key => true if immutable
        };
        params = extend({}, defaults, params);
        return function removeDataImpl(names) {
            var p = params;
            var self = this;
            var selfIsArrayLike = self.length !== undefined;
            var all = selfIsArrayLike ? self : [
                self
            ]; // put in array if not array-like
            // .removeData('foo bar')
            if (string(names)) {
                // then get the list of keys, and delete them
                var keys = names.split(/\s+/);
                var l = keys.length;
                for(var i = 0; i < l; i++){
                    // delete each non-empty key
                    var key = keys[i];
                    if (emptyString(key)) continue;
                    var valid = !p.immutableKeys[key]; // not valid if immutable
                    if (valid) for(var i_a = 0, l_a = all.length; i_a < l_a; i_a++)all[i_a]._private[p.field][key] = undefined;
                }
                if (p.triggerEvent) self[p.triggerFnName](p.event);
                 // .removeData()
            } else if (names === undefined) {
                // then delete all keys
                for(var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++){
                    var _privateFields = all[_i_a]._private[p.field];
                    var _keys = Object.keys(_privateFields);
                    for(var _i2 = 0; _i2 < _keys.length; _i2++){
                        var _key = _keys[_i2];
                        var validKeyToDelete = !p.immutableKeys[_key];
                        if (validKeyToDelete) _privateFields[_key] = undefined;
                    }
                }
                if (p.triggerEvent) self[p.triggerFnName](p.event);
            }
            return self; // maintain chaining
        }; // function
    } // removeData
}; // define
var define$1 = {
    eventAliasesOn: function eventAliasesOn(proto) {
        var p = proto;
        p.addListener = p.listen = p.bind = p.on;
        p.unlisten = p.unbind = p.off = p.removeListener;
        p.trigger = p.emit; // this is just a wrapper alias of .on()
        p.pon = p.promiseOn = function(events, selector) {
            var self = this;
            var args = Array.prototype.slice.call(arguments, 0);
            return new Promise$1(function(resolve, reject) {
                var callback = function callback(e) {
                    self.off.apply(self, offArgs);
                    resolve(e);
                };
                var onArgs = args.concat([
                    callback
                ]);
                var offArgs = onArgs.concat([]);
                self.on.apply(self, onArgs);
            });
        };
    }
}; // define
// use this module to cherry pick functions into your prototype
var define = {};
[
    define$3,
    define$2,
    define$1
].forEach(function(m1) {
    extend(define, m1);
});
var elesfn$i = {
    animate: define.animate(),
    animation: define.animation(),
    animated: define.animated(),
    clearQueue: define.clearQueue(),
    delay: define.delay(),
    delayAnimation: define.delayAnimation(),
    stop: define.stop()
};
var elesfn$h = {
    classes: function classes(_classes) {
        var self = this;
        if (_classes === undefined) {
            var ret = [];
            self[0]._private.classes.forEach(function(cls) {
                return ret.push(cls);
            });
            return ret;
        } else if (!array(_classes)) // extract classes from string
        _classes = (_classes || "").match(/\S+/g) || [];
        var changed = [];
        var classesSet = new Set$1(_classes); // check and update each ele
        for(var j = 0; j < self.length; j++){
            var ele = self[j];
            var _p = ele._private;
            var eleClasses = _p.classes;
            var changedEle = false; // check if ele has all of the passed classes
            for(var i = 0; i < _classes.length; i++){
                var cls = _classes[i];
                var eleHasClass = eleClasses.has(cls);
                if (!eleHasClass) {
                    changedEle = true;
                    break;
                }
            } // check if ele has classes outside of those passed
            if (!changedEle) changedEle = eleClasses.size !== _classes.length;
            if (changedEle) {
                _p.classes = classesSet;
                changed.push(ele);
            }
        } // trigger update style on those eles that had class changes
        if (changed.length > 0) this.spawn(changed).updateStyle().emit("class");
        return self;
    },
    addClass: function addClass(classes) {
        return this.toggleClass(classes, true);
    },
    hasClass: function hasClass(className) {
        var ele = this[0];
        return ele != null && ele._private.classes.has(className);
    },
    toggleClass: function toggleClass(classes, toggle) {
        if (!array(classes)) // extract classes from string
        classes = classes.match(/\S+/g) || [];
        var self = this;
        var toggleUndefd = toggle === undefined;
        var changed = []; // eles who had classes changed
        for(var i = 0, il = self.length; i < il; i++){
            var ele = self[i];
            var eleClasses = ele._private.classes;
            var changedEle = false;
            for(var j = 0; j < classes.length; j++){
                var cls = classes[j];
                var hasClass = eleClasses.has(cls);
                var changedNow = false;
                if (toggle || toggleUndefd && !hasClass) {
                    eleClasses.add(cls);
                    changedNow = true;
                } else if (!toggle || toggleUndefd && hasClass) {
                    eleClasses["delete"](cls);
                    changedNow = true;
                }
                if (!changedEle && changedNow) {
                    changed.push(ele);
                    changedEle = true;
                }
            } // for j classes
        } // for i eles
        // trigger update style on those eles that had class changes
        if (changed.length > 0) this.spawn(changed).updateStyle().emit("class");
        return self;
    },
    removeClass: function removeClass(classes) {
        return this.toggleClass(classes, false);
    },
    flashClass: function flashClass(classes, duration) {
        var self = this;
        if (duration == null) duration = 250;
        else if (duration === 0) return self; // nothing to do really
        self.addClass(classes);
        setTimeout(function() {
            self.removeClass(classes);
        }, duration);
        return self;
    }
};
elesfn$h.className = elesfn$h.classNames = elesfn$h.classes;
var tokens = {
    metaChar: "[\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]",
    // chars we need to escape in let names, etc
    comparatorOp: "=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=",
    // binary comparison op (used in data selectors)
    boolOp: "\\?|\\!|\\^",
    // boolean (unary) operators (used in data selectors)
    string: "\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'",
    // string literals (used in data selectors) -- doublequotes | singlequotes
    number: number,
    // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
    meta: "degree|indegree|outdegree",
    // allowed metadata fields (i.e. allowed functions to use from Collection)
    separator: "\\s*,\\s*",
    // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
    descendant: "\\s+",
    child: "\\s+>\\s+",
    subject: "\\$",
    group: "node|edge|\\*",
    directedEdge: "\\s+->\\s+",
    undirectedEdge: "\\s+<->\\s+"
};
tokens.variable = "(?:[\\w-.]|(?:\\\\" + tokens.metaChar + "))+"; // a variable name can have letters, numbers, dashes, and periods
tokens.className = "(?:[\\w-]|(?:\\\\" + tokens.metaChar + "))+"; // a class name has the same rules as a variable except it can't have a '.' in the name
tokens.value = tokens.string + "|" + tokens.number; // a value literal, either a string or number
tokens.id = tokens.variable; // an element id (follows variable conventions)
(function() {
    var ops, op, i; // add @ variants to comparatorOp
    ops = tokens.comparatorOp.split("|");
    for(i = 0; i < ops.length; i++){
        op = ops[i];
        tokens.comparatorOp += "|@" + op;
    } // add ! variants to comparatorOp
    ops = tokens.comparatorOp.split("|");
    for(i = 0; i < ops.length; i++){
        op = ops[i];
        if (op.indexOf("!") >= 0) continue;
         // skip ops that explicitly contain !
        if (op === "=") continue;
         // skip = b/c != is explicitly defined
        tokens.comparatorOp += "|\\!" + op;
    }
})();
/**
 * Make a new query object
 *
 * @prop type {Type} The type enum (int) of the query
 * @prop checks List of checks to make against an ele to test for a match
 */ var newQuery = function newQuery() {
    return {
        checks: []
    };
};
/**
 * A check type enum-like object.  Uses integer values for fast match() lookup.
 * The ordering does not matter as long as the ints are unique.
 */ var Type = {
    /** E.g. node */ GROUP: 0,
    /** A collection of elements */ COLLECTION: 1,
    /** A filter(ele) function */ FILTER: 2,
    /** E.g. [foo > 1] */ DATA_COMPARE: 3,
    /** E.g. [foo] */ DATA_EXIST: 4,
    /** E.g. [?foo] */ DATA_BOOL: 5,
    /** E.g. [[degree > 2]] */ META_COMPARE: 6,
    /** E.g. :selected */ STATE: 7,
    /** E.g. #foo */ ID: 8,
    /** E.g. .foo */ CLASS: 9,
    /** E.g. #foo <-> #bar */ UNDIRECTED_EDGE: 10,
    /** E.g. #foo -> #bar */ DIRECTED_EDGE: 11,
    /** E.g. $#foo -> #bar */ NODE_SOURCE: 12,
    /** E.g. #foo -> $#bar */ NODE_TARGET: 13,
    /** E.g. $#foo <-> #bar */ NODE_NEIGHBOR: 14,
    /** E.g. #foo > #bar */ CHILD: 15,
    /** E.g. #foo #bar */ DESCENDANT: 16,
    /** E.g. $#foo > #bar */ PARENT: 17,
    /** E.g. $#foo #bar */ ANCESTOR: 18,
    /** E.g. #foo > $bar > #baz */ COMPOUND_SPLIT: 19,
    /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */ TRUE: 20
};
var stateSelectors = [
    {
        selector: ":selected",
        matches: function matches(ele) {
            return ele.selected();
        }
    },
    {
        selector: ":unselected",
        matches: function matches(ele) {
            return !ele.selected();
        }
    },
    {
        selector: ":selectable",
        matches: function matches(ele) {
            return ele.selectable();
        }
    },
    {
        selector: ":unselectable",
        matches: function matches(ele) {
            return !ele.selectable();
        }
    },
    {
        selector: ":locked",
        matches: function matches(ele) {
            return ele.locked();
        }
    },
    {
        selector: ":unlocked",
        matches: function matches(ele) {
            return !ele.locked();
        }
    },
    {
        selector: ":visible",
        matches: function matches(ele) {
            return ele.visible();
        }
    },
    {
        selector: ":hidden",
        matches: function matches(ele) {
            return !ele.visible();
        }
    },
    {
        selector: ":transparent",
        matches: function matches(ele) {
            return ele.transparent();
        }
    },
    {
        selector: ":grabbed",
        matches: function matches(ele) {
            return ele.grabbed();
        }
    },
    {
        selector: ":free",
        matches: function matches(ele) {
            return !ele.grabbed();
        }
    },
    {
        selector: ":removed",
        matches: function matches(ele) {
            return ele.removed();
        }
    },
    {
        selector: ":inside",
        matches: function matches(ele) {
            return !ele.removed();
        }
    },
    {
        selector: ":grabbable",
        matches: function matches(ele) {
            return ele.grabbable();
        }
    },
    {
        selector: ":ungrabbable",
        matches: function matches(ele) {
            return !ele.grabbable();
        }
    },
    {
        selector: ":animated",
        matches: function matches(ele) {
            return ele.animated();
        }
    },
    {
        selector: ":unanimated",
        matches: function matches(ele) {
            return !ele.animated();
        }
    },
    {
        selector: ":parent",
        matches: function matches(ele) {
            return ele.isParent();
        }
    },
    {
        selector: ":childless",
        matches: function matches(ele) {
            return ele.isChildless();
        }
    },
    {
        selector: ":child",
        matches: function matches(ele) {
            return ele.isChild();
        }
    },
    {
        selector: ":orphan",
        matches: function matches(ele) {
            return ele.isOrphan();
        }
    },
    {
        selector: ":nonorphan",
        matches: function matches(ele) {
            return ele.isChild();
        }
    },
    {
        selector: ":compound",
        matches: function matches(ele) {
            if (ele.isNode()) return ele.isParent();
            else return ele.source().isParent() || ele.target().isParent();
        }
    },
    {
        selector: ":loop",
        matches: function matches(ele) {
            return ele.isLoop();
        }
    },
    {
        selector: ":simple",
        matches: function matches(ele) {
            return ele.isSimple();
        }
    },
    {
        selector: ":active",
        matches: function matches(ele) {
            return ele.active();
        }
    },
    {
        selector: ":inactive",
        matches: function matches(ele) {
            return !ele.active();
        }
    },
    {
        selector: ":backgrounding",
        matches: function matches(ele) {
            return ele.backgrounding();
        }
    },
    {
        selector: ":nonbackgrounding",
        matches: function matches(ele) {
            return !ele.backgrounding();
        }
    }
].sort(function(a, b) {
    // n.b. selectors that are starting substrings of others must have the longer ones first
    return descending(a.selector, b.selector);
});
var lookup = function() {
    var selToFn = {};
    var s;
    for(var i = 0; i < stateSelectors.length; i++){
        s = stateSelectors[i];
        selToFn[s.selector] = s.matches;
    }
    return selToFn;
}();
var stateSelectorMatches = function stateSelectorMatches(sel, ele) {
    return lookup[sel](ele);
};
var stateSelectorRegex = "(" + stateSelectors.map(function(s) {
    return s.selector;
}).join("|") + ")";
// so that values get compared properly in Selector.filter()
var cleanMetaChars = function cleanMetaChars(str) {
    return str.replace(new RegExp("\\\\(" + tokens.metaChar + ")", "g"), function(match, $1) {
        return $1;
    });
};
var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {
    selector[selector.length - 1] = replacementQuery;
}; // NOTE: add new expression syntax here to have it recognised by the parser;
// - a query contains all adjacent (i.e. no separator in between) expressions;
// - the current query is stored in selector[i]
// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward
var exprs = [
    {
        name: "group",
        // just used for identifying when debugging
        query: true,
        regex: "(" + tokens.group + ")",
        populate: function populate(selector, query, _ref) {
            var _ref2 = _slicedToArray(_ref, 1), group = _ref2[0];
            query.checks.push({
                type: Type.GROUP,
                value: group === "*" ? group : group + "s"
            });
        }
    },
    {
        name: "state",
        query: true,
        regex: stateSelectorRegex,
        populate: function populate(selector, query, _ref3) {
            var _ref4 = _slicedToArray(_ref3, 1), state = _ref4[0];
            query.checks.push({
                type: Type.STATE,
                value: state
            });
        }
    },
    {
        name: "id",
        query: true,
        regex: "\\#(" + tokens.id + ")",
        populate: function populate(selector, query, _ref5) {
            var _ref6 = _slicedToArray(_ref5, 1), id = _ref6[0];
            query.checks.push({
                type: Type.ID,
                value: cleanMetaChars(id)
            });
        }
    },
    {
        name: "className",
        query: true,
        regex: "\\.(" + tokens.className + ")",
        populate: function populate(selector, query, _ref7) {
            var _ref8 = _slicedToArray(_ref7, 1), className = _ref8[0];
            query.checks.push({
                type: Type.CLASS,
                value: cleanMetaChars(className)
            });
        }
    },
    {
        name: "dataExists",
        query: true,
        regex: "\\[\\s*(" + tokens.variable + ")\\s*\\]",
        populate: function populate(selector, query, _ref9) {
            var _ref10 = _slicedToArray(_ref9, 1), variable = _ref10[0];
            query.checks.push({
                type: Type.DATA_EXIST,
                field: cleanMetaChars(variable)
            });
        }
    },
    {
        name: "dataCompare",
        query: true,
        regex: "\\[\\s*(" + tokens.variable + ")\\s*(" + tokens.comparatorOp + ")\\s*(" + tokens.value + ")\\s*\\]",
        populate: function populate(selector, query, _ref11) {
            var _ref12 = _slicedToArray(_ref11, 3), variable = _ref12[0], comparatorOp = _ref12[1], value = _ref12[2];
            var valueIsString = new RegExp("^" + tokens.string + "$").exec(value) != null;
            if (valueIsString) value = value.substring(1, value.length - 1);
            else value = parseFloat(value);
            query.checks.push({
                type: Type.DATA_COMPARE,
                field: cleanMetaChars(variable),
                operator: comparatorOp,
                value: value
            });
        }
    },
    {
        name: "dataBool",
        query: true,
        regex: "\\[\\s*(" + tokens.boolOp + ")\\s*(" + tokens.variable + ")\\s*\\]",
        populate: function populate(selector, query, _ref13) {
            var _ref14 = _slicedToArray(_ref13, 2), boolOp = _ref14[0], variable = _ref14[1];
            query.checks.push({
                type: Type.DATA_BOOL,
                field: cleanMetaChars(variable),
                operator: boolOp
            });
        }
    },
    {
        name: "metaCompare",
        query: true,
        regex: "\\[\\[\\s*(" + tokens.meta + ")\\s*(" + tokens.comparatorOp + ")\\s*(" + tokens.number + ")\\s*\\]\\]",
        populate: function populate(selector, query, _ref15) {
            var _ref16 = _slicedToArray(_ref15, 3), meta = _ref16[0], comparatorOp = _ref16[1], number = _ref16[2];
            query.checks.push({
                type: Type.META_COMPARE,
                field: cleanMetaChars(meta),
                operator: comparatorOp,
                value: parseFloat(number)
            });
        }
    },
    {
        name: "nextQuery",
        separator: true,
        regex: tokens.separator,
        populate: function populate(selector, query) {
            var currentSubject = selector.currentSubject;
            var edgeCount = selector.edgeCount;
            var compoundCount = selector.compoundCount;
            var lastQ = selector[selector.length - 1];
            if (currentSubject != null) {
                lastQ.subject = currentSubject;
                selector.currentSubject = null;
            }
            lastQ.edgeCount = edgeCount;
            lastQ.compoundCount = compoundCount;
            selector.edgeCount = 0;
            selector.compoundCount = 0; // go on to next query
            var nextQuery = selector[selector.length++] = newQuery();
            return nextQuery; // this is the new query to be filled by the following exprs
        }
    },
    {
        name: "directedEdge",
        separator: true,
        regex: tokens.directedEdge,
        populate: function populate(selector, query) {
            if (selector.currentSubject == null) {
                // undirected edge
                var edgeQuery = newQuery();
                var source = query;
                var target = newQuery();
                edgeQuery.checks.push({
                    type: Type.DIRECTED_EDGE,
                    source: source,
                    target: target
                }); // the query in the selector should be the edge rather than the source
                replaceLastQuery(selector, query, edgeQuery);
                selector.edgeCount++; // we're now populating the target query with expressions that follow
                return target;
            } else {
                // source/target
                var srcTgtQ = newQuery();
                var _source = query;
                var _target = newQuery();
                srcTgtQ.checks.push({
                    type: Type.NODE_SOURCE,
                    source: _source,
                    target: _target
                }); // the query in the selector should be the neighbourhood rather than the node
                replaceLastQuery(selector, query, srcTgtQ);
                selector.edgeCount++;
                return _target; // now populating the target with the following expressions
            }
        }
    },
    {
        name: "undirectedEdge",
        separator: true,
        regex: tokens.undirectedEdge,
        populate: function populate(selector, query) {
            if (selector.currentSubject == null) {
                // undirected edge
                var edgeQuery = newQuery();
                var source = query;
                var target = newQuery();
                edgeQuery.checks.push({
                    type: Type.UNDIRECTED_EDGE,
                    nodes: [
                        source,
                        target
                    ]
                }); // the query in the selector should be the edge rather than the source
                replaceLastQuery(selector, query, edgeQuery);
                selector.edgeCount++; // we're now populating the target query with expressions that follow
                return target;
            } else {
                // neighbourhood
                var nhoodQ = newQuery();
                var node = query;
                var neighbor = newQuery();
                nhoodQ.checks.push({
                    type: Type.NODE_NEIGHBOR,
                    node: node,
                    neighbor: neighbor
                }); // the query in the selector should be the neighbourhood rather than the node
                replaceLastQuery(selector, query, nhoodQ);
                return neighbor; // now populating the neighbor with following expressions
            }
        }
    },
    {
        name: "child",
        separator: true,
        regex: tokens.child,
        populate: function populate(selector, query) {
            if (selector.currentSubject == null) {
                // default: child query
                var parentChildQuery = newQuery();
                var child = newQuery();
                var parent = selector[selector.length - 1];
                parentChildQuery.checks.push({
                    type: Type.CHILD,
                    parent: parent,
                    child: child
                }); // the query in the selector should be the '>' itself
                replaceLastQuery(selector, query, parentChildQuery);
                selector.compoundCount++; // we're now populating the child query with expressions that follow
                return child;
            } else if (selector.currentSubject === query) {
                // compound split query
                var compound = newQuery();
                var left = selector[selector.length - 1];
                var right = newQuery();
                var subject = newQuery();
                var _child = newQuery();
                var _parent = newQuery(); // set up the root compound q
                compound.checks.push({
                    type: Type.COMPOUND_SPLIT,
                    left: left,
                    right: right,
                    subject: subject
                }); // populate the subject and replace the q at the old spot (within left) with TRUE
                subject.checks = query.checks; // take the checks from the left
                query.checks = [
                    {
                        type: Type.TRUE
                    }
                ]; // checks under left refs the subject implicitly
                // set up the right q
                _parent.checks.push({
                    type: Type.TRUE
                }); // parent implicitly refs the subject
                right.checks.push({
                    type: Type.PARENT,
                    // type is swapped on right side queries
                    parent: _parent,
                    child: _child // empty for now
                });
                replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`
                selector.currentSubject = subject;
                selector.compoundCount++;
                return _child; // now populating the right side's child
            } else {
                // parent query
                // info for parent query
                var _parent2 = newQuery();
                var _child2 = newQuery();
                var pcQChecks = [
                    {
                        type: Type.PARENT,
                        parent: _parent2,
                        child: _child2
                    }
                ]; // the parent-child query takes the place of the query previously being populated
                _parent2.checks = query.checks; // the previous query contains the checks for the parent
                query.checks = pcQChecks; // pc query takes over
                selector.compoundCount++;
                return _child2; // we're now populating the child
            }
        }
    },
    {
        name: "descendant",
        separator: true,
        regex: tokens.descendant,
        populate: function populate(selector, query) {
            if (selector.currentSubject == null) {
                // default: descendant query
                var ancChQuery = newQuery();
                var descendant = newQuery();
                var ancestor = selector[selector.length - 1];
                ancChQuery.checks.push({
                    type: Type.DESCENDANT,
                    ancestor: ancestor,
                    descendant: descendant
                }); // the query in the selector should be the '>' itself
                replaceLastQuery(selector, query, ancChQuery);
                selector.compoundCount++; // we're now populating the descendant query with expressions that follow
                return descendant;
            } else if (selector.currentSubject === query) {
                // compound split query
                var compound = newQuery();
                var left = selector[selector.length - 1];
                var right = newQuery();
                var subject = newQuery();
                var _descendant = newQuery();
                var _ancestor = newQuery(); // set up the root compound q
                compound.checks.push({
                    type: Type.COMPOUND_SPLIT,
                    left: left,
                    right: right,
                    subject: subject
                }); // populate the subject and replace the q at the old spot (within left) with TRUE
                subject.checks = query.checks; // take the checks from the left
                query.checks = [
                    {
                        type: Type.TRUE
                    }
                ]; // checks under left refs the subject implicitly
                // set up the right q
                _ancestor.checks.push({
                    type: Type.TRUE
                }); // ancestor implicitly refs the subject
                right.checks.push({
                    type: Type.ANCESTOR,
                    // type is swapped on right side queries
                    ancestor: _ancestor,
                    descendant: _descendant // empty for now
                });
                replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`
                selector.currentSubject = subject;
                selector.compoundCount++;
                return _descendant; // now populating the right side's descendant
            } else {
                // ancestor query
                // info for parent query
                var _ancestor2 = newQuery();
                var _descendant2 = newQuery();
                var adQChecks = [
                    {
                        type: Type.ANCESTOR,
                        ancestor: _ancestor2,
                        descendant: _descendant2
                    }
                ]; // the parent-child query takes the place of the query previously being populated
                _ancestor2.checks = query.checks; // the previous query contains the checks for the parent
                query.checks = adQChecks; // pc query takes over
                selector.compoundCount++;
                return _descendant2; // we're now populating the child
            }
        }
    },
    {
        name: "subject",
        modifier: true,
        regex: tokens.subject,
        populate: function populate(selector, query) {
            if (selector.currentSubject != null && selector.currentSubject !== query) {
                warn("Redefinition of subject in selector `" + selector.toString() + "`");
                return false;
            }
            selector.currentSubject = query;
            var topQ = selector[selector.length - 1];
            var topChk = topQ.checks[0];
            var topType = topChk == null ? null : topChk.type;
            if (topType === Type.DIRECTED_EDGE) // directed edge with subject on the target
            // change to target node check
            topChk.type = Type.NODE_TARGET;
            else if (topType === Type.UNDIRECTED_EDGE) {
                // undirected edge with subject on the second node
                // change to neighbor check
                topChk.type = Type.NODE_NEIGHBOR;
                topChk.node = topChk.nodes[1]; // second node is subject
                topChk.neighbor = topChk.nodes[0]; // clean up unused fields for new type
                topChk.nodes = null;
            }
        }
    }
];
exprs.forEach(function(e) {
    return e.regexObj = new RegExp("^" + e.regex);
});
/**
 * Of all the expressions, find the first match in the remaining text.
 * @param {string} remaining The remaining text to parse
 * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`
 */ var consumeExpr = function consumeExpr(remaining) {
    var expr;
    var match;
    var name;
    for(var j = 0; j < exprs.length; j++){
        var e = exprs[j];
        var n = e.name;
        var m1 = remaining.match(e.regexObj);
        if (m1 != null) {
            match = m1;
            expr = e;
            name = n;
            var consumed = m1[0];
            remaining = remaining.substring(consumed.length);
            break; // we've consumed one expr, so we can return now
        }
    }
    return {
        expr: expr,
        match: match,
        name: name,
        remaining: remaining
    };
};
/**
 * Consume all the leading whitespace
 * @param {string} remaining The text to consume
 * @returns The text with the leading whitespace removed
 */ var consumeWhitespace = function consumeWhitespace(remaining) {
    var match = remaining.match(/^\s+/);
    if (match) {
        var consumed = match[0];
        remaining = remaining.substring(consumed.length);
    }
    return remaining;
};
/**
 * Parse the string and store the parsed representation in the Selector.
 * @param {string} selector The selector string
 * @returns `true` if the selector was successfully parsed, `false` otherwise
 */ var parse = function parse(selector) {
    var self = this;
    var remaining = self.inputText = selector;
    var currentQuery = self[0] = newQuery();
    self.length = 1;
    remaining = consumeWhitespace(remaining); // get rid of leading whitespace
    for(;;){
        var exprInfo = consumeExpr(remaining);
        if (exprInfo.expr == null) {
            warn("The selector `" + selector + "`is invalid");
            return false;
        } else {
            var args = exprInfo.match.slice(1); // let the token populate the selector object in currentQuery
            var ret = exprInfo.expr.populate(self, currentQuery, args);
            if (ret === false) return false; // exit if population failed
            else if (ret != null) currentQuery = ret; // change the current query to be filled if the expr specifies
        }
        remaining = exprInfo.remaining; // we're done when there's nothing left to parse
        if (remaining.match(/^\s*$/)) break;
    }
    var lastQ = self[self.length - 1];
    if (self.currentSubject != null) lastQ.subject = self.currentSubject;
    lastQ.edgeCount = self.edgeCount;
    lastQ.compoundCount = self.compoundCount;
    for(var i = 0; i < self.length; i++){
        var q = self[i]; // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations
        if (q.compoundCount > 0 && q.edgeCount > 0) {
            warn("The selector `" + selector + "` is invalid because it uses both a compound selector and an edge selector");
            return false;
        }
        if (q.edgeCount > 1) {
            warn("The selector `" + selector + "` is invalid because it uses multiple edge selectors");
            return false;
        } else if (q.edgeCount === 1) warn("The selector `" + selector + "` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.");
    }
    return true; // success
};
/**
 * Get the selector represented as a string.  This value uses default formatting,
 * so things like spacing may differ from the input text passed to the constructor.
 * @returns {string} The selector string
 */ var toString = function toString() {
    if (this.toStringCache != null) return this.toStringCache;
    var clean = function clean(obj) {
        if (obj == null) return "";
        else return obj;
    };
    var cleanVal = function cleanVal(val) {
        if (string(val)) return '"' + val + '"';
        else return clean(val);
    };
    var space = function space(val) {
        return " " + val + " ";
    };
    var checkToString = function checkToString(check, subject) {
        var type = check.type, value = check.value;
        switch(type){
            case Type.GROUP:
                var group = clean(value);
                return group.substring(0, group.length - 1);
            case Type.DATA_COMPARE:
                var field = check.field, operator = check.operator;
                return "[" + field + space(clean(operator)) + cleanVal(value) + "]";
            case Type.DATA_BOOL:
                var _operator = check.operator, _field = check.field;
                return "[" + clean(_operator) + _field + "]";
            case Type.DATA_EXIST:
                var _field2 = check.field;
                return "[" + _field2 + "]";
            case Type.META_COMPARE:
                var _operator2 = check.operator, _field3 = check.field;
                return "[[" + _field3 + space(clean(_operator2)) + cleanVal(value) + "]]";
            case Type.STATE:
                return value;
            case Type.ID:
                return "#" + value;
            case Type.CLASS:
                return "." + value;
            case Type.PARENT:
            case Type.CHILD:
                return queryToString(check.parent, subject) + space(">") + queryToString(check.child, subject);
            case Type.ANCESTOR:
            case Type.DESCENDANT:
                return queryToString(check.ancestor, subject) + " " + queryToString(check.descendant, subject);
            case Type.COMPOUND_SPLIT:
                var lhs = queryToString(check.left, subject);
                var sub = queryToString(check.subject, subject);
                var rhs = queryToString(check.right, subject);
                return lhs + (lhs.length > 0 ? " " : "") + sub + rhs;
            case Type.TRUE:
                return "";
        }
    };
    var queryToString = function queryToString(query, subject) {
        return query.checks.reduce(function(str, chk, i) {
            return str + (subject === query && i === 0 ? "$" : "") + checkToString(chk, subject);
        }, "");
    };
    var str = "";
    for(var i = 0; i < this.length; i++){
        var query = this[i];
        str += queryToString(query, query.subject);
        if (this.length > 1 && i < this.length - 1) str += ", ";
    }
    this.toStringCache = str;
    return str;
};
var parse$1 = {
    parse: parse,
    toString: toString
};
var valCmp = function valCmp(fieldVal, operator, value) {
    var matches;
    var isFieldStr = string(fieldVal);
    var isFieldNum = number$1(fieldVal);
    var isValStr = string(value);
    var fieldStr, valStr;
    var caseInsensitive = false;
    var notExpr = false;
    var isIneqCmp = false;
    if (operator.indexOf("!") >= 0) {
        operator = operator.replace("!", "");
        notExpr = true;
    }
    if (operator.indexOf("@") >= 0) {
        operator = operator.replace("@", "");
        caseInsensitive = true;
    }
    if (isFieldStr || isValStr || caseInsensitive) {
        fieldStr = !isFieldStr && !isFieldNum ? "" : "" + fieldVal;
        valStr = "" + value;
    } // if we're doing a case insensitive comparison, then we're using a STRING comparison
    // even if we're comparing numbers
    if (caseInsensitive) {
        fieldVal = fieldStr = fieldStr.toLowerCase();
        value = valStr = valStr.toLowerCase();
    }
    switch(operator){
        case "*=":
            matches = fieldStr.indexOf(valStr) >= 0;
            break;
        case "$=":
            matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
            break;
        case "^=":
            matches = fieldStr.indexOf(valStr) === 0;
            break;
        case "=":
            matches = fieldVal === value;
            break;
        case ">":
            isIneqCmp = true;
            matches = fieldVal > value;
            break;
        case ">=":
            isIneqCmp = true;
            matches = fieldVal >= value;
            break;
        case "<":
            isIneqCmp = true;
            matches = fieldVal < value;
            break;
        case "<=":
            isIneqCmp = true;
            matches = fieldVal <= value;
            break;
        default:
            matches = false;
            break;
    } // apply the not op, but null vals for inequalities should always stay non-matching
    if (notExpr && (fieldVal != null || !isIneqCmp)) matches = !matches;
    return matches;
};
var boolCmp = function boolCmp(fieldVal, operator) {
    switch(operator){
        case "?":
            return fieldVal ? true : false;
        case "!":
            return fieldVal ? false : true;
        case "^":
            return fieldVal === undefined;
    }
};
var existCmp = function existCmp(fieldVal) {
    return fieldVal !== undefined;
};
var data$1 = function data(ele, field) {
    return ele.data(field);
};
var meta = function meta(ele, field) {
    return ele[field]();
};
/** A lookup of `match(check, ele)` functions by `Type` int */ var match = [];
/**
 * Returns whether the query matches for the element
 * @param query The `{ type, value, ... }` query object
 * @param ele The element to compare against
*/ var matches$1 = function matches(query, ele) {
    return query.checks.every(function(chk) {
        return match[chk.type](chk, ele);
    });
};
match[Type.GROUP] = function(check, ele) {
    var group = check.value;
    return group === "*" || group === ele.group();
};
match[Type.STATE] = function(check, ele) {
    var stateSelector = check.value;
    return stateSelectorMatches(stateSelector, ele);
};
match[Type.ID] = function(check, ele) {
    var id = check.value;
    return ele.id() === id;
};
match[Type.CLASS] = function(check, ele) {
    var cls = check.value;
    return ele.hasClass(cls);
};
match[Type.META_COMPARE] = function(check, ele) {
    var field = check.field, operator = check.operator, value = check.value;
    return valCmp(meta(ele, field), operator, value);
};
match[Type.DATA_COMPARE] = function(check, ele) {
    var field = check.field, operator = check.operator, value = check.value;
    return valCmp(data$1(ele, field), operator, value);
};
match[Type.DATA_BOOL] = function(check, ele) {
    var field = check.field, operator = check.operator;
    return boolCmp(data$1(ele, field), operator);
};
match[Type.DATA_EXIST] = function(check, ele) {
    var field = check.field;
    check.operator;
    return existCmp(data$1(ele, field));
};
match[Type.UNDIRECTED_EDGE] = function(check, ele) {
    var qA = check.nodes[0];
    var qB = check.nodes[1];
    var src = ele.source();
    var tgt = ele.target();
    return matches$1(qA, src) && matches$1(qB, tgt) || matches$1(qB, src) && matches$1(qA, tgt);
};
match[Type.NODE_NEIGHBOR] = function(check, ele) {
    return matches$1(check.node, ele) && ele.neighborhood().some(function(n) {
        return n.isNode() && matches$1(check.neighbor, n);
    });
};
match[Type.DIRECTED_EDGE] = function(check, ele) {
    return matches$1(check.source, ele.source()) && matches$1(check.target, ele.target());
};
match[Type.NODE_SOURCE] = function(check, ele) {
    return matches$1(check.source, ele) && ele.outgoers().some(function(n) {
        return n.isNode() && matches$1(check.target, n);
    });
};
match[Type.NODE_TARGET] = function(check, ele) {
    return matches$1(check.target, ele) && ele.incomers().some(function(n) {
        return n.isNode() && matches$1(check.source, n);
    });
};
match[Type.CHILD] = function(check, ele) {
    return matches$1(check.child, ele) && matches$1(check.parent, ele.parent());
};
match[Type.PARENT] = function(check, ele) {
    return matches$1(check.parent, ele) && ele.children().some(function(c) {
        return matches$1(check.child, c);
    });
};
match[Type.DESCENDANT] = function(check, ele) {
    return matches$1(check.descendant, ele) && ele.ancestors().some(function(a) {
        return matches$1(check.ancestor, a);
    });
};
match[Type.ANCESTOR] = function(check, ele) {
    return matches$1(check.ancestor, ele) && ele.descendants().some(function(d) {
        return matches$1(check.descendant, d);
    });
};
match[Type.COMPOUND_SPLIT] = function(check, ele) {
    return matches$1(check.subject, ele) && matches$1(check.left, ele) && matches$1(check.right, ele);
};
match[Type.TRUE] = function() {
    return true;
};
match[Type.COLLECTION] = function(check, ele) {
    var collection = check.value;
    return collection.has(ele);
};
match[Type.FILTER] = function(check, ele) {
    var filter = check.value;
    return filter(ele);
};
var filter = function filter(collection) {
    var self = this; // for 1 id #foo queries, just get the element
    if (self.length === 1 && self[0].checks.length === 1 && self[0].checks[0].type === Type.ID) return collection.getElementById(self[0].checks[0].value).collection();
    var selectorFunction = function selectorFunction(element) {
        for(var j = 0; j < self.length; j++){
            var query = self[j];
            if (matches$1(query, element)) return true;
        }
        return false;
    };
    if (self.text() == null) selectorFunction = function selectorFunction() {
        return true;
    };
    return collection.filter(selectorFunction);
}; // filter
// does selector match a single element?
var matches = function matches(ele) {
    var self = this;
    for(var j = 0; j < self.length; j++){
        var query = self[j];
        if (matches$1(query, ele)) return true;
    }
    return false;
}; // matches
var matching = {
    matches: matches,
    filter: filter
};
var Selector = function Selector(selector) {
    this.inputText = selector;
    this.currentSubject = null;
    this.compoundCount = 0;
    this.edgeCount = 0;
    this.length = 0;
    if (selector == null || string(selector) && selector.match(/^\s*$/)) ;
    else if (elementOrCollection(selector)) this.addQuery({
        checks: [
            {
                type: Type.COLLECTION,
                value: selector.collection()
            }
        ]
    });
    else if (fn$6(selector)) this.addQuery({
        checks: [
            {
                type: Type.FILTER,
                value: selector
            }
        ]
    });
    else if (string(selector)) {
        if (!this.parse(selector)) this.invalid = true;
    } else error("A selector must be created from a string; found ");
};
var selfn = Selector.prototype;
[
    parse$1,
    matching
].forEach(function(p) {
    return extend(selfn, p);
});
selfn.text = function() {
    return this.inputText;
};
selfn.size = function() {
    return this.length;
};
selfn.eq = function(i) {
    return this[i];
};
selfn.sameText = function(otherSel) {
    return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();
};
selfn.addQuery = function(q) {
    this[this.length++] = q;
};
selfn.selector = selfn.toString;
var elesfn$g = {
    allAre: function allAre(selector) {
        var selObj = new Selector(selector);
        return this.every(function(ele) {
            return selObj.matches(ele);
        });
    },
    is: function is(selector) {
        var selObj = new Selector(selector);
        return this.some(function(ele) {
            return selObj.matches(ele);
        });
    },
    some: function some(fn, thisArg) {
        for(var i = 0; i < this.length; i++){
            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [
                this[i],
                i,
                this
            ]);
            if (ret) return true;
        }
        return false;
    },
    every: function every(fn, thisArg) {
        for(var i = 0; i < this.length; i++){
            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [
                this[i],
                i,
                this
            ]);
            if (!ret) return false;
        }
        return true;
    },
    same: function same(collection) {
        // cheap collection ref check
        if (this === collection) return true;
        collection = this.cy().collection(collection);
        var thisLength = this.length;
        var collectionLength = collection.length; // cheap length check
        if (thisLength !== collectionLength) return false;
         // cheap element ref check
        if (thisLength === 1) return this[0] === collection[0];
        return this.every(function(ele) {
            return collection.hasElementWithId(ele.id());
        });
    },
    anySame: function anySame(collection) {
        collection = this.cy().collection(collection);
        return this.some(function(ele) {
            return collection.hasElementWithId(ele.id());
        });
    },
    allAreNeighbors: function allAreNeighbors(collection) {
        collection = this.cy().collection(collection);
        var nhood = this.neighborhood();
        return collection.every(function(ele) {
            return nhood.hasElementWithId(ele.id());
        });
    },
    contains: function contains(collection) {
        collection = this.cy().collection(collection);
        var self = this;
        return collection.every(function(ele) {
            return self.hasElementWithId(ele.id());
        });
    }
};
elesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;
elesfn$g.has = elesfn$g.contains;
elesfn$g.equal = elesfn$g.equals = elesfn$g.same;
var cache = function cache(fn, name) {
    return function traversalCache(arg1, arg2, arg3, arg4) {
        var selectorOrEles = arg1;
        var eles = this;
        var key;
        if (selectorOrEles == null) key = "";
        else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) key = selectorOrEles.id();
        if (eles.length === 1 && key) {
            var _p = eles[0]._private;
            var tch = _p.traversalCache = _p.traversalCache || {};
            var ch = tch[name] = tch[name] || [];
            var hash = hashString(key);
            var cacheHit = ch[hash];
            if (cacheHit) return cacheHit;
            else return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);
        } else return fn.call(eles, arg1, arg2, arg3, arg4);
    };
};
var elesfn$f = {
    parent: function parent(selector) {
        var parents = []; // optimisation for single ele call
        if (this.length === 1) {
            var parent = this[0]._private.parent;
            if (parent) return parent;
        }
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            var _parent = ele._private.parent;
            if (_parent) parents.push(_parent);
        }
        return this.spawn(parents, true).filter(selector);
    },
    parents: function parents(selector) {
        var parents = [];
        var eles = this.parent();
        while(eles.nonempty()){
            for(var i = 0; i < eles.length; i++){
                var ele = eles[i];
                parents.push(ele);
            }
            eles = eles.parent();
        }
        return this.spawn(parents, true).filter(selector);
    },
    commonAncestors: function commonAncestors(selector) {
        var ancestors;
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            var parents = ele.parents();
            ancestors = ancestors || parents;
            ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set
        }
        return ancestors.filter(selector);
    },
    orphans: function orphans(selector) {
        return this.stdFilter(function(ele) {
            return ele.isOrphan();
        }).filter(selector);
    },
    nonorphans: function nonorphans(selector) {
        return this.stdFilter(function(ele) {
            return ele.isChild();
        }).filter(selector);
    },
    children: cache(function(selector) {
        var children = [];
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            var eleChildren = ele._private.children;
            for(var j = 0; j < eleChildren.length; j++)children.push(eleChildren[j]);
        }
        return this.spawn(children, true).filter(selector);
    }, "children"),
    siblings: function siblings(selector) {
        return this.parent().children().not(this).filter(selector);
    },
    isParent: function isParent() {
        var ele = this[0];
        if (ele) return ele.isNode() && ele._private.children.length !== 0;
    },
    isChildless: function isChildless() {
        var ele = this[0];
        if (ele) return ele.isNode() && ele._private.children.length === 0;
    },
    isChild: function isChild() {
        var ele = this[0];
        if (ele) return ele.isNode() && ele._private.parent != null;
    },
    isOrphan: function isOrphan() {
        var ele = this[0];
        if (ele) return ele.isNode() && ele._private.parent == null;
    },
    descendants: function descendants(selector) {
        var elements = [];
        function add(eles) {
            for(var i = 0; i < eles.length; i++){
                var ele = eles[i];
                elements.push(ele);
                if (ele.children().nonempty()) add(ele.children());
            }
        }
        add(this.children());
        return this.spawn(elements, true).filter(selector);
    }
};
function forEachCompound(eles, fn, includeSelf, recursiveStep) {
    var q = [];
    var did = new Set$1();
    var cy = eles.cy();
    var hasCompounds = cy.hasCompoundNodes();
    for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        if (includeSelf) q.push(ele);
        else if (hasCompounds) recursiveStep(q, did, ele);
    }
    while(q.length > 0){
        var _ele = q.shift();
        fn(_ele);
        did.add(_ele.id());
        if (hasCompounds) recursiveStep(q, did, _ele);
    }
    return eles;
}
function addChildren(q, did, ele) {
    if (ele.isParent()) {
        var children = ele._private.children;
        for(var i = 0; i < children.length; i++){
            var child = children[i];
            if (!did.has(child.id())) q.push(child);
        }
    }
} // very efficient version of eles.add( eles.descendants() ).forEach()
// for internal use
elesfn$f.forEachDown = function(fn) {
    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return forEachCompound(this, fn, includeSelf, addChildren);
};
function addParent(q, did, ele) {
    if (ele.isChild()) {
        var parent = ele._private.parent;
        if (!did.has(parent.id())) q.push(parent);
    }
}
elesfn$f.forEachUp = function(fn) {
    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return forEachCompound(this, fn, includeSelf, addParent);
};
function addParentAndChildren(q, did, ele) {
    addParent(q, did, ele);
    addChildren(q, did, ele);
}
elesfn$f.forEachUpAndDown = function(fn) {
    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return forEachCompound(this, fn, includeSelf, addParentAndChildren);
}; // aliases
elesfn$f.ancestors = elesfn$f.parents;
var fn$5, elesfn$e;
fn$5 = elesfn$e = {
    data: define.data({
        field: "data",
        bindingEvent: "data",
        allowBinding: true,
        allowSetting: true,
        settingEvent: "data",
        settingTriggersEvent: true,
        triggerFnName: "trigger",
        allowGetting: true,
        immutableKeys: {
            "id": true,
            "source": true,
            "target": true,
            "parent": true
        },
        updateStyle: true
    }),
    removeData: define.removeData({
        field: "data",
        event: "data",
        triggerFnName: "trigger",
        triggerEvent: true,
        immutableKeys: {
            "id": true,
            "source": true,
            "target": true,
            "parent": true
        },
        updateStyle: true
    }),
    scratch: define.data({
        field: "scratch",
        bindingEvent: "scratch",
        allowBinding: true,
        allowSetting: true,
        settingEvent: "scratch",
        settingTriggersEvent: true,
        triggerFnName: "trigger",
        allowGetting: true,
        updateStyle: true
    }),
    removeScratch: define.removeData({
        field: "scratch",
        event: "scratch",
        triggerFnName: "trigger",
        triggerEvent: true,
        updateStyle: true
    }),
    rscratch: define.data({
        field: "rscratch",
        allowBinding: false,
        allowSetting: true,
        settingTriggersEvent: false,
        allowGetting: true
    }),
    removeRscratch: define.removeData({
        field: "rscratch",
        triggerEvent: false
    }),
    id: function id() {
        var ele = this[0];
        if (ele) return ele._private.data.id;
    }
}; // aliases
fn$5.attr = fn$5.data;
fn$5.removeAttr = fn$5.removeData;
var data = elesfn$e;
var elesfn$d = {};
function defineDegreeFunction(callback) {
    return function(includeLoops) {
        var self = this;
        if (includeLoops === undefined) includeLoops = true;
        if (self.length === 0) return;
        if (self.isNode() && !self.removed()) {
            var degree = 0;
            var node = self[0];
            var connectedEdges = node._private.edges;
            for(var i = 0; i < connectedEdges.length; i++){
                var edge = connectedEdges[i];
                if (!includeLoops && edge.isLoop()) continue;
                degree += callback(node, edge);
            }
            return degree;
        } else return;
    };
}
extend(elesfn$d, {
    degree: defineDegreeFunction(function(node, edge) {
        if (edge.source().same(edge.target())) return 2;
        else return 1;
    }),
    indegree: defineDegreeFunction(function(node, edge) {
        if (edge.target().same(node)) return 1;
        else return 0;
    }),
    outdegree: defineDegreeFunction(function(node, edge) {
        if (edge.source().same(node)) return 1;
        else return 0;
    })
});
function defineDegreeBoundsFunction(degreeFn, callback) {
    return function(includeLoops) {
        var ret;
        var nodes = this.nodes();
        for(var i = 0; i < nodes.length; i++){
            var ele = nodes[i];
            var degree = ele[degreeFn](includeLoops);
            if (degree !== undefined && (ret === undefined || callback(degree, ret))) ret = degree;
        }
        return ret;
    };
}
extend(elesfn$d, {
    minDegree: defineDegreeBoundsFunction("degree", function(degree, min) {
        return degree < min;
    }),
    maxDegree: defineDegreeBoundsFunction("degree", function(degree, max) {
        return degree > max;
    }),
    minIndegree: defineDegreeBoundsFunction("indegree", function(degree, min) {
        return degree < min;
    }),
    maxIndegree: defineDegreeBoundsFunction("indegree", function(degree, max) {
        return degree > max;
    }),
    minOutdegree: defineDegreeBoundsFunction("outdegree", function(degree, min) {
        return degree < min;
    }),
    maxOutdegree: defineDegreeBoundsFunction("outdegree", function(degree, max) {
        return degree > max;
    })
});
extend(elesfn$d, {
    totalDegree: function totalDegree(includeLoops) {
        var total = 0;
        var nodes = this.nodes();
        for(var i = 0; i < nodes.length; i++)total += nodes[i].degree(includeLoops);
        return total;
    }
});
var fn$4, elesfn$c;
var beforePositionSet = function beforePositionSet(eles, newPos, silent) {
    for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        if (!ele.locked()) {
            var oldPos = ele._private.position;
            var delta = {
                x: newPos.x != null ? newPos.x - oldPos.x : 0,
                y: newPos.y != null ? newPos.y - oldPos.y : 0
            };
            if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) ele.children().shift(delta, silent);
            ele.dirtyBoundingBoxCache();
        }
    }
};
var positionDef = {
    field: "position",
    bindingEvent: "position",
    allowBinding: true,
    allowSetting: true,
    settingEvent: "position",
    settingTriggersEvent: true,
    triggerFnName: "emitAndNotify",
    allowGetting: true,
    validKeys: [
        "x",
        "y"
    ],
    beforeGet: function beforeGet(ele) {
        ele.updateCompoundBounds();
    },
    beforeSet: function beforeSet(eles, newPos) {
        beforePositionSet(eles, newPos, false);
    },
    onSet: function onSet(eles) {
        eles.dirtyCompoundBoundsCache();
    },
    canSet: function canSet(ele) {
        return !ele.locked();
    }
};
fn$4 = elesfn$c = {
    position: define.data(positionDef),
    // position but no notification to renderer
    silentPosition: define.data(extend({}, positionDef, {
        allowBinding: false,
        allowSetting: true,
        settingTriggersEvent: false,
        allowGetting: false,
        beforeSet: function beforeSet(eles, newPos) {
            beforePositionSet(eles, newPos, true);
        },
        onSet: function onSet(eles) {
            eles.dirtyCompoundBoundsCache();
        }
    })),
    positions: function positions(pos, silent) {
        if (plainObject(pos)) {
            if (silent) this.silentPosition(pos);
            else this.position(pos);
        } else if (fn$6(pos)) {
            var _fn = pos;
            var cy = this.cy();
            cy.startBatch();
            for(var i = 0; i < this.length; i++){
                var ele = this[i];
                var _pos = void 0;
                if (_pos = _fn(ele, i)) {
                    if (silent) ele.silentPosition(_pos);
                    else ele.position(_pos);
                }
            }
            cy.endBatch();
        }
        return this; // chaining
    },
    silentPositions: function silentPositions(pos) {
        return this.positions(pos, true);
    },
    shift: function shift(dim, val, silent) {
        var delta;
        if (plainObject(dim)) {
            delta = {
                x: number$1(dim.x) ? dim.x : 0,
                y: number$1(dim.y) ? dim.y : 0
            };
            silent = val;
        } else if (string(dim) && number$1(val)) {
            delta = {
                x: 0,
                y: 0
            };
            delta[dim] = val;
        }
        if (delta != null) {
            var cy = this.cy();
            cy.startBatch();
            for(var i = 0; i < this.length; i++){
                var ele = this[i]; // exclude any node that is a descendant of the calling collection
                if (cy.hasCompoundNodes() && ele.isChild() && ele.ancestors().anySame(this)) continue;
                var pos = ele.position();
                var newPos = {
                    x: pos.x + delta.x,
                    y: pos.y + delta.y
                };
                if (silent) ele.silentPosition(newPos);
                else ele.position(newPos);
            }
            cy.endBatch();
        }
        return this;
    },
    silentShift: function silentShift(dim, val) {
        if (plainObject(dim)) this.shift(dim, true);
        else if (string(dim) && number$1(val)) this.shift(dim, val, true);
        return this;
    },
    // get/set the rendered (i.e. on screen) positon of the element
    renderedPosition: function renderedPosition(dim, val) {
        var ele = this[0];
        var cy = this.cy();
        var zoom = cy.zoom();
        var pan = cy.pan();
        var rpos = plainObject(dim) ? dim : undefined;
        var setting = rpos !== undefined || val !== undefined && string(dim);
        if (ele && ele.isNode()) {
            // must have an element and must be a node to return position
            if (setting) for(var i = 0; i < this.length; i++){
                var _ele = this[i];
                if (val !== undefined) // set one dimension
                _ele.position(dim, (val - pan[dim]) / zoom);
                else if (rpos !== undefined) // set whole position
                _ele.position(renderedToModelPosition(rpos, zoom, pan));
            }
            else {
                // getting
                var pos = ele.position();
                rpos = modelToRenderedPosition(pos, zoom, pan);
                if (dim === undefined) // then return the whole rendered position
                return rpos;
                else // then return the specified dimension
                return rpos[dim];
            }
        } else if (!setting) return undefined; // for empty collection case
        return this; // chaining
    },
    // get/set the position relative to the parent
    relativePosition: function relativePosition(dim, val) {
        var ele = this[0];
        var cy = this.cy();
        var ppos = plainObject(dim) ? dim : undefined;
        var setting = ppos !== undefined || val !== undefined && string(dim);
        var hasCompoundNodes = cy.hasCompoundNodes();
        if (ele && ele.isNode()) {
            // must have an element and must be a node to return position
            if (setting) for(var i = 0; i < this.length; i++){
                var _ele2 = this[i];
                var parent = hasCompoundNodes ? _ele2.parent() : null;
                var hasParent = parent && parent.length > 0;
                var relativeToParent = hasParent;
                if (hasParent) parent = parent[0];
                var origin = relativeToParent ? parent.position() : {
                    x: 0,
                    y: 0
                };
                if (val !== undefined) // set one dimension
                _ele2.position(dim, val + origin[dim]);
                else if (ppos !== undefined) // set whole position
                _ele2.position({
                    x: ppos.x + origin.x,
                    y: ppos.y + origin.y
                });
            }
            else {
                // getting
                var pos = ele.position();
                var _parent = hasCompoundNodes ? ele.parent() : null;
                var _hasParent = _parent && _parent.length > 0;
                var _relativeToParent = _hasParent;
                if (_hasParent) _parent = _parent[0];
                var _origin = _relativeToParent ? _parent.position() : {
                    x: 0,
                    y: 0
                };
                ppos = {
                    x: pos.x - _origin.x,
                    y: pos.y - _origin.y
                };
                if (dim === undefined) // then return the whole rendered position
                return ppos;
                else // then return the specified dimension
                return ppos[dim];
            }
        } else if (!setting) return undefined; // for empty collection case
        return this; // chaining
    }
}; // aliases
fn$4.modelPosition = fn$4.point = fn$4.position;
fn$4.modelPositions = fn$4.points = fn$4.positions;
fn$4.renderedPoint = fn$4.renderedPosition;
fn$4.relativePoint = fn$4.relativePosition;
var position = elesfn$c;
var fn$3, elesfn$b;
fn$3 = elesfn$b = {};
elesfn$b.renderedBoundingBox = function(options) {
    var bb = this.boundingBox(options);
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var x1 = bb.x1 * zoom + pan.x;
    var x2 = bb.x2 * zoom + pan.x;
    var y1 = bb.y1 * zoom + pan.y;
    var y2 = bb.y2 * zoom + pan.y;
    return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
    };
};
elesfn$b.dirtyCompoundBoundsCache = function() {
    var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var cy = this.cy();
    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) return this;
    this.forEachUp(function(ele) {
        if (ele.isParent()) {
            var _p = ele._private;
            _p.compoundBoundsClean = false;
            _p.bbCache = null;
            if (!silent) ele.emitAndNotify("bounds");
        }
    });
    return this;
};
elesfn$b.updateCompoundBounds = function() {
    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var cy = this.cy(); // not possible to do on non-compound graphs or with the style disabled
    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) return this;
     // save cycles when batching -- but bounds will be stale (or not exist yet)
    if (!force && cy.batching()) return this;
    function update(parent) {
        if (!parent.isParent()) return;
        var _p = parent._private;
        var children = parent.children();
        var includeLabels = parent.pstyle("compound-sizing-wrt-labels").value === "include";
        var min = {
            width: {
                val: parent.pstyle("min-width").pfValue,
                left: parent.pstyle("min-width-bias-left"),
                right: parent.pstyle("min-width-bias-right")
            },
            height: {
                val: parent.pstyle("min-height").pfValue,
                top: parent.pstyle("min-height-bias-top"),
                bottom: parent.pstyle("min-height-bias-bottom")
            }
        };
        var bb = children.boundingBox({
            includeLabels: includeLabels,
            includeOverlays: false,
            // updating the compound bounds happens outside of the regular
            // cache cycle (i.e. before fired events)
            useCache: false
        });
        var pos = _p.position; // if children take up zero area then keep position and fall back on stylesheet w/h
        if (bb.w === 0 || bb.h === 0) {
            bb = {
                w: parent.pstyle("width").pfValue,
                h: parent.pstyle("height").pfValue
            };
            bb.x1 = pos.x - bb.w / 2;
            bb.x2 = pos.x + bb.w / 2;
            bb.y1 = pos.y - bb.h / 2;
            bb.y2 = pos.y + bb.h / 2;
        }
        function computeBiasValues(propDiff, propBias, propBiasComplement) {
            var biasDiff = 0;
            var biasComplementDiff = 0;
            var biasTotal = propBias + propBiasComplement;
            if (propDiff > 0 && biasTotal > 0) {
                biasDiff = propBias / biasTotal * propDiff;
                biasComplementDiff = propBiasComplement / biasTotal * propDiff;
            }
            return {
                biasDiff: biasDiff,
                biasComplementDiff: biasComplementDiff
            };
        }
        function computePaddingValues(width, height, paddingObject, relativeTo) {
            // Assuming percentage is number from 0 to 1
            if (paddingObject.units === "%") switch(relativeTo){
                case "width":
                    return width > 0 ? paddingObject.pfValue * width : 0;
                case "height":
                    return height > 0 ? paddingObject.pfValue * height : 0;
                case "average":
                    return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;
                case "min":
                    return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;
                case "max":
                    return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;
                default:
                    return 0;
            }
            else if (paddingObject.units === "px") return paddingObject.pfValue;
            else return 0;
        }
        var leftVal = min.width.left.value;
        if (min.width.left.units === "px" && min.width.val > 0) leftVal = leftVal * 100 / min.width.val;
        var rightVal = min.width.right.value;
        if (min.width.right.units === "px" && min.width.val > 0) rightVal = rightVal * 100 / min.width.val;
        var topVal = min.height.top.value;
        if (min.height.top.units === "px" && min.height.val > 0) topVal = topVal * 100 / min.height.val;
        var bottomVal = min.height.bottom.value;
        if (min.height.bottom.units === "px" && min.height.val > 0) bottomVal = bottomVal * 100 / min.height.val;
        var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);
        var diffLeft = widthBiasDiffs.biasDiff;
        var diffRight = widthBiasDiffs.biasComplementDiff;
        var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);
        var diffTop = heightBiasDiffs.biasDiff;
        var diffBottom = heightBiasDiffs.biasComplementDiff;
        _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle("padding"), parent.pstyle("padding-relative-to").value);
        _p.autoWidth = Math.max(bb.w, min.width.val);
        pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;
        _p.autoHeight = Math.max(bb.h, min.height.val);
        pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;
    }
    for(var i = 0; i < this.length; i++){
        var ele = this[i];
        var _p = ele._private;
        if (!_p.compoundBoundsClean || force) {
            update(ele);
            if (!cy.batching()) _p.compoundBoundsClean = true;
        }
    }
    return this;
};
var noninf = function noninf(x) {
    if (x === Infinity || x === -Infinity) return 0;
    return x;
};
var updateBounds = function updateBounds(b, x1, y1, x2, y2) {
    // don't update with zero area boxes
    if (x2 - x1 === 0 || y2 - y1 === 0) return;
     // don't update with null dim
    if (x1 == null || y1 == null || x2 == null || y2 == null) return;
    b.x1 = x1 < b.x1 ? x1 : b.x1;
    b.x2 = x2 > b.x2 ? x2 : b.x2;
    b.y1 = y1 < b.y1 ? y1 : b.y1;
    b.y2 = y2 > b.y2 ? y2 : b.y2;
    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;
};
var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {
    if (b2 == null) return b;
    return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
};
var prefixedProperty = function prefixedProperty(obj, field, prefix) {
    return getPrefixedProperty(obj, field, prefix);
};
var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {
    if (ele.cy().headless()) return;
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var halfArW = rstyle.arrowWidth / 2;
    var arrowType = ele.pstyle(prefix + "-arrow-shape").value;
    var x;
    var y;
    if (arrowType !== "none") {
        if (prefix === "source") {
            x = rstyle.srcX;
            y = rstyle.srcY;
        } else if (prefix === "target") {
            x = rstyle.tgtX;
            y = rstyle.tgtY;
        } else {
            x = rstyle.midX;
            y = rstyle.midY;
        } // always store the individual arrow bounds
        var bbs = _p.arrowBounds = _p.arrowBounds || {};
        var bb = bbs[prefix] = bbs[prefix] || {};
        bb.x1 = x - halfArW;
        bb.y1 = y - halfArW;
        bb.x2 = x + halfArW;
        bb.y2 = y + halfArW;
        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;
        expandBoundingBox(bb, 1);
        updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);
    }
};
var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {
    if (ele.cy().headless()) return;
    var prefixDash;
    if (prefix) prefixDash = prefix + "-";
    else prefixDash = "";
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var label = ele.pstyle(prefixDash + "label").strValue;
    if (label) {
        var halign = ele.pstyle("text-halign");
        var valign = ele.pstyle("text-valign");
        var labelWidth = prefixedProperty(rstyle, "labelWidth", prefix);
        var labelHeight = prefixedProperty(rstyle, "labelHeight", prefix);
        var labelX = prefixedProperty(rstyle, "labelX", prefix);
        var labelY = prefixedProperty(rstyle, "labelY", prefix);
        var marginX = ele.pstyle(prefixDash + "text-margin-x").pfValue;
        var marginY = ele.pstyle(prefixDash + "text-margin-y").pfValue;
        var isEdge = ele.isEdge();
        var rotation = ele.pstyle(prefixDash + "text-rotation");
        var outlineWidth = ele.pstyle("text-outline-width").pfValue;
        var borderWidth = ele.pstyle("text-border-width").pfValue;
        var halfBorderWidth = borderWidth / 2;
        var padding = ele.pstyle("text-background-padding").pfValue;
        var marginOfError = 2; // expand to work around browser dimension inaccuracies
        var lh = labelHeight;
        var lw = labelWidth;
        var lw_2 = lw / 2;
        var lh_2 = lh / 2;
        var lx1, lx2, ly1, ly2;
        if (isEdge) {
            lx1 = labelX - lw_2;
            lx2 = labelX + lw_2;
            ly1 = labelY - lh_2;
            ly2 = labelY + lh_2;
        } else {
            switch(halign.value){
                case "left":
                    lx1 = labelX - lw;
                    lx2 = labelX;
                    break;
                case "center":
                    lx1 = labelX - lw_2;
                    lx2 = labelX + lw_2;
                    break;
                case "right":
                    lx1 = labelX;
                    lx2 = labelX + lw;
                    break;
            }
            switch(valign.value){
                case "top":
                    ly1 = labelY - lh;
                    ly2 = labelY;
                    break;
                case "center":
                    ly1 = labelY - lh_2;
                    ly2 = labelY + lh_2;
                    break;
                case "bottom":
                    ly1 = labelY;
                    ly2 = labelY + lh;
                    break;
            }
        } // shift by margin and expand by outline and border
        lx1 += marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;
        lx2 += marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;
        ly1 += marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;
        ly2 += marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError; // always store the unrotated label bounds separately
        var bbPrefix = prefix || "main";
        var bbs = _p.labelBounds;
        var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};
        bb.x1 = lx1;
        bb.y1 = ly1;
        bb.x2 = lx2;
        bb.y2 = ly2;
        bb.w = lx2 - lx1;
        bb.h = ly2 - ly1;
        var isAutorotate = isEdge && rotation.strValue === "autorotate";
        var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;
        if (isAutorotate || isPfValue) {
            var theta = isAutorotate ? prefixedProperty(_p.rstyle, "labelAngle", prefix) : rotation.pfValue;
            var cos = Math.cos(theta);
            var sin = Math.sin(theta); // rotation point (default value for center-center)
            var xo = (lx1 + lx2) / 2;
            var yo = (ly1 + ly2) / 2;
            if (!isEdge) {
                switch(halign.value){
                    case "left":
                        xo = lx2;
                        break;
                    case "right":
                        xo = lx1;
                        break;
                }
                switch(valign.value){
                    case "top":
                        yo = ly2;
                        break;
                    case "bottom":
                        yo = ly1;
                        break;
                }
            }
            var rotate = function rotate(x, y) {
                x = x - xo;
                y = y - yo;
                return {
                    x: x * cos - y * sin + xo,
                    y: x * sin + y * cos + yo
                };
            };
            var px1y1 = rotate(lx1, ly1);
            var px1y2 = rotate(lx1, ly2);
            var px2y1 = rotate(lx2, ly1);
            var px2y2 = rotate(lx2, ly2);
            lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
            lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
            ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
            ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
        }
        var bbPrefixRot = bbPrefix + "Rot";
        var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};
        bbRot.x1 = lx1;
        bbRot.y1 = ly1;
        bbRot.x2 = lx2;
        bbRot.y2 = ly2;
        bbRot.w = lx2 - lx1;
        bbRot.h = ly2 - ly1;
        updateBounds(bounds, lx1, ly1, lx2, ly2);
        updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);
    }
    return bounds;
}; // get the bounding box of the elements (in raw model position)
var boundingBoxImpl = function boundingBoxImpl(ele, options) {
    var cy = ele._private.cy;
    var styleEnabled = cy.styleEnabled();
    var headless = cy.headless();
    var bounds = makeBoundingBox();
    var _p = ele._private;
    var isNode = ele.isNode();
    var isEdge = ele.isEdge();
    var ex1, ex2, ey1, ey2; // extrema of body / lines
    var x, y; // node pos
    var rstyle = _p.rstyle;
    var manualExpansion = isNode && styleEnabled ? ele.pstyle("bounds-expansion").pfValue : [
        0
    ]; // must use `display` prop only, as reading `compound.width()` causes recursion
    // (other factors like width values will be considered later in this function anyway)
    var isDisplayed = function isDisplayed(ele) {
        return ele.pstyle("display").value !== "none";
    };
    var displayed = !styleEnabled || isDisplayed(ele) // must take into account connected nodes b/c of implicit edge hiding on display:none node
     && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));
    if (displayed) {
        // displayed suffices, since we will find zero area eles anyway
        var overlayOpacity = 0;
        var overlayPadding = 0;
        if (styleEnabled && options.includeOverlays) {
            overlayOpacity = ele.pstyle("overlay-opacity").value;
            if (overlayOpacity !== 0) overlayPadding = ele.pstyle("overlay-padding").value;
        }
        var underlayOpacity = 0;
        var underlayPadding = 0;
        if (styleEnabled && options.includeUnderlays) {
            underlayOpacity = ele.pstyle("underlay-opacity").value;
            if (underlayOpacity !== 0) underlayPadding = ele.pstyle("underlay-padding").value;
        }
        var padding = Math.max(overlayPadding, underlayPadding);
        var w = 0;
        var wHalf = 0;
        if (styleEnabled) {
            w = ele.pstyle("width").pfValue;
            wHalf = w / 2;
        }
        if (isNode && options.includeNodes) {
            var pos = ele.position();
            x = pos.x;
            y = pos.y;
            var _w = ele.outerWidth();
            var halfW = _w / 2;
            var h = ele.outerHeight();
            var halfH = h / 2; // handle node dimensions
            /////////////////////////
            ex1 = x - halfW;
            ex2 = x + halfW;
            ey1 = y - halfH;
            ey2 = y + halfH;
            updateBounds(bounds, ex1, ey1, ex2, ey2);
        } else if (isEdge && options.includeEdges) {
            if (styleEnabled && !headless) {
                var curveStyle = ele.pstyle("curve-style").strValue; // handle edge dimensions (rough box estimate)
                //////////////////////////////////////////////
                ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
                ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
                ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
                ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY); // take into account edge width
                ex1 -= wHalf;
                ex2 += wHalf;
                ey1 -= wHalf;
                ey2 += wHalf;
                updateBounds(bounds, ex1, ey1, ex2, ey2); // precise edges
                ////////////////
                if (curveStyle === "haystack") {
                    var hpts = rstyle.haystackPts;
                    if (hpts && hpts.length === 2) {
                        ex1 = hpts[0].x;
                        ey1 = hpts[0].y;
                        ex2 = hpts[1].x;
                        ey2 = hpts[1].y;
                        if (ex1 > ex2) {
                            var temp = ex1;
                            ex1 = ex2;
                            ex2 = temp;
                        }
                        if (ey1 > ey2) {
                            var _temp = ey1;
                            ey1 = ey2;
                            ey2 = _temp;
                        }
                        updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);
                    }
                } else if (curveStyle === "bezier" || curveStyle === "unbundled-bezier" || curveStyle === "segments" || curveStyle === "taxi") {
                    var pts;
                    switch(curveStyle){
                        case "bezier":
                        case "unbundled-bezier":
                            pts = rstyle.bezierPts;
                            break;
                        case "segments":
                        case "taxi":
                            pts = rstyle.linePts;
                            break;
                    }
                    if (pts != null) for(var j = 0; j < pts.length; j++){
                        var pt = pts[j];
                        ex1 = pt.x - wHalf;
                        ex2 = pt.x + wHalf;
                        ey1 = pt.y - wHalf;
                        ey2 = pt.y + wHalf;
                        updateBounds(bounds, ex1, ey1, ex2, ey2);
                    }
                } // bezier-like or segment-like edge
            } else {
                // headless or style disabled
                // fallback on source and target positions
                //////////////////////////////////////////
                var n1 = ele.source();
                var n1pos = n1.position();
                var n2 = ele.target();
                var n2pos = n2.position();
                ex1 = n1pos.x;
                ex2 = n2pos.x;
                ey1 = n1pos.y;
                ey2 = n2pos.y;
                if (ex1 > ex2) {
                    var _temp2 = ex1;
                    ex1 = ex2;
                    ex2 = _temp2;
                }
                if (ey1 > ey2) {
                    var _temp3 = ey1;
                    ey1 = ey2;
                    ey2 = _temp3;
                } // take into account edge width
                ex1 -= wHalf;
                ex2 += wHalf;
                ey1 -= wHalf;
                ey2 += wHalf;
                updateBounds(bounds, ex1, ey1, ex2, ey2);
            } // headless or style disabled
        } // edges
        // handle edge arrow size
        /////////////////////////
        if (styleEnabled && options.includeEdges && isEdge) {
            updateBoundsFromArrow(bounds, ele, "mid-source");
            updateBoundsFromArrow(bounds, ele, "mid-target");
            updateBoundsFromArrow(bounds, ele, "source");
            updateBoundsFromArrow(bounds, ele, "target");
        } // ghost
        ////////
        if (styleEnabled) {
            var ghost = ele.pstyle("ghost").value === "yes";
            if (ghost) {
                var gx = ele.pstyle("ghost-offset-x").pfValue;
                var gy = ele.pstyle("ghost-offset-y").pfValue;
                updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);
            }
        } // always store the body bounds separately from the labels
        var bbBody = _p.bodyBounds = _p.bodyBounds || {};
        assignBoundingBox(bbBody, bounds);
        expandBoundingBoxSides(bbBody, manualExpansion);
        expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies
        // overlay
        //////////
        if (styleEnabled) {
            ex1 = bounds.x1;
            ex2 = bounds.x2;
            ey1 = bounds.y1;
            ey2 = bounds.y2;
            updateBounds(bounds, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);
        } // always store the body bounds separately from the labels
        var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};
        assignBoundingBox(bbOverlay, bounds);
        expandBoundingBoxSides(bbOverlay, manualExpansion);
        expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies
        // handle label dimensions
        //////////////////////////
        var bbLabels = _p.labelBounds = _p.labelBounds || {};
        if (bbLabels.all != null) clearBoundingBox(bbLabels.all);
        else bbLabels.all = makeBoundingBox();
        if (styleEnabled && options.includeLabels) {
            if (options.includeMainLabels) updateBoundsFromLabel(bounds, ele, null);
            if (isEdge) {
                if (options.includeSourceLabels) updateBoundsFromLabel(bounds, ele, "source");
                if (options.includeTargetLabels) updateBoundsFromLabel(bounds, ele, "target");
            }
        } // style enabled for labels
    } // if displayed
    bounds.x1 = noninf(bounds.x1);
    bounds.y1 = noninf(bounds.y1);
    bounds.x2 = noninf(bounds.x2);
    bounds.y2 = noninf(bounds.y2);
    bounds.w = noninf(bounds.x2 - bounds.x1);
    bounds.h = noninf(bounds.y2 - bounds.y1);
    if (bounds.w > 0 && bounds.h > 0 && displayed) {
        expandBoundingBoxSides(bounds, manualExpansion); // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides
        expandBoundingBox(bounds, 1);
    }
    return bounds;
};
var getKey = function getKey(opts) {
    var i = 0;
    var tf = function tf(val) {
        return (val ? 1 : 0) << i++;
    };
    var key = 0;
    key += tf(opts.incudeNodes);
    key += tf(opts.includeEdges);
    key += tf(opts.includeLabels);
    key += tf(opts.includeMainLabels);
    key += tf(opts.includeSourceLabels);
    key += tf(opts.includeTargetLabels);
    key += tf(opts.includeOverlays);
    return key;
};
var getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {
    if (ele.isEdge()) {
        var p1 = ele.source().position();
        var p2 = ele.target().position();
        var r = function r(x) {
            return Math.round(x);
        };
        return hashIntsArray([
            r(p1.x),
            r(p1.y),
            r(p2.x),
            r(p2.y)
        ]);
    } else return 0;
};
var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {
    var _p = ele._private;
    var bb;
    var isEdge = ele.isEdge();
    var key = opts == null ? defBbOptsKey : getKey(opts);
    var usingDefOpts = key === defBbOptsKey;
    var currPosKey = getBoundingBoxPosKey(ele);
    var isPosKeySame = _p.bbCachePosKey === currPosKey;
    var useCache = opts.useCache && isPosKeySame;
    var isDirty = function isDirty(ele) {
        return ele._private.bbCache == null || ele._private.styleDirty;
    };
    var needRecalc = !useCache || isDirty(ele) || isEdge && isDirty(ele.source()) || isDirty(ele.target());
    if (needRecalc) {
        if (!isPosKeySame) ele.recalculateRenderedStyle(useCache);
        bb = boundingBoxImpl(ele, defBbOpts);
        _p.bbCache = bb;
        _p.bbCachePosKey = currPosKey;
    } else bb = _p.bbCache;
     // not using def opts => need to build up bb from combination of sub bbs
    if (!usingDefOpts) {
        var isNode = ele.isNode();
        bb = makeBoundingBox();
        if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {
            if (opts.includeOverlays) updateBoundsFromBox(bb, _p.overlayBounds);
            else updateBoundsFromBox(bb, _p.bodyBounds);
        }
        if (opts.includeLabels) {
            if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) updateBoundsFromBox(bb, _p.labelBounds.all);
            else {
                if (opts.includeMainLabels) updateBoundsFromBox(bb, _p.labelBounds.mainRot);
                if (opts.includeSourceLabels) updateBoundsFromBox(bb, _p.labelBounds.sourceRot);
                if (opts.includeTargetLabels) updateBoundsFromBox(bb, _p.labelBounds.targetRot);
            }
        }
        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;
    }
    return bb;
};
var defBbOpts = {
    includeNodes: true,
    includeEdges: true,
    includeLabels: true,
    includeMainLabels: true,
    includeSourceLabels: true,
    includeTargetLabels: true,
    includeOverlays: true,
    includeUnderlays: true,
    useCache: true
};
var defBbOptsKey = getKey(defBbOpts);
var filledBbOpts = defaults$g(defBbOpts);
elesfn$b.boundingBox = function(options) {
    var bounds; // the main usecase is ele.boundingBox() for a single element with no/def options
    // specified s.t. the cache is used, so check for this case to make it faster by
    // avoiding the overhead of the rest of the function
    if (this.length === 1 && this[0]._private.bbCache != null && !this[0]._private.styleDirty && (options === undefined || options.useCache === undefined || options.useCache === true)) {
        if (options === undefined) options = defBbOpts;
        else options = filledBbOpts(options);
        bounds = cachedBoundingBoxImpl(this[0], options);
    } else {
        bounds = makeBoundingBox();
        options = options || defBbOpts;
        var opts = filledBbOpts(options);
        var eles = this;
        var cy = eles.cy();
        var styleEnabled = cy.styleEnabled();
        if (styleEnabled) for(var i = 0; i < eles.length; i++){
            var ele = eles[i];
            var _p = ele._private;
            var currPosKey = getBoundingBoxPosKey(ele);
            var isPosKeySame = _p.bbCachePosKey === currPosKey;
            var useCache = opts.useCache && isPosKeySame && !_p.styleDirty;
            ele.recalculateRenderedStyle(useCache);
        }
        this.updateCompoundBounds(!options.useCache);
        for(var _i = 0; _i < eles.length; _i++){
            var _ele = eles[_i];
            updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));
        }
    }
    bounds.x1 = noninf(bounds.x1);
    bounds.y1 = noninf(bounds.y1);
    bounds.x2 = noninf(bounds.x2);
    bounds.y2 = noninf(bounds.y2);
    bounds.w = noninf(bounds.x2 - bounds.x1);
    bounds.h = noninf(bounds.y2 - bounds.y1);
    return bounds;
};
elesfn$b.dirtyBoundingBoxCache = function() {
    for(var i = 0; i < this.length; i++){
        var _p = this[i]._private;
        _p.bbCache = null;
        _p.bbCachePosKey = null;
        _p.bodyBounds = null;
        _p.overlayBounds = null;
        _p.labelBounds.all = null;
        _p.labelBounds.source = null;
        _p.labelBounds.target = null;
        _p.labelBounds.main = null;
        _p.labelBounds.sourceRot = null;
        _p.labelBounds.targetRot = null;
        _p.labelBounds.mainRot = null;
        _p.arrowBounds.source = null;
        _p.arrowBounds.target = null;
        _p.arrowBounds["mid-source"] = null;
        _p.arrowBounds["mid-target"] = null;
    }
    this.emitAndNotify("bounds");
    return this;
}; // private helper to get bounding box for custom node positions
// - good for perf in certain cases but currently requires dirtying the rendered style
// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
// - try to use for only things like discrete layouts where the node position would change anyway
elesfn$b.boundingBoxAt = function(fn) {
    var nodes = this.nodes();
    var cy = this.cy();
    var hasCompoundNodes = cy.hasCompoundNodes();
    var parents = cy.collection();
    if (hasCompoundNodes) {
        parents = nodes.filter(function(node) {
            return node.isParent();
        });
        nodes = nodes.not(parents);
    }
    if (plainObject(fn)) {
        var obj = fn;
        fn = function fn() {
            return obj;
        };
    }
    var storeOldPos = function storeOldPos(node, i) {
        return node._private.bbAtOldPos = fn(node, i);
    };
    var getOldPos = function getOldPos(node) {
        return node._private.bbAtOldPos;
    };
    cy.startBatch();
    nodes.forEach(storeOldPos).silentPositions(fn);
    if (hasCompoundNodes) {
        parents.dirtyCompoundBoundsCache();
        parents.dirtyBoundingBoxCache();
        parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle
    }
    var bb = copyBoundingBox(this.boundingBox({
        useCache: false
    }));
    nodes.silentPositions(getOldPos);
    if (hasCompoundNodes) {
        parents.dirtyCompoundBoundsCache();
        parents.dirtyBoundingBoxCache();
        parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle
    }
    cy.endBatch();
    return bb;
};
fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;
fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;
var bounds = elesfn$b;
var fn$2, elesfn$a;
fn$2 = elesfn$a = {};
var defineDimFns = function defineDimFns(opts) {
    opts.uppercaseName = capitalize(opts.name);
    opts.autoName = "auto" + opts.uppercaseName;
    opts.labelName = "label" + opts.uppercaseName;
    opts.outerName = "outer" + opts.uppercaseName;
    opts.uppercaseOuterName = capitalize(opts.outerName);
    fn$2[opts.name] = function dimImpl() {
        var ele = this[0];
        var _p = ele._private;
        var cy = _p.cy;
        var styleEnabled = cy._private.styleEnabled;
        if (ele) {
            if (styleEnabled) {
                if (ele.isParent()) {
                    ele.updateCompoundBounds();
                    return _p[opts.autoName] || 0;
                }
                var d = ele.pstyle(opts.name);
                switch(d.strValue){
                    case "label":
                        ele.recalculateRenderedStyle();
                        return _p.rstyle[opts.labelName] || 0;
                    default:
                        return d.pfValue;
                }
            } else return 1;
        }
    };
    fn$2["outer" + opts.uppercaseName] = function outerDimImpl() {
        var ele = this[0];
        var _p = ele._private;
        var cy = _p.cy;
        var styleEnabled = cy._private.styleEnabled;
        if (ele) {
            if (styleEnabled) {
                var dim = ele[opts.name]();
                var border = ele.pstyle("border-width").pfValue; // n.b. 1/2 each side
                var padding = 2 * ele.padding();
                return dim + border + padding;
            } else return 1;
        }
    };
    fn$2["rendered" + opts.uppercaseName] = function renderedDimImpl() {
        var ele = this[0];
        if (ele) {
            var d = ele[opts.name]();
            return d * this.cy().zoom();
        }
    };
    fn$2["rendered" + opts.uppercaseOuterName] = function renderedOuterDimImpl() {
        var ele = this[0];
        if (ele) {
            var od = ele[opts.outerName]();
            return od * this.cy().zoom();
        }
    };
};
defineDimFns({
    name: "width"
});
defineDimFns({
    name: "height"
});
elesfn$a.padding = function() {
    var ele = this[0];
    var _p = ele._private;
    if (ele.isParent()) {
        ele.updateCompoundBounds();
        if (_p.autoPadding !== undefined) return _p.autoPadding;
        else return ele.pstyle("padding").pfValue;
    } else return ele.pstyle("padding").pfValue;
};
elesfn$a.paddedHeight = function() {
    var ele = this[0];
    return ele.height() + 2 * ele.padding();
};
elesfn$a.paddedWidth = function() {
    var ele = this[0];
    return ele.width() + 2 * ele.padding();
};
var widthHeight = elesfn$a;
var ifEdge = function ifEdge(ele, getValue) {
    if (ele.isEdge()) return getValue(ele);
};
var ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {
    if (ele.isEdge()) {
        var cy = ele.cy();
        return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());
    }
};
var ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {
    if (ele.isEdge()) {
        var cy = ele.cy();
        var pan = cy.pan();
        var zoom = cy.zoom();
        return getPoints(ele).map(function(p) {
            return modelToRenderedPosition(p, zoom, pan);
        });
    }
};
var controlPoints = function controlPoints(ele) {
    return ele.renderer().getControlPoints(ele);
};
var segmentPoints = function segmentPoints(ele) {
    return ele.renderer().getSegmentPoints(ele);
};
var sourceEndpoint = function sourceEndpoint(ele) {
    return ele.renderer().getSourceEndpoint(ele);
};
var targetEndpoint = function targetEndpoint(ele) {
    return ele.renderer().getTargetEndpoint(ele);
};
var midpoint = function midpoint(ele) {
    return ele.renderer().getEdgeMidpoint(ele);
};
var pts = {
    controlPoints: {
        get: controlPoints,
        mult: true
    },
    segmentPoints: {
        get: segmentPoints,
        mult: true
    },
    sourceEndpoint: {
        get: sourceEndpoint
    },
    targetEndpoint: {
        get: targetEndpoint
    },
    midpoint: {
        get: midpoint
    }
};
var renderedName = function renderedName(name) {
    return "rendered" + name[0].toUpperCase() + name.substr(1);
};
var edgePoints = Object.keys(pts).reduce(function(obj, name) {
    var spec = pts[name];
    var rName = renderedName(name);
    obj[name] = function() {
        return ifEdge(this, spec.get);
    };
    if (spec.mult) obj[rName] = function() {
        return ifEdgeRenderedPositions(this, spec.get);
    };
    else obj[rName] = function() {
        return ifEdgeRenderedPosition(this, spec.get);
    };
    return obj;
}, {});
var dimensions = extend({}, position, bounds, widthHeight, edgePoints);
/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/ var Event = function Event(src, props) {
    this.recycle(src, props);
};
function returnFalse() {
    return false;
}
function returnTrue() {
    return true;
} // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
Event.prototype = {
    instanceString: function instanceString() {
        return "event";
    },
    recycle: function recycle(src, props) {
        this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;
        if (src != null && src.preventDefault) {
            // Browser Event object
            this.type = src.type; // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
        } else if (src != null && src.type) // Plain object containing all event details
        props = src;
        else // Event string
        this.type = src;
         // Put explicitly provided properties onto the event object
        if (props != null) {
            // more efficient to manually copy fields we use
            this.originalEvent = props.originalEvent;
            this.type = props.type != null ? props.type : this.type;
            this.cy = props.cy;
            this.target = props.target;
            this.position = props.position;
            this.renderedPosition = props.renderedPosition;
            this.namespace = props.namespace;
            this.layout = props.layout;
        }
        if (this.cy != null && this.position != null && this.renderedPosition == null) {
            // create a rendered position based on the passed position
            var pos = this.position;
            var zoom = this.cy.zoom();
            var pan = this.cy.pan();
            this.renderedPosition = {
                x: pos.x * zoom + pan.x,
                y: pos.y * zoom + pan.y
            };
        } // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || Date.now();
    },
    preventDefault: function preventDefault() {
        this.isDefaultPrevented = returnTrue;
        var e = this.originalEvent;
        if (!e) return;
         // if preventDefault exists run it on the original event
        if (e.preventDefault) e.preventDefault();
    },
    stopPropagation: function stopPropagation() {
        this.isPropagationStopped = returnTrue;
        var e = this.originalEvent;
        if (!e) return;
         // if stopPropagation exists run it on the original event
        if (e.stopPropagation) e.stopPropagation();
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
        this.isImmediatePropagationStopped = returnTrue;
        this.stopPropagation();
    },
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse
};
var eventRegex = /^([^.]+)(\.(?:[^.]+))?$/; // regex for matching event strings (e.g. "click.namespace")
var universalNamespace = ".*"; // matches as if no namespace specified and prevents users from unbinding accidentally
var defaults$8 = {
    qualifierCompare: function qualifierCompare(q1, q2) {
        return q1 === q2;
    },
    eventMatches: function /*context, listener, eventObj*/ eventMatches() {
        return true;
    },
    addEventFields: function /*context, evt*/ addEventFields() {},
    callbackContext: function callbackContext(context) {
        return context;
    },
    beforeEmit: function /* context, listener, eventObj */ beforeEmit() {},
    afterEmit: function /* context, listener, eventObj */ afterEmit() {},
    bubble: function /*context*/ bubble() {
        return false;
    },
    parent: function /*context*/ parent() {
        return null;
    },
    context: null
};
var defaultsKeys = Object.keys(defaults$8);
var emptyOpts = {};
function Emitter() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;
    var context = arguments.length > 1 ? arguments[1] : undefined;
    // micro-optimisation vs Object.assign() -- reduces Element instantiation time
    for(var i = 0; i < defaultsKeys.length; i++){
        var key = defaultsKeys[i];
        this[key] = opts[key] || defaults$8[key];
    }
    this.context = context || this.context;
    this.listeners = [];
    this.emitting = 0;
}
var p = Emitter.prototype;
var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {
    if (fn$6(qualifier)) {
        callback = qualifier;
        qualifier = null;
    }
    if (confOverrides) {
        if (conf == null) conf = confOverrides;
        else conf = extend({}, conf, confOverrides);
    }
    var eventList = array(events) ? events : events.split(/\s+/);
    for(var i = 0; i < eventList.length; i++){
        var evt = eventList[i];
        if (emptyString(evt)) continue;
        var match = evt.match(eventRegex); // type[.namespace]
        if (match) {
            var type = match[1];
            var namespace = match[2] ? match[2] : null;
            var ret = handler(self, evt, type, namespace, qualifier, callback, conf);
            if (ret === false) break;
             // allow exiting early
        }
    }
};
var makeEventObj = function makeEventObj(self, obj) {
    self.addEventFields(self.context, obj);
    return new Event(obj.type, obj);
};
var forEachEventObj = function forEachEventObj(self, handler, events) {
    if (event(events)) {
        handler(self, events);
        return;
    } else if (plainObject(events)) {
        handler(self, makeEventObj(self, events));
        return;
    }
    var eventList = array(events) ? events : events.split(/\s+/);
    for(var i = 0; i < eventList.length; i++){
        var evt = eventList[i];
        if (emptyString(evt)) continue;
        var match = evt.match(eventRegex); // type[.namespace]
        if (match) {
            var type = match[1];
            var namespace = match[2] ? match[2] : null;
            var eventObj = makeEventObj(self, {
                type: type,
                namespace: namespace,
                target: self.context
            });
            handler(self, eventObj);
        }
    }
};
p.on = p.addListener = function(events, qualifier, callback, conf, confOverrides) {
    forEachEvent(this, function(self, event, type, namespace, qualifier, callback, conf) {
        if (fn$6(callback)) self.listeners.push({
            event: event,
            // full event string
            callback: callback,
            // callback to run
            type: type,
            // the event type (e.g. 'click')
            namespace: namespace,
            // the event namespace (e.g. ".foo")
            qualifier: qualifier,
            // a restriction on whether to match this emitter
            conf: conf // additional configuration
        });
    }, events, qualifier, callback, conf, confOverrides);
    return this;
};
p.one = function(events, qualifier, callback, conf) {
    return this.on(events, qualifier, callback, conf, {
        one: true
    });
};
p.removeListener = p.off = function(events, qualifier, callback, conf) {
    var _this = this;
    if (this.emitting !== 0) this.listeners = copyArray(this.listeners);
    var listeners = this.listeners;
    var _loop = function _loop(i) {
        var listener = listeners[i];
        forEachEvent(_this, function(self, event, type, namespace, qualifier, callback) {
            if ((listener.type === type || events === "*") && (!namespace && listener.namespace !== ".*" || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {
                listeners.splice(i, 1);
                return false;
            }
        }, events, qualifier, callback, conf);
    };
    for(var i = listeners.length - 1; i >= 0; i--)_loop(i);
    return this;
};
p.removeAllListeners = function() {
    return this.removeListener("*");
};
p.emit = p.trigger = function(events, extraParams, manualCallback) {
    var listeners = this.listeners;
    var numListenersBeforeEmit = listeners.length;
    this.emitting++;
    if (!array(extraParams)) extraParams = [
        extraParams
    ];
    forEachEventObj(this, function(self, eventObj) {
        if (manualCallback != null) {
            listeners = [
                {
                    event: eventObj.event,
                    type: eventObj.type,
                    namespace: eventObj.namespace,
                    callback: manualCallback
                }
            ];
            numListenersBeforeEmit = listeners.length;
        }
        var _loop2 = function _loop2(i) {
            var listener = listeners[i];
            if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {
                var args = [
                    eventObj
                ];
                if (extraParams != null) push(args, extraParams);
                self.beforeEmit(self.context, listener, eventObj);
                if (listener.conf && listener.conf.one) self.listeners = self.listeners.filter(function(l) {
                    return l !== listener;
                });
                var context = self.callbackContext(self.context, listener, eventObj);
                var ret = listener.callback.apply(context, args);
                self.afterEmit(self.context, listener, eventObj);
                if (ret === false) {
                    eventObj.stopPropagation();
                    eventObj.preventDefault();
                }
            } // if listener matches
        };
        for(var i = 0; i < numListenersBeforeEmit; i++)_loop2(i);
         // for listener
        if (self.bubble(self.context) && !eventObj.isPropagationStopped()) self.parent(self.context).emit(eventObj, extraParams);
    }, events);
    this.emitting--;
    return this;
};
var emitterOptions$1 = {
    qualifierCompare: function qualifierCompare(selector1, selector2) {
        if (selector1 == null || selector2 == null) return selector1 == null && selector2 == null;
        else return selector1.sameText(selector2);
    },
    eventMatches: function eventMatches(ele, listener, eventObj) {
        var selector = listener.qualifier;
        if (selector != null) return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
        return true;
    },
    addEventFields: function addEventFields(ele, evt) {
        evt.cy = ele.cy();
        evt.target = ele;
    },
    callbackContext: function callbackContext(ele, listener, eventObj) {
        return listener.qualifier != null ? eventObj.target : ele;
    },
    beforeEmit: function beforeEmit(context, listener) {
        if (listener.conf && listener.conf.once) listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
    },
    bubble: function bubble() {
        return true;
    },
    parent: function parent(ele) {
        return ele.isChild() ? ele.parent() : ele.cy();
    }
};
var argSelector$1 = function argSelector(arg) {
    if (string(arg)) return new Selector(arg);
    else return arg;
};
var elesfn$9 = {
    createEmitter: function createEmitter() {
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            var _p = ele._private;
            if (!_p.emitter) _p.emitter = new Emitter(emitterOptions$1, ele);
        }
        return this;
    },
    emitter: function emitter() {
        return this._private.emitter;
    },
    on: function on(events, selector, callback) {
        var argSel = argSelector$1(selector);
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            ele.emitter().on(events, argSel, callback);
        }
        return this;
    },
    removeListener: function removeListener(events, selector, callback) {
        var argSel = argSelector$1(selector);
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            ele.emitter().removeListener(events, argSel, callback);
        }
        return this;
    },
    removeAllListeners: function removeAllListeners() {
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            ele.emitter().removeAllListeners();
        }
        return this;
    },
    one: function one(events, selector, callback) {
        var argSel = argSelector$1(selector);
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            ele.emitter().one(events, argSel, callback);
        }
        return this;
    },
    once: function once(events, selector, callback) {
        var argSel = argSelector$1(selector);
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            ele.emitter().on(events, argSel, callback, {
                once: true,
                onceCollection: this
            });
        }
    },
    emit: function emit(events, extraParams) {
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            ele.emitter().emit(events, extraParams);
        }
        return this;
    },
    emitAndNotify: function emitAndNotify(event, extraParams) {
        // for internal use only
        if (this.length === 0) return;
         // empty collections don't need to notify anything
        // notify renderer
        this.cy().notify(event, this);
        this.emit(event, extraParams);
        return this;
    }
};
define.eventAliasesOn(elesfn$9);
var elesfn$8 = {
    nodes: function nodes(selector) {
        return this.filter(function(ele) {
            return ele.isNode();
        }).filter(selector);
    },
    edges: function edges(selector) {
        return this.filter(function(ele) {
            return ele.isEdge();
        }).filter(selector);
    },
    // internal helper to get nodes and edges as separate collections with single iteration over elements
    byGroup: function byGroup() {
        var nodes = this.spawn();
        var edges = this.spawn();
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            if (ele.isNode()) nodes.push(ele);
            else edges.push(ele);
        }
        return {
            nodes: nodes,
            edges: edges
        };
    },
    filter: function filter(_filter, thisArg) {
        if (_filter === undefined) // check this first b/c it's the most common/performant case
        return this;
        else if (string(_filter) || elementOrCollection(_filter)) return new Selector(_filter).filter(this);
        else if (fn$6(_filter)) {
            var filterEles = this.spawn();
            var eles = this;
            for(var i = 0; i < eles.length; i++){
                var ele = eles[i];
                var include = thisArg ? _filter.apply(thisArg, [
                    ele,
                    i,
                    eles
                ]) : _filter(ele, i, eles);
                if (include) filterEles.push(ele);
            }
            return filterEles;
        }
        return this.spawn(); // if not handled by above, give 'em an empty collection
    },
    not: function not(toRemove) {
        if (!toRemove) return this;
        else {
            if (string(toRemove)) toRemove = this.filter(toRemove);
            var elements = this.spawn();
            for(var i = 0; i < this.length; i++){
                var element = this[i];
                var remove = toRemove.has(element);
                if (!remove) elements.push(element);
            }
            return elements;
        }
    },
    absoluteComplement: function absoluteComplement() {
        var cy = this.cy();
        return cy.mutableElements().not(this);
    },
    intersect: function intersect(other) {
        // if a selector is specified, then filter by it instead
        if (string(other)) {
            var selector = other;
            return this.filter(selector);
        }
        var elements = this.spawn();
        var col1 = this;
        var col2 = other;
        var col1Smaller = this.length < other.length;
        var colS = col1Smaller ? col1 : col2;
        var colL = col1Smaller ? col2 : col1;
        for(var i = 0; i < colS.length; i++){
            var ele = colS[i];
            if (colL.has(ele)) elements.push(ele);
        }
        return elements;
    },
    xor: function xor(other) {
        var cy = this._private.cy;
        if (string(other)) other = cy.$(other);
        var elements = this.spawn();
        var col1 = this;
        var col2 = other;
        var add = function add(col, other) {
            for(var i = 0; i < col.length; i++){
                var ele = col[i];
                var id = ele._private.data.id;
                var inOther = other.hasElementWithId(id);
                if (!inOther) elements.push(ele);
            }
        };
        add(col1, col2);
        add(col2, col1);
        return elements;
    },
    diff: function diff(other) {
        var cy = this._private.cy;
        if (string(other)) other = cy.$(other);
        var left = this.spawn();
        var right = this.spawn();
        var both = this.spawn();
        var col1 = this;
        var col2 = other;
        var add = function add(col, other, retEles) {
            for(var i = 0; i < col.length; i++){
                var ele = col[i];
                var id = ele._private.data.id;
                var inOther = other.hasElementWithId(id);
                if (inOther) both.merge(ele);
                else retEles.push(ele);
            }
        };
        add(col1, col2, left);
        add(col2, col1, right);
        return {
            left: left,
            right: right,
            both: both
        };
    },
    add: function add(toAdd) {
        var cy = this._private.cy;
        if (!toAdd) return this;
        if (string(toAdd)) {
            var selector = toAdd;
            toAdd = cy.mutableElements().filter(selector);
        }
        var elements = this.spawnSelf();
        for(var i = 0; i < toAdd.length; i++){
            var ele = toAdd[i];
            var add = !this.has(ele);
            if (add) elements.push(ele);
        }
        return elements;
    },
    // in place merge on calling collection
    merge: function merge(toAdd) {
        var _p = this._private;
        var cy = _p.cy;
        if (!toAdd) return this;
        if (toAdd && string(toAdd)) {
            var selector = toAdd;
            toAdd = cy.mutableElements().filter(selector);
        }
        var map = _p.map;
        for(var i = 0; i < toAdd.length; i++){
            var toAddEle = toAdd[i];
            var id = toAddEle._private.data.id;
            var add = !map.has(id);
            if (add) {
                var index = this.length++;
                this[index] = toAddEle;
                map.set(id, {
                    ele: toAddEle,
                    index: index
                });
            }
        }
        return this; // chaining
    },
    unmergeAt: function unmergeAt(i) {
        var ele = this[i];
        var id = ele.id();
        var _p = this._private;
        var map = _p.map; // remove ele
        this[i] = undefined;
        map["delete"](id);
        var unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection
        if (this.length > 1 && !unmergedLastEle) {
            var lastEleI = this.length - 1;
            var lastEle = this[lastEleI];
            var lastEleId = lastEle._private.data.id;
            this[lastEleI] = undefined;
            this[i] = lastEle;
            map.set(lastEleId, {
                ele: lastEle,
                index: i
            });
        } // the collection is now 1 ele smaller
        this.length--;
        return this;
    },
    // remove single ele in place in calling collection
    unmergeOne: function unmergeOne(ele) {
        ele = ele[0];
        var _p = this._private;
        var id = ele._private.data.id;
        var map = _p.map;
        var entry = map.get(id);
        if (!entry) return this; // no need to remove
        var i = entry.index;
        this.unmergeAt(i);
        return this;
    },
    // remove eles in place on calling collection
    unmerge: function unmerge(toRemove) {
        var cy = this._private.cy;
        if (!toRemove) return this;
        if (toRemove && string(toRemove)) {
            var selector = toRemove;
            toRemove = cy.mutableElements().filter(selector);
        }
        for(var i = 0; i < toRemove.length; i++)this.unmergeOne(toRemove[i]);
        return this; // chaining
    },
    unmergeBy: function unmergeBy(toRmFn) {
        for(var i = this.length - 1; i >= 0; i--){
            var ele = this[i];
            if (toRmFn(ele)) this.unmergeAt(i);
        }
        return this;
    },
    map: function map(mapFn, thisArg) {
        var arr = [];
        var eles = this;
        for(var i = 0; i < eles.length; i++){
            var ele = eles[i];
            var ret = thisArg ? mapFn.apply(thisArg, [
                ele,
                i,
                eles
            ]) : mapFn(ele, i, eles);
            arr.push(ret);
        }
        return arr;
    },
    reduce: function reduce(fn, initialValue) {
        var val = initialValue;
        var eles = this;
        for(var i = 0; i < eles.length; i++)val = fn(val, eles[i], i, eles);
        return val;
    },
    max: function max(valFn, thisArg) {
        var max = -Infinity;
        var maxEle;
        var eles = this;
        for(var i = 0; i < eles.length; i++){
            var ele = eles[i];
            var val = thisArg ? valFn.apply(thisArg, [
                ele,
                i,
                eles
            ]) : valFn(ele, i, eles);
            if (val > max) {
                max = val;
                maxEle = ele;
            }
        }
        return {
            value: max,
            ele: maxEle
        };
    },
    min: function min(valFn, thisArg) {
        var min = Infinity;
        var minEle;
        var eles = this;
        for(var i = 0; i < eles.length; i++){
            var ele = eles[i];
            var val = thisArg ? valFn.apply(thisArg, [
                ele,
                i,
                eles
            ]) : valFn(ele, i, eles);
            if (val < min) {
                min = val;
                minEle = ele;
            }
        }
        return {
            value: min,
            ele: minEle
        };
    }
}; // aliases
var fn$1 = elesfn$8;
fn$1["u"] = fn$1["|"] = fn$1["+"] = fn$1.union = fn$1.or = fn$1.add;
fn$1["\\"] = fn$1["!"] = fn$1["-"] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;
fn$1["n"] = fn$1["&"] = fn$1["."] = fn$1.and = fn$1.intersection = fn$1.intersect;
fn$1["^"] = fn$1["(+)"] = fn$1["(-)"] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;
fn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;
fn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;
var elesfn$7 = {
    isNode: function isNode() {
        return this.group() === "nodes";
    },
    isEdge: function isEdge() {
        return this.group() === "edges";
    },
    isLoop: function isLoop() {
        return this.isEdge() && this.source()[0] === this.target()[0];
    },
    isSimple: function isSimple() {
        return this.isEdge() && this.source()[0] !== this.target()[0];
    },
    group: function group() {
        var ele = this[0];
        if (ele) return ele._private.group;
    }
};
/**
 *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
 *  and z-index (low to high).  These styles affect how this applies:
 *
 *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
 *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
 *      root to leaves of the compound graph.  The last drawn is `top`.
 *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
 *      `manual` ignores this convention and draws based on the `z-index` value setting.
 *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
 *      `z-index` will be drawn on top of an element with a lower `z-index`.
 */ var zIndexSort = function zIndexSort(a, b) {
    var cy = a.cy();
    var hasCompoundNodes = cy.hasCompoundNodes();
    function getDepth(ele) {
        var style = ele.pstyle("z-compound-depth");
        if (style.value === "auto") return hasCompoundNodes ? ele.zDepth() : 0;
        else if (style.value === "bottom") return -1;
        else if (style.value === "top") return MAX_INT$1;
         // 'orphan'
        return 0;
    }
    var depthDiff = getDepth(a) - getDepth(b);
    if (depthDiff !== 0) return depthDiff;
    function getEleDepth(ele) {
        var style = ele.pstyle("z-index-compare");
        if (style.value === "auto") return ele.isNode() ? 1 : 0;
         // 'manual'
        return 0;
    }
    var eleDiff = getEleDepth(a) - getEleDepth(b);
    if (eleDiff !== 0) return eleDiff;
    var zDiff = a.pstyle("z-index").value - b.pstyle("z-index").value;
    if (zDiff !== 0) return zDiff;
     // compare indices in the core (order added to graph w/ last on top)
    return a.poolIndex() - b.poolIndex();
};
var elesfn$6 = {
    forEach: function forEach(fn, thisArg) {
        if (fn$6(fn)) {
            var N = this.length;
            for(var i = 0; i < N; i++){
                var ele = this[i];
                var ret = thisArg ? fn.apply(thisArg, [
                    ele,
                    i,
                    this
                ]) : fn(ele, i, this);
                if (ret === false) break;
                 // exit each early on return false
            }
        }
        return this;
    },
    toArray: function toArray() {
        var array = [];
        for(var i = 0; i < this.length; i++)array.push(this[i]);
        return array;
    },
    slice: function slice(start, end) {
        var array = [];
        var thisSize = this.length;
        if (end == null) end = thisSize;
        if (start == null) start = 0;
        if (start < 0) start = thisSize + start;
        if (end < 0) end = thisSize + end;
        for(var i = start; i >= 0 && i < end && i < thisSize; i++)array.push(this[i]);
        return this.spawn(array);
    },
    size: function size() {
        return this.length;
    },
    eq: function eq(i) {
        return this[i] || this.spawn();
    },
    first: function first() {
        return this[0] || this.spawn();
    },
    last: function last() {
        return this[this.length - 1] || this.spawn();
    },
    empty: function empty() {
        return this.length === 0;
    },
    nonempty: function nonempty() {
        return !this.empty();
    },
    sort: function sort(sortFn) {
        if (!fn$6(sortFn)) return this;
        var sorted = this.toArray().sort(sortFn);
        return this.spawn(sorted);
    },
    sortByZIndex: function sortByZIndex() {
        return this.sort(zIndexSort);
    },
    zDepth: function zDepth() {
        var ele = this[0];
        if (!ele) return undefined;
         // let cy = ele.cy();
        var _p = ele._private;
        var group = _p.group;
        if (group === "nodes") {
            var depth = _p.data.parent ? ele.parents().size() : 0;
            if (!ele.isParent()) return MAX_INT$1 - 1; // childless nodes always on top
            return depth;
        } else {
            var src = _p.source;
            var tgt = _p.target;
            var srcDepth = src.zDepth();
            var tgtDepth = tgt.zDepth();
            return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent
        }
    }
};
elesfn$6.each = elesfn$6.forEach;
var defineSymbolIterator = function defineSymbolIterator() {
    var typeofUndef = "undefined";
    var isIteratorSupported = (typeof Symbol === "undefined" ? "undefined" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef; // eslint-disable-line no-undef
    if (isIteratorSupported) elesfn$6[Symbol.iterator] = function() {
        var _this = this;
        // eslint-disable-line no-undef
        var entry = {
            value: undefined,
            done: false
        };
        var i = 0;
        var length = this.length;
        return _defineProperty({
            next: function next() {
                if (i < length) entry.value = _this[i++];
                else {
                    entry.value = undefined;
                    entry.done = true;
                }
                return entry;
            }
        }, Symbol.iterator, function() {
            // eslint-disable-line no-undef
            return this;
        });
    };
};
defineSymbolIterator();
var getLayoutDimensionOptions = defaults$g({
    nodeDimensionsIncludeLabels: false
});
var elesfn$5 = {
    // Calculates and returns node dimensions { x, y } based on options given
    layoutDimensions: function layoutDimensions(options) {
        options = getLayoutDimensionOptions(options);
        var dims;
        if (!this.takesUpSpace()) dims = {
            w: 0,
            h: 0
        };
        else if (options.nodeDimensionsIncludeLabels) {
            var bbDim = this.boundingBox();
            dims = {
                w: bbDim.w,
                h: bbDim.h
            };
        } else dims = {
            w: this.outerWidth(),
            h: this.outerHeight()
        };
         // sanitise the dimensions for external layouts (avoid division by zero)
        if (dims.w === 0 || dims.h === 0) dims.w = dims.h = 1;
        return dims;
    },
    // using standard layout options, apply position function (w/ or w/o animation)
    layoutPositions: function layoutPositions(layout, options, fn) {
        var nodes = this.nodes().filter(function(n) {
            return !n.isParent();
        });
        var cy = this.cy();
        var layoutEles = options.eles; // nodes & edges
        var getMemoizeKey = function getMemoizeKey(node) {
            return node.id();
        };
        var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function
        layout.emit({
            type: "layoutstart",
            layout: layout
        });
        layout.animations = [];
        var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {
            var center = {
                x: nodesBb.x1 + nodesBb.w / 2,
                y: nodesBb.y1 + nodesBb.h / 2
            };
            var spacingVector = {
                // scale from center of bounding box (not necessarily 0,0)
                x: (pos.x - center.x) * spacing,
                y: (pos.y - center.y) * spacing
            };
            return {
                x: center.x + spacingVector.x,
                y: center.y + spacingVector.y
            };
        };
        var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;
        var spacingBb = function spacingBb() {
            if (!useSpacingFactor) return null;
            var bb = makeBoundingBox();
            for(var i = 0; i < nodes.length; i++){
                var node = nodes[i];
                var pos = fnMem(node, i);
                expandBoundingBoxByPoint(bb, pos.x, pos.y);
            }
            return bb;
        };
        var bb = spacingBb();
        var getFinalPos = memoize(function(node, i) {
            var newPos = fnMem(node, i);
            if (useSpacingFactor) {
                var spacing = Math.abs(options.spacingFactor);
                newPos = calculateSpacing(spacing, bb, newPos);
            }
            if (options.transform != null) newPos = options.transform(node, newPos);
            return newPos;
        }, getMemoizeKey);
        if (options.animate) {
            for(var i = 0; i < nodes.length; i++){
                var node = nodes[i];
                var newPos = getFinalPos(node, i);
                var animateNode = options.animateFilter == null || options.animateFilter(node, i);
                if (animateNode) {
                    var ani = node.animation({
                        position: newPos,
                        duration: options.animationDuration,
                        easing: options.animationEasing
                    });
                    layout.animations.push(ani);
                } else node.position(newPos);
            }
            if (options.fit) {
                var fitAni = cy.animation({
                    fit: {
                        boundingBox: layoutEles.boundingBoxAt(getFinalPos),
                        padding: options.padding
                    },
                    duration: options.animationDuration,
                    easing: options.animationEasing
                });
                layout.animations.push(fitAni);
            } else if (options.zoom !== undefined && options.pan !== undefined) {
                var zoomPanAni = cy.animation({
                    zoom: options.zoom,
                    pan: options.pan,
                    duration: options.animationDuration,
                    easing: options.animationEasing
                });
                layout.animations.push(zoomPanAni);
            }
            layout.animations.forEach(function(ani) {
                return ani.play();
            });
            layout.one("layoutready", options.ready);
            layout.emit({
                type: "layoutready",
                layout: layout
            });
            Promise$1.all(layout.animations.map(function(ani) {
                return ani.promise();
            })).then(function() {
                layout.one("layoutstop", options.stop);
                layout.emit({
                    type: "layoutstop",
                    layout: layout
                });
            });
        } else {
            nodes.positions(getFinalPos);
            if (options.fit) cy.fit(options.eles, options.padding);
            if (options.zoom != null) cy.zoom(options.zoom);
            if (options.pan) cy.pan(options.pan);
            layout.one("layoutready", options.ready);
            layout.emit({
                type: "layoutready",
                layout: layout
            });
            layout.one("layoutstop", options.stop);
            layout.emit({
                type: "layoutstop",
                layout: layout
            });
        }
        return this; // chaining
    },
    layout: function layout(options) {
        var cy = this.cy();
        return cy.makeLayout(extend({}, options, {
            eles: this
        }));
    }
}; // aliases:
elesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;
function styleCache(key, fn, ele) {
    var _p = ele._private;
    var cache = _p.styleCache = _p.styleCache || [];
    var val;
    if ((val = cache[key]) != null) return val;
    else {
        val = cache[key] = fn(ele);
        return val;
    }
}
function cacheStyleFunction(key, fn) {
    key = hashString(key);
    return function cachedStyleFunction(ele) {
        return styleCache(key, fn, ele);
    };
}
function cachePrototypeStyleFunction(key, fn) {
    key = hashString(key);
    var selfFn = function selfFn(ele) {
        return fn.call(ele);
    };
    return function cachedPrototypeStyleFunction() {
        var ele = this[0];
        if (ele) return styleCache(key, selfFn, ele);
    };
}
var elesfn$4 = {
    recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {
        var cy = this.cy();
        var renderer = cy.renderer();
        var styleEnabled = cy.styleEnabled();
        if (renderer && styleEnabled) renderer.recalculateRenderedStyle(this, useCache);
        return this;
    },
    dirtyStyleCache: function dirtyStyleCache() {
        var cy = this.cy();
        var dirty = function dirty(ele) {
            return ele._private.styleCache = null;
        };
        if (cy.hasCompoundNodes()) {
            var eles;
            eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
            eles.merge(eles.connectedEdges());
            eles.forEach(dirty);
        } else this.forEach(function(ele) {
            dirty(ele);
            ele.connectedEdges().forEach(dirty);
        });
        return this;
    },
    // fully updates (recalculates) the style for the elements
    updateStyle: function updateStyle(notifyRenderer) {
        var cy = this._private.cy;
        if (!cy.styleEnabled()) return this;
        if (cy.batching()) {
            var bEles = cy._private.batchStyleEles;
            bEles.merge(this);
            return this; // chaining and exit early when batching
        }
        var hasCompounds = cy.hasCompoundNodes();
        var updatedEles = this;
        notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;
        if (hasCompounds) // then add everything up and down for compound selector checks
        updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
         // let changedEles = style.apply( updatedEles );
        var changedEles = updatedEles;
        if (notifyRenderer) changedEles.emitAndNotify("style"); // let renderer know we changed style
        else changedEles.emit("style"); // just fire the event
        updatedEles.forEach(function(ele) {
            return ele._private.styleDirty = true;
        });
        return this; // chaining
    },
    // private: clears dirty flag and recalculates style
    cleanStyle: function cleanStyle() {
        var cy = this.cy();
        if (!cy.styleEnabled()) return;
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            if (ele._private.styleDirty) {
                // n.b. this flag should be set before apply() to avoid potential infinite recursion
                ele._private.styleDirty = false;
                cy.style().apply(ele);
            }
        }
    },
    // get the internal parsed style object for the specified property
    parsedStyle: function parsedStyle(property) {
        var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var ele = this[0];
        var cy = ele.cy();
        if (!cy.styleEnabled()) return;
        if (ele) {
            this.cleanStyle();
            var overriddenStyle = ele._private.style[property];
            if (overriddenStyle != null) return overriddenStyle;
            else if (includeNonDefault) return cy.style().getDefaultProperty(property);
            else return null;
        }
    },
    numericStyle: function numericStyle(property) {
        var ele = this[0];
        if (!ele.cy().styleEnabled()) return;
        if (ele) {
            var pstyle = ele.pstyle(property);
            return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
        }
    },
    numericStyleUnits: function numericStyleUnits(property) {
        var ele = this[0];
        if (!ele.cy().styleEnabled()) return;
        if (ele) return ele.pstyle(property).units;
    },
    // get the specified css property as a rendered value (i.e. on-screen value)
    // or get the whole rendered style if no property specified (NB doesn't allow setting)
    renderedStyle: function renderedStyle(property) {
        var cy = this.cy();
        if (!cy.styleEnabled()) return this;
        var ele = this[0];
        if (ele) return cy.style().getRenderedStyle(ele, property);
    },
    // read the calculated css style of the element or override the style (via a bypass)
    style: function style(name, value) {
        var cy = this.cy();
        if (!cy.styleEnabled()) return this;
        var updateTransitions = false;
        var style = cy.style();
        if (plainObject(name)) {
            // then extend the bypass
            var props = name;
            style.applyBypass(this, props, updateTransitions);
            this.emitAndNotify("style"); // let the renderer know we've updated style
        } else if (string(name)) {
            if (value === undefined) {
                // then get the property from the style
                var ele = this[0];
                if (ele) return style.getStylePropertyValue(ele, name);
                else // empty collection => can't get any value
                return;
            } else {
                // then set the bypass with the property value
                style.applyBypass(this, name, value, updateTransitions);
                this.emitAndNotify("style"); // let the renderer know we've updated style
            }
        } else if (name === undefined) {
            var _ele = this[0];
            if (_ele) return style.getRawStyle(_ele);
            else // empty collection => can't get any value
            return;
        }
        return this; // chaining
    },
    removeStyle: function removeStyle(names) {
        var cy = this.cy();
        if (!cy.styleEnabled()) return this;
        var updateTransitions = false;
        var style = cy.style();
        var eles = this;
        if (names === undefined) for(var i = 0; i < eles.length; i++){
            var ele = eles[i];
            style.removeAllBypasses(ele, updateTransitions);
        }
        else {
            names = names.split(/\s+/);
            for(var _i = 0; _i < eles.length; _i++){
                var _ele2 = eles[_i];
                style.removeBypasses(_ele2, names, updateTransitions);
            }
        }
        this.emitAndNotify("style"); // let the renderer know we've updated style
        return this; // chaining
    },
    show: function show() {
        this.css("display", "element");
        return this; // chaining
    },
    hide: function hide() {
        this.css("display", "none");
        return this; // chaining
    },
    effectiveOpacity: function effectiveOpacity() {
        var cy = this.cy();
        if (!cy.styleEnabled()) return 1;
        var hasCompoundNodes = cy.hasCompoundNodes();
        var ele = this[0];
        if (ele) {
            var _p = ele._private;
            var parentOpacity = ele.pstyle("opacity").value;
            if (!hasCompoundNodes) return parentOpacity;
            var parents = !_p.data.parent ? null : ele.parents();
            if (parents) for(var i = 0; i < parents.length; i++){
                var parent = parents[i];
                var opacity = parent.pstyle("opacity").value;
                parentOpacity = opacity * parentOpacity;
            }
            return parentOpacity;
        }
    },
    transparent: function transparent() {
        var cy = this.cy();
        if (!cy.styleEnabled()) return false;
        var ele = this[0];
        var hasCompoundNodes = ele.cy().hasCompoundNodes();
        if (ele) {
            if (!hasCompoundNodes) return ele.pstyle("opacity").value === 0;
            else return ele.effectiveOpacity() === 0;
        }
    },
    backgrounding: function backgrounding() {
        var cy = this.cy();
        if (!cy.styleEnabled()) return false;
        var ele = this[0];
        return ele._private.backgrounding ? true : false;
    }
};
function checkCompound(ele, parentOk) {
    var _p = ele._private;
    var parents = _p.data.parent ? ele.parents() : null;
    if (parents) for(var i = 0; i < parents.length; i++){
        var parent = parents[i];
        if (!parentOk(parent)) return false;
    }
    return true;
}
function defineDerivedStateFunction(specs) {
    var ok = specs.ok;
    var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
    var parentOk = specs.parentOk || specs.ok;
    return function() {
        var cy = this.cy();
        if (!cy.styleEnabled()) return true;
        var ele = this[0];
        var hasCompoundNodes = cy.hasCompoundNodes();
        if (ele) {
            var _p = ele._private;
            if (!ok(ele)) return false;
            if (ele.isNode()) return !hasCompoundNodes || checkCompound(ele, parentOk);
            else {
                var src = _p.source;
                var tgt = _p.target;
                return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));
            }
        }
    };
}
var eleTakesUpSpace = cacheStyleFunction("eleTakesUpSpace", function(ele) {
    return ele.pstyle("display").value === "element" && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
});
elesfn$4.takesUpSpace = cachePrototypeStyleFunction("takesUpSpace", defineDerivedStateFunction({
    ok: eleTakesUpSpace
}));
var eleInteractive = cacheStyleFunction("eleInteractive", function(ele) {
    return ele.pstyle("events").value === "yes" && ele.pstyle("visibility").value === "visible" && eleTakesUpSpace(ele);
});
var parentInteractive = cacheStyleFunction("parentInteractive", function(parent) {
    return parent.pstyle("visibility").value === "visible" && eleTakesUpSpace(parent);
});
elesfn$4.interactive = cachePrototypeStyleFunction("interactive", defineDerivedStateFunction({
    ok: eleInteractive,
    parentOk: parentInteractive,
    edgeOkViaNode: eleTakesUpSpace
}));
elesfn$4.noninteractive = function() {
    var ele = this[0];
    if (ele) return !ele.interactive();
};
var eleVisible = cacheStyleFunction("eleVisible", function(ele) {
    return ele.pstyle("visibility").value === "visible" && ele.pstyle("opacity").pfValue !== 0 && eleTakesUpSpace(ele);
});
var edgeVisibleViaNode = eleTakesUpSpace;
elesfn$4.visible = cachePrototypeStyleFunction("visible", defineDerivedStateFunction({
    ok: eleVisible,
    edgeOkViaNode: edgeVisibleViaNode
}));
elesfn$4.hidden = function() {
    var ele = this[0];
    if (ele) return !ele.visible();
};
elesfn$4.isBundledBezier = cachePrototypeStyleFunction("isBundledBezier", function() {
    if (!this.cy().styleEnabled()) return false;
    return !this.removed() && this.pstyle("curve-style").value === "bezier" && this.takesUpSpace();
});
elesfn$4.bypass = elesfn$4.css = elesfn$4.style;
elesfn$4.renderedCss = elesfn$4.renderedStyle;
elesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;
elesfn$4.pstyle = elesfn$4.parsedStyle;
var elesfn$3 = {};
function defineSwitchFunction(params) {
    return function() {
        var args = arguments;
        var changedEles = []; // e.g. cy.nodes().select( data, handler )
        if (args.length === 2) {
            var data = args[0];
            var handler = args[1];
            this.on(params.event, data, handler);
        } else if (args.length === 1 && fn$6(args[0])) {
            var _handler = args[0];
            this.on(params.event, _handler);
        } else if (args.length === 0 || args.length === 1 && array(args[0])) {
            var addlEvents = args.length === 1 ? args[0] : null;
            for(var i = 0; i < this.length; i++){
                var ele = this[i];
                var able = !params.ableField || ele._private[params.ableField];
                var changed = ele._private[params.field] != params.value;
                if (params.overrideAble) {
                    var overrideAble = params.overrideAble(ele);
                    if (overrideAble !== undefined) {
                        able = overrideAble;
                        if (!overrideAble) return this;
                         // to save cycles assume not able for all on override
                    }
                }
                if (able) {
                    ele._private[params.field] = params.value;
                    if (changed) changedEles.push(ele);
                }
            }
            var changedColl = this.spawn(changedEles);
            changedColl.updateStyle(); // change of state => possible change of style
            changedColl.emit(params.event);
            if (addlEvents) changedColl.emit(addlEvents);
        }
        return this;
    };
}
function defineSwitchSet(params) {
    elesfn$3[params.field] = function() {
        var ele = this[0];
        if (ele) {
            if (params.overrideField) {
                var val = params.overrideField(ele);
                if (val !== undefined) return val;
            }
            return ele._private[params.field];
        }
    };
    elesfn$3[params.on] = defineSwitchFunction({
        event: params.on,
        field: params.field,
        ableField: params.ableField,
        overrideAble: params.overrideAble,
        value: true
    });
    elesfn$3[params.off] = defineSwitchFunction({
        event: params.off,
        field: params.field,
        ableField: params.ableField,
        overrideAble: params.overrideAble,
        value: false
    });
}
defineSwitchSet({
    field: "locked",
    overrideField: function overrideField(ele) {
        return ele.cy().autolock() ? true : undefined;
    },
    on: "lock",
    off: "unlock"
});
defineSwitchSet({
    field: "grabbable",
    overrideField: function overrideField(ele) {
        return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;
    },
    on: "grabify",
    off: "ungrabify"
});
defineSwitchSet({
    field: "selected",
    ableField: "selectable",
    overrideAble: function overrideAble(ele) {
        return ele.cy().autounselectify() ? false : undefined;
    },
    on: "select",
    off: "unselect"
});
defineSwitchSet({
    field: "selectable",
    overrideField: function overrideField(ele) {
        return ele.cy().autounselectify() ? false : undefined;
    },
    on: "selectify",
    off: "unselectify"
});
elesfn$3.deselect = elesfn$3.unselect;
elesfn$3.grabbed = function() {
    var ele = this[0];
    if (ele) return ele._private.grabbed;
};
defineSwitchSet({
    field: "active",
    on: "activate",
    off: "unactivate"
});
defineSwitchSet({
    field: "pannable",
    on: "panify",
    off: "unpanify"
});
elesfn$3.inactive = function() {
    var ele = this[0];
    if (ele) return !ele._private.active;
};
var elesfn$2 = {}; // DAG functions
////////////////
var defineDagExtremity = function defineDagExtremity(params) {
    return function dagExtremityImpl(selector) {
        var eles = this;
        var ret = [];
        for(var i = 0; i < eles.length; i++){
            var ele = eles[i];
            if (!ele.isNode()) continue;
            var disqualified = false;
            var edges = ele.connectedEdges();
            for(var j = 0; j < edges.length; j++){
                var edge = edges[j];
                var src = edge.source();
                var tgt = edge.target();
                if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
                    disqualified = true;
                    break;
                }
            }
            if (!disqualified) ret.push(ele);
        }
        return this.spawn(ret, true).filter(selector);
    };
};
var defineDagOneHop = function defineDagOneHop(params) {
    return function(selector) {
        var eles = this;
        var oEles = [];
        for(var i = 0; i < eles.length; i++){
            var ele = eles[i];
            if (!ele.isNode()) continue;
            var edges = ele.connectedEdges();
            for(var j = 0; j < edges.length; j++){
                var edge = edges[j];
                var src = edge.source();
                var tgt = edge.target();
                if (params.outgoing && src === ele) {
                    oEles.push(edge);
                    oEles.push(tgt);
                } else if (params.incoming && tgt === ele) {
                    oEles.push(edge);
                    oEles.push(src);
                }
            }
        }
        return this.spawn(oEles, true).filter(selector);
    };
};
var defineDagAllHops = function defineDagAllHops(params) {
    return function(selector) {
        var eles = this;
        var sEles = [];
        var sElesIds = {};
        for(;;){
            var next = params.outgoing ? eles.outgoers() : eles.incomers();
            if (next.length === 0) break;
             // done if none left
            var newNext = false;
            for(var i = 0; i < next.length; i++){
                var n = next[i];
                var nid = n.id();
                if (!sElesIds[nid]) {
                    sElesIds[nid] = true;
                    sEles.push(n);
                    newNext = true;
                }
            }
            if (!newNext) break;
             // done if touched all outgoers already
            eles = next;
        }
        return this.spawn(sEles, true).filter(selector);
    };
};
elesfn$2.clearTraversalCache = function() {
    for(var i = 0; i < this.length; i++)this[i]._private.traversalCache = null;
};
extend(elesfn$2, {
    // get the root nodes in the DAG
    roots: defineDagExtremity({
        noIncomingEdges: true
    }),
    // get the leaf nodes in the DAG
    leaves: defineDagExtremity({
        noOutgoingEdges: true
    }),
    // normally called children in graph theory
    // these nodes =edges=> outgoing nodes
    outgoers: cache(defineDagOneHop({
        outgoing: true
    }), "outgoers"),
    // aka DAG descendants
    successors: defineDagAllHops({
        outgoing: true
    }),
    // normally called parents in graph theory
    // these nodes <=edges= incoming nodes
    incomers: cache(defineDagOneHop({
        incoming: true
    }), "incomers"),
    // aka DAG ancestors
    predecessors: defineDagAllHops({
        incoming: true
    })
}); // Neighbourhood functions
//////////////////////////
extend(elesfn$2, {
    neighborhood: cache(function(selector) {
        var elements = [];
        var nodes = this.nodes();
        for(var i = 0; i < nodes.length; i++){
            // for all nodes
            var node = nodes[i];
            var connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node
            for(var j = 0; j < connectedEdges.length; j++){
                var edge = connectedEdges[j];
                var src = edge.source();
                var tgt = edge.target();
                var otherNode = node === src ? tgt : src; // need check in case of loop
                if (otherNode.length > 0) elements.push(otherNode[0]); // add node 1 hop away
                 // add connected edge
                elements.push(edge[0]);
            }
        }
        return this.spawn(elements, true).filter(selector);
    }, "neighborhood"),
    closedNeighborhood: function closedNeighborhood(selector) {
        return this.neighborhood().add(this).filter(selector);
    },
    openNeighborhood: function openNeighborhood(selector) {
        return this.neighborhood(selector);
    }
}); // aliases
elesfn$2.neighbourhood = elesfn$2.neighborhood;
elesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;
elesfn$2.openNeighbourhood = elesfn$2.openNeighborhood; // Edge functions
/////////////////
extend(elesfn$2, {
    source: cache(function sourceImpl(selector) {
        var ele = this[0];
        var src;
        if (ele) src = ele._private.source || ele.cy().collection();
        return src && selector ? src.filter(selector) : src;
    }, "source"),
    target: cache(function targetImpl(selector) {
        var ele = this[0];
        var tgt;
        if (ele) tgt = ele._private.target || ele.cy().collection();
        return tgt && selector ? tgt.filter(selector) : tgt;
    }, "target"),
    sources: defineSourceFunction({
        attr: "source"
    }),
    targets: defineSourceFunction({
        attr: "target"
    })
});
function defineSourceFunction(params) {
    return function sourceImpl(selector) {
        var sources = [];
        for(var i = 0; i < this.length; i++){
            var ele = this[i];
            var src = ele._private[params.attr];
            if (src) sources.push(src);
        }
        return this.spawn(sources, true).filter(selector);
    };
}
extend(elesfn$2, {
    edgesWith: cache(defineEdgesWithFunction(), "edgesWith"),
    edgesTo: cache(defineEdgesWithFunction({
        thisIsSrc: true
    }), "edgesTo")
});
function defineEdgesWithFunction(params) {
    return function edgesWithImpl(otherNodes) {
        var elements = [];
        var cy = this._private.cy;
        var p = params || {}; // get elements if a selector is specified
        if (string(otherNodes)) otherNodes = cy.$(otherNodes);
        for(var h = 0; h < otherNodes.length; h++){
            var edges = otherNodes[h]._private.edges;
            for(var i = 0; i < edges.length; i++){
                var edge = edges[i];
                var edgeData = edge._private.data;
                var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
                var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
                var edgeConnectsThisAndOther = thisToOther || otherToThis;
                if (!edgeConnectsThisAndOther) continue;
                if (p.thisIsSrc || p.thisIsTgt) {
                    if (p.thisIsSrc && !thisToOther) continue;
                    if (p.thisIsTgt && !otherToThis) continue;
                }
                elements.push(edge);
            }
        }
        return this.spawn(elements, true);
    };
}
extend(elesfn$2, {
    connectedEdges: cache(function(selector) {
        var retEles = [];
        var eles = this;
        for(var i = 0; i < eles.length; i++){
            var node = eles[i];
            if (!node.isNode()) continue;
            var edges = node._private.edges;
            for(var j = 0; j < edges.length; j++){
                var edge = edges[j];
                retEles.push(edge);
            }
        }
        return this.spawn(retEles, true).filter(selector);
    }, "connectedEdges"),
    connectedNodes: cache(function(selector) {
        var retEles = [];
        var eles = this;
        for(var i = 0; i < eles.length; i++){
            var edge = eles[i];
            if (!edge.isEdge()) continue;
            retEles.push(edge.source()[0]);
            retEles.push(edge.target()[0]);
        }
        return this.spawn(retEles, true).filter(selector);
    }, "connectedNodes"),
    parallelEdges: cache(defineParallelEdgesFunction(), "parallelEdges"),
    codirectedEdges: cache(defineParallelEdgesFunction({
        codirected: true
    }), "codirectedEdges")
});
function defineParallelEdgesFunction(params) {
    var defaults = {
        codirected: false
    };
    params = extend({}, defaults, params);
    return function parallelEdgesImpl(selector) {
        // micro-optimised for renderer
        var elements = [];
        var edges = this.edges();
        var p = params; // look at all the edges in the collection
        for(var i = 0; i < edges.length; i++){
            var edge1 = edges[i];
            var edge1_p = edge1._private;
            var src1 = edge1_p.source;
            var srcid1 = src1._private.data.id;
            var tgtid1 = edge1_p.data.target;
            var srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge
            for(var j = 0; j < srcEdges1.length; j++){
                var edge2 = srcEdges1[j];
                var edge2data = edge2._private.data;
                var tgtid2 = edge2data.target;
                var srcid2 = edge2data.source;
                var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
                var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;
                if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) elements.push(edge2);
            }
        }
        return this.spawn(elements, true).filter(selector);
    };
} // Misc functions
/////////////////
extend(elesfn$2, {
    components: function components(root) {
        var self = this;
        var cy = self.cy();
        var visited = cy.collection();
        var unvisited = root == null ? self.nodes() : root.nodes();
        var components = [];
        if (root != null && unvisited.empty()) // root may contain only edges
        unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides
        var visitInComponent = function visitInComponent(node, component) {
            visited.merge(node);
            unvisited.unmerge(node);
            component.merge(node);
        };
        if (unvisited.empty()) return self.spawn();
        var _loop = function _loop() {
            // each iteration yields a component
            var cmpt = cy.collection();
            components.push(cmpt);
            var root = unvisited[0];
            visitInComponent(root, cmpt);
            self.bfs({
                directed: false,
                roots: root,
                visit: function visit(v) {
                    return visitInComponent(v, cmpt);
                }
            });
            cmpt.forEach(function(node) {
                node.connectedEdges().forEach(function(e) {
                    // connectedEdges() usually cached
                    if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) // has() is cheap
                    cmpt.merge(e); // forEach() only considers nodes -- sets N at call time
                });
            });
        };
        do _loop();
        while (unvisited.length > 0);
        return components;
    },
    component: function component() {
        var ele = this[0];
        return ele.cy().mutableElements().components(ele)[0];
    }
});
elesfn$2.componentsOf = elesfn$2.components;
var Collection = function Collection(cy, elements) {
    var unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (cy === undefined) {
        error("A collection must have a reference to the core");
        return;
    }
    var map = new Map$1();
    var createdElements = false;
    if (!elements) elements = [];
    else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {
        createdElements = true; // make elements from json and restore all at once later
        var eles = [];
        var elesIds = new Set$1();
        for(var i = 0, l = elements.length; i < l; i++){
            var json = elements[i];
            if (json.data == null) json.data = {};
            var _data = json.data; // make sure newly created elements have valid ids
            if (_data.id == null) _data.id = uuid();
            else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) continue; // can't create element if prior id already exists
            var ele = new Element(cy, json, false);
            eles.push(ele);
            elesIds.add(_data.id);
        }
        elements = eles;
    }
    this.length = 0;
    for(var _i = 0, _l = elements.length; _i < _l; _i++){
        var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements
        if (element$1 == null) continue;
        var id = element$1._private.data.id;
        if (!unique || !map.has(id)) {
            if (unique) map.set(id, {
                index: this.length,
                ele: element$1
            });
            this[this.length] = element$1;
            this.length++;
        }
    }
    this._private = {
        eles: this,
        cy: cy,
        get map () {
            if (this.lazyMap == null) this.rebuildMap();
            return this.lazyMap;
        },
        set map (m){
            this.lazyMap = m;
        },
        rebuildMap: function rebuildMap() {
            var m1 = this.lazyMap = new Map$1();
            var eles = this.eles;
            for(var _i2 = 0; _i2 < eles.length; _i2++){
                var _ele = eles[_i2];
                m1.set(_ele.id(), {
                    index: _i2,
                    ele: _ele
                });
            }
        }
    };
    if (unique) this._private.map = map;
     // restore the elements if we created them from json
    if (createdElements) this.restore();
}; // Functions
////////////////////////////////////////////////////////////////////////////////////////////////////
// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes
var elesfn$1 = Element.prototype = Collection.prototype = Object.create(Array.prototype);
elesfn$1.instanceString = function() {
    return "collection";
};
elesfn$1.spawn = function(eles, unique) {
    return new Collection(this.cy(), eles, unique);
};
elesfn$1.spawnSelf = function() {
    return this.spawn(this);
};
elesfn$1.cy = function() {
    return this._private.cy;
};
elesfn$1.renderer = function() {
    return this._private.cy.renderer();
};
elesfn$1.element = function() {
    return this[0];
};
elesfn$1.collection = function() {
    if (collection(this)) return this;
    else // an element
    return new Collection(this._private.cy, [
        this
    ]);
};
elesfn$1.unique = function() {
    return new Collection(this._private.cy, this, true);
};
elesfn$1.hasElementWithId = function(id) {
    id = "" + id; // id must be string
    return this._private.map.has(id);
};
elesfn$1.getElementById = function(id) {
    id = "" + id; // id must be string
    var cy = this._private.cy;
    var entry = this._private.map.get(id);
    return entry ? entry.ele : new Collection(cy); // get ele or empty collection
};
elesfn$1.$id = elesfn$1.getElementById;
elesfn$1.poolIndex = function() {
    var cy = this._private.cy;
    var eles = cy._private.elements;
    var id = this[0]._private.data.id;
    return eles._private.map.get(id).index;
};
elesfn$1.indexOf = function(ele) {
    var id = ele[0]._private.data.id;
    return this._private.map.get(id).index;
};
elesfn$1.indexOfId = function(id) {
    id = "" + id; // id must be string
    return this._private.map.get(id).index;
};
elesfn$1.json = function(obj) {
    var ele = this.element();
    var cy = this.cy();
    if (ele == null && obj) return this;
     // can't set to no eles
    if (ele == null) return undefined;
     // can't get from no eles
    var p = ele._private;
    if (plainObject(obj)) {
        // set
        cy.startBatch();
        if (obj.data) {
            ele.data(obj.data);
            var _data2 = p.data;
            if (ele.isEdge()) {
                // source and target are immutable via data()
                var move = false;
                var spec = {};
                var src = obj.data.source;
                var tgt = obj.data.target;
                if (src != null && src != _data2.source) {
                    spec.source = "" + src; // id must be string
                    move = true;
                }
                if (tgt != null && tgt != _data2.target) {
                    spec.target = "" + tgt; // id must be string
                    move = true;
                }
                if (move) ele = ele.move(spec);
            } else {
                // parent is immutable via data()
                var newParentValSpecd = "parent" in obj.data;
                var parent = obj.data.parent;
                if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {
                    if (parent === undefined) // can't set undefined imperatively, so use null
                    parent = null;
                    if (parent != null) parent = "" + parent; // id must be string
                    ele = ele.move({
                        parent: parent
                    });
                }
            }
        }
        if (obj.position) ele.position(obj.position);
         // ignore group -- immutable
        var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {
            var obj_k = obj[k];
            if (obj_k != null && obj_k !== p[k]) {
                if (obj_k) ele[trueFnName]();
                else ele[falseFnName]();
            }
        };
        checkSwitch("removed", "remove", "restore");
        checkSwitch("selected", "select", "unselect");
        checkSwitch("selectable", "selectify", "unselectify");
        checkSwitch("locked", "lock", "unlock");
        checkSwitch("grabbable", "grabify", "ungrabify");
        checkSwitch("pannable", "panify", "unpanify");
        if (obj.classes != null) ele.classes(obj.classes);
        cy.endBatch();
        return this;
    } else if (obj === undefined) {
        // get
        var json = {
            data: copy(p.data),
            position: copy(p.position),
            group: p.group,
            removed: p.removed,
            selected: p.selected,
            selectable: p.selectable,
            locked: p.locked,
            grabbable: p.grabbable,
            pannable: p.pannable,
            classes: null
        };
        json.classes = "";
        var i = 0;
        p.classes.forEach(function(cls) {
            return json.classes += (i++) === 0 ? cls : " " + cls;
        });
        return json;
    }
};
elesfn$1.jsons = function() {
    var jsons = [];
    for(var i = 0; i < this.length; i++){
        var ele = this[i];
        var json = ele.json();
        jsons.push(json);
    }
    return jsons;
};
elesfn$1.clone = function() {
    var cy = this.cy();
    var elesArr = [];
    for(var i = 0; i < this.length; i++){
        var ele = this[i];
        var json = ele.json();
        var clone = new Element(cy, json, false); // NB no restore
        elesArr.push(clone);
    }
    return new Collection(cy, elesArr);
};
elesfn$1.copy = elesfn$1.clone;
elesfn$1.restore = function() {
    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var self = this;
    var cy = self.cy();
    var cy_p = cy._private; // create arrays of nodes and edges, since we need to
    // restore the nodes first
    var nodes = [];
    var edges = [];
    var elements;
    for(var _i3 = 0, l = self.length; _i3 < l; _i3++){
        var ele = self[_i3];
        if (addToPool && !ele.removed()) continue;
         // keep nodes first in the array and edges after
        if (ele.isNode()) // put to front of array if node
        nodes.push(ele);
        else // put to end of array if edge
        edges.push(ele);
    }
    elements = nodes.concat(edges);
    var i;
    var removeFromElements = function removeFromElements() {
        elements.splice(i, 1);
        i--;
    }; // now, restore each element
    for(i = 0; i < elements.length; i++){
        var _ele2 = elements[i];
        var _private = _ele2._private;
        var _data3 = _private.data; // the traversal cache should start fresh when ele is added
        _ele2.clearTraversalCache(); // set id and validate
        if (!addToPool && !_private.removed) ;
        else if (_data3.id === undefined) _data3.id = uuid();
        else if (number$1(_data3.id)) _data3.id = "" + _data3.id; // now it's a string
        else if (emptyString(_data3.id) || !string(_data3.id)) {
            error("Can not create element with invalid string ID `" + _data3.id + "`"); // can't create element if it has empty string as id or non-string id
            removeFromElements();
            continue;
        } else if (cy.hasElementWithId(_data3.id)) {
            error("Can not create second element with ID `" + _data3.id + "`"); // can't create element if one already has that id
            removeFromElements();
            continue;
        }
        var id = _data3.id; // id is finalised, now let's keep a ref
        if (_ele2.isNode()) {
            // extra checks for nodes
            var pos = _private.position; // make sure the nodes have a defined position
            if (pos.x == null) pos.x = 0;
            if (pos.y == null) pos.y = 0;
        }
        if (_ele2.isEdge()) {
            // extra checks for edges
            var edge = _ele2;
            var fields = [
                "source",
                "target"
            ];
            var fieldsLength = fields.length;
            var badSourceOrTarget = false;
            for(var j = 0; j < fieldsLength; j++){
                var field = fields[j];
                var val = _data3[field];
                if (number$1(val)) val = _data3[field] = "" + _data3[field]; // now string
                if (val == null || val === "") {
                    // can't create if source or target is not defined properly
                    error("Can not create edge `" + id + "` with unspecified " + field);
                    badSourceOrTarget = true;
                } else if (!cy.hasElementWithId(val)) {
                    // can't create edge if one of its nodes doesn't exist
                    error("Can not create edge `" + id + "` with nonexistant " + field + " `" + val + "`");
                    badSourceOrTarget = true;
                }
            }
            if (badSourceOrTarget) {
                removeFromElements();
                continue;
            } // can't create this
            var src = cy.getElementById(_data3.source);
            var tgt = cy.getElementById(_data3.target); // only one edge in node if loop
            if (src.same(tgt)) src._private.edges.push(edge);
            else {
                src._private.edges.push(edge);
                tgt._private.edges.push(edge);
            }
            edge._private.source = src;
            edge._private.target = tgt;
        } // if is edge
        // create mock ids / indexes maps for element so it can be used like collections
        _private.map = new Map$1();
        _private.map.set(id, {
            ele: _ele2,
            index: 0
        });
        _private.removed = false;
        if (addToPool) cy.addToPool(_ele2);
    } // for each element
    // do compound node sanity checks
    for(var _i4 = 0; _i4 < nodes.length; _i4++){
        // each node
        var node = nodes[_i4];
        var _data4 = node._private.data;
        if (number$1(_data4.parent)) // then automake string
        _data4.parent = "" + _data4.parent;
        var parentId = _data4.parent;
        var specifiedParent = parentId != null;
        if (specifiedParent) {
            var parent = cy.getElementById(parentId);
            if (parent.empty()) // non-existant parent; just remove it
            _data4.parent = undefined;
            else {
                var selfAsParent = false;
                var ancestor = parent;
                while(!ancestor.empty()){
                    if (node.same(ancestor)) {
                        // mark self as parent and remove from data
                        selfAsParent = true;
                        _data4.parent = undefined; // remove parent reference
                        break;
                    }
                    ancestor = ancestor.parent();
                }
                if (!selfAsParent) {
                    // connect with children
                    parent[0]._private.children.push(node);
                    node._private.parent = parent[0]; // let the core know we have a compound graph
                    cy_p.hasCompoundNodes = true;
                }
            } // else
        } // if specified parent
    } // for each node
    if (elements.length > 0) {
        var restored = elements.length === self.length ? self : new Collection(cy, elements);
        for(var _i5 = 0; _i5 < restored.length; _i5++){
            var _ele3 = restored[_i5];
            if (_ele3.isNode()) continue;
             // adding an edge invalidates the traversal caches for the parallel edges
            _ele3.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes
            _ele3.source().clearTraversalCache();
            _ele3.target().clearTraversalCache();
        }
        var toUpdateStyle;
        if (cy_p.hasCompoundNodes) toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
        else toUpdateStyle = restored;
        toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);
        if (notifyRenderer) restored.emitAndNotify("add");
        else if (addToPool) restored.emit("add");
    }
    return self; // chainability
};
elesfn$1.removed = function() {
    var ele = this[0];
    return ele && ele._private.removed;
};
elesfn$1.inside = function() {
    var ele = this[0];
    return ele && !ele._private.removed;
};
elesfn$1.remove = function() {
    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var self = this;
    var elesToRemove = [];
    var elesToRemoveIds = {};
    var cy = self._private.cy; // add connected edges
    function addConnectedEdges(node) {
        var edges = node._private.edges;
        for(var i = 0; i < edges.length; i++)add(edges[i]);
    } // add descendant nodes
    function addChildren(node) {
        var children = node._private.children;
        for(var i = 0; i < children.length; i++)add(children[i]);
    }
    function add(ele) {
        var alreadyAdded = elesToRemoveIds[ele.id()];
        if (removeFromPool && ele.removed() || alreadyAdded) return;
        else elesToRemoveIds[ele.id()] = true;
        if (ele.isNode()) {
            elesToRemove.push(ele); // nodes are removed last
            addConnectedEdges(ele);
            addChildren(ele);
        } else elesToRemove.unshift(ele); // edges are removed first
    } // make the list of elements to remove
    // (may be removing more than specified due to connected edges etc)
    for(var i = 0, l = self.length; i < l; i++){
        var ele = self[i];
        add(ele);
    }
    function removeEdgeRef(node, edge) {
        var connectedEdges = node._private.edges;
        removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes
        node.clearTraversalCache();
    }
    function removeParallelRef(pllEdge) {
        // removing an edge invalidates the traversal caches for the parallel edges
        pllEdge.clearTraversalCache();
    }
    var alteredParents = [];
    alteredParents.ids = {};
    function removeChildRef(parent, ele) {
        ele = ele[0];
        parent = parent[0];
        var children = parent._private.children;
        var pid = parent.id();
        removeFromArray(children, ele); // remove parent => child ref
        ele._private.parent = null; // remove child => parent ref
        if (!alteredParents.ids[pid]) {
            alteredParents.ids[pid] = true;
            alteredParents.push(parent);
        }
    }
    self.dirtyCompoundBoundsCache();
    if (removeFromPool) cy.removeFromPool(elesToRemove); // remove from core pool
    for(var _i6 = 0; _i6 < elesToRemove.length; _i6++){
        var _ele4 = elesToRemove[_i6];
        if (_ele4.isEdge()) {
            // remove references to this edge in its connected nodes
            var src = _ele4.source()[0];
            var tgt = _ele4.target()[0];
            removeEdgeRef(src, _ele4);
            removeEdgeRef(tgt, _ele4);
            var pllEdges = _ele4.parallelEdges();
            for(var j = 0; j < pllEdges.length; j++){
                var pllEdge = pllEdges[j];
                removeParallelRef(pllEdge);
                if (pllEdge.isBundledBezier()) pllEdge.dirtyBoundingBoxCache();
            }
        } else {
            // remove reference to parent
            var parent = _ele4.parent();
            if (parent.length !== 0) removeChildRef(parent, _ele4);
        }
        if (removeFromPool) // mark as removed
        _ele4._private.removed = true;
    } // check to see if we have a compound graph or not
    var elesStillInside = cy._private.elements;
    cy._private.hasCompoundNodes = false;
    for(var _i7 = 0; _i7 < elesStillInside.length; _i7++){
        var _ele5 = elesStillInside[_i7];
        if (_ele5.isParent()) {
            cy._private.hasCompoundNodes = true;
            break;
        }
    }
    var removedElements = new Collection(this.cy(), elesToRemove);
    if (removedElements.size() > 0) {
        // must manually notify since trigger won't do this automatically once removed
        if (notifyRenderer) removedElements.emitAndNotify("remove");
        else if (removeFromPool) removedElements.emit("remove");
    } // the parents who were modified by the removal need their style updated
    for(var _i8 = 0; _i8 < alteredParents.length; _i8++){
        var _ele6 = alteredParents[_i8];
        if (!removeFromPool || !_ele6.removed()) _ele6.updateStyle();
    }
    return removedElements;
};
elesfn$1.move = function(struct) {
    var cy = this._private.cy;
    var eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring
    // (our calls to remove/restore do not remove from the graph or make events)
    var notifyRenderer = false;
    var modifyPool = false;
    var toString = function toString(id) {
        return id == null ? id : "" + id;
    }; // id must be string
    if (struct.source !== undefined || struct.target !== undefined) {
        var srcId = toString(struct.source);
        var tgtId = toString(struct.target);
        var srcExists = srcId != null && cy.hasElementWithId(srcId);
        var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);
        if (srcExists || tgtExists) {
            cy.batch(function() {
                // avoid duplicate style updates
                eles.remove(notifyRenderer, modifyPool); // clean up refs etc.
                eles.emitAndNotify("moveout");
                for(var i = 0; i < eles.length; i++){
                    var ele = eles[i];
                    var _data5 = ele._private.data;
                    if (ele.isEdge()) {
                        if (srcExists) _data5.source = srcId;
                        if (tgtExists) _data5.target = tgtId;
                    }
                }
                eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
            });
            eles.emitAndNotify("move");
        }
    } else if (struct.parent !== undefined) {
        // move node to new parent
        var parentId = toString(struct.parent);
        var parentExists = parentId === null || cy.hasElementWithId(parentId);
        if (parentExists) {
            var pidToAssign = parentId === null ? undefined : parentId;
            cy.batch(function() {
                // avoid duplicate style updates
                var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.
                updated.emitAndNotify("moveout");
                for(var i = 0; i < eles.length; i++){
                    var ele = eles[i];
                    var _data6 = ele._private.data;
                    if (ele.isNode()) _data6.parent = pidToAssign;
                }
                updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
            });
            eles.emitAndNotify("move");
        }
    }
    return this;
};
[
    elesfn$j,
    elesfn$i,
    elesfn$h,
    elesfn$g,
    elesfn$f,
    data,
    elesfn$d,
    dimensions,
    elesfn$9,
    elesfn$8,
    elesfn$7,
    elesfn$6,
    elesfn$5,
    elesfn$4,
    elesfn$3,
    elesfn$2
].forEach(function(props) {
    extend(elesfn$1, props);
});
var corefn$9 = {
    add: function add(opts) {
        var elements;
        var cy = this; // add the elements
        if (elementOrCollection(opts)) {
            var eles = opts;
            if (eles._private.cy === cy) // same instance => just restore
            elements = eles.restore();
            else {
                // otherwise, copy from json
                var jsons = [];
                for(var i = 0; i < eles.length; i++){
                    var ele = eles[i];
                    jsons.push(ele.json());
                }
                elements = new Collection(cy, jsons);
            }
        } else if (array(opts)) {
            var _jsons = opts;
            elements = new Collection(cy, _jsons);
        } else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {
            var elesByGroup = opts;
            var _jsons2 = [];
            var grs = [
                "nodes",
                "edges"
            ];
            for(var _i = 0, il = grs.length; _i < il; _i++){
                var group = grs[_i];
                var elesArray = elesByGroup[group];
                if (array(elesArray)) for(var j = 0, jl = elesArray.length; j < jl; j++){
                    var json = extend({
                        group: group
                    }, elesArray[j]);
                    _jsons2.push(json);
                }
            }
            elements = new Collection(cy, _jsons2);
        } else {
            var _json = opts;
            elements = new Element(cy, _json).collection();
        }
        return elements;
    },
    remove: function remove(collection) {
        if (elementOrCollection(collection)) ;
        else if (string(collection)) {
            var selector = collection;
            collection = this.$(selector);
        }
        return collection.remove();
    }
};
/* global Float32Array */ /*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */ function generateCubicBezier(mX1, mY1, mX2, mY2) {
    var NEWTON_ITERATIONS = 4, NEWTON_MIN_SLOPE = 0.001, SUBDIVISION_PRECISION = 0.0000001, SUBDIVISION_MAX_ITERATIONS = 10, kSplineTableSize = 11, kSampleStepSize = 1.0 / (kSplineTableSize - 1.0), float32ArraySupported = typeof Float32Array !== "undefined";
    /* Must contain four arguments. */ if (arguments.length !== 4) return false;
    /* Arguments must be numbers. */ for(var i = 0; i < 4; ++i){
        if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) return false;
    }
    /* X values must be in the [0, 1] range. */ mX1 = Math.min(mX1, 1);
    mX2 = Math.min(mX2, 1);
    mX1 = Math.max(mX1, 0);
    mX2 = Math.max(mX2, 0);
    var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    function A(aA1, aA2) {
        return 1.0 - 3.0 * aA2 + 3.0 * aA1;
    }
    function B(aA1, aA2) {
        return 3.0 * aA2 - 6.0 * aA1;
    }
    function C(aA1) {
        return 3.0 * aA1;
    }
    function calcBezier(aT, aA1, aA2) {
        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    }
    function getSlope(aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }
    function newtonRaphsonIterate(aX, aGuessT) {
        for(var _i = 0; _i < NEWTON_ITERATIONS; ++_i){
            var currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope === 0.0) return aGuessT;
            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
    }
    function calcSampleValues() {
        for(var _i2 = 0; _i2 < kSplineTableSize; ++_i2)mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
    }
    function binarySubdivide(aX, aA, aB) {
        var currentX, currentT, i = 0;
        do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) aB = currentT;
            else aA = currentT;
        }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
    }
    function getTForX(aX) {
        var intervalStart = 0.0, currentSample = 1, lastSample = kSplineTableSize - 1;
        for(; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample)intervalStart += kSampleStepSize;
        --currentSample;
        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]), guessForT = intervalStart + dist * kSampleStepSize, initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT);
        else if (initialSlope === 0.0) return guessForT;
        else return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
    }
    var _precomputed = false;
    function precompute() {
        _precomputed = true;
        if (mX1 !== mY1 || mX2 !== mY2) calcSampleValues();
    }
    var f = function f(aX) {
        if (!_precomputed) precompute();
        if (mX1 === mY1 && mX2 === mY2) return aX;
        if (aX === 0) return 0;
        if (aX === 1) return 1;
        return calcBezier(getTForX(aX), mY1, mY2);
    };
    f.getControlPoints = function() {
        return [
            {
                x: mX1,
                y: mY1
            },
            {
                x: mX2,
                y: mY2
            }
        ];
    };
    var str = "generateBezier(" + [
        mX1,
        mY1,
        mX2,
        mY2
    ] + ")";
    f.toString = function() {
        return str;
    };
    return f;
}
/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */ /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */ var generateSpringRK4 = function() {
    function springAccelerationForState(state) {
        return -state.tension * state.x - state.friction * state.v;
    }
    function springEvaluateStateWithDerivative(initialState, dt, derivative) {
        var state = {
            x: initialState.x + derivative.dx * dt,
            v: initialState.v + derivative.dv * dt,
            tension: initialState.tension,
            friction: initialState.friction
        };
        return {
            dx: state.v,
            dv: springAccelerationForState(state)
        };
    }
    function springIntegrateState(state, dt) {
        var a = {
            dx: state.v,
            dv: springAccelerationForState(state)
        }, b = springEvaluateStateWithDerivative(state, dt * 0.5, a), c = springEvaluateStateWithDerivative(state, dt * 0.5, b), d = springEvaluateStateWithDerivative(state, dt, c), dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx), dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);
        state.x = state.x + dxdt * dt;
        state.v = state.v + dvdt * dt;
        return state;
    }
    return function springRK4Factory(tension, friction, duration) {
        var initState = {
            x: -1,
            v: 0,
            tension: null,
            friction: null
        }, path = [
            0
        ], time_lapsed = 0, tolerance = 0.0001, DT = 0.016, have_duration, dt, last_state;
        tension = parseFloat(tension) || 500;
        friction = parseFloat(friction) || 20;
        duration = duration || null;
        initState.tension = tension;
        initState.friction = friction;
        have_duration = duration !== null;
        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */ if (have_duration) {
            /* Run the simulation without a duration. */ time_lapsed = springRK4Factory(tension, friction);
            /* Compute the adjusted time delta. */ dt = time_lapsed / duration * DT;
        } else dt = DT;
        for(;;){
            /* Next/step function .*/ last_state = springIntegrateState(last_state || initState, dt);
            /* Store the position. */ path.push(1 + last_state.x);
            time_lapsed += 16;
            /* If the change threshold is reached, break. */ if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) break;
        }
        /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
       computed path and returns a snapshot of the position according to a given percentComplete. */ return !have_duration ? time_lapsed : function(percentComplete) {
            return path[percentComplete * (path.length - 1) | 0];
        };
    };
}();
var cubicBezier = function cubicBezier(t1, p1, t2, p2) {
    var bezier = generateCubicBezier(t1, p1, t2, p2);
    return function(start, end, percent) {
        return start + (end - start) * bezier(percent);
    };
};
var easings = {
    "linear": function linear(start, end, percent) {
        return start + (end - start) * percent;
    },
    // default easings
    "ease": cubicBezier(0.25, 0.1, 0.25, 1),
    "ease-in": cubicBezier(0.42, 0, 1, 1),
    "ease-out": cubicBezier(0, 0, 0.58, 1),
    "ease-in-out": cubicBezier(0.42, 0, 0.58, 1),
    // sine
    "ease-in-sine": cubicBezier(0.47, 0, 0.745, 0.715),
    "ease-out-sine": cubicBezier(0.39, 0.575, 0.565, 1),
    "ease-in-out-sine": cubicBezier(0.445, 0.05, 0.55, 0.95),
    // quad
    "ease-in-quad": cubicBezier(0.55, 0.085, 0.68, 0.53),
    "ease-out-quad": cubicBezier(0.25, 0.46, 0.45, 0.94),
    "ease-in-out-quad": cubicBezier(0.455, 0.03, 0.515, 0.955),
    // cubic
    "ease-in-cubic": cubicBezier(0.55, 0.055, 0.675, 0.19),
    "ease-out-cubic": cubicBezier(0.215, 0.61, 0.355, 1),
    "ease-in-out-cubic": cubicBezier(0.645, 0.045, 0.355, 1),
    // quart
    "ease-in-quart": cubicBezier(0.895, 0.03, 0.685, 0.22),
    "ease-out-quart": cubicBezier(0.165, 0.84, 0.44, 1),
    "ease-in-out-quart": cubicBezier(0.77, 0, 0.175, 1),
    // quint
    "ease-in-quint": cubicBezier(0.755, 0.05, 0.855, 0.06),
    "ease-out-quint": cubicBezier(0.23, 1, 0.32, 1),
    "ease-in-out-quint": cubicBezier(0.86, 0, 0.07, 1),
    // expo
    "ease-in-expo": cubicBezier(0.95, 0.05, 0.795, 0.035),
    "ease-out-expo": cubicBezier(0.19, 1, 0.22, 1),
    "ease-in-out-expo": cubicBezier(1, 0, 0, 1),
    // circ
    "ease-in-circ": cubicBezier(0.6, 0.04, 0.98, 0.335),
    "ease-out-circ": cubicBezier(0.075, 0.82, 0.165, 1),
    "ease-in-out-circ": cubicBezier(0.785, 0.135, 0.15, 0.86),
    // user param easings...
    "spring": function spring(tension, friction, duration) {
        if (duration === 0) // can't get a spring w/ duration 0
        return easings.linear; // duration 0 => jump to end so impl doesn't matter
        var spring = generateSpringRK4(tension, friction, duration);
        return function(start, end, percent) {
            return start + (end - start) * spring(percent);
        };
    },
    "cubic-bezier": cubicBezier
};
function getEasedValue(type, start, end, percent, easingFn) {
    if (percent === 1) return end;
    if (start === end) return end;
    var val = easingFn(start, end, percent);
    if (type == null) return val;
    if (type.roundValue || type.color) val = Math.round(val);
    if (type.min !== undefined) val = Math.max(val, type.min);
    if (type.max !== undefined) val = Math.min(val, type.max);
    return val;
}
function getValue(prop, spec) {
    if (prop.pfValue != null || prop.value != null) {
        if (prop.pfValue != null && (spec == null || spec.type.units !== "%")) return prop.pfValue;
        else return prop.value;
    } else return prop;
}
function ease(startProp, endProp, percent, easingFn, propSpec) {
    var type = propSpec != null ? propSpec.type : null;
    if (percent < 0) percent = 0;
    else if (percent > 1) percent = 1;
    var start = getValue(startProp, propSpec);
    var end = getValue(endProp, propSpec);
    if (number$1(start) && number$1(end)) return getEasedValue(type, start, end, percent, easingFn);
    else if (array(start) && array(end)) {
        var easedArr = [];
        for(var i = 0; i < end.length; i++){
            var si = start[i];
            var ei = end[i];
            if (si != null && ei != null) {
                var val = getEasedValue(type, si, ei, percent, easingFn);
                easedArr.push(val);
            } else easedArr.push(ei);
        }
        return easedArr;
    }
    return undefined;
}
function step$1(self, ani, now, isCore) {
    var isEles = !isCore;
    var _p = self._private;
    var ani_p = ani._private;
    var pEasing = ani_p.easing;
    var startTime = ani_p.startTime;
    var cy = isCore ? self : self.cy();
    var style = cy.style();
    if (!ani_p.easingImpl) {
        if (pEasing == null) // use default
        ani_p.easingImpl = easings["linear"];
        else {
            // then define w/ name
            var easingVals;
            if (string(pEasing)) {
                var easingProp = style.parse("transition-timing-function", pEasing);
                easingVals = easingProp.value;
            } else // then assume preparsed array
            easingVals = pEasing;
            var name, args;
            if (string(easingVals)) {
                name = easingVals;
                args = [];
            } else {
                name = easingVals[1];
                args = easingVals.slice(2).map(function(n) {
                    return +n;
                });
            }
            if (args.length > 0) {
                // create with args
                if (name === "spring") args.push(ani_p.duration); // need duration to generate spring
                ani_p.easingImpl = easings[name].apply(null, args);
            } else // static impl by name
            ani_p.easingImpl = easings[name];
        }
    }
    var easing = ani_p.easingImpl;
    var percent;
    if (ani_p.duration === 0) percent = 1;
    else percent = (now - startTime) / ani_p.duration;
    if (ani_p.applying) percent = ani_p.progress;
    if (percent < 0) percent = 0;
    else if (percent > 1) percent = 1;
    if (ani_p.delay == null) {
        // then update
        var startPos = ani_p.startPosition;
        var endPos = ani_p.position;
        if (endPos && isEles && !self.locked()) {
            var newPos = {};
            if (valid(startPos.x, endPos.x)) newPos.x = ease(startPos.x, endPos.x, percent, easing);
            if (valid(startPos.y, endPos.y)) newPos.y = ease(startPos.y, endPos.y, percent, easing);
            self.position(newPos);
        }
        var startPan = ani_p.startPan;
        var endPan = ani_p.pan;
        var pan = _p.pan;
        var animatingPan = endPan != null && isCore;
        if (animatingPan) {
            if (valid(startPan.x, endPan.x)) pan.x = ease(startPan.x, endPan.x, percent, easing);
            if (valid(startPan.y, endPan.y)) pan.y = ease(startPan.y, endPan.y, percent, easing);
            self.emit("pan");
        }
        var startZoom = ani_p.startZoom;
        var endZoom = ani_p.zoom;
        var animatingZoom = endZoom != null && isCore;
        if (animatingZoom) {
            if (valid(startZoom, endZoom)) _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);
            self.emit("zoom");
        }
        if (animatingPan || animatingZoom) self.emit("viewport");
        var props = ani_p.style;
        if (props && props.length > 0 && isEles) {
            for(var i = 0; i < props.length; i++){
                var prop = props[i];
                var _name = prop.name;
                var end = prop;
                var start = ani_p.startStyle[_name];
                var propSpec = style.properties[start.name];
                var easedVal = ease(start, end, percent, easing, propSpec);
                style.overrideBypass(self, _name, easedVal);
            } // for props
            self.emit("style");
        } // if
    }
    ani_p.progress = percent;
    return percent;
}
function valid(start, end) {
    if (start == null || end == null) return false;
    if (number$1(start) && number$1(end)) return true;
    else if (start && end) return true;
    return false;
}
function startAnimation(self, ani, now, isCore) {
    var ani_p = ani._private;
    ani_p.started = true;
    ani_p.startTime = now - ani_p.progress * ani_p.duration;
}
function stepAll(now, cy) {
    var eles = cy._private.aniEles;
    var doneEles = [];
    function stepOne(ele, isCore) {
        var _p = ele._private;
        var current = _p.animation.current;
        var queue = _p.animation.queue;
        var ranAnis = false; // if nothing currently animating, get something from the queue
        if (current.length === 0) {
            var next = queue.shift();
            if (next) current.push(next);
        }
        var callbacks = function callbacks(_callbacks) {
            for(var j = _callbacks.length - 1; j >= 0; j--){
                var cb = _callbacks[j];
                cb();
            }
            _callbacks.splice(0, _callbacks.length);
        }; // step and remove if done
        for(var i = current.length - 1; i >= 0; i--){
            var ani = current[i];
            var ani_p = ani._private;
            if (ani_p.stopped) {
                current.splice(i, 1);
                ani_p.hooked = false;
                ani_p.playing = false;
                ani_p.started = false;
                callbacks(ani_p.frames);
                continue;
            }
            if (!ani_p.playing && !ani_p.applying) continue;
             // an apply() while playing shouldn't do anything
            if (ani_p.playing && ani_p.applying) ani_p.applying = false;
            if (!ani_p.started) startAnimation(ele, ani, now);
            step$1(ele, ani, now, isCore);
            if (ani_p.applying) ani_p.applying = false;
            callbacks(ani_p.frames);
            if (ani_p.step != null) ani_p.step(now);
            if (ani.completed()) {
                current.splice(i, 1);
                ani_p.hooked = false;
                ani_p.playing = false;
                ani_p.started = false;
                callbacks(ani_p.completes);
            }
            ranAnis = true;
        }
        if (!isCore && current.length === 0 && queue.length === 0) doneEles.push(ele);
        return ranAnis;
    } // stepElement
    // handle all eles
    var ranEleAni = false;
    for(var e = 0; e < eles.length; e++){
        var ele = eles[e];
        var handledThisEle = stepOne(ele);
        ranEleAni = ranEleAni || handledThisEle;
    } // each element
    var ranCoreAni = stepOne(cy, true); // notify renderer
    if (ranEleAni || ranCoreAni) {
        if (eles.length > 0) cy.notify("draw", eles);
        else cy.notify("draw");
    } // remove elements from list of currently animating if its queues are empty
    eles.unmerge(doneEles);
    cy.emit("step");
} // stepAll
var corefn$8 = {
    // pull in animation functions
    animate: define.animate(),
    animation: define.animation(),
    animated: define.animated(),
    clearQueue: define.clearQueue(),
    delay: define.delay(),
    delayAnimation: define.delayAnimation(),
    stop: define.stop(),
    addToAnimationPool: function addToAnimationPool(eles) {
        var cy = this;
        if (!cy.styleEnabled()) return;
         // save cycles when no style used
        cy._private.aniEles.merge(eles);
    },
    stopAnimationLoop: function stopAnimationLoop() {
        this._private.animationsRunning = false;
    },
    startAnimationLoop: function startAnimationLoop() {
        var cy = this;
        cy._private.animationsRunning = true;
        if (!cy.styleEnabled()) return;
         // save cycles when no style used
        // NB the animation loop will exec in headless environments if style enabled
        // and explicit cy.destroy() is necessary to stop the loop
        function headlessStep() {
            if (!cy._private.animationsRunning) return;
            requestAnimationFrame(function animationStep(now) {
                stepAll(now, cy);
                headlessStep();
            });
        }
        var renderer = cy.renderer();
        if (renderer && renderer.beforeRender) // let the renderer schedule animations
        renderer.beforeRender(function rendererAnimationStep(willDraw, now) {
            stepAll(now, cy);
        }, renderer.beforeRenderPriorities.animations);
        else // manage the animation loop ourselves
        headlessStep(); // first call
    }
};
var emitterOptions = {
    qualifierCompare: function qualifierCompare(selector1, selector2) {
        if (selector1 == null || selector2 == null) return selector1 == null && selector2 == null;
        else return selector1.sameText(selector2);
    },
    eventMatches: function eventMatches(cy, listener, eventObj) {
        var selector = listener.qualifier;
        if (selector != null) return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
        return true;
    },
    addEventFields: function addEventFields(cy, evt) {
        evt.cy = cy;
        evt.target = cy;
    },
    callbackContext: function callbackContext(cy, listener, eventObj) {
        return listener.qualifier != null ? eventObj.target : cy;
    }
};
var argSelector = function argSelector(arg) {
    if (string(arg)) return new Selector(arg);
    else return arg;
};
var elesfn = {
    createEmitter: function createEmitter() {
        var _p = this._private;
        if (!_p.emitter) _p.emitter = new Emitter(emitterOptions, this);
        return this;
    },
    emitter: function emitter() {
        return this._private.emitter;
    },
    on: function on(events, selector, callback) {
        this.emitter().on(events, argSelector(selector), callback);
        return this;
    },
    removeListener: function removeListener(events, selector, callback) {
        this.emitter().removeListener(events, argSelector(selector), callback);
        return this;
    },
    removeAllListeners: function removeAllListeners() {
        this.emitter().removeAllListeners();
        return this;
    },
    one: function one(events, selector, callback) {
        this.emitter().one(events, argSelector(selector), callback);
        return this;
    },
    once: function once(events, selector, callback) {
        this.emitter().one(events, argSelector(selector), callback);
        return this;
    },
    emit: function emit(events, extraParams) {
        this.emitter().emit(events, extraParams);
        return this;
    },
    emitAndNotify: function emitAndNotify(event, eles) {
        this.emit(event);
        this.notify(event, eles);
        return this;
    }
};
define.eventAliasesOn(elesfn);
var corefn$7 = {
    png: function png(options) {
        var renderer = this._private.renderer;
        options = options || {};
        return renderer.png(options);
    },
    jpg: function jpg(options) {
        var renderer = this._private.renderer;
        options = options || {};
        options.bg = options.bg || "#fff";
        return renderer.jpg(options);
    }
};
corefn$7.jpeg = corefn$7.jpg;
var corefn$6 = {
    layout: function layout(options) {
        var cy = this;
        if (options == null) {
            error("Layout options must be specified to make a layout");
            return;
        }
        if (options.name == null) {
            error("A `name` must be specified to make a layout");
            return;
        }
        var name = options.name;
        var Layout = cy.extension("layout", name);
        if (Layout == null) {
            error("No such layout `" + name + "` found.  Did you forget to import it and `cytoscape.use()` it?");
            return;
        }
        var eles;
        if (string(options.eles)) eles = cy.$(options.eles);
        else eles = options.eles != null ? options.eles : cy.$();
        var layout = new Layout(extend({}, options, {
            cy: cy,
            eles: eles
        }));
        return layout;
    }
};
corefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;
var corefn$5 = {
    notify: function notify(eventName, eventEles) {
        var _p = this._private;
        if (this.batching()) {
            _p.batchNotifications = _p.batchNotifications || {};
            var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();
            if (eventEles != null) eles.merge(eventEles);
            return; // notifications are disabled during batching
        }
        if (!_p.notificationsEnabled) return;
         // exit on disabled
        var renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528
        if (this.destroyed() || !renderer) return;
        renderer.notify(eventName, eventEles);
    },
    notifications: function notifications(bool) {
        var p = this._private;
        if (bool === undefined) return p.notificationsEnabled;
        else p.notificationsEnabled = bool ? true : false;
        return this;
    },
    noNotifications: function noNotifications(callback) {
        this.notifications(false);
        callback();
        this.notifications(true);
    },
    batching: function batching() {
        return this._private.batchCount > 0;
    },
    startBatch: function startBatch() {
        var _p = this._private;
        if (_p.batchCount == null) _p.batchCount = 0;
        if (_p.batchCount === 0) {
            _p.batchStyleEles = this.collection();
            _p.batchNotifications = {};
        }
        _p.batchCount++;
        return this;
    },
    endBatch: function endBatch() {
        var _p = this._private;
        if (_p.batchCount === 0) return this;
        _p.batchCount--;
        if (_p.batchCount === 0) {
            // update style for dirty eles
            _p.batchStyleEles.updateStyle();
            var renderer = this.renderer(); // notify the renderer of queued eles and event types
            Object.keys(_p.batchNotifications).forEach(function(eventName) {
                var eles = _p.batchNotifications[eventName];
                if (eles.empty()) renderer.notify(eventName);
                else renderer.notify(eventName, eles);
            });
        }
        return this;
    },
    batch: function batch(callback) {
        this.startBatch();
        callback();
        this.endBatch();
        return this;
    },
    // for backwards compatibility
    batchData: function batchData(map) {
        var cy = this;
        return this.batch(function() {
            var ids = Object.keys(map);
            for(var i = 0; i < ids.length; i++){
                var id = ids[i];
                var data = map[id];
                var ele = cy.getElementById(id);
                ele.data(data);
            }
        });
    }
};
var rendererDefaults = defaults$g({
    hideEdgesOnViewport: false,
    textureOnViewport: false,
    motionBlur: false,
    motionBlurOpacity: 0.05,
    pixelRatio: undefined,
    desktopTapThreshold: 4,
    touchTapThreshold: 8,
    wheelSensitivity: 1,
    debug: false,
    showFps: false
});
var corefn$4 = {
    renderTo: function renderTo(context, zoom, pan, pxRatio) {
        var r = this._private.renderer;
        r.renderTo(context, zoom, pan, pxRatio);
        return this;
    },
    renderer: function renderer() {
        return this._private.renderer;
    },
    forceRender: function forceRender() {
        this.notify("draw");
        return this;
    },
    resize: function resize() {
        this.invalidateSize();
        this.emitAndNotify("resize");
        return this;
    },
    initRenderer: function initRenderer(options) {
        var cy = this;
        var RendererProto = cy.extension("renderer", options.name);
        if (RendererProto == null) {
            error("Can not initialise: No such renderer `".concat(options.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
            return;
        }
        if (options.wheelSensitivity !== undefined) warn("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
        var rOpts = rendererDefaults(options);
        rOpts.cy = cy;
        cy._private.renderer = new RendererProto(rOpts);
        this.notify("init");
    },
    destroyRenderer: function destroyRenderer() {
        var cy = this;
        cy.notify("destroy"); // destroy the renderer
        var domEle = cy.container();
        if (domEle) {
            domEle._cyreg = null;
            while(domEle.childNodes.length > 0)domEle.removeChild(domEle.childNodes[0]);
        }
        cy._private.renderer = null; // to be extra safe, remove the ref
        cy.mutableElements().forEach(function(ele) {
            var _p = ele._private;
            _p.rscratch = {};
            _p.rstyle = {};
            _p.animation.current = [];
            _p.animation.queue = [];
        });
    },
    onRender: function onRender(fn) {
        return this.on("render", fn);
    },
    offRender: function offRender(fn) {
        return this.off("render", fn);
    }
};
corefn$4.invalidateDimensions = corefn$4.resize;
var corefn$3 = {
    // get a collection
    // - empty collection on no args
    // - collection of elements in the graph on selector arg
    // - guarantee a returned collection when elements or collection specified
    collection: function collection(eles, opts) {
        if (string(eles)) return this.$(eles);
        else if (elementOrCollection(eles)) return eles.collection();
        else if (array(eles)) return new Collection(this, eles, opts);
        return new Collection(this);
    },
    nodes: function nodes(selector) {
        var nodes = this.$(function(ele) {
            return ele.isNode();
        });
        if (selector) return nodes.filter(selector);
        return nodes;
    },
    edges: function edges(selector) {
        var edges = this.$(function(ele) {
            return ele.isEdge();
        });
        if (selector) return edges.filter(selector);
        return edges;
    },
    // search the graph like jQuery
    $: function $(selector) {
        var eles = this._private.elements;
        if (selector) return eles.filter(selector);
        else return eles.spawnSelf();
    },
    mutableElements: function mutableElements() {
        return this._private.elements;
    }
}; // aliases
corefn$3.elements = corefn$3.filter = corefn$3.$;
var styfn$8 = {}; // keys for style blocks, e.g. ttfftt
var TRUE = "t";
var FALSE = "f"; // (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it
styfn$8.apply = function(eles) {
    var self = this;
    var _p = self._private;
    var cy = _p.cy;
    var updatedEles = cy.collection();
    for(var ie = 0; ie < eles.length; ie++){
        var ele = eles[ie];
        var cxtMeta = self.getContextMeta(ele);
        if (cxtMeta.empty) continue;
        var cxtStyle = self.getContextStyle(cxtMeta);
        var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);
        if (ele._private.appliedInitStyle) self.updateTransitions(ele, app.diffProps);
        else ele._private.appliedInitStyle = true;
        var hintsDiff = self.updateStyleHints(ele);
        if (hintsDiff) updatedEles.push(ele);
    } // for elements
    return updatedEles;
};
styfn$8.getPropertiesDiff = function(oldCxtKey, newCxtKey) {
    var self = this;
    var cache = self._private.propDiffs = self._private.propDiffs || {};
    var dualCxtKey = oldCxtKey + "-" + newCxtKey;
    var cachedVal = cache[dualCxtKey];
    if (cachedVal) return cachedVal;
    var diffProps = [];
    var addedProp = {};
    for(var i = 0; i < self.length; i++){
        var cxt = self[i];
        var oldHasCxt = oldCxtKey[i] === TRUE;
        var newHasCxt = newCxtKey[i] === TRUE;
        var cxtHasDiffed = oldHasCxt !== newHasCxt;
        var cxtHasMappedProps = cxt.mappedProperties.length > 0;
        if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {
            var props = void 0;
            if (cxtHasDiffed && cxtHasMappedProps) props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
            else if (cxtHasDiffed) props = cxt.properties; // need to check them all
            else if (cxtHasMappedProps) props = cxt.mappedProperties; // only need to check mapped
            for(var j = 0; j < props.length; j++){
                var prop = props[j];
                var name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
                // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
                // is cached)
                var laterCxtOverrides = false;
                for(var k = i + 1; k < self.length; k++){
                    var laterCxt = self[k];
                    var hasLaterCxt = newCxtKey[k] === TRUE;
                    if (!hasLaterCxt) continue;
                     // can't override unless the context is active
                    laterCxtOverrides = laterCxt.properties[prop.name] != null;
                    if (laterCxtOverrides) break;
                     // exit early as long as one later context overrides
                }
                if (!addedProp[name] && !laterCxtOverrides) {
                    addedProp[name] = true;
                    diffProps.push(name);
                }
            } // for props
        } // if
    } // for contexts
    cache[dualCxtKey] = diffProps;
    return diffProps;
};
styfn$8.getContextMeta = function(ele) {
    var self = this;
    var cxtKey = "";
    var diffProps;
    var prevKey = ele._private.styleCxtKey || ""; // get the cxt key
    for(var i = 0; i < self.length; i++){
        var context = self[i];
        var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'
        if (contextSelectorMatches) cxtKey += TRUE;
        else cxtKey += FALSE;
    } // for context
    diffProps = self.getPropertiesDiff(prevKey, cxtKey);
    ele._private.styleCxtKey = cxtKey;
    return {
        key: cxtKey,
        diffPropNames: diffProps,
        empty: diffProps.length === 0
    };
}; // gets a computed ele style object based on matched contexts
styfn$8.getContextStyle = function(cxtMeta) {
    var cxtKey = cxtMeta.key;
    var self = this;
    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy
    if (cxtStyles[cxtKey]) return cxtStyles[cxtKey];
    var style = {
        _private: {
            key: cxtKey
        }
    };
    for(var i = 0; i < self.length; i++){
        var cxt = self[i];
        var hasCxt = cxtKey[i] === TRUE;
        if (!hasCxt) continue;
        for(var j = 0; j < cxt.properties.length; j++){
            var prop = cxt.properties[j];
            style[prop.name] = prop;
        }
    }
    cxtStyles[cxtKey] = style;
    return style;
};
styfn$8.applyContextStyle = function(cxtMeta, cxtStyle, ele) {
    var self = this;
    var diffProps = cxtMeta.diffPropNames;
    var retDiffProps = {};
    var types = self.types;
    for(var i = 0; i < diffProps.length; i++){
        var diffPropName = diffProps[i];
        var cxtProp = cxtStyle[diffPropName];
        var eleProp = ele.pstyle(diffPropName);
        if (!cxtProp) {
            // no context prop means delete
            if (!eleProp) continue; // no existing prop means nothing needs to be removed
            else if (eleProp.bypass) cxtProp = {
                name: diffPropName,
                deleteBypassed: true
            };
            else cxtProp = {
                name: diffPropName,
                "delete": true
            };
        } // save cycles when the context prop doesn't need to be applied
        if (eleProp === cxtProp) continue;
         // save cycles when a mapped context prop doesn't need to be applied
        if (cxtProp.mapped === types.fn // context prop is function mapper
         && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)
         && eleProp.mapping != null // ele prop is a concrete value from from a mapper
         && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper
        ) {
            // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)
            var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy
            var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss
            if (fnValue === mapping.prevFnValue) continue;
        }
        var retDiffProp = retDiffProps[diffPropName] = {
            prev: eleProp
        };
        self.applyParsedProperty(ele, cxtProp);
        retDiffProp.next = ele.pstyle(diffPropName);
        if (retDiffProp.next && retDiffProp.next.bypass) retDiffProp.next = retDiffProp.next.bypassed;
    }
    return {
        diffProps: retDiffProps
    };
};
styfn$8.updateStyleHints = function(ele) {
    var _p = ele._private;
    var self = this;
    var propNames = self.propertyGroupNames;
    var propGrKeys = self.propertyGroupKeys;
    var propHash = function propHash(ele, propNames, seedKey) {
        return self.getPropertiesHash(ele, propNames, seedKey);
    };
    var oldStyleKey = _p.styleKey;
    if (ele.removed()) return false;
    var isNode = _p.group === "nodes"; // get the style key hashes per prop group
    // but lazily -- only use non-default prop values to reduce the number of hashes
    //
    var overriddenStyles = ele._private.style;
    propNames = Object.keys(overriddenStyles);
    for(var i = 0; i < propGrKeys.length; i++){
        var grKey = propGrKeys[i];
        _p.styleKeys[grKey] = [
            DEFAULT_HASH_SEED,
            DEFAULT_HASH_SEED_ALT
        ];
    }
    var updateGrKey1 = function updateGrKey1(val, grKey) {
        return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);
    };
    var updateGrKey2 = function updateGrKey2(val, grKey) {
        return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);
    };
    var updateGrKey = function updateGrKey(val, grKey) {
        updateGrKey1(val, grKey);
        updateGrKey2(val, grKey);
    };
    var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {
        for(var j = 0; j < strVal.length; j++){
            var ch = strVal.charCodeAt(j);
            updateGrKey1(ch, grKey);
            updateGrKey2(ch, grKey);
        }
    }; // - hashing works on 32 bit ints b/c we use bitwise ops
    // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)
    // - raise up small numbers so more significant digits are seen by hashing
    // - make small numbers larger than a normal value to avoid collisions
    // - works in practice and it's relatively cheap
    var N = 2000000000;
    var cleanNum = function cleanNum(val) {
        return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;
    };
    for(var _i = 0; _i < propNames.length; _i++){
        var name = propNames[_i];
        var parsedProp = overriddenStyles[name];
        if (parsedProp == null) continue;
        var propInfo = this.properties[name];
        var type = propInfo.type;
        var _grKey = propInfo.groupKey;
        var normalizedNumberVal = void 0;
        if (propInfo.hashOverride != null) normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);
        else if (parsedProp.pfValue != null) normalizedNumberVal = parsedProp.pfValue;
         // might not be a number if it allows enums
        var numberVal = propInfo.enums == null ? parsedProp.value : null;
        var haveNormNum = normalizedNumberVal != null;
        var haveUnitedNum = numberVal != null;
        var haveNum = haveNormNum || haveUnitedNum;
        var units = parsedProp.units; // numbers are cheaper to hash than strings
        // 1 hash op vs n hash ops (for length n string)
        if (type.number && haveNum && !type.multiple) {
            var v = haveNormNum ? normalizedNumberVal : numberVal;
            updateGrKey(cleanNum(v), _grKey);
            if (!haveNormNum && units != null) updateGrKeyWStr(units, _grKey);
        } else updateGrKeyWStr(parsedProp.strValue, _grKey);
    } // overall style key
    //
    var hash = [
        DEFAULT_HASH_SEED,
        DEFAULT_HASH_SEED_ALT
    ];
    for(var _i2 = 0; _i2 < propGrKeys.length; _i2++){
        var _grKey2 = propGrKeys[_i2];
        var grHash = _p.styleKeys[_grKey2];
        hash[0] = hashInt(grHash[0], hash[0]);
        hash[1] = hashIntAlt(grHash[1], hash[1]);
    }
    _p.styleKey = combineHashes(hash[0], hash[1]); // label dims
    //
    var sk = _p.styleKeys;
    _p.labelDimsKey = combineHashesArray(sk.labelDimensions);
    var labelKeys = propHash(ele, [
        "label"
    ], sk.labelDimensions);
    _p.labelKey = combineHashesArray(labelKeys);
    _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));
    if (!isNode) {
        var sourceLabelKeys = propHash(ele, [
            "source-label"
        ], sk.labelDimensions);
        _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);
        _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));
        var targetLabelKeys = propHash(ele, [
            "target-label"
        ], sk.labelDimensions);
        _p.targetLabelKey = combineHashesArray(targetLabelKeys);
        _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));
    } // node
    //
    if (isNode) {
        var _p$styleKeys = _p.styleKeys, nodeBody = _p$styleKeys.nodeBody, nodeBorder = _p$styleKeys.nodeBorder, backgroundImage = _p$styleKeys.backgroundImage, compound = _p$styleKeys.compound, pie = _p$styleKeys.pie;
        var nodeKeys = [
            nodeBody,
            nodeBorder,
            backgroundImage,
            compound,
            pie
        ].filter(function(k) {
            return k != null;
        }).reduce(hashArrays, [
            DEFAULT_HASH_SEED,
            DEFAULT_HASH_SEED_ALT
        ]);
        _p.nodeKey = combineHashesArray(nodeKeys);
        _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;
    }
    return oldStyleKey !== _p.styleKey;
};
styfn$8.clearStyleHints = function(ele) {
    var _p = ele._private;
    _p.styleCxtKey = "";
    _p.styleKeys = {};
    _p.styleKey = null;
    _p.labelKey = null;
    _p.labelStyleKey = null;
    _p.sourceLabelKey = null;
    _p.sourceLabelStyleKey = null;
    _p.targetLabelKey = null;
    _p.targetLabelStyleKey = null;
    _p.nodeKey = null;
    _p.hasPie = null;
}; // apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }
styfn$8.applyParsedProperty = function(ele, parsedProp) {
    var self = this;
    var prop = parsedProp;
    var style = ele._private.style;
    var flatProp;
    var types = self.types;
    var type = self.properties[prop.name].type;
    var propIsBypass = prop.bypass;
    var origProp = style[prop.name];
    var origPropIsBypass = origProp && origProp.bypass;
    var _p = ele._private;
    var flatPropMapping = "mapping";
    var getVal = function getVal(p) {
        if (p == null) return null;
        else if (p.pfValue != null) return p.pfValue;
        else return p.value;
    };
    var checkTriggers = function checkTriggers() {
        var fromVal = getVal(origProp);
        var toVal = getVal(prop);
        self.checkTriggers(ele, prop.name, fromVal, toVal);
    };
    if (prop && prop.name.substr(0, 3) === "pie") warn("The pie style properties are deprecated.  Create charts using background images instead.");
     // edge sanity checks to prevent the client from making serious mistakes
    if (parsedProp.name === "curve-style" && ele.isEdge() && (parsedProp.value !== "bezier" && ele.isLoop() || parsedProp.value === "haystack" && (ele.source().isParent() || ele.target().isParent()))) prop = parsedProp = this.parse(parsedProp.name, "bezier", propIsBypass);
    if (prop["delete"]) {
        // delete the property and use the default value on falsey value
        style[prop.name] = undefined;
        checkTriggers();
        return true;
    }
    if (prop.deleteBypassed) {
        // delete the property that the
        if (!origProp) {
            checkTriggers();
            return true; // can't delete if no prop
        } else if (origProp.bypass) {
            // delete bypassed
            origProp.bypassed = undefined;
            checkTriggers();
            return true;
        } else return false; // we're unsuccessful deleting the bypassed
    } // check if we need to delete the current bypass
    if (prop.deleteBypass) {
        // then this property is just here to indicate we need to delete
        if (!origProp) {
            checkTriggers();
            return true; // property is already not defined
        } else if (origProp.bypass) {
            // then replace the bypass property with the original
            // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
            style[prop.name] = origProp.bypassed;
            checkTriggers();
            return true;
        } else return false; // we're unsuccessful deleting the bypass
    }
    var printMappingErr = function printMappingErr() {
        warn("Do not assign mappings to elements without corresponding data (i.e. ele `" + ele.id() + "` has no mapping for property `" + prop.name + "` with data field `" + prop.field + "`); try a `[" + prop.field + "]` selector to limit scope to elements with `" + prop.field + "` defined");
    }; // put the property in the style objects
    switch(prop.mapped){
        // flatten the property if mapped
        case types.mapData:
            // flatten the field (e.g. data.foo.bar)
            var fields = prop.field.split(".");
            var fieldVal = _p.data;
            for(var i = 0; i < fields.length && fieldVal; i++){
                var field = fields[i];
                fieldVal = fieldVal[field];
            }
            if (fieldVal == null) {
                printMappingErr();
                return false;
            }
            var percent;
            if (!number$1(fieldVal)) {
                // then don't apply and fall back on the existing style
                warn("Do not use continuous mappers without specifying numeric data (i.e. `" + prop.field + ": " + fieldVal + "` for `" + ele.id() + "` is non-numeric)");
                return false;
            } else {
                var fieldWidth = prop.fieldMax - prop.fieldMin;
                if (fieldWidth === 0) // safety check -- not strictly necessary as no props of zero range should be passed here
                percent = 0;
                else percent = (fieldVal - prop.fieldMin) / fieldWidth;
            } // make sure to bound percent value
            if (percent < 0) percent = 0;
            else if (percent > 1) percent = 1;
            if (type.color) {
                var r1 = prop.valueMin[0];
                var r2 = prop.valueMax[0];
                var g1 = prop.valueMin[1];
                var g2 = prop.valueMax[1];
                var b1 = prop.valueMin[2];
                var b2 = prop.valueMax[2];
                var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
                var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];
                var clr = [
                    Math.round(r1 + (r2 - r1) * percent),
                    Math.round(g1 + (g2 - g1) * percent),
                    Math.round(b1 + (b2 - b1) * percent),
                    Math.round(a1 + (a2 - a1) * percent)
                ];
                flatProp = {
                    // colours are simple, so just create the flat property instead of expensive string parsing
                    bypass: prop.bypass,
                    // we're a bypass if the mapping property is a bypass
                    name: prop.name,
                    value: clr,
                    strValue: "rgb(" + clr[0] + ", " + clr[1] + ", " + clr[2] + ")"
                };
            } else if (type.number) {
                var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
                flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);
            } else return false; // can only map to colours and numbers
            if (!flatProp) {
                // if we can't flatten the property, then don't apply the property and fall back on the existing style
                printMappingErr();
                return false;
            }
            flatProp.mapping = prop; // keep a reference to the mapping
            prop = flatProp; // the flattened (mapped) property is the one we want
            break;
        // direct mapping
        case types.data:
            // flatten the field (e.g. data.foo.bar)
            var _fields = prop.field.split(".");
            var _fieldVal = _p.data;
            for(var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++){
                var _field = _fields[_i3];
                _fieldVal = _fieldVal[_field];
            }
            if (_fieldVal != null) flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);
            if (!flatProp) {
                // if we can't flatten the property, then don't apply and fall back on the existing style
                printMappingErr();
                return false;
            }
            flatProp.mapping = prop; // keep a reference to the mapping
            prop = flatProp; // the flattened (mapped) property is the one we want
            break;
        case types.fn:
            var fn = prop.value;
            var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function
            prop.prevFnValue = fnRetVal;
            if (fnRetVal == null) {
                warn("Custom function mappers may not return null (i.e. `" + prop.name + "` for ele `" + ele.id() + "` is null)");
                return false;
            }
            flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);
            if (!flatProp) {
                warn("Custom function mappers may not return invalid values for the property type (i.e. `" + prop.name + "` for ele `" + ele.id() + "` is invalid)");
                return false;
            }
            flatProp.mapping = copy(prop); // keep a reference to the mapping
            prop = flatProp; // the flattened (mapped) property is the one we want
            break;
        case undefined:
            break;
        // just set the property
        default:
            return false;
    } // if the property is a bypass property, then link the resultant property to the original one
    if (propIsBypass) {
        if (origPropIsBypass) // then this bypass overrides the existing one
        prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
        else // then link the orig prop to the new bypass
        prop.bypassed = origProp;
        style[prop.name] = prop; // and set
    } else // prop is not bypass
    if (origPropIsBypass) // then keep the orig prop (since it's a bypass) and link to the new prop
    origProp.bypassed = prop;
    else // then just replace the old prop with the new one
    style[prop.name] = prop;
    checkTriggers();
    return true;
};
styfn$8.cleanElements = function(eles, keepBypasses) {
    for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        this.clearStyleHints(ele);
        ele.dirtyCompoundBoundsCache();
        ele.dirtyBoundingBoxCache();
        if (!keepBypasses) ele._private.style = {};
        else {
            var style = ele._private.style;
            var propNames = Object.keys(style);
            for(var j = 0; j < propNames.length; j++){
                var propName = propNames[j];
                var eleProp = style[propName];
                if (eleProp != null) {
                    if (eleProp.bypass) eleProp.bypassed = null;
                    else style[propName] = null;
                }
            }
        }
    }
}; // updates the visual style for all elements (useful for manual style modification after init)
styfn$8.update = function() {
    var cy = this._private.cy;
    var eles = cy.mutableElements();
    eles.updateStyle();
}; // diffProps : { name => { prev, next } }
styfn$8.updateTransitions = function(ele, diffProps) {
    var self = this;
    var _p = ele._private;
    var props = ele.pstyle("transition-property").value;
    var duration = ele.pstyle("transition-duration").pfValue;
    var delay = ele.pstyle("transition-delay").pfValue;
    if (props.length > 0 && duration > 0) {
        var style = {}; // build up the style to animate towards
        var anyPrev = false;
        for(var i = 0; i < props.length; i++){
            var prop = props[i];
            var styProp = ele.pstyle(prop);
            var diffProp = diffProps[prop];
            if (!diffProp) continue;
            var prevProp = diffProp.prev;
            var fromProp = prevProp;
            var toProp = diffProp.next != null ? diffProp.next : styProp;
            var diff = false;
            var initVal = void 0;
            var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)
            if (!fromProp) continue;
             // consider px values
            if (number$1(fromProp.pfValue) && number$1(toProp.pfValue)) {
                diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
                initVal = fromProp.pfValue + initDt * diff; // consider numerical values
            } else if (number$1(fromProp.value) && number$1(toProp.value)) {
                diff = toProp.value - fromProp.value; // nonzero is truthy
                initVal = fromProp.value + initDt * diff; // consider colour values
            } else if (array(fromProp.value) && array(toProp.value)) {
                diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];
                initVal = fromProp.strValue;
            } // the previous value is good for an animation only if it's different
            if (diff) {
                style[prop] = toProp.strValue; // to val
                this.applyBypass(ele, prop, initVal); // from val
                anyPrev = true;
            }
        } // end if props allow ani
        // can't transition if there's nothing previous to transition from
        if (!anyPrev) return;
        _p.transitioning = true;
        new Promise$1(function(resolve) {
            if (delay > 0) ele.delayAnimation(delay).play().promise().then(resolve);
            else resolve();
        }).then(function() {
            return ele.animation({
                style: style,
                duration: duration,
                easing: ele.pstyle("transition-timing-function").value,
                queue: false
            }).play().promise();
        }).then(function() {
            // if( !isBypass ){
            self.removeBypasses(ele, props);
            ele.emitAndNotify("style"); // }
            _p.transitioning = false;
        });
    } else if (_p.transitioning) {
        this.removeBypasses(ele, props);
        ele.emitAndNotify("style");
        _p.transitioning = false;
    }
};
styfn$8.checkTrigger = function(ele, name, fromValue, toValue, getTrigger, onTrigger) {
    var prop = this.properties[name];
    var triggerCheck = getTrigger(prop);
    if (triggerCheck != null && triggerCheck(fromValue, toValue)) onTrigger(prop);
};
styfn$8.checkZOrderTrigger = function(ele, name, fromValue, toValue) {
    var _this = this;
    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {
        return prop.triggersZOrder;
    }, function() {
        _this._private.cy.notify("zorder", ele);
    });
};
styfn$8.checkBoundsTrigger = function(ele, name, fromValue, toValue) {
    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {
        return prop.triggersBounds;
    }, function(prop) {
        ele.dirtyCompoundBoundsCache();
        ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,
        // then dirty the pll edge bb cache as well
        if (prop.triggersBoundsOfParallelBeziers && (name === "curve-style" && (fromValue === "bezier" || toValue === "bezier") || name === "display" && (fromValue === "none" || toValue === "none"))) ele.parallelEdges().forEach(function(pllEdge) {
            if (pllEdge.isBundledBezier()) pllEdge.dirtyBoundingBoxCache();
        });
    });
};
styfn$8.checkTriggers = function(ele, name, fromValue, toValue) {
    ele.dirtyStyleCache();
    this.checkZOrderTrigger(ele, name, fromValue, toValue);
    this.checkBoundsTrigger(ele, name, fromValue, toValue);
};
var styfn$7 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property
styfn$7.applyBypass = function(eles, name, value, updateTransitions) {
    var self = this;
    var props = [];
    var isBypass = true; // put all the properties (can specify one or many) in an array after parsing them
    if (name === "*" || name === "**") {
        // apply to all property names
        if (value !== undefined) for(var i = 0; i < self.properties.length; i++){
            var prop = self.properties[i];
            var _name = prop.name;
            var parsedProp = this.parse(_name, value, true);
            if (parsedProp) props.push(parsedProp);
        }
    } else if (string(name)) {
        // then parse the single property
        var _parsedProp = this.parse(name, value, true);
        if (_parsedProp) props.push(_parsedProp);
    } else if (plainObject(name)) {
        // then parse each property
        var specifiedProps = name;
        updateTransitions = value;
        var names = Object.keys(specifiedProps);
        for(var _i = 0; _i < names.length; _i++){
            var _name2 = names[_i];
            var _value = specifiedProps[_name2];
            if (_value === undefined) // try camel case name too
            _value = specifiedProps[dash2camel(_name2)];
            if (_value !== undefined) {
                var _parsedProp2 = this.parse(_name2, _value, true);
                if (_parsedProp2) props.push(_parsedProp2);
            }
        }
    } else // can't do anything without well defined properties
    return false;
     // we've failed if there are no valid properties
    if (props.length === 0) return false;
     // now, apply the bypass properties on the elements
    var ret = false; // return true if at least one succesful bypass applied
    for(var _i2 = 0; _i2 < eles.length; _i2++){
        // for each ele
        var ele = eles[_i2];
        var diffProps = {};
        var diffProp = void 0;
        for(var j = 0; j < props.length; j++){
            // for each prop
            var _prop = props[j];
            if (updateTransitions) {
                var prevProp = ele.pstyle(_prop.name);
                diffProp = diffProps[_prop.name] = {
                    prev: prevProp
                };
            }
            ret = this.applyParsedProperty(ele, copy(_prop)) || ret;
            if (updateTransitions) diffProp.next = ele.pstyle(_prop.name);
        } // for props
        if (ret) this.updateStyleHints(ele);
        if (updateTransitions) this.updateTransitions(ele, diffProps, isBypass);
    } // for eles
    return ret;
}; // only useful in specific cases like animation
styfn$7.overrideBypass = function(eles, name, value) {
    name = camel2dash(name);
    for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        var prop = ele._private.style[name];
        var type = this.properties[name].type;
        var isColor = type.color;
        var isMulti = type.mutiple;
        var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;
        if (!prop || !prop.bypass) // need a bypass if one doesn't exist
        this.applyBypass(ele, name, value);
        else {
            prop.value = value;
            if (prop.pfValue != null) prop.pfValue = value;
            if (isColor) prop.strValue = "rgb(" + value.join(",") + ")";
            else if (isMulti) prop.strValue = value.join(" ");
            else prop.strValue = "" + value;
            this.updateStyleHints(ele);
        }
        this.checkTriggers(ele, name, oldValue, value);
    }
};
styfn$7.removeAllBypasses = function(eles, updateTransitions) {
    return this.removeBypasses(eles, this.propertyNames, updateTransitions);
};
styfn$7.removeBypasses = function(eles, props, updateTransitions) {
    var isBypass = true;
    for(var j = 0; j < eles.length; j++){
        var ele = eles[j];
        var diffProps = {};
        for(var i = 0; i < props.length; i++){
            var name = props[i];
            var prop = this.properties[name];
            var prevProp = ele.pstyle(prop.name);
            if (!prevProp || !prevProp.bypass) continue;
            var value = ""; // empty => remove bypass
            var parsedProp = this.parse(name, value, true);
            var diffProp = diffProps[prop.name] = {
                prev: prevProp
            };
            this.applyParsedProperty(ele, parsedProp);
            diffProp.next = ele.pstyle(prop.name);
        } // for props
        this.updateStyleHints(ele);
        if (updateTransitions) this.updateTransitions(ele, diffProps, isBypass);
    } // for eles
};
var styfn$6 = {}; // gets what an em size corresponds to in pixels relative to a dom element
styfn$6.getEmSizeInPixels = function() {
    var px = this.containerCss("font-size");
    if (px != null) return parseFloat(px);
    else return 1; // for headless
}; // gets css property from the core container
styfn$6.containerCss = function(propName) {
    var cy = this._private.cy;
    var domElement = cy.container();
    if (window$1 && domElement && window$1.getComputedStyle) return window$1.getComputedStyle(domElement).getPropertyValue(propName);
};
var styfn$5 = {}; // gets the rendered style for an element
styfn$5.getRenderedStyle = function(ele, prop) {
    if (prop) return this.getStylePropertyValue(ele, prop, true);
    else return this.getRawStyle(ele, true);
}; // gets the raw style for an element
styfn$5.getRawStyle = function(ele, isRenderedVal) {
    var self = this;
    ele = ele[0]; // insure it's an element
    if (ele) {
        var rstyle = {};
        for(var i = 0; i < self.properties.length; i++){
            var prop = self.properties[i];
            var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);
            if (val != null) {
                rstyle[prop.name] = val;
                rstyle[dash2camel(prop.name)] = val;
            }
        }
        return rstyle;
    }
};
styfn$5.getIndexedStyle = function(ele, property, subproperty, index) {
    var pstyle = ele.pstyle(property)[subproperty][index];
    return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
};
styfn$5.getStylePropertyValue = function(ele, propName, isRenderedVal) {
    var self = this;
    ele = ele[0]; // insure it's an element
    if (ele) {
        var prop = self.properties[propName];
        if (prop.alias) prop = prop.pointsTo;
        var type = prop.type;
        var styleProp = ele.pstyle(prop.name);
        if (styleProp) {
            var value = styleProp.value, units = styleProp.units, strValue = styleProp.strValue;
            if (isRenderedVal && type.number && value != null && number$1(value)) {
                var zoom = ele.cy().zoom();
                var getRenderedValue = function getRenderedValue(val) {
                    return val * zoom;
                };
                var getValueStringWithUnits = function getValueStringWithUnits(val, units) {
                    return getRenderedValue(val) + units;
                };
                var isArrayValue = array(value);
                var haveUnits = isArrayValue ? units.every(function(u) {
                    return u != null;
                }) : units != null;
                if (haveUnits) {
                    if (isArrayValue) return value.map(function(v, i) {
                        return getValueStringWithUnits(v, units[i]);
                    }).join(" ");
                    else return getValueStringWithUnits(value, units);
                } else {
                    if (isArrayValue) return value.map(function(v) {
                        return string(v) ? v : "" + getRenderedValue(v);
                    }).join(" ");
                    else return "" + getRenderedValue(value);
                }
            } else if (strValue != null) return strValue;
        }
        return null;
    }
};
styfn$5.getAnimationStartStyle = function(ele, aniProps) {
    var rstyle = {};
    for(var i = 0; i < aniProps.length; i++){
        var aniProp = aniProps[i];
        var name = aniProp.name;
        var styleProp = ele.pstyle(name);
        if (styleProp !== undefined) {
            // then make a prop of it
            if (plainObject(styleProp)) styleProp = this.parse(name, styleProp.strValue);
            else styleProp = this.parse(name, styleProp);
        }
        if (styleProp) rstyle[name] = styleProp;
    }
    return rstyle;
};
styfn$5.getPropsList = function(propsObj) {
    var self = this;
    var rstyle = [];
    var style = propsObj;
    var props = self.properties;
    if (style) {
        var names = Object.keys(style);
        for(var i = 0; i < names.length; i++){
            var name = names[i];
            var val = style[name];
            var prop = props[name] || props[camel2dash(name)];
            var styleProp = this.parse(prop.name, val);
            if (styleProp) rstyle.push(styleProp);
        }
    }
    return rstyle;
};
styfn$5.getNonDefaultPropertiesHash = function(ele, propNames, seed) {
    var hash = seed.slice();
    var name, val, strVal, chVal;
    var i, j;
    for(i = 0; i < propNames.length; i++){
        name = propNames[i];
        val = ele.pstyle(name, false);
        if (val == null) continue;
        else if (val.pfValue != null) {
            hash[0] = hashInt(chVal, hash[0]);
            hash[1] = hashIntAlt(chVal, hash[1]);
        } else {
            strVal = val.strValue;
            for(j = 0; j < strVal.length; j++){
                chVal = strVal.charCodeAt(j);
                hash[0] = hashInt(chVal, hash[0]);
                hash[1] = hashIntAlt(chVal, hash[1]);
            }
        }
    }
    return hash;
};
styfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;
var styfn$4 = {};
styfn$4.appendFromJson = function(json) {
    var style = this;
    for(var i = 0; i < json.length; i++){
        var context = json[i];
        var selector = context.selector;
        var props = context.style || context.css;
        var names = Object.keys(props);
        style.selector(selector); // apply selector
        for(var j = 0; j < names.length; j++){
            var name = names[j];
            var value = props[name];
            style.css(name, value); // apply property
        }
    }
    return style;
}; // accessible cy.style() function
styfn$4.fromJson = function(json) {
    var style = this;
    style.resetToDefault();
    style.appendFromJson(json);
    return style;
}; // get json from cy.style() api
styfn$4.json = function() {
    var json = [];
    for(var i = this.defaultLength; i < this.length; i++){
        var cxt = this[i];
        var selector = cxt.selector;
        var props = cxt.properties;
        var css = {};
        for(var j = 0; j < props.length; j++){
            var prop = props[j];
            css[prop.name] = prop.strValue;
        }
        json.push({
            selector: !selector ? "core" : selector.toString(),
            style: css
        });
    }
    return json;
};
var styfn$3 = {};
styfn$3.appendFromString = function(string) {
    var self = this;
    var style = this;
    var remaining = "" + string;
    var selAndBlockStr;
    var blockRem;
    var propAndValStr; // remove comments from the style string
    remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, "");
    function removeSelAndBlockFromRemaining() {
        // remove the parsed selector and block from the remaining text to parse
        if (remaining.length > selAndBlockStr.length) remaining = remaining.substr(selAndBlockStr.length);
        else remaining = "";
    }
    function removePropAndValFromRem() {
        // remove the parsed property and value from the remaining block text to parse
        if (blockRem.length > propAndValStr.length) blockRem = blockRem.substr(propAndValStr.length);
        else blockRem = "";
    }
    for(;;){
        var nothingLeftToParse = remaining.match(/^\s*$/);
        if (nothingLeftToParse) break;
        var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);
        if (!selAndBlock) {
            warn("Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: " + remaining);
            break;
        }
        selAndBlockStr = selAndBlock[0]; // parse the selector
        var selectorStr = selAndBlock[1];
        if (selectorStr !== "core") {
            var selector = new Selector(selectorStr);
            if (selector.invalid) {
                warn("Skipping parsing of block: Invalid selector found in string stylesheet: " + selectorStr); // skip this selector and block
                removeSelAndBlockFromRemaining();
                continue;
            }
        } // parse the block of properties and values
        var blockStr = selAndBlock[2];
        var invalidBlock = false;
        blockRem = blockStr;
        var props = [];
        for(;;){
            var _nothingLeftToParse = blockRem.match(/^\s*$/);
            if (_nothingLeftToParse) break;
            var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)(?:\s*;|\s*$)/);
            if (!propAndVal) {
                warn("Skipping parsing of block: Invalid formatting of style property and value definitions found in:" + blockStr);
                invalidBlock = true;
                break;
            }
            propAndValStr = propAndVal[0];
            var propStr = propAndVal[1];
            var valStr = propAndVal[2];
            var prop = self.properties[propStr];
            if (!prop) {
                warn("Skipping property: Invalid property name in: " + propAndValStr); // skip this property in the block
                removePropAndValFromRem();
                continue;
            }
            var parsedProp = style.parse(propStr, valStr);
            if (!parsedProp) {
                warn("Skipping property: Invalid property definition in: " + propAndValStr); // skip this property in the block
                removePropAndValFromRem();
                continue;
            }
            props.push({
                name: propStr,
                val: valStr
            });
            removePropAndValFromRem();
        }
        if (invalidBlock) {
            removeSelAndBlockFromRemaining();
            break;
        } // put the parsed block in the style
        style.selector(selectorStr);
        for(var i = 0; i < props.length; i++){
            var _prop = props[i];
            style.css(_prop.name, _prop.val);
        }
        removeSelAndBlockFromRemaining();
    }
    return style;
};
styfn$3.fromString = function(string) {
    var style = this;
    style.resetToDefault();
    style.appendFromString(string);
    return style;
};
var styfn$2 = {};
(function() {
    var number$1 = number;
    var rgba = rgbaNoBackRefs;
    var hsla = hslaNoBackRefs;
    var hex3$1 = hex3;
    var hex6$1 = hex6;
    var data = function data(prefix) {
        return "^" + prefix + "\\s*\\(\\s*([\\w\\.]+)\\s*\\)$";
    };
    var mapData = function mapData(prefix) {
        var mapArg = number$1 + "|\\w+|" + rgba + "|" + hsla + "|" + hex3$1 + "|" + hex6$1;
        return "^" + prefix + "\\s*\\(([\\w\\.]+)\\s*\\,\\s*(" + number$1 + ")\\s*\\,\\s*(" + number$1 + ")\\s*,\\s*(" + mapArg + ")\\s*\\,\\s*(" + mapArg + ")\\)$";
    };
    var urlRegexes = [
        "^url\\s*\\(\\s*['\"]?(.+?)['\"]?\\s*\\)$",
        "^(none)$",
        "^(.+)$"
    ]; // each visual style property has a type and needs to be validated according to it
    styfn$2.types = {
        time: {
            number: true,
            min: 0,
            units: "s|ms",
            implicitUnits: "ms"
        },
        percent: {
            number: true,
            min: 0,
            max: 100,
            units: "%",
            implicitUnits: "%"
        },
        percentages: {
            number: true,
            min: 0,
            max: 100,
            units: "%",
            implicitUnits: "%",
            multiple: true
        },
        zeroOneNumber: {
            number: true,
            min: 0,
            max: 1,
            unitless: true
        },
        zeroOneNumbers: {
            number: true,
            min: 0,
            max: 1,
            unitless: true,
            multiple: true
        },
        nOneOneNumber: {
            number: true,
            min: -1,
            max: 1,
            unitless: true
        },
        nonNegativeInt: {
            number: true,
            min: 0,
            integer: true,
            unitless: true
        },
        position: {
            enums: [
                "parent",
                "origin"
            ]
        },
        nodeSize: {
            number: true,
            min: 0,
            enums: [
                "label"
            ]
        },
        number: {
            number: true,
            unitless: true
        },
        numbers: {
            number: true,
            unitless: true,
            multiple: true
        },
        positiveNumber: {
            number: true,
            unitless: true,
            min: 0,
            strictMin: true
        },
        size: {
            number: true,
            min: 0
        },
        bidirectionalSize: {
            number: true
        },
        // allows negative
        bidirectionalSizeMaybePercent: {
            number: true,
            allowPercent: true
        },
        // allows negative
        bidirectionalSizes: {
            number: true,
            multiple: true
        },
        // allows negative
        sizeMaybePercent: {
            number: true,
            min: 0,
            allowPercent: true
        },
        axisDirection: {
            enums: [
                "horizontal",
                "leftward",
                "rightward",
                "vertical",
                "upward",
                "downward",
                "auto"
            ]
        },
        paddingRelativeTo: {
            enums: [
                "width",
                "height",
                "average",
                "min",
                "max"
            ]
        },
        bgWH: {
            number: true,
            min: 0,
            allowPercent: true,
            enums: [
                "auto"
            ],
            multiple: true
        },
        bgPos: {
            number: true,
            allowPercent: true,
            multiple: true
        },
        bgRelativeTo: {
            enums: [
                "inner",
                "include-padding"
            ],
            multiple: true
        },
        bgRepeat: {
            enums: [
                "repeat",
                "repeat-x",
                "repeat-y",
                "no-repeat"
            ],
            multiple: true
        },
        bgFit: {
            enums: [
                "none",
                "contain",
                "cover"
            ],
            multiple: true
        },
        bgCrossOrigin: {
            enums: [
                "anonymous",
                "use-credentials"
            ],
            multiple: true
        },
        bgClip: {
            enums: [
                "none",
                "node"
            ],
            multiple: true
        },
        bgContainment: {
            enums: [
                "inside",
                "over"
            ],
            multiple: true
        },
        color: {
            color: true
        },
        colors: {
            color: true,
            multiple: true
        },
        fill: {
            enums: [
                "solid",
                "linear-gradient",
                "radial-gradient"
            ]
        },
        bool: {
            enums: [
                "yes",
                "no"
            ]
        },
        bools: {
            enums: [
                "yes",
                "no"
            ],
            multiple: true
        },
        lineStyle: {
            enums: [
                "solid",
                "dotted",
                "dashed"
            ]
        },
        lineCap: {
            enums: [
                "butt",
                "round",
                "square"
            ]
        },
        borderStyle: {
            enums: [
                "solid",
                "dotted",
                "dashed",
                "double"
            ]
        },
        curveStyle: {
            enums: [
                "bezier",
                "unbundled-bezier",
                "haystack",
                "segments",
                "straight",
                "straight-triangle",
                "taxi"
            ]
        },
        fontFamily: {
            regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$'
        },
        fontStyle: {
            enums: [
                "italic",
                "normal",
                "oblique"
            ]
        },
        fontWeight: {
            enums: [
                "normal",
                "bold",
                "bolder",
                "lighter",
                "100",
                "200",
                "300",
                "400",
                "500",
                "600",
                "800",
                "900",
                100,
                200,
                300,
                400,
                500,
                600,
                700,
                800,
                900
            ]
        },
        textDecoration: {
            enums: [
                "none",
                "underline",
                "overline",
                "line-through"
            ]
        },
        textTransform: {
            enums: [
                "none",
                "uppercase",
                "lowercase"
            ]
        },
        textWrap: {
            enums: [
                "none",
                "wrap",
                "ellipsis"
            ]
        },
        textOverflowWrap: {
            enums: [
                "whitespace",
                "anywhere"
            ]
        },
        textBackgroundShape: {
            enums: [
                "rectangle",
                "roundrectangle",
                "round-rectangle"
            ]
        },
        nodeShape: {
            enums: [
                "rectangle",
                "roundrectangle",
                "round-rectangle",
                "cutrectangle",
                "cut-rectangle",
                "bottomroundrectangle",
                "bottom-round-rectangle",
                "barrel",
                "ellipse",
                "triangle",
                "round-triangle",
                "square",
                "pentagon",
                "round-pentagon",
                "hexagon",
                "round-hexagon",
                "concavehexagon",
                "concave-hexagon",
                "heptagon",
                "round-heptagon",
                "octagon",
                "round-octagon",
                "tag",
                "round-tag",
                "star",
                "diamond",
                "round-diamond",
                "vee",
                "rhomboid",
                "polygon"
            ]
        },
        overlayShape: {
            enums: [
                "roundrectangle",
                "round-rectangle",
                "ellipse"
            ]
        },
        compoundIncludeLabels: {
            enums: [
                "include",
                "exclude"
            ]
        },
        arrowShape: {
            enums: [
                "tee",
                "triangle",
                "triangle-tee",
                "circle-triangle",
                "triangle-cross",
                "triangle-backcurve",
                "vee",
                "square",
                "circle",
                "diamond",
                "chevron",
                "none"
            ]
        },
        arrowFill: {
            enums: [
                "filled",
                "hollow"
            ]
        },
        display: {
            enums: [
                "element",
                "none"
            ]
        },
        visibility: {
            enums: [
                "hidden",
                "visible"
            ]
        },
        zCompoundDepth: {
            enums: [
                "bottom",
                "orphan",
                "auto",
                "top"
            ]
        },
        zIndexCompare: {
            enums: [
                "auto",
                "manual"
            ]
        },
        valign: {
            enums: [
                "top",
                "center",
                "bottom"
            ]
        },
        halign: {
            enums: [
                "left",
                "center",
                "right"
            ]
        },
        justification: {
            enums: [
                "left",
                "center",
                "right",
                "auto"
            ]
        },
        text: {
            string: true
        },
        data: {
            mapping: true,
            regex: data("data")
        },
        layoutData: {
            mapping: true,
            regex: data("layoutData")
        },
        scratch: {
            mapping: true,
            regex: data("scratch")
        },
        mapData: {
            mapping: true,
            regex: mapData("mapData")
        },
        mapLayoutData: {
            mapping: true,
            regex: mapData("mapLayoutData")
        },
        mapScratch: {
            mapping: true,
            regex: mapData("mapScratch")
        },
        fn: {
            mapping: true,
            fn: true
        },
        url: {
            regexes: urlRegexes,
            singleRegexMatchValue: true
        },
        urls: {
            regexes: urlRegexes,
            singleRegexMatchValue: true,
            multiple: true
        },
        propList: {
            propList: true
        },
        angle: {
            number: true,
            units: "deg|rad",
            implicitUnits: "rad"
        },
        textRotation: {
            number: true,
            units: "deg|rad",
            implicitUnits: "rad",
            enums: [
                "none",
                "autorotate"
            ]
        },
        polygonPointList: {
            number: true,
            multiple: true,
            evenMultiple: true,
            min: -1,
            max: 1,
            unitless: true
        },
        edgeDistances: {
            enums: [
                "intersection",
                "node-position"
            ]
        },
        edgeEndpoint: {
            number: true,
            multiple: true,
            units: "%|px|em|deg|rad",
            implicitUnits: "px",
            enums: [
                "inside-to-node",
                "outside-to-node",
                "outside-to-node-or-label",
                "outside-to-line",
                "outside-to-line-or-label"
            ],
            singleEnum: true,
            validate: function validate(valArr, unitsArr) {
                switch(valArr.length){
                    case 2:
                        // can be % or px only
                        return unitsArr[0] !== "deg" && unitsArr[0] !== "rad" && unitsArr[1] !== "deg" && unitsArr[1] !== "rad";
                    case 1:
                        // can be enum, deg, or rad only
                        return string(valArr[0]) || unitsArr[0] === "deg" || unitsArr[0] === "rad";
                    default:
                        return false;
                }
            }
        },
        easing: {
            regexes: [
                "^(spring)\\s*\\(\\s*(" + number$1 + ")\\s*,\\s*(" + number$1 + ")\\s*\\)$",
                "^(cubic-bezier)\\s*\\(\\s*(" + number$1 + ")\\s*,\\s*(" + number$1 + ")\\s*,\\s*(" + number$1 + ")\\s*,\\s*(" + number$1 + ")\\s*\\)$"
            ],
            enums: [
                "linear",
                "ease",
                "ease-in",
                "ease-out",
                "ease-in-out",
                "ease-in-sine",
                "ease-out-sine",
                "ease-in-out-sine",
                "ease-in-quad",
                "ease-out-quad",
                "ease-in-out-quad",
                "ease-in-cubic",
                "ease-out-cubic",
                "ease-in-out-cubic",
                "ease-in-quart",
                "ease-out-quart",
                "ease-in-out-quart",
                "ease-in-quint",
                "ease-out-quint",
                "ease-in-out-quint",
                "ease-in-expo",
                "ease-out-expo",
                "ease-in-out-expo",
                "ease-in-circ",
                "ease-out-circ",
                "ease-in-out-circ"
            ]
        },
        gradientDirection: {
            enums: [
                "to-bottom",
                "to-top",
                "to-left",
                "to-right",
                "to-bottom-right",
                "to-bottom-left",
                "to-top-right",
                "to-top-left",
                "to-right-bottom",
                "to-left-bottom",
                "to-right-top",
                "to-left-top" // different order
            ]
        },
        boundsExpansion: {
            number: true,
            multiple: true,
            min: 0,
            validate: function validate(valArr) {
                var length = valArr.length;
                return length === 1 || length === 2 || length === 4;
            }
        }
    };
    var diff = {
        zeroNonZero: function zeroNonZero(val1, val2) {
            if ((val1 == null || val2 == null) && val1 !== val2) return true; // null cases could represent any value
            if (val1 == 0 && val2 != 0) return true;
            else if (val1 != 0 && val2 == 0) return true;
            else return false;
        },
        any: function any(val1, val2) {
            return val1 != val2;
        },
        emptyNonEmpty: function emptyNonEmpty(str1, str2) {
            var empty1 = emptyString(str1);
            var empty2 = emptyString(str2);
            return empty1 && !empty2 || !empty1 && empty2;
        }
    }; // define visual style properties
    //
    // - n.b. adding a new group of props may require updates to updateStyleHints()
    // - adding new props to an existing group gets handled automatically
    var t = styfn$2.types;
    var mainLabel = [
        {
            name: "label",
            type: t.text,
            triggersBounds: diff.any,
            triggersZOrder: diff.emptyNonEmpty
        },
        {
            name: "text-rotation",
            type: t.textRotation,
            triggersBounds: diff.any
        },
        {
            name: "text-margin-x",
            type: t.bidirectionalSize,
            triggersBounds: diff.any
        },
        {
            name: "text-margin-y",
            type: t.bidirectionalSize,
            triggersBounds: diff.any
        }
    ];
    var sourceLabel = [
        {
            name: "source-label",
            type: t.text,
            triggersBounds: diff.any
        },
        {
            name: "source-text-rotation",
            type: t.textRotation,
            triggersBounds: diff.any
        },
        {
            name: "source-text-margin-x",
            type: t.bidirectionalSize,
            triggersBounds: diff.any
        },
        {
            name: "source-text-margin-y",
            type: t.bidirectionalSize,
            triggersBounds: diff.any
        },
        {
            name: "source-text-offset",
            type: t.size,
            triggersBounds: diff.any
        }
    ];
    var targetLabel = [
        {
            name: "target-label",
            type: t.text,
            triggersBounds: diff.any
        },
        {
            name: "target-text-rotation",
            type: t.textRotation,
            triggersBounds: diff.any
        },
        {
            name: "target-text-margin-x",
            type: t.bidirectionalSize,
            triggersBounds: diff.any
        },
        {
            name: "target-text-margin-y",
            type: t.bidirectionalSize,
            triggersBounds: diff.any
        },
        {
            name: "target-text-offset",
            type: t.size,
            triggersBounds: diff.any
        }
    ];
    var labelDimensions = [
        {
            name: "font-family",
            type: t.fontFamily,
            triggersBounds: diff.any
        },
        {
            name: "font-style",
            type: t.fontStyle,
            triggersBounds: diff.any
        },
        {
            name: "font-weight",
            type: t.fontWeight,
            triggersBounds: diff.any
        },
        {
            name: "font-size",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "text-transform",
            type: t.textTransform,
            triggersBounds: diff.any
        },
        {
            name: "text-wrap",
            type: t.textWrap,
            triggersBounds: diff.any
        },
        {
            name: "text-overflow-wrap",
            type: t.textOverflowWrap,
            triggersBounds: diff.any
        },
        {
            name: "text-max-width",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "text-outline-width",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "line-height",
            type: t.positiveNumber,
            triggersBounds: diff.any
        }
    ];
    var commonLabel = [
        {
            name: "text-valign",
            type: t.valign,
            triggersBounds: diff.any
        },
        {
            name: "text-halign",
            type: t.halign,
            triggersBounds: diff.any
        },
        {
            name: "color",
            type: t.color
        },
        {
            name: "text-outline-color",
            type: t.color
        },
        {
            name: "text-outline-opacity",
            type: t.zeroOneNumber
        },
        {
            name: "text-background-color",
            type: t.color
        },
        {
            name: "text-background-opacity",
            type: t.zeroOneNumber
        },
        {
            name: "text-background-padding",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "text-border-opacity",
            type: t.zeroOneNumber
        },
        {
            name: "text-border-color",
            type: t.color
        },
        {
            name: "text-border-width",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "text-border-style",
            type: t.borderStyle,
            triggersBounds: diff.any
        },
        {
            name: "text-background-shape",
            type: t.textBackgroundShape,
            triggersBounds: diff.any
        },
        {
            name: "text-justification",
            type: t.justification
        }
    ];
    var behavior = [
        {
            name: "events",
            type: t.bool
        },
        {
            name: "text-events",
            type: t.bool
        }
    ];
    var visibility = [
        {
            name: "display",
            type: t.display,
            triggersZOrder: diff.any,
            triggersBounds: diff.any,
            triggersBoundsOfParallelBeziers: true
        },
        {
            name: "visibility",
            type: t.visibility,
            triggersZOrder: diff.any
        },
        {
            name: "opacity",
            type: t.zeroOneNumber,
            triggersZOrder: diff.zeroNonZero
        },
        {
            name: "text-opacity",
            type: t.zeroOneNumber
        },
        {
            name: "min-zoomed-font-size",
            type: t.size
        },
        {
            name: "z-compound-depth",
            type: t.zCompoundDepth,
            triggersZOrder: diff.any
        },
        {
            name: "z-index-compare",
            type: t.zIndexCompare,
            triggersZOrder: diff.any
        },
        {
            name: "z-index",
            type: t.nonNegativeInt,
            triggersZOrder: diff.any
        }
    ];
    var overlay = [
        {
            name: "overlay-padding",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "overlay-color",
            type: t.color
        },
        {
            name: "overlay-opacity",
            type: t.zeroOneNumber,
            triggersBounds: diff.zeroNonZero
        },
        {
            name: "overlay-shape",
            type: t.overlayShape,
            triggersBounds: diff.any
        }
    ];
    var underlay = [
        {
            name: "underlay-padding",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "underlay-color",
            type: t.color
        },
        {
            name: "underlay-opacity",
            type: t.zeroOneNumber,
            triggersBounds: diff.zeroNonZero
        },
        {
            name: "underlay-shape",
            type: t.overlayShape,
            triggersBounds: diff.any
        }
    ];
    var transition = [
        {
            name: "transition-property",
            type: t.propList
        },
        {
            name: "transition-duration",
            type: t.time
        },
        {
            name: "transition-delay",
            type: t.time
        },
        {
            name: "transition-timing-function",
            type: t.easing
        }
    ];
    var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {
        if (parsedProp.value === "label") return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)
        else return parsedProp.pfValue;
    };
    var nodeBody = [
        {
            name: "height",
            type: t.nodeSize,
            triggersBounds: diff.any,
            hashOverride: nodeSizeHashOverride
        },
        {
            name: "width",
            type: t.nodeSize,
            triggersBounds: diff.any,
            hashOverride: nodeSizeHashOverride
        },
        {
            name: "shape",
            type: t.nodeShape,
            triggersBounds: diff.any
        },
        {
            name: "shape-polygon-points",
            type: t.polygonPointList,
            triggersBounds: diff.any
        },
        {
            name: "background-color",
            type: t.color
        },
        {
            name: "background-fill",
            type: t.fill
        },
        {
            name: "background-opacity",
            type: t.zeroOneNumber
        },
        {
            name: "background-blacken",
            type: t.nOneOneNumber
        },
        {
            name: "background-gradient-stop-colors",
            type: t.colors
        },
        {
            name: "background-gradient-stop-positions",
            type: t.percentages
        },
        {
            name: "background-gradient-direction",
            type: t.gradientDirection
        },
        {
            name: "padding",
            type: t.sizeMaybePercent,
            triggersBounds: diff.any
        },
        {
            name: "padding-relative-to",
            type: t.paddingRelativeTo,
            triggersBounds: diff.any
        },
        {
            name: "bounds-expansion",
            type: t.boundsExpansion,
            triggersBounds: diff.any
        }
    ];
    var nodeBorder = [
        {
            name: "border-color",
            type: t.color
        },
        {
            name: "border-opacity",
            type: t.zeroOneNumber
        },
        {
            name: "border-width",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "border-style",
            type: t.borderStyle
        }
    ];
    var backgroundImage = [
        {
            name: "background-image",
            type: t.urls
        },
        {
            name: "background-image-crossorigin",
            type: t.bgCrossOrigin
        },
        {
            name: "background-image-opacity",
            type: t.zeroOneNumbers
        },
        {
            name: "background-image-containment",
            type: t.bgContainment
        },
        {
            name: "background-image-smoothing",
            type: t.bools
        },
        {
            name: "background-position-x",
            type: t.bgPos
        },
        {
            name: "background-position-y",
            type: t.bgPos
        },
        {
            name: "background-width-relative-to",
            type: t.bgRelativeTo
        },
        {
            name: "background-height-relative-to",
            type: t.bgRelativeTo
        },
        {
            name: "background-repeat",
            type: t.bgRepeat
        },
        {
            name: "background-fit",
            type: t.bgFit
        },
        {
            name: "background-clip",
            type: t.bgClip
        },
        {
            name: "background-width",
            type: t.bgWH
        },
        {
            name: "background-height",
            type: t.bgWH
        },
        {
            name: "background-offset-x",
            type: t.bgPos
        },
        {
            name: "background-offset-y",
            type: t.bgPos
        }
    ];
    var compound = [
        {
            name: "position",
            type: t.position,
            triggersBounds: diff.any
        },
        {
            name: "compound-sizing-wrt-labels",
            type: t.compoundIncludeLabels,
            triggersBounds: diff.any
        },
        {
            name: "min-width",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "min-width-bias-left",
            type: t.sizeMaybePercent,
            triggersBounds: diff.any
        },
        {
            name: "min-width-bias-right",
            type: t.sizeMaybePercent,
            triggersBounds: diff.any
        },
        {
            name: "min-height",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "min-height-bias-top",
            type: t.sizeMaybePercent,
            triggersBounds: diff.any
        },
        {
            name: "min-height-bias-bottom",
            type: t.sizeMaybePercent,
            triggersBounds: diff.any
        }
    ];
    var edgeLine = [
        {
            name: "line-style",
            type: t.lineStyle
        },
        {
            name: "line-color",
            type: t.color
        },
        {
            name: "line-fill",
            type: t.fill
        },
        {
            name: "line-cap",
            type: t.lineCap
        },
        {
            name: "line-opacity",
            type: t.zeroOneNumber
        },
        {
            name: "line-dash-pattern",
            type: t.numbers
        },
        {
            name: "line-dash-offset",
            type: t.number
        },
        {
            name: "line-gradient-stop-colors",
            type: t.colors
        },
        {
            name: "line-gradient-stop-positions",
            type: t.percentages
        },
        {
            name: "curve-style",
            type: t.curveStyle,
            triggersBounds: diff.any,
            triggersBoundsOfParallelBeziers: true
        },
        {
            name: "haystack-radius",
            type: t.zeroOneNumber,
            triggersBounds: diff.any
        },
        {
            name: "source-endpoint",
            type: t.edgeEndpoint,
            triggersBounds: diff.any
        },
        {
            name: "target-endpoint",
            type: t.edgeEndpoint,
            triggersBounds: diff.any
        },
        {
            name: "control-point-step-size",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "control-point-distances",
            type: t.bidirectionalSizes,
            triggersBounds: diff.any
        },
        {
            name: "control-point-weights",
            type: t.numbers,
            triggersBounds: diff.any
        },
        {
            name: "segment-distances",
            type: t.bidirectionalSizes,
            triggersBounds: diff.any
        },
        {
            name: "segment-weights",
            type: t.numbers,
            triggersBounds: diff.any
        },
        {
            name: "taxi-turn",
            type: t.bidirectionalSizeMaybePercent,
            triggersBounds: diff.any
        },
        {
            name: "taxi-turn-min-distance",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "taxi-direction",
            type: t.axisDirection,
            triggersBounds: diff.any
        },
        {
            name: "edge-distances",
            type: t.edgeDistances,
            triggersBounds: diff.any
        },
        {
            name: "arrow-scale",
            type: t.positiveNumber,
            triggersBounds: diff.any
        },
        {
            name: "loop-direction",
            type: t.angle,
            triggersBounds: diff.any
        },
        {
            name: "loop-sweep",
            type: t.angle,
            triggersBounds: diff.any
        },
        {
            name: "source-distance-from-node",
            type: t.size,
            triggersBounds: diff.any
        },
        {
            name: "target-distance-from-node",
            type: t.size,
            triggersBounds: diff.any
        }
    ];
    var ghost = [
        {
            name: "ghost",
            type: t.bool,
            triggersBounds: diff.any
        },
        {
            name: "ghost-offset-x",
            type: t.bidirectionalSize,
            triggersBounds: diff.any
        },
        {
            name: "ghost-offset-y",
            type: t.bidirectionalSize,
            triggersBounds: diff.any
        },
        {
            name: "ghost-opacity",
            type: t.zeroOneNumber
        }
    ];
    var core = [
        {
            name: "selection-box-color",
            type: t.color
        },
        {
            name: "selection-box-opacity",
            type: t.zeroOneNumber
        },
        {
            name: "selection-box-border-color",
            type: t.color
        },
        {
            name: "selection-box-border-width",
            type: t.size
        },
        {
            name: "active-bg-color",
            type: t.color
        },
        {
            name: "active-bg-opacity",
            type: t.zeroOneNumber
        },
        {
            name: "active-bg-size",
            type: t.size
        },
        {
            name: "outside-texture-bg-color",
            type: t.color
        },
        {
            name: "outside-texture-bg-opacity",
            type: t.zeroOneNumber
        }
    ]; // pie backgrounds for nodes
    var pie = [];
    styfn$2.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
    pie.push({
        name: "pie-size",
        type: t.sizeMaybePercent
    });
    for(var i = 1; i <= styfn$2.pieBackgroundN; i++){
        pie.push({
            name: "pie-" + i + "-background-color",
            type: t.color
        });
        pie.push({
            name: "pie-" + i + "-background-size",
            type: t.percent
        });
        pie.push({
            name: "pie-" + i + "-background-opacity",
            type: t.zeroOneNumber
        });
    } // edge arrows
    var edgeArrow = [];
    var arrowPrefixes = styfn$2.arrowPrefixes = [
        "source",
        "mid-source",
        "target",
        "mid-target"
    ];
    [
        {
            name: "arrow-shape",
            type: t.arrowShape,
            triggersBounds: diff.any
        },
        {
            name: "arrow-color",
            type: t.color
        },
        {
            name: "arrow-fill",
            type: t.arrowFill
        }
    ].forEach(function(prop) {
        arrowPrefixes.forEach(function(prefix) {
            var name = prefix + "-" + prop.name;
            var type = prop.type, triggersBounds = prop.triggersBounds;
            edgeArrow.push({
                name: name,
                type: type,
                triggersBounds: triggersBounds
            });
        });
    }, {});
    var props = styfn$2.properties = [].concat(behavior, transition, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);
    var propGroups = styfn$2.propertyGroups = {
        // common to all eles
        behavior: behavior,
        transition: transition,
        visibility: visibility,
        overlay: overlay,
        underlay: underlay,
        ghost: ghost,
        // labels
        commonLabel: commonLabel,
        labelDimensions: labelDimensions,
        mainLabel: mainLabel,
        sourceLabel: sourceLabel,
        targetLabel: targetLabel,
        // node props
        nodeBody: nodeBody,
        nodeBorder: nodeBorder,
        backgroundImage: backgroundImage,
        pie: pie,
        compound: compound,
        // edge props
        edgeLine: edgeLine,
        edgeArrow: edgeArrow,
        core: core
    };
    var propGroupNames = styfn$2.propertyGroupNames = {};
    var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);
    propGroupKeys.forEach(function(key) {
        propGroupNames[key] = propGroups[key].map(function(prop) {
            return prop.name;
        });
        propGroups[key].forEach(function(prop) {
            return prop.groupKey = key;
        });
    }); // define aliases
    var aliases = styfn$2.aliases = [
        {
            name: "content",
            pointsTo: "label"
        },
        {
            name: "control-point-distance",
            pointsTo: "control-point-distances"
        },
        {
            name: "control-point-weight",
            pointsTo: "control-point-weights"
        },
        {
            name: "edge-text-rotation",
            pointsTo: "text-rotation"
        },
        {
            name: "padding-left",
            pointsTo: "padding"
        },
        {
            name: "padding-right",
            pointsTo: "padding"
        },
        {
            name: "padding-top",
            pointsTo: "padding"
        },
        {
            name: "padding-bottom",
            pointsTo: "padding"
        }
    ]; // list of property names
    styfn$2.propertyNames = props.map(function(p) {
        return p.name;
    }); // allow access of properties by name ( e.g. style.properties.height )
    for(var _i = 0; _i < props.length; _i++){
        var prop = props[_i];
        props[prop.name] = prop; // allow lookup by name
    } // map aliases
    for(var _i2 = 0; _i2 < aliases.length; _i2++){
        var alias = aliases[_i2];
        var pointsToProp = props[alias.pointsTo];
        var aliasProp = {
            name: alias.name,
            alias: true,
            pointsTo: pointsToProp
        }; // add alias prop for parsing
        props.push(aliasProp);
        props[alias.name] = aliasProp; // allow lookup by name
    }
})();
styfn$2.getDefaultProperty = function(name) {
    return this.getDefaultProperties()[name];
};
styfn$2.getDefaultProperties = function() {
    var _p = this._private;
    if (_p.defaultProperties != null) return _p.defaultProperties;
    var rawProps = extend({
        // core props
        "selection-box-color": "#ddd",
        "selection-box-opacity": 0.65,
        "selection-box-border-color": "#aaa",
        "selection-box-border-width": 1,
        "active-bg-color": "black",
        "active-bg-opacity": 0.15,
        "active-bg-size": 30,
        "outside-texture-bg-color": "#000",
        "outside-texture-bg-opacity": 0.125,
        // common node/edge props
        "events": "yes",
        "text-events": "no",
        "text-valign": "top",
        "text-halign": "center",
        "text-justification": "auto",
        "line-height": 1,
        "color": "#000",
        "text-outline-color": "#000",
        "text-outline-width": 0,
        "text-outline-opacity": 1,
        "text-opacity": 1,
        "text-decoration": "none",
        "text-transform": "none",
        "text-wrap": "none",
        "text-overflow-wrap": "whitespace",
        "text-max-width": 9999,
        "text-background-color": "#000",
        "text-background-opacity": 0,
        "text-background-shape": "rectangle",
        "text-background-padding": 0,
        "text-border-opacity": 0,
        "text-border-width": 0,
        "text-border-style": "solid",
        "text-border-color": "#000",
        "font-family": "Helvetica Neue, Helvetica, sans-serif",
        "font-style": "normal",
        "font-weight": "normal",
        "font-size": 16,
        "min-zoomed-font-size": 0,
        "text-rotation": "none",
        "source-text-rotation": "none",
        "target-text-rotation": "none",
        "visibility": "visible",
        "display": "element",
        "opacity": 1,
        "z-compound-depth": "auto",
        "z-index-compare": "auto",
        "z-index": 0,
        "label": "",
        "text-margin-x": 0,
        "text-margin-y": 0,
        "source-label": "",
        "source-text-offset": 0,
        "source-text-margin-x": 0,
        "source-text-margin-y": 0,
        "target-label": "",
        "target-text-offset": 0,
        "target-text-margin-x": 0,
        "target-text-margin-y": 0,
        "overlay-opacity": 0,
        "overlay-color": "#000",
        "overlay-padding": 10,
        "overlay-shape": "round-rectangle",
        "underlay-opacity": 0,
        "underlay-color": "#000",
        "underlay-padding": 10,
        "underlay-shape": "round-rectangle",
        "transition-property": "none",
        "transition-duration": 0,
        "transition-delay": 0,
        "transition-timing-function": "linear",
        // node props
        "background-blacken": 0,
        "background-color": "#999",
        "background-fill": "solid",
        "background-opacity": 1,
        "background-image": "none",
        "background-image-crossorigin": "anonymous",
        "background-image-opacity": 1,
        "background-image-containment": "inside",
        "background-image-smoothing": "yes",
        "background-position-x": "50%",
        "background-position-y": "50%",
        "background-offset-x": 0,
        "background-offset-y": 0,
        "background-width-relative-to": "include-padding",
        "background-height-relative-to": "include-padding",
        "background-repeat": "no-repeat",
        "background-fit": "none",
        "background-clip": "node",
        "background-width": "auto",
        "background-height": "auto",
        "border-color": "#000",
        "border-opacity": 1,
        "border-width": 0,
        "border-style": "solid",
        "height": 30,
        "width": 30,
        "shape": "ellipse",
        "shape-polygon-points": "-1, -1,   1, -1,   1, 1,   -1, 1",
        "bounds-expansion": 0,
        // node gradient
        "background-gradient-direction": "to-bottom",
        "background-gradient-stop-colors": "#999",
        "background-gradient-stop-positions": "0%",
        // ghost props
        "ghost": "no",
        "ghost-offset-y": 0,
        "ghost-offset-x": 0,
        "ghost-opacity": 0,
        // compound props
        "padding": 0,
        "padding-relative-to": "width",
        "position": "origin",
        "compound-sizing-wrt-labels": "include",
        "min-width": 0,
        "min-width-bias-left": 0,
        "min-width-bias-right": 0,
        "min-height": 0,
        "min-height-bias-top": 0,
        "min-height-bias-bottom": 0
    }, {
        // node pie bg
        "pie-size": "100%"
    }, [
        {
            name: "pie-{{i}}-background-color",
            value: "black"
        },
        {
            name: "pie-{{i}}-background-size",
            value: "0%"
        },
        {
            name: "pie-{{i}}-background-opacity",
            value: 1
        }
    ].reduce(function(css, prop) {
        for(var i = 1; i <= styfn$2.pieBackgroundN; i++){
            var name = prop.name.replace("{{i}}", i);
            var val = prop.value;
            css[name] = val;
        }
        return css;
    }, {}), {
        // edge props
        "line-style": "solid",
        "line-color": "#999",
        "line-fill": "solid",
        "line-cap": "butt",
        "line-opacity": 1,
        "line-gradient-stop-colors": "#999",
        "line-gradient-stop-positions": "0%",
        "control-point-step-size": 40,
        "control-point-weights": 0.5,
        "segment-weights": 0.5,
        "segment-distances": 20,
        "taxi-turn": "50%",
        "taxi-turn-min-distance": 10,
        "taxi-direction": "auto",
        "edge-distances": "intersection",
        "curve-style": "haystack",
        "haystack-radius": 0,
        "arrow-scale": 1,
        "loop-direction": "-45deg",
        "loop-sweep": "-90deg",
        "source-distance-from-node": 0,
        "target-distance-from-node": 0,
        "source-endpoint": "outside-to-node",
        "target-endpoint": "outside-to-node",
        "line-dash-pattern": [
            6,
            3
        ],
        "line-dash-offset": 0
    }, [
        {
            name: "arrow-shape",
            value: "none"
        },
        {
            name: "arrow-color",
            value: "#999"
        },
        {
            name: "arrow-fill",
            value: "filled"
        }
    ].reduce(function(css, prop) {
        styfn$2.arrowPrefixes.forEach(function(prefix) {
            var name = prefix + "-" + prop.name;
            var val = prop.value;
            css[name] = val;
        });
        return css;
    }, {}));
    var parsedProps = {};
    for(var i = 0; i < this.properties.length; i++){
        var prop = this.properties[i];
        if (prop.pointsTo) continue;
        var name = prop.name;
        var val = rawProps[name];
        var parsedProp = this.parse(name, val);
        parsedProps[name] = parsedProp;
    }
    _p.defaultProperties = parsedProps;
    return _p.defaultProperties;
};
styfn$2.addDefaultStylesheet = function() {
    this.selector(":parent").css({
        "shape": "rectangle",
        "padding": 10,
        "background-color": "#eee",
        "border-color": "#ccc",
        "border-width": 1
    }).selector("edge").css({
        "width": 3
    }).selector(":loop").css({
        "curve-style": "bezier"
    }).selector("edge:compound").css({
        "curve-style": "bezier",
        "source-endpoint": "outside-to-line",
        "target-endpoint": "outside-to-line"
    }).selector(":selected").css({
        "background-color": "#0169D9",
        "line-color": "#0169D9",
        "source-arrow-color": "#0169D9",
        "target-arrow-color": "#0169D9",
        "mid-source-arrow-color": "#0169D9",
        "mid-target-arrow-color": "#0169D9"
    }).selector(":parent:selected").css({
        "background-color": "#CCE1F9",
        "border-color": "#aec8e5"
    }).selector(":active").css({
        "overlay-color": "black",
        "overlay-padding": 10,
        "overlay-opacity": 0.25
    });
    this.defaultLength = this.length;
};
var styfn$1 = {}; // a caching layer for property parsing
styfn$1.parse = function(name, value, propIsBypass, propIsFlat) {
    var self = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway
    if (fn$6(value)) return self.parseImplWarn(name, value, propIsBypass, propIsFlat);
    var flatKey = propIsFlat === "mapping" || propIsFlat === true || propIsFlat === false || propIsFlat == null ? "dontcare" : propIsFlat;
    var bypassKey = propIsBypass ? "t" : "f";
    var valueKey = "" + value;
    var argHash = hashStrings(name, valueKey, bypassKey, flatKey);
    var propCache = self.propCache = self.propCache || [];
    var ret;
    if (!(ret = propCache[argHash])) ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);
     // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
    // - mappings can't be shared b/c mappings are per-element
    if (propIsBypass || propIsFlat === "mapping") {
        // need a copy since props are mutated later in their lifecycles
        ret = copy(ret);
        if (ret) ret.value = copy(ret.value); // because it could be an array, e.g. colour
    }
    return ret;
};
styfn$1.parseImplWarn = function(name, value, propIsBypass, propIsFlat) {
    var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);
    if (!prop && value != null) warn("The style property `".concat(name, ": ").concat(value, "` is invalid"));
    if (prop && (prop.name === "width" || prop.name === "height") && value === "label") warn("The style value of `label` is deprecated for `" + prop.name + "`");
    return prop;
}; // parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property
styfn$1.parseImpl = function(name, value, propIsBypass, propIsFlat) {
    var self = this;
    name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')
    var property = self.properties[name];
    var passedValue = value;
    var types = self.types;
    if (!property) return null;
     // return null on property of unknown name
    if (value === undefined) return null;
     // can't assign undefined
    // the property may be an alias
    if (property.alias) {
        property = property.pointsTo;
        name = property.name;
    }
    var valueIsString = string(value);
    if (valueIsString) // trim the value to make parsing easier
    value = value.trim();
    var type = property.type;
    if (!type) return null;
     // no type, no luck
    // check if bypass is null or empty string (i.e. indication to delete bypass property)
    if (propIsBypass && (value === "" || value === null)) return {
        name: name,
        value: value,
        bypass: true,
        deleteBypass: true
    };
     // check if value is a function used as a mapper
    if (fn$6(value)) return {
        name: name,
        value: value,
        strValue: "fn",
        mapped: types.fn,
        bypass: propIsBypass
    };
     // check if value is mapped
    var data, mapData;
    if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== "a") ;
    else if (value.length >= 7 && value[0] === "d" && (data = new RegExp(types.data.regex).exec(value))) {
        if (propIsBypass) return false;
         // mappers not allowed in bypass
        var mapped = types.data;
        return {
            name: name,
            value: data,
            strValue: "" + value,
            mapped: mapped,
            field: data[1],
            bypass: propIsBypass
        };
    } else if (value.length >= 10 && value[0] === "m" && (mapData = new RegExp(types.mapData.regex).exec(value))) {
        if (propIsBypass) return false;
         // mappers not allowed in bypass
        if (type.multiple) return false;
         // impossible to map to num
        var _mapped = types.mapData; // we can map only if the type is a colour or a number
        if (!(type.color || type.number)) return false;
        var valueMin = this.parse(name, mapData[4]); // parse to validate
        if (!valueMin || valueMin.mapped) return false;
         // can't be invalid or mapped
        var valueMax = this.parse(name, mapData[5]); // parse to validate
        if (!valueMax || valueMax.mapped) return false;
         // can't be invalid or mapped
        // check if valueMin and valueMax are the same
        if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {
            warn("`" + name + ": " + value + "` is not a valid mapper because the output range is zero; converting to `" + name + ": " + valueMin.strValue + "`");
            return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range
        } else if (type.color) {
            var c1 = valueMin.value;
            var c2 = valueMax.value;
            var same = c1[0] === c2[0] // red
             && c1[1] === c2[1] // green
             && c1[2] === c2[2] // blue
             && (c1[3] === c2[3] // same alpha outright
             || (c1[3] == null || c1[3] === 1 // full opacity for colour 1?
            ) && (c2[3] == null || c2[3] === 1 // full opacity for colour 2?
            ));
            if (same) return false;
             // can't make a mapper without a range
        }
        return {
            name: name,
            value: mapData,
            strValue: "" + value,
            mapped: _mapped,
            field: mapData[1],
            fieldMin: parseFloat(mapData[2]),
            // min & max are numeric
            fieldMax: parseFloat(mapData[3]),
            valueMin: valueMin.value,
            valueMax: valueMax.value,
            bypass: propIsBypass
        };
    }
    if (type.multiple && propIsFlat !== "multiple") {
        var vals;
        if (valueIsString) vals = value.split(/\s+/);
        else if (array(value)) vals = value;
        else vals = [
            value
        ];
        if (type.evenMultiple && vals.length % 2 !== 0) return null;
        var valArr = [];
        var unitsArr = [];
        var pfValArr = [];
        var strVal = "";
        var hasEnum = false;
        for(var i = 0; i < vals.length; i++){
            var p = self.parse(name, vals[i], propIsBypass, "multiple");
            hasEnum = hasEnum || string(p.value);
            valArr.push(p.value);
            pfValArr.push(p.pfValue != null ? p.pfValue : p.value);
            unitsArr.push(p.units);
            strVal += (i > 0 ? " " : "") + p.strValue;
        }
        if (type.validate && !type.validate(valArr, unitsArr)) return null;
        if (type.singleEnum && hasEnum) {
            if (valArr.length === 1 && string(valArr[0])) return {
                name: name,
                value: valArr[0],
                strValue: valArr[0],
                bypass: propIsBypass
            };
            else return null;
        }
        return {
            name: name,
            value: valArr,
            pfValue: pfValArr,
            strValue: strVal,
            bypass: propIsBypass,
            units: unitsArr
        };
    } // several types also allow enums
    var checkEnums = function checkEnums() {
        for(var _i = 0; _i < type.enums.length; _i++){
            var en = type.enums[_i];
            if (en === value) return {
                name: name,
                value: value,
                strValue: "" + value,
                bypass: propIsBypass
            };
        }
        return null;
    }; // check the type and return the appropriate object
    if (type.number) {
        var units;
        var implicitUnits = "px"; // not set => px
        if (type.units) // use specified units if set
        units = type.units;
        if (type.implicitUnits) implicitUnits = type.implicitUnits;
        if (!type.unitless) {
            if (valueIsString) {
                var unitsRegex = "px|em" + (type.allowPercent ? "|\\%" : "");
                if (units) unitsRegex = units;
                 // only allow explicit units if so set
                var match = value.match("^(" + number + ")(" + unitsRegex + ")?" + "$");
                if (match) {
                    value = match[1];
                    units = match[2] || implicitUnits;
                }
            } else if (!units || type.implicitUnits) units = implicitUnits; // implicitly px if unspecified
        }
        value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid
        if (isNaN(value) && type.enums === undefined) return null;
         // check if this number type also accepts special keywords in place of numbers
        // (i.e. `left`, `auto`, etc)
        if (isNaN(value) && type.enums !== undefined) {
            value = passedValue;
            return checkEnums();
        } // check if value must be an integer
        if (type.integer && !integer(value)) return null;
         // check value is within range
        if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) return null;
        var ret = {
            name: name,
            value: value,
            strValue: "" + value + (units ? units : ""),
            units: units,
            bypass: propIsBypass
        }; // normalise value in pixels
        if (type.unitless || units !== "px" && units !== "em") ret.pfValue = value;
        else ret.pfValue = units === "px" || !units ? value : this.getEmSizeInPixels() * value;
         // normalise value in ms
        if (units === "ms" || units === "s") ret.pfValue = units === "ms" ? value : 1000 * value;
         // normalise value in rad
        if (units === "deg" || units === "rad") ret.pfValue = units === "rad" ? value : deg2rad(value);
         // normalize value in %
        if (units === "%") ret.pfValue = value / 100;
        return ret;
    } else if (type.propList) {
        var props = [];
        var propsStr = "" + value;
        if (propsStr === "none") ;
        else {
            // go over each prop
            var propsSplit = propsStr.split(/\s*,\s*|\s+/);
            for(var _i2 = 0; _i2 < propsSplit.length; _i2++){
                var propName = propsSplit[_i2].trim();
                if (self.properties[propName]) props.push(propName);
                else warn("`" + propName + "` is not a valid property name");
            }
            if (props.length === 0) return null;
        }
        return {
            name: name,
            value: props,
            strValue: props.length === 0 ? "none" : props.join(" "),
            bypass: propIsBypass
        };
    } else if (type.color) {
        var tuple = color2tuple(value);
        if (!tuple) return null;
        return {
            name: name,
            value: tuple,
            pfValue: tuple,
            strValue: "rgb(" + tuple[0] + "," + tuple[1] + "," + tuple[2] + ")",
            // n.b. no spaces b/c of multiple support
            bypass: propIsBypass
        };
    } else if (type.regex || type.regexes) {
        // first check enums
        if (type.enums) {
            var enumProp = checkEnums();
            if (enumProp) return enumProp;
        }
        var regexes = type.regexes ? type.regexes : [
            type.regex
        ];
        for(var _i3 = 0; _i3 < regexes.length; _i3++){
            var regex = new RegExp(regexes[_i3]); // make a regex from the type string
            var m1 = regex.exec(value);
            if (m1) // regex matches
            return {
                name: name,
                value: type.singleRegexMatchValue ? m1[1] : m1,
                strValue: "" + value,
                bypass: propIsBypass
            };
        }
        return null; // didn't match any
    } else if (type.string) // just return
    return {
        name: name,
        value: "" + value,
        strValue: "" + value,
        bypass: propIsBypass
    };
    else if (type.enums) // check enums last because it's a combo type in others
    return checkEnums();
    else return null; // not a type we can handle
};
var Style = function Style(cy) {
    if (!(this instanceof Style)) return new Style(cy);
    if (!core(cy)) {
        error("A style must have a core reference");
        return;
    }
    this._private = {
        cy: cy,
        coreStyle: {}
    };
    this.length = 0;
    this.resetToDefault();
};
var styfn = Style.prototype;
styfn.instanceString = function() {
    return "style";
}; // remove all contexts
styfn.clear = function() {
    var _p = this._private;
    var cy = _p.cy;
    var eles = cy.elements();
    for(var i = 0; i < this.length; i++)this[i] = undefined;
    this.length = 0;
    _p.contextStyles = {};
    _p.propDiffs = {};
    this.cleanElements(eles, true);
    eles.forEach(function(ele) {
        var ele_p = ele[0]._private;
        ele_p.styleDirty = true;
        ele_p.appliedInitStyle = false;
    });
    return this; // chaining
};
styfn.resetToDefault = function() {
    this.clear();
    this.addDefaultStylesheet();
    return this;
}; // builds a style object for the 'core' selector
styfn.core = function(propName) {
    return this._private.coreStyle[propName] || this.getDefaultProperty(propName);
}; // create a new context from the specified selector string and switch to that context
styfn.selector = function(selectorStr) {
    // 'core' is a special case and does not need a selector
    var selector = selectorStr === "core" ? null : new Selector(selectorStr);
    var i = this.length++; // new context means new index
    this[i] = {
        selector: selector,
        properties: [],
        mappedProperties: [],
        index: i
    };
    return this; // chaining
}; // add one or many css rules to the current context
styfn.css = function() {
    var self = this;
    var args = arguments;
    if (args.length === 1) {
        var map = args[0];
        for(var i = 0; i < self.properties.length; i++){
            var prop = self.properties[i];
            var mapVal = map[prop.name];
            if (mapVal === undefined) mapVal = map[dash2camel(prop.name)];
            if (mapVal !== undefined) this.cssRule(prop.name, mapVal);
        }
    } else if (args.length === 2) this.cssRule(args[0], args[1]);
     // do nothing if args are invalid
    return this; // chaining
};
styfn.style = styfn.css; // add a single css rule to the current context
styfn.cssRule = function(name, value) {
    // name-value pair
    var property = this.parse(name, value); // add property to current context if valid
    if (property) {
        var i = this.length - 1;
        this[i].properties.push(property);
        this[i].properties[property.name] = property; // allow access by name as well
        if (property.name.match(/pie-(\d+)-background-size/) && property.value) this._private.hasPie = true;
        if (property.mapped) this[i].mappedProperties.push(property);
         // add to core style if necessary
        var currentSelectorIsCore = !this[i].selector;
        if (currentSelectorIsCore) this._private.coreStyle[property.name] = property;
    }
    return this; // chaining
};
styfn.append = function(style) {
    if (stylesheet(style)) style.appendToStyle(this);
    else if (array(style)) this.appendFromJson(style);
    else if (string(style)) this.appendFromString(style);
     // you probably wouldn't want to append a Style, since you'd duplicate the default parts
    return this;
}; // static function
Style.fromJson = function(cy, json) {
    var style = new Style(cy);
    style.fromJson(json);
    return style;
};
Style.fromString = function(cy, string) {
    return new Style(cy).fromString(string);
};
[
    styfn$8,
    styfn$7,
    styfn$6,
    styfn$5,
    styfn$4,
    styfn$3,
    styfn$2,
    styfn$1
].forEach(function(props) {
    extend(styfn, props);
});
Style.types = styfn.types;
Style.properties = styfn.properties;
Style.propertyGroups = styfn.propertyGroups;
Style.propertyGroupNames = styfn.propertyGroupNames;
Style.propertyGroupKeys = styfn.propertyGroupKeys;
var corefn$2 = {
    style: function style(newStyle) {
        if (newStyle) {
            var s = this.setStyle(newStyle);
            s.update();
        }
        return this._private.style;
    },
    setStyle: function setStyle(style) {
        var _p = this._private;
        if (stylesheet(style)) _p.style = style.generateStyle(this);
        else if (array(style)) _p.style = Style.fromJson(this, style);
        else if (string(style)) _p.style = Style.fromString(this, style);
        else _p.style = Style(this);
        return _p.style;
    },
    // e.g. cy.data() changed => recalc ele mappers
    updateStyle: function updateStyle() {
        this.mutableElements().updateStyle(); // just send to all eles
    }
};
var defaultSelectionType = "single";
var corefn$1 = {
    autolock: function autolock(bool) {
        if (bool !== undefined) this._private.autolock = bool ? true : false;
        else return this._private.autolock;
        return this; // chaining
    },
    autoungrabify: function autoungrabify(bool) {
        if (bool !== undefined) this._private.autoungrabify = bool ? true : false;
        else return this._private.autoungrabify;
        return this; // chaining
    },
    autounselectify: function autounselectify(bool) {
        if (bool !== undefined) this._private.autounselectify = bool ? true : false;
        else return this._private.autounselectify;
        return this; // chaining
    },
    selectionType: function selectionType(selType) {
        var _p = this._private;
        if (_p.selectionType == null) _p.selectionType = defaultSelectionType;
        if (selType !== undefined) {
            if (selType === "additive" || selType === "single") _p.selectionType = selType;
        } else return _p.selectionType;
        return this;
    },
    panningEnabled: function panningEnabled(bool) {
        if (bool !== undefined) this._private.panningEnabled = bool ? true : false;
        else return this._private.panningEnabled;
        return this; // chaining
    },
    userPanningEnabled: function userPanningEnabled(bool) {
        if (bool !== undefined) this._private.userPanningEnabled = bool ? true : false;
        else return this._private.userPanningEnabled;
        return this; // chaining
    },
    zoomingEnabled: function zoomingEnabled(bool) {
        if (bool !== undefined) this._private.zoomingEnabled = bool ? true : false;
        else return this._private.zoomingEnabled;
        return this; // chaining
    },
    userZoomingEnabled: function userZoomingEnabled(bool) {
        if (bool !== undefined) this._private.userZoomingEnabled = bool ? true : false;
        else return this._private.userZoomingEnabled;
        return this; // chaining
    },
    boxSelectionEnabled: function boxSelectionEnabled(bool) {
        if (bool !== undefined) this._private.boxSelectionEnabled = bool ? true : false;
        else return this._private.boxSelectionEnabled;
        return this; // chaining
    },
    pan: function pan() {
        var args = arguments;
        var pan = this._private.pan;
        var dim, val, dims, x, y;
        switch(args.length){
            case 0:
                // .pan()
                return pan;
            case 1:
                if (string(args[0])) {
                    // .pan('x')
                    dim = args[0];
                    return pan[dim];
                } else if (plainObject(args[0])) {
                    // .pan({ x: 0, y: 100 })
                    if (!this._private.panningEnabled) return this;
                    dims = args[0];
                    x = dims.x;
                    y = dims.y;
                    if (number$1(x)) pan.x = x;
                    if (number$1(y)) pan.y = y;
                    this.emit("pan viewport");
                }
                break;
            case 2:
                // .pan('x', 100)
                if (!this._private.panningEnabled) return this;
                dim = args[0];
                val = args[1];
                if ((dim === "x" || dim === "y") && number$1(val)) pan[dim] = val;
                this.emit("pan viewport");
                break;
        }
        this.notify("viewport");
        return this; // chaining
    },
    panBy: function panBy(arg0, arg1) {
        var args = arguments;
        var pan = this._private.pan;
        var dim, val, dims, x, y;
        if (!this._private.panningEnabled) return this;
        switch(args.length){
            case 1:
                if (plainObject(arg0)) {
                    // .panBy({ x: 0, y: 100 })
                    dims = args[0];
                    x = dims.x;
                    y = dims.y;
                    if (number$1(x)) pan.x += x;
                    if (number$1(y)) pan.y += y;
                    this.emit("pan viewport");
                }
                break;
            case 2:
                // .panBy('x', 100)
                dim = arg0;
                val = arg1;
                if ((dim === "x" || dim === "y") && number$1(val)) pan[dim] += val;
                this.emit("pan viewport");
                break;
        }
        this.notify("viewport");
        return this; // chaining
    },
    fit: function fit(elements, padding) {
        var viewportState = this.getFitViewport(elements, padding);
        if (viewportState) {
            var _p = this._private;
            _p.zoom = viewportState.zoom;
            _p.pan = viewportState.pan;
            this.emit("pan zoom viewport");
            this.notify("viewport");
        }
        return this; // chaining
    },
    getFitViewport: function getFitViewport(elements, padding) {
        if (number$1(elements) && padding === undefined) {
            // elements is optional
            padding = elements;
            elements = undefined;
        }
        if (!this._private.panningEnabled || !this._private.zoomingEnabled) return;
        var bb;
        if (string(elements)) {
            var sel = elements;
            elements = this.$(sel);
        } else if (boundingBox(elements)) {
            // assume bb
            var bbe = elements;
            bb = {
                x1: bbe.x1,
                y1: bbe.y1,
                x2: bbe.x2,
                y2: bbe.y2
            };
            bb.w = bb.x2 - bb.x1;
            bb.h = bb.y2 - bb.y1;
        } else if (!elementOrCollection(elements)) elements = this.mutableElements();
        if (elementOrCollection(elements) && elements.empty()) return;
         // can't fit to nothing
        bb = bb || elements.boundingBox();
        var w = this.width();
        var h = this.height();
        var zoom;
        padding = number$1(padding) ? padding : 0;
        if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
            zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom
            zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
            zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;
            var pan = {
                // now pan to middle
                x: (w - zoom * (bb.x1 + bb.x2)) / 2,
                y: (h - zoom * (bb.y1 + bb.y2)) / 2
            };
            return {
                zoom: zoom,
                pan: pan
            };
        }
        return;
    },
    zoomRange: function zoomRange(min, max) {
        var _p = this._private;
        if (max == null) {
            var opts = min;
            min = opts.min;
            max = opts.max;
        }
        if (number$1(min) && number$1(max) && min <= max) {
            _p.minZoom = min;
            _p.maxZoom = max;
        } else if (number$1(min) && max === undefined && min <= _p.maxZoom) _p.minZoom = min;
        else if (number$1(max) && min === undefined && max >= _p.minZoom) _p.maxZoom = max;
        return this;
    },
    minZoom: function minZoom(zoom) {
        if (zoom === undefined) return this._private.minZoom;
        else return this.zoomRange({
            min: zoom
        });
    },
    maxZoom: function maxZoom(zoom) {
        if (zoom === undefined) return this._private.maxZoom;
        else return this.zoomRange({
            max: zoom
        });
    },
    getZoomedViewport: function getZoomedViewport(params) {
        var _p = this._private;
        var currentPan = _p.pan;
        var currentZoom = _p.zoom;
        var pos; // in rendered px
        var zoom;
        var bail = false;
        if (!_p.zoomingEnabled) // zooming disabled
        bail = true;
        if (number$1(params)) // then set the zoom
        zoom = params;
        else if (plainObject(params)) {
            // then zoom about a point
            zoom = params.level;
            if (params.position != null) pos = modelToRenderedPosition(params.position, currentZoom, currentPan);
            else if (params.renderedPosition != null) pos = params.renderedPosition;
            if (pos != null && !_p.panningEnabled) // panning disabled
            bail = true;
        } // crop zoom
        zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;
        zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params
        if (bail || !number$1(zoom) || zoom === currentZoom || pos != null && (!number$1(pos.x) || !number$1(pos.y))) return null;
        if (pos != null) {
            // set zoom about position
            var pan1 = currentPan;
            var zoom1 = currentZoom;
            var zoom2 = zoom;
            var pan2 = {
                x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
                y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
            };
            return {
                zoomed: true,
                panned: true,
                zoom: zoom2,
                pan: pan2
            };
        } else // just set the zoom
        return {
            zoomed: true,
            panned: false,
            zoom: zoom,
            pan: currentPan
        };
    },
    zoom: function zoom(params) {
        if (params === undefined) // get
        return this._private.zoom;
        else {
            // set
            var vp = this.getZoomedViewport(params);
            var _p = this._private;
            if (vp == null || !vp.zoomed) return this;
            _p.zoom = vp.zoom;
            if (vp.panned) {
                _p.pan.x = vp.pan.x;
                _p.pan.y = vp.pan.y;
            }
            this.emit("zoom" + (vp.panned ? " pan" : "") + " viewport");
            this.notify("viewport");
            return this; // chaining
        }
    },
    viewport: function viewport(opts) {
        var _p = this._private;
        var zoomDefd = true;
        var panDefd = true;
        var events = []; // to trigger
        var zoomFailed = false;
        var panFailed = false;
        if (!opts) return this;
        if (!number$1(opts.zoom)) zoomDefd = false;
        if (!plainObject(opts.pan)) panDefd = false;
        if (!zoomDefd && !panDefd) return this;
        if (zoomDefd) {
            var z = opts.zoom;
            if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) zoomFailed = true;
            else {
                _p.zoom = z;
                events.push("zoom");
            }
        }
        if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
            var p = opts.pan;
            if (number$1(p.x)) {
                _p.pan.x = p.x;
                panFailed = false;
            }
            if (number$1(p.y)) {
                _p.pan.y = p.y;
                panFailed = false;
            }
            if (!panFailed) events.push("pan");
        }
        if (events.length > 0) {
            events.push("viewport");
            this.emit(events.join(" "));
            this.notify("viewport");
        }
        return this; // chaining
    },
    center: function center(elements) {
        var pan = this.getCenterPan(elements);
        if (pan) {
            this._private.pan = pan;
            this.emit("pan viewport");
            this.notify("viewport");
        }
        return this; // chaining
    },
    getCenterPan: function getCenterPan(elements, zoom) {
        if (!this._private.panningEnabled) return;
        if (string(elements)) {
            var selector = elements;
            elements = this.mutableElements().filter(selector);
        } else if (!elementOrCollection(elements)) elements = this.mutableElements();
        if (elements.length === 0) return;
         // can't centre pan to nothing
        var bb = elements.boundingBox();
        var w = this.width();
        var h = this.height();
        zoom = zoom === undefined ? this._private.zoom : zoom;
        var pan = {
            // middle
            x: (w - zoom * (bb.x1 + bb.x2)) / 2,
            y: (h - zoom * (bb.y1 + bb.y2)) / 2
        };
        return pan;
    },
    reset: function reset() {
        if (!this._private.panningEnabled || !this._private.zoomingEnabled) return this;
        this.viewport({
            pan: {
                x: 0,
                y: 0
            },
            zoom: 1
        });
        return this; // chaining
    },
    invalidateSize: function invalidateSize() {
        this._private.sizeCache = null;
    },
    size: function size() {
        var _p = this._private;
        var container = _p.container;
        return _p.sizeCache = _p.sizeCache || (container ? function() {
            var style = window$1.getComputedStyle(container);
            var val = function val(name) {
                return parseFloat(style.getPropertyValue(name));
            };
            return {
                width: container.clientWidth - val("padding-left") - val("padding-right"),
                height: container.clientHeight - val("padding-top") - val("padding-bottom")
            };
        }() : {
            // fallback if no container (not 0 b/c can be used for dividing etc)
            width: 1,
            height: 1
        });
    },
    width: function width() {
        return this.size().width;
    },
    height: function height() {
        return this.size().height;
    },
    extent: function extent() {
        var pan = this._private.pan;
        var zoom = this._private.zoom;
        var rb = this.renderedExtent();
        var b = {
            x1: (rb.x1 - pan.x) / zoom,
            x2: (rb.x2 - pan.x) / zoom,
            y1: (rb.y1 - pan.y) / zoom,
            y2: (rb.y2 - pan.y) / zoom
        };
        b.w = b.x2 - b.x1;
        b.h = b.y2 - b.y1;
        return b;
    },
    renderedExtent: function renderedExtent() {
        var width = this.width();
        var height = this.height();
        return {
            x1: 0,
            y1: 0,
            x2: width,
            y2: height,
            w: width,
            h: height
        };
    },
    multiClickDebounceTime: function multiClickDebounceTime(_int) {
        if (_int) this._private.multiClickDebounceTime = _int;
        else return this._private.multiClickDebounceTime;
        return this; // chaining
    }
}; // aliases
corefn$1.centre = corefn$1.center; // backwards compatibility
corefn$1.autolockNodes = corefn$1.autolock;
corefn$1.autoungrabifyNodes = corefn$1.autoungrabify;
var fn = {
    data: define.data({
        field: "data",
        bindingEvent: "data",
        allowBinding: true,
        allowSetting: true,
        settingEvent: "data",
        settingTriggersEvent: true,
        triggerFnName: "trigger",
        allowGetting: true,
        updateStyle: true
    }),
    removeData: define.removeData({
        field: "data",
        event: "data",
        triggerFnName: "trigger",
        triggerEvent: true,
        updateStyle: true
    }),
    scratch: define.data({
        field: "scratch",
        bindingEvent: "scratch",
        allowBinding: true,
        allowSetting: true,
        settingEvent: "scratch",
        settingTriggersEvent: true,
        triggerFnName: "trigger",
        allowGetting: true,
        updateStyle: true
    }),
    removeScratch: define.removeData({
        field: "scratch",
        event: "scratch",
        triggerFnName: "trigger",
        triggerEvent: true,
        updateStyle: true
    })
}; // aliases
fn.attr = fn.data;
fn.removeAttr = fn.removeData;
var Core = function Core(opts) {
    var cy = this;
    opts = extend({}, opts);
    var container = opts.container; // allow for passing a wrapped jquery object
    // e.g. cytoscape({ container: $('#cy') })
    if (container && !htmlElement(container) && htmlElement(container[0])) container = container[0];
    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
    reg = reg || {};
    if (reg && reg.cy) {
        reg.cy.destroy();
        reg = {}; // old instance => replace reg completely
    }
    var readies = reg.readies = reg.readies || [];
    if (container) container._cyreg = reg;
     // make sure container assoc'd reg points to this cy
    reg.cy = cy;
    var head = window$1 !== undefined && container !== undefined && !opts.headless;
    var options = opts;
    options.layout = extend({
        name: head ? "grid" : "null"
    }, options.layout);
    options.renderer = extend({
        name: head ? "canvas" : "null"
    }, options.renderer);
    var defVal = function defVal(def, val, altVal) {
        if (val !== undefined) return val;
        else if (altVal !== undefined) return altVal;
        else return def;
    };
    var _p = this._private = {
        container: container,
        // html dom ele container
        ready: false,
        // whether ready has been triggered
        options: options,
        // cached options
        elements: new Collection(this),
        // elements in the graph
        listeners: [],
        // list of listeners
        aniEles: new Collection(this),
        // elements being animated
        data: options.data || {},
        // data for the core
        scratch: {},
        // scratch object for core
        layout: null,
        renderer: null,
        destroyed: false,
        // whether destroy was called
        notificationsEnabled: true,
        // whether notifications are sent to the renderer
        minZoom: 1e-50,
        maxZoom: 1e50,
        zoomingEnabled: defVal(true, options.zoomingEnabled),
        userZoomingEnabled: defVal(true, options.userZoomingEnabled),
        panningEnabled: defVal(true, options.panningEnabled),
        userPanningEnabled: defVal(true, options.userPanningEnabled),
        boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
        autolock: defVal(false, options.autolock, options.autolockNodes),
        autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
        autounselectify: defVal(false, options.autounselectify),
        styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
        zoom: number$1(options.zoom) ? options.zoom : 1,
        pan: {
            x: plainObject(options.pan) && number$1(options.pan.x) ? options.pan.x : 0,
            y: plainObject(options.pan) && number$1(options.pan.y) ? options.pan.y : 0
        },
        animation: {
            // object for currently-running animations
            current: [],
            queue: []
        },
        hasCompoundNodes: false,
        multiClickDebounceTime: defVal(250, options.multiClickDebounceTime)
    };
    this.createEmitter(); // set selection type
    this.selectionType(options.selectionType); // init zoom bounds
    this.zoomRange({
        min: options.minZoom,
        max: options.maxZoom
    });
    var loadExtData = function loadExtData(extData, next) {
        var anyIsPromise = extData.some(promise);
        if (anyIsPromise) return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init
        else next(extData); // exec synchronously for convenience
    }; // start with the default stylesheet so we have something before loading an external stylesheet
    if (_p.styleEnabled) cy.setStyle([]);
     // create the renderer
    var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options
    cy.initRenderer(rendererOptions);
    var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {
        cy.notifications(false); // remove old elements
        var oldEles = cy.mutableElements();
        if (oldEles.length > 0) oldEles.remove();
        if (elements != null) {
            if (plainObject(elements) || array(elements)) cy.add(elements);
        }
        cy.one("layoutready", function(e) {
            cy.notifications(true);
            cy.emit(e); // we missed this event by turning notifications off, so pass it on
            cy.one("load", onload);
            cy.emitAndNotify("load");
        }).one("layoutstop", function() {
            cy.one("done", ondone);
            cy.emit("done");
        });
        var layoutOpts = extend({}, cy._private.options.layout);
        layoutOpts.eles = cy.elements();
        cy.layout(layoutOpts).run();
    };
    loadExtData([
        options.style,
        options.elements
    ], function(thens) {
        var initStyle = thens[0];
        var initEles = thens[1]; // init style
        if (_p.styleEnabled) cy.style().append(initStyle);
         // initial load
        setElesAndLayout(initEles, function() {
            // onready
            cy.startAnimationLoop();
            _p.ready = true; // if a ready callback is specified as an option, the bind it
            if (fn$6(options.ready)) cy.on("ready", options.ready);
             // bind all the ready handlers registered before creating this instance
            for(var i = 0; i < readies.length; i++){
                var fn = readies[i];
                cy.on("ready", fn);
            }
            if (reg) reg.readies = [];
             // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc
            cy.emit("ready");
        }, options.done);
    });
};
var corefn = Core.prototype; // short alias
extend(corefn, {
    instanceString: function instanceString() {
        return "core";
    },
    isReady: function isReady() {
        return this._private.ready;
    },
    destroyed: function destroyed() {
        return this._private.destroyed;
    },
    ready: function ready(fn) {
        if (this.isReady()) this.emitter().emit("ready", [], fn); // just calls fn as though triggered via ready event
        else this.on("ready", fn);
        return this;
    },
    destroy: function destroy() {
        var cy = this;
        if (cy.destroyed()) return;
        cy.stopAnimationLoop();
        cy.destroyRenderer();
        this.emit("destroy");
        cy._private.destroyed = true;
        return cy;
    },
    hasElementWithId: function hasElementWithId(id) {
        return this._private.elements.hasElementWithId(id);
    },
    getElementById: function getElementById(id) {
        return this._private.elements.getElementById(id);
    },
    hasCompoundNodes: function hasCompoundNodes() {
        return this._private.hasCompoundNodes;
    },
    headless: function headless() {
        return this._private.renderer.isHeadless();
    },
    styleEnabled: function styleEnabled() {
        return this._private.styleEnabled;
    },
    addToPool: function addToPool(eles) {
        this._private.elements.merge(eles);
        return this; // chaining
    },
    removeFromPool: function removeFromPool(eles) {
        this._private.elements.unmerge(eles);
        return this;
    },
    container: function container() {
        return this._private.container || null;
    },
    mount: function mount(container) {
        if (container == null) return;
        var cy = this;
        var _p = cy._private;
        var options = _p.options;
        if (!htmlElement(container) && htmlElement(container[0])) container = container[0];
        cy.stopAnimationLoop();
        cy.destroyRenderer();
        _p.container = container;
        _p.styleEnabled = true;
        cy.invalidateSize();
        cy.initRenderer(extend({}, options, options.renderer, {
            // allow custom renderer name to be re-used, otherwise use canvas
            name: options.renderer.name === "null" ? "canvas" : options.renderer.name
        }));
        cy.startAnimationLoop();
        cy.style(options.style);
        cy.emit("mount");
        return cy;
    },
    unmount: function unmount() {
        var cy = this;
        cy.stopAnimationLoop();
        cy.destroyRenderer();
        cy.initRenderer({
            name: "null"
        });
        cy.emit("unmount");
        return cy;
    },
    options: function options() {
        return copy(this._private.options);
    },
    json: function json(obj) {
        var cy = this;
        var _p = cy._private;
        var eles = cy.mutableElements();
        var getFreshRef = function getFreshRef(ele) {
            return cy.getElementById(ele.id());
        };
        if (plainObject(obj)) {
            // set
            cy.startBatch();
            if (obj.elements) {
                var idInJson = {};
                var updateEles = function updateEles(jsons, gr) {
                    var toAdd = [];
                    var toMod = [];
                    for(var i = 0; i < jsons.length; i++){
                        var json = jsons[i];
                        if (!json.data.id) {
                            warn("cy.json() cannot handle elements without an ID attribute");
                            continue;
                        }
                        var id = "" + json.data.id; // id must be string
                        var ele = cy.getElementById(id);
                        idInJson[id] = true;
                        if (ele.length !== 0) // existing element should be updated
                        toMod.push({
                            ele: ele,
                            json: json
                        });
                        else // otherwise should be added
                        if (gr) {
                            json.group = gr;
                            toAdd.push(json);
                        } else toAdd.push(json);
                    }
                    cy.add(toAdd);
                    for(var _i = 0; _i < toMod.length; _i++){
                        var _toMod$_i = toMod[_i], _ele = _toMod$_i.ele, _json = _toMod$_i.json;
                        _ele.json(_json);
                    }
                };
                if (array(obj.elements)) // elements: []
                updateEles(obj.elements);
                else {
                    // elements: { nodes: [], edges: [] }
                    var grs = [
                        "nodes",
                        "edges"
                    ];
                    for(var i = 0; i < grs.length; i++){
                        var gr = grs[i];
                        var elements = obj.elements[gr];
                        if (array(elements)) updateEles(elements, gr);
                    }
                }
                var parentsToRemove = cy.collection();
                eles.filter(function(ele) {
                    return !idInJson[ele.id()];
                }).forEach(function(ele) {
                    if (ele.isParent()) parentsToRemove.merge(ele);
                    else ele.remove();
                }); // so that children are not removed w/parent
                parentsToRemove.forEach(function(ele) {
                    return ele.children().move({
                        parent: null
                    });
                }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs
                parentsToRemove.forEach(function(ele) {
                    return getFreshRef(ele).remove();
                });
            }
            if (obj.style) cy.style(obj.style);
            if (obj.zoom != null && obj.zoom !== _p.zoom) cy.zoom(obj.zoom);
            if (obj.pan) {
                if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) cy.pan(obj.pan);
            }
            if (obj.data) cy.data(obj.data);
            var fields = [
                "minZoom",
                "maxZoom",
                "zoomingEnabled",
                "userZoomingEnabled",
                "panningEnabled",
                "userPanningEnabled",
                "boxSelectionEnabled",
                "autolock",
                "autoungrabify",
                "autounselectify",
                "multiClickDebounceTime"
            ];
            for(var _i2 = 0; _i2 < fields.length; _i2++){
                var f = fields[_i2];
                if (obj[f] != null) cy[f](obj[f]);
            }
            cy.endBatch();
            return this; // chaining
        } else {
            // get
            var flat = !!obj;
            var json = {};
            if (flat) json.elements = this.elements().map(function(ele) {
                return ele.json();
            });
            else {
                json.elements = {};
                eles.forEach(function(ele) {
                    var group = ele.group();
                    if (!json.elements[group]) json.elements[group] = [];
                    json.elements[group].push(ele.json());
                });
            }
            if (this._private.styleEnabled) json.style = cy.style().json();
            json.data = copy(cy.data());
            var options = _p.options;
            json.zoomingEnabled = _p.zoomingEnabled;
            json.userZoomingEnabled = _p.userZoomingEnabled;
            json.zoom = _p.zoom;
            json.minZoom = _p.minZoom;
            json.maxZoom = _p.maxZoom;
            json.panningEnabled = _p.panningEnabled;
            json.userPanningEnabled = _p.userPanningEnabled;
            json.pan = copy(_p.pan);
            json.boxSelectionEnabled = _p.boxSelectionEnabled;
            json.renderer = copy(options.renderer);
            json.hideEdgesOnViewport = options.hideEdgesOnViewport;
            json.textureOnViewport = options.textureOnViewport;
            json.wheelSensitivity = options.wheelSensitivity;
            json.motionBlur = options.motionBlur;
            json.multiClickDebounceTime = options.multiClickDebounceTime;
            return json;
        }
    }
});
corefn.$id = corefn.getElementById;
[
    corefn$9,
    corefn$8,
    elesfn,
    corefn$7,
    corefn$6,
    corefn$5,
    corefn$4,
    corefn$3,
    corefn$2,
    corefn$1,
    fn
].forEach(function(props) {
    extend(corefn, props);
});
/* eslint-disable no-unused-vars */ var defaults$7 = {
    fit: true,
    // whether to fit the viewport to the graph
    directed: false,
    // whether the tree is directed downwards (or edges can point in any direction if false)
    padding: 30,
    // padding on fit
    circle: false,
    // put depths in concentric circles if true, put depths top down if false
    grid: false,
    // whether to create an even grid into which the DAG is placed (circle:false only)
    spacingFactor: 1.75,
    // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
    boundingBox: undefined,
    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true,
    // prevents node overlap, may overflow boundingBox if not enough space
    nodeDimensionsIncludeLabels: false,
    // Excludes the label when calculating node bounding boxes for the layout algorithm
    roots: undefined,
    // the roots of the trees
    maximal: false,
    // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only)
    depthSort: undefined,
    // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }
    animate: false,
    // whether to transition the node positions
    animationDuration: 500,
    // duration of animation in ms if enabled
    animationEasing: undefined,
    // easing of animation if enabled,
    animateFilter: function animateFilter(node, i) {
        return true;
    },
    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
    ready: undefined,
    // callback on layoutready
    stop: undefined,
    // callback on layoutstop
    transform: function transform(node, position) {
        return position;
    } // transform a given node position. Useful for changing flow direction in discrete layouts
};
/* eslint-enable */ var getInfo = function getInfo(ele) {
    return ele.scratch("breadthfirst");
};
var setInfo = function setInfo(ele, obj) {
    return ele.scratch("breadthfirst", obj);
};
function BreadthFirstLayout(options) {
    this.options = extend({}, defaults$7, options);
}
BreadthFirstLayout.prototype.run = function() {
    var params = this.options;
    var options = params;
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().filter(function(n) {
        return !n.isParent();
    });
    var graph = eles;
    var directed = options.directed;
    var maximal = options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code
    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
        x1: 0,
        y1: 0,
        w: cy.width(),
        h: cy.height()
    });
    var roots;
    if (elementOrCollection(options.roots)) roots = options.roots;
    else if (array(options.roots)) {
        var rootsArray = [];
        for(var i = 0; i < options.roots.length; i++){
            var id = options.roots[i];
            var ele = cy.getElementById(id);
            rootsArray.push(ele);
        }
        roots = cy.collection(rootsArray);
    } else if (string(options.roots)) roots = cy.$(options.roots);
    else if (directed) roots = nodes.roots();
    else {
        var components = eles.components();
        roots = cy.collection();
        var _loop = function _loop(_i) {
            var comp = components[_i];
            var maxDegree = comp.maxDegree(false);
            var compRoots = comp.filter(function(ele) {
                return ele.degree(false) === maxDegree;
            });
            roots = roots.add(compRoots);
        };
        for(var _i = 0; _i < components.length; _i++)_loop(_i);
    }
    var depths = [];
    var foundByBfs = {};
    var addToDepth = function addToDepth(ele, d) {
        if (depths[d] == null) depths[d] = [];
        var i = depths[d].length;
        depths[d].push(ele);
        setInfo(ele, {
            index: i,
            depth: d
        });
    };
    var changeDepth = function changeDepth(ele, newDepth) {
        var _getInfo = getInfo(ele), depth = _getInfo.depth, index = _getInfo.index;
        depths[depth][index] = null;
        addToDepth(ele, newDepth);
    }; // find the depths of the nodes
    graph.bfs({
        roots: roots,
        directed: options.directed,
        visit: function visit(node, edge, pNode, i, depth) {
            var ele = node[0];
            var id = ele.id();
            addToDepth(ele, depth);
            foundByBfs[id] = true;
        }
    }); // check for nodes not found by bfs
    var orphanNodes = [];
    for(var _i2 = 0; _i2 < nodes.length; _i2++){
        var _ele = nodes[_i2];
        if (foundByBfs[_ele.id()]) continue;
        else orphanNodes.push(_ele);
    } // assign the nodes a depth and index
    var assignDepthsAt = function assignDepthsAt(i) {
        var eles = depths[i];
        for(var j = 0; j < eles.length; j++){
            var _ele2 = eles[j];
            if (_ele2 == null) {
                eles.splice(j, 1);
                j--;
                continue;
            }
            setInfo(_ele2, {
                depth: i,
                index: j
            });
        }
    };
    var assignDepths = function assignDepths() {
        for(var _i3 = 0; _i3 < depths.length; _i3++)assignDepthsAt(_i3);
    };
    var adjustMaximally = function adjustMaximally(ele, shifted) {
        var eInfo = getInfo(ele);
        var incomers = ele.incomers().filter(function(el) {
            return el.isNode() && eles.has(el);
        });
        var maxDepth = -1;
        var id = ele.id();
        for(var k = 0; k < incomers.length; k++){
            var incmr = incomers[k];
            var iInfo = getInfo(incmr);
            maxDepth = Math.max(maxDepth, iInfo.depth);
        }
        if (eInfo.depth <= maxDepth) {
            if (shifted[id]) return null;
            changeDepth(ele, maxDepth + 1);
            shifted[id] = true;
            return true;
        }
        return false;
    }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)
    if (directed && maximal) {
        var Q = [];
        var shifted = {};
        var enqueue = function enqueue(n) {
            return Q.push(n);
        };
        var dequeue = function dequeue() {
            return Q.shift();
        };
        nodes.forEach(function(n) {
            return Q.push(n);
        });
        while(Q.length > 0){
            var _ele3 = dequeue();
            var didShift = adjustMaximally(_ele3, shifted);
            if (didShift) _ele3.outgoers().filter(function(el) {
                return el.isNode() && eles.has(el);
            }).forEach(enqueue);
            else if (didShift === null) {
                warn("Detected double maximal shift for node `" + _ele3.id() + "`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.");
                break; // exit on failure
            }
        }
    }
    assignDepths(); // clear holes
    // find min distance we need to leave between nodes
    var minDistance = 0;
    if (options.avoidOverlap) for(var _i4 = 0; _i4 < nodes.length; _i4++){
        var n = nodes[_i4];
        var nbb = n.layoutDimensions(options);
        var w = nbb.w;
        var h = nbb.h;
        minDistance = Math.max(minDistance, w, h);
    }
     // get the weighted percent for an element based on its connectivity to other levels
    var cachedWeightedPercent = {};
    var getWeightedPercent = function getWeightedPercent(ele) {
        if (cachedWeightedPercent[ele.id()]) return cachedWeightedPercent[ele.id()];
        var eleDepth = getInfo(ele).depth;
        var neighbors = ele.neighborhood();
        var percent = 0;
        var samples = 0;
        for(var _i5 = 0; _i5 < neighbors.length; _i5++){
            var neighbor = neighbors[_i5];
            if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) continue;
            var bf = getInfo(neighbor);
            if (bf == null) continue;
            var index = bf.index;
            var depth = bf.depth; // unassigned neighbours shouldn't affect the ordering
            if (index == null || depth == null) continue;
            var nDepth = depths[depth].length;
            if (depth < eleDepth) {
                // only get influenced by elements above
                percent += index / nDepth;
                samples++;
            }
        }
        samples = Math.max(1, samples);
        percent = percent / samples;
        if (samples === 0) // put lone nodes at the start
        percent = 0;
        cachedWeightedPercent[ele.id()] = percent;
        return percent;
    }; // rearrange the indices in each depth level based on connectivity
    var sortFn = function sortFn(a, b) {
        var apct = getWeightedPercent(a);
        var bpct = getWeightedPercent(b);
        var diff = apct - bpct;
        if (diff === 0) return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons
        else return diff;
    };
    if (options.depthSort !== undefined) sortFn = options.depthSort;
     // sort each level to make connected nodes closer
    for(var _i6 = 0; _i6 < depths.length; _i6++){
        depths[_i6].sort(sortFn);
        assignDepthsAt(_i6);
    } // assign orphan nodes to a new top-level depth
    var orphanDepth = [];
    for(var _i7 = 0; _i7 < orphanNodes.length; _i7++)orphanDepth.push(orphanNodes[_i7]);
    depths.unshift(orphanDepth);
    assignDepths();
    var biggestDepthSize = 0;
    for(var _i8 = 0; _i8 < depths.length; _i8++)biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);
    var center = {
        x: bb.x1 + bb.w / 2,
        y: bb.x1 + bb.h / 2
    };
    var maxDepthSize = depths.reduce(function(max, eles) {
        return Math.max(max, eles.length);
    }, 0);
    var getPosition = function getPosition(ele) {
        var _getInfo2 = getInfo(ele), depth = _getInfo2.depth, index = _getInfo2.index;
        var depthSize = depths[depth].length;
        var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);
        var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);
        var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);
        radiusStepSize = Math.max(radiusStepSize, minDistance);
        if (!options.circle) {
            var epos = {
                x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
                y: (depth + 1) * distanceY
            };
            return epos;
        } else {
            var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
            var theta = 2 * Math.PI / depths[depth].length * index;
            if (depth === 0 && depths[0].length === 1) radius = 1;
            return {
                x: center.x + radius * Math.cos(theta),
                y: center.y + radius * Math.sin(theta)
            };
        }
    };
    eles.nodes().layoutPositions(this, options, getPosition);
    return this; // chaining
};
var defaults$6 = {
    fit: true,
    // whether to fit the viewport to the graph
    padding: 30,
    // the padding on fit
    boundingBox: undefined,
    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true,
    // prevents node overlap, may overflow boundingBox and radius if not enough space
    nodeDimensionsIncludeLabels: false,
    // Excludes the label when calculating node bounding boxes for the layout algorithm
    spacingFactor: undefined,
    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
    radius: undefined,
    // the radius of the circle
    startAngle: 1.5 * Math.PI,
    // where nodes start in radians
    sweep: undefined,
    // how many radians should be between the first and last node (defaults to full circle)
    clockwise: true,
    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
    sort: undefined,
    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
    animate: false,
    // whether to transition the node positions
    animationDuration: 500,
    // duration of animation in ms if enabled
    animationEasing: undefined,
    // easing of animation if enabled
    animateFilter: function animateFilter(node, i) {
        return true;
    },
    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
    ready: undefined,
    // callback on layoutready
    stop: undefined,
    // callback on layoutstop
    transform: function transform(node, position) {
        return position;
    } // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function CircleLayout(options) {
    this.options = extend({}, defaults$6, options);
}
CircleLayout.prototype.run = function() {
    var params = this.options;
    var options = params;
    var cy = params.cy;
    var eles = options.eles;
    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
    var nodes = eles.nodes().not(":parent");
    if (options.sort) nodes = nodes.sort(options.sort);
    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
        x1: 0,
        y1: 0,
        w: cy.width(),
        h: cy.height()
    });
    var center = {
        x: bb.x1 + bb.w / 2,
        y: bb.y1 + bb.h / 2
    };
    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;
    var dTheta = sweep / Math.max(1, nodes.length - 1);
    var r;
    var minDistance = 0;
    for(var i = 0; i < nodes.length; i++){
        var n = nodes[i];
        var nbb = n.layoutDimensions(options);
        var w = nbb.w;
        var h = nbb.h;
        minDistance = Math.max(minDistance, w, h);
    }
    if (number$1(options.radius)) r = options.radius;
    else if (nodes.length <= 1) r = 0;
    else r = Math.min(bb.h, bb.w) / 2 - minDistance;
     // calculate the radius
    if (nodes.length > 1 && options.avoidOverlap) {
        // but only if more than one node (can't overlap)
        minDistance *= 1.75; // just to have some nice spacing
        var dcos = Math.cos(dTheta) - Math.cos(0);
        var dsin = Math.sin(dTheta) - Math.sin(0);
        var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping
        r = Math.max(rMin, r);
    }
    var getPos = function getPos(ele, i) {
        var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);
        var rx = r * Math.cos(theta);
        var ry = r * Math.sin(theta);
        var pos = {
            x: center.x + rx,
            y: center.y + ry
        };
        return pos;
    };
    eles.nodes().layoutPositions(this, options, getPos);
    return this; // chaining
};
var defaults$5 = {
    fit: true,
    // whether to fit the viewport to the graph
    padding: 30,
    // the padding on fit
    startAngle: 1.5 * Math.PI,
    // where nodes start in radians
    sweep: undefined,
    // how many radians should be between the first and last node (defaults to full circle)
    clockwise: true,
    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
    equidistant: false,
    // whether levels have an equal radial distance betwen them, may cause bounding box overflow
    minNodeSpacing: 10,
    // min spacing between outside of nodes (used for radius adjustment)
    boundingBox: undefined,
    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true,
    // prevents node overlap, may overflow boundingBox if not enough space
    nodeDimensionsIncludeLabels: false,
    // Excludes the label when calculating node bounding boxes for the layout algorithm
    height: undefined,
    // height of layout area (overrides container height)
    width: undefined,
    // width of layout area (overrides container width)
    spacingFactor: undefined,
    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
    concentric: function concentric(node) {
        // returns numeric value for each node, placing higher nodes in levels towards the centre
        return node.degree();
    },
    levelWidth: function levelWidth(nodes) {
        // the variation of concentric values in each level
        return nodes.maxDegree() / 4;
    },
    animate: false,
    // whether to transition the node positions
    animationDuration: 500,
    // duration of animation in ms if enabled
    animationEasing: undefined,
    // easing of animation if enabled
    animateFilter: function animateFilter(node, i) {
        return true;
    },
    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
    ready: undefined,
    // callback on layoutready
    stop: undefined,
    // callback on layoutstop
    transform: function transform(node, position) {
        return position;
    } // transform a given node position. Useful for changing flow direction in discrete layouts
};
function ConcentricLayout(options) {
    this.options = extend({}, defaults$5, options);
}
ConcentricLayout.prototype.run = function() {
    var params = this.options;
    var options = params;
    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(":parent");
    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
        x1: 0,
        y1: 0,
        w: cy.width(),
        h: cy.height()
    });
    var center = {
        x: bb.x1 + bb.w / 2,
        y: bb.y1 + bb.h / 2
    };
    var nodeValues = []; // { node, value }
    var maxNodeSize = 0;
    for(var i = 0; i < nodes.length; i++){
        var node = nodes[i];
        var value = void 0; // calculate the node value
        value = options.concentric(node);
        nodeValues.push({
            value: value,
            node: node
        }); // for style mapping
        node._private.scratch.concentric = value;
    } // in case we used the `concentric` in style
    nodes.updateStyle(); // calculate max size now based on potentially updated mappers
    for(var _i = 0; _i < nodes.length; _i++){
        var _node = nodes[_i];
        var nbb = _node.layoutDimensions(options);
        maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
    } // sort node values in descreasing order
    nodeValues.sort(function(a, b) {
        return b.value - a.value;
    });
    var levelWidth = options.levelWidth(nodes); // put the values into levels
    var levels = [
        []
    ];
    var currentLevel = levels[0];
    for(var _i2 = 0; _i2 < nodeValues.length; _i2++){
        var val = nodeValues[_i2];
        if (currentLevel.length > 0) {
            var diff = Math.abs(currentLevel[0].value - val.value);
            if (diff >= levelWidth) {
                currentLevel = [];
                levels.push(currentLevel);
            }
        }
        currentLevel.push(val);
    } // create positions from levels
    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes
    if (!options.avoidOverlap) {
        // then strictly constrain to bb
        var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
        var maxR = Math.min(bb.w, bb.h) / 2 - minDist;
        var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);
        minDist = Math.min(minDist, rStep);
    } // find the metrics for each level
    var r = 0;
    for(var _i3 = 0; _i3 < levels.length; _i3++){
        var level = levels[_i3];
        var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
        var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius
        if (level.length > 1 && options.avoidOverlap) {
            // but only if more than one node (can't overlap)
            var dcos = Math.cos(dTheta) - Math.cos(0);
            var dsin = Math.sin(dTheta) - Math.sin(0);
            var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping
            r = Math.max(rMin, r);
        }
        level.r = r;
        r += minDist;
    }
    if (options.equidistant) {
        var rDeltaMax = 0;
        var _r = 0;
        for(var _i4 = 0; _i4 < levels.length; _i4++){
            var _level = levels[_i4];
            var rDelta = _level.r - _r;
            rDeltaMax = Math.max(rDeltaMax, rDelta);
        }
        _r = 0;
        for(var _i5 = 0; _i5 < levels.length; _i5++){
            var _level2 = levels[_i5];
            if (_i5 === 0) _r = _level2.r;
            _level2.r = _r;
            _r += rDeltaMax;
        }
    } // calculate the node positions
    var pos = {}; // id => position
    for(var _i6 = 0; _i6 < levels.length; _i6++){
        var _level3 = levels[_i6];
        var _dTheta = _level3.dTheta;
        var _r2 = _level3.r;
        for(var j = 0; j < _level3.length; j++){
            var _val = _level3[j];
            var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;
            var p = {
                x: center.x + _r2 * Math.cos(theta),
                y: center.y + _r2 * Math.sin(theta)
            };
            pos[_val.node.id()] = p;
        }
    } // position the nodes
    eles.nodes().layoutPositions(this, options, function(ele) {
        var id = ele.id();
        return pos[id];
    });
    return this; // chaining
};
/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/ var DEBUG;
/**
 * @brief :  default layout options
 */ var defaults$4 = {
    // Called on `layoutready`
    ready: function ready() {},
    // Called on `layoutstop`
    stop: function stop() {},
    // Whether to animate while running the layout
    // true : Animate continuously as the layout is running
    // false : Just show the end result
    // 'end' : Animate with the end result, from the initial positions to the end positions
    animate: true,
    // Easing of the animation for animate:'end'
    animationEasing: undefined,
    // The duration of the animation for animate:'end'
    animationDuration: undefined,
    // A function that determines whether the node should be animated
    // All nodes animated by default on animate enabled
    // Non-animated nodes are positioned immediately when the layout starts
    animateFilter: function animateFilter(node, i) {
        return true;
    },
    // The layout animates only after this many milliseconds for animate:true
    // (prevents flashing on fast runs)
    animationThreshold: 250,
    // Number of iterations between consecutive screen positions update
    refresh: 20,
    // Whether to fit the network view after when done
    fit: true,
    // Padding on fit
    padding: 30,
    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    boundingBox: undefined,
    // Excludes the label when calculating node bounding boxes for the layout algorithm
    nodeDimensionsIncludeLabels: false,
    // Randomize the initial positions of the nodes (true) or use existing positions (false)
    randomize: false,
    // Extra spacing between components in non-compound graphs
    componentSpacing: 40,
    // Node repulsion (non overlapping) multiplier
    nodeRepulsion: function nodeRepulsion(node) {
        return 2048;
    },
    // Node repulsion (overlapping) multiplier
    nodeOverlap: 4,
    // Ideal edge (non nested) length
    idealEdgeLength: function idealEdgeLength(edge) {
        return 32;
    },
    // Divisor to compute edge forces
    edgeElasticity: function edgeElasticity(edge) {
        return 32;
    },
    // Nesting factor (multiplier) to compute ideal edge length for nested edges
    nestingFactor: 1.2,
    // Gravity force (constant)
    gravity: 1,
    // Maximum number of iterations to perform
    numIter: 1000,
    // Initial temperature (maximum node displacement)
    initialTemp: 1000,
    // Cooling factor (how the temperature is reduced between consecutive iterations
    coolingFactor: 0.99,
    // Lower temperature threshold (below this point the layout will end)
    minTemp: 1.0
};
/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */ function CoseLayout(options) {
    this.options = extend({}, defaults$4, options);
    this.options.layout = this;
}
/**
 * @brief : runs the layout
 */ CoseLayout.prototype.run = function() {
    var options = this.options;
    var cy = options.cy;
    var layout = this;
    layout.stopped = false;
    if (options.animate === true || options.animate === false) layout.emit({
        type: "layoutstart",
        layout: layout
    });
     // Set DEBUG - Global variable
    if (true === options.debug) DEBUG = true;
    else DEBUG = false;
     // Initialize layout info
    var layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging
    if (DEBUG) printLayoutInfo(layoutInfo);
     // If required, randomize node positions
    if (options.randomize) randomizePositions(layoutInfo);
    var startTime = performanceNow();
    var refresh = function refresh() {
        refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary
        if (true === options.fit) cy.fit(options.padding);
    };
    var mainLoop = function mainLoop(i) {
        if (layout.stopped || i >= options.numIter) // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
         // Do one step in the phisical simulation
        step(layoutInfo, options); // Update temperature
        layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug("New temperature: " + layoutInfo.temperature);
        if (layoutInfo.temperature < options.minTemp) // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
        return true;
    };
    var done = function done() {
        if (options.animate === true || options.animate === false) {
            refresh(); // Layout has finished
            layout.one("layoutstop", options.stop);
            layout.emit({
                type: "layoutstop",
                layout: layout
            });
        } else {
            var nodes = options.eles.nodes();
            var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
            nodes.layoutPositions(layout, options, getScaledPos);
        }
    };
    var i = 0;
    var loopRet = true;
    if (options.animate === true) {
        var frame = function frame() {
            var f = 0;
            while(loopRet && f < options.refresh){
                loopRet = mainLoop(i);
                i++;
                f++;
            }
            if (!loopRet) {
                // it's done
                separateComponents(layoutInfo, options);
                done();
            } else {
                var now = performanceNow();
                if (now - startTime >= options.animationThreshold) refresh();
                requestAnimationFrame(frame);
            }
        };
        frame();
    } else {
        while(loopRet){
            loopRet = mainLoop(i);
            i++;
        }
        separateComponents(layoutInfo, options);
        done();
    }
    return this; // chaining
};
/**
 * @brief : called on continuous layouts to stop them before they finish
 */ CoseLayout.prototype.stop = function() {
    this.stopped = true;
    if (this.thread) this.thread.stop();
    this.emit("layoutstop");
    return this; // chaining
};
CoseLayout.prototype.destroy = function() {
    if (this.thread) this.thread.stop();
    return this; // chaining
};
/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */ var createLayoutInfo = function createLayoutInfo(cy, layout, options) {
    // Shortcut
    var edges = options.eles.edges();
    var nodes = options.eles.nodes();
    var layoutInfo = {
        isCompound: cy.hasCompoundNodes(),
        layoutNodes: [],
        idToIndex: {},
        nodeSize: nodes.size(),
        graphSet: [],
        indexToGraph: [],
        layoutEdges: [],
        edgeSize: edges.size(),
        temperature: options.initialTemp,
        clientWidth: cy.width(),
        clientHeight: cy.width(),
        boundingBox: makeBoundingBox(options.boundingBox ? options.boundingBox : {
            x1: 0,
            y1: 0,
            w: cy.width(),
            h: cy.height()
        })
    };
    var components = options.eles.components();
    var id2cmptId = {};
    for(var i = 0; i < components.length; i++){
        var component = components[i];
        for(var j = 0; j < component.length; j++){
            var node = component[j];
            id2cmptId[node.id()] = i;
        }
    } // Iterate over all nodes, creating layout nodes
    for(var i = 0; i < layoutInfo.nodeSize; i++){
        var n = nodes[i];
        var nbb = n.layoutDimensions(options);
        var tempNode = {};
        tempNode.isLocked = n.locked();
        tempNode.id = n.data("id");
        tempNode.parentId = n.data("parent");
        tempNode.cmptId = id2cmptId[n.id()];
        tempNode.children = [];
        tempNode.positionX = n.position("x");
        tempNode.positionY = n.position("y");
        tempNode.offsetX = 0;
        tempNode.offsetY = 0;
        tempNode.height = nbb.w;
        tempNode.width = nbb.h;
        tempNode.maxX = tempNode.positionX + tempNode.width / 2;
        tempNode.minX = tempNode.positionX - tempNode.width / 2;
        tempNode.maxY = tempNode.positionY + tempNode.height / 2;
        tempNode.minY = tempNode.positionY - tempNode.height / 2;
        tempNode.padLeft = parseFloat(n.style("padding"));
        tempNode.padRight = parseFloat(n.style("padding"));
        tempNode.padTop = parseFloat(n.style("padding"));
        tempNode.padBottom = parseFloat(n.style("padding")); // forces
        tempNode.nodeRepulsion = fn$6(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node
        layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map
        layoutInfo.idToIndex[tempNode.id] = i;
    } // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0; // Points to the start the queue
    var end = -1; // Points to the end of the queue
    var tempGraph = []; // Second pass to add child information and
    // initialize queue for hierarchical traversal
    for(var i = 0; i < layoutInfo.nodeSize; i++){
        var n = layoutInfo.layoutNodes[i];
        var p_id = n.parentId; // Check if node n has a parent node
        if (null != p_id) // Add node Id to parent's list of children
        layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
        else {
            // If a node doesn't have a parent, then it's in the root graph
            queue[++end] = n.id;
            tempGraph.push(n.id);
        }
    } // Add root graph to graphSet
    layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,
    while(start <= end){
        // Get the node to visit and remove it from queue
        var node_id = queue[start++];
        var node_ix = layoutInfo.idToIndex[node_id];
        var node = layoutInfo.layoutNodes[node_ix];
        var children = node.children;
        if (children.length > 0) {
            // Add children nodes as a new graph to graph set
            layoutInfo.graphSet.push(children); // Add children to que queue to be visited
            for(var i = 0; i < children.length; i++)queue[++end] = children[i];
        }
    } // Create indexToGraph map
    for(var i = 0; i < layoutInfo.graphSet.length; i++){
        var graph = layoutInfo.graphSet[i];
        for(var j = 0; j < graph.length; j++){
            var index = layoutInfo.idToIndex[graph[j]];
            layoutInfo.indexToGraph[index] = i;
        }
    } // Iterate over all edges, creating Layout Edges
    for(var i = 0; i < layoutInfo.edgeSize; i++){
        var e = edges[i];
        var tempEdge = {};
        tempEdge.id = e.data("id");
        tempEdge.sourceId = e.data("source");
        tempEdge.targetId = e.data("target"); // Compute ideal length
        var idealLength = fn$6(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;
        var elasticity = fn$6(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge
        var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
        var targetIx = layoutInfo.idToIndex[tempEdge.targetId];
        var sourceGraph = layoutInfo.indexToGraph[sourceIx];
        var targetGraph = layoutInfo.indexToGraph[targetIx];
        if (sourceGraph != targetGraph) {
            // Find lowest common graph ancestor
            var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph
            var lcaGraph = layoutInfo.graphSet[lca];
            var depth = 0; // Source depth
            var tempNode = layoutInfo.layoutNodes[sourceIx];
            while(-1 === lcaGraph.indexOf(tempNode.id)){
                tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
                depth++;
            } // Target depth
            tempNode = layoutInfo.layoutNodes[targetIx];
            while(-1 === lcaGraph.indexOf(tempNode.id)){
                tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
                depth++;
            } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
            //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
            //  ". Depth: " + depth);
            // Update idealLength
            idealLength *= depth * options.nestingFactor;
        }
        tempEdge.idealLength = idealLength;
        tempEdge.elasticity = elasticity;
        layoutInfo.layoutEdges.push(tempEdge);
    } // Finally, return layoutInfo object
    return layoutInfo;
};
/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */ var findLCA = function findLCA(node1, node2, layoutInfo) {
    // Find their common ancester, starting from the root graph
    var res = findLCA_aux(node1, node2, 0, layoutInfo);
    if (2 > res.count) // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
    else return res.graph;
};
/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */ var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {
    var graph = layoutInfo.graphSet[graphIx]; // If both nodes belongs to graphIx
    if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) return {
        count: 2,
        graph: graphIx
    };
     // Make recursive calls for all subgraphs
    var c = 0;
    for(var i = 0; i < graph.length; i++){
        var nodeId = graph[i];
        var nodeIx = layoutInfo.idToIndex[nodeId];
        var children = layoutInfo.layoutNodes[nodeIx].children; // If the node has no child, skip it
        if (0 === children.length) continue;
        var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
        var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
        if (0 === result.count) continue;
        else if (1 === result.count) {
            // One of (node1, node2) is present in this subgraph
            c++;
            if (2 === c) break;
        } else // Both nodes are present in this subgraph
        return result;
    }
    return {
        count: c,
        graph: graphIx
    };
};
/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */ var printLayoutInfo;
/**
 * @brief : Randomizes the position of all nodes
 */ var randomizePositions = function randomizePositions(layoutInfo, cy) {
    var width = layoutInfo.clientWidth;
    var height = layoutInfo.clientHeight;
    for(var i = 0; i < layoutInfo.nodeSize; i++){
        var n = layoutInfo.layoutNodes[i]; // No need to randomize compound nodes or locked nodes
        if (0 === n.children.length && !n.isLocked) {
            n.positionX = Math.random() * width;
            n.positionY = Math.random() * height;
        }
    }
};
var getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {
    var bb = layoutInfo.boundingBox;
    var coseBB = {
        x1: Infinity,
        x2: -Infinity,
        y1: Infinity,
        y2: -Infinity
    };
    if (options.boundingBox) {
        nodes.forEach(function(node) {
            var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data("id")]];
            coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
            coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);
            coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
            coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
        });
        coseBB.w = coseBB.x2 - coseBB.x1;
        coseBB.h = coseBB.y2 - coseBB.y1;
    }
    return function(ele, i) {
        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data("id")]];
        if (options.boundingBox) {
            // then add extra bounding box constraint
            var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
            var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;
            return {
                x: bb.x1 + pctX * bb.w,
                y: bb.y1 + pctY * bb.h
            };
        } else return {
            x: lnode.positionX,
            y: lnode.positionY
        };
    };
};
/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */ var refreshPositions = function refreshPositions(layoutInfo, cy, options) {
    // var s = 'Refreshing positions';
    // logDebug(s);
    var layout = options.layout;
    var nodes = options.eles.nodes();
    var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
    nodes.positions(getScaledPos); // Trigger layoutReady only on first call
    if (true !== layoutInfo.ready) {
        // s = 'Triggering layoutready';
        // logDebug(s);
        layoutInfo.ready = true;
        layout.one("layoutready", options.ready);
        layout.emit({
            type: "layoutready",
            layout: this
        });
    }
};
/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */ // var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };
/**
 * @brief          : Performs one iteration of the physical simulation
 * @arg layoutInfo : LayoutInfo object already initialized
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */ var step = function step(layoutInfo, options, _step) {
    // var s = "\n\n###############################";
    // s += "\nSTEP: " + step;
    // s += "\n###############################\n";
    // logDebug(s);
    // Calculate node repulsions
    calculateNodeForces(layoutInfo, options); // Calculate edge forces
    calculateEdgeForces(layoutInfo); // Calculate gravity forces
    calculateGravityForces(layoutInfo, options); // Propagate forces from parent to child
    propagateForces(layoutInfo); // Update positions based on calculated forces
    updatePositions(layoutInfo);
};
/**
 * @brief : Computes the node repulsion forces
 */ var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {
    // Go through each of the graphs in graphSet
    // Nodes only repel each other if they belong to the same graph
    // var s = 'calculateNodeForces';
    // logDebug(s);
    for(var i = 0; i < layoutInfo.graphSet.length; i++){
        var graph = layoutInfo.graphSet[i];
        var numNodes = graph.length; // s = "Set: " + graph.toString();
        // logDebug(s);
        // Now get all the pairs of nodes
        // Only get each pair once, (A, B) = (B, A)
        for(var j = 0; j < numNodes; j++){
            var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
            for(var k = j + 1; k < numNodes; k++){
                var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
                nodeRepulsion(node1, node2, layoutInfo, options);
            }
        }
    }
};
var randomDistance = function randomDistance(max) {
    return -max + 2 * max * Math.random();
};
/**
 * @brief : Compute the node repulsion forces between a pair of nodes
 */ var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {
    // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;
    var cmptId1 = node1.cmptId;
    var cmptId2 = node2.cmptId;
    if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) return;
     // Get direction of line connecting both node centers
    var directionX = node2.positionX - node1.positionX;
    var directionY = node2.positionY - node1.positionY;
    var maxRandDist = 1; // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;
    // If both centers are the same, apply a random force
    if (0 === directionX && 0 === directionY) {
        directionX = randomDistance(maxRandDist);
        directionY = randomDistance(maxRandDist);
    }
    var overlap = nodesOverlap(node1, node2, directionX, directionY);
    if (overlap > 0) {
        // s += "\nNodes DO overlap.";
        // s += "\nOverlap: " + overlap;
        // If nodes overlap, repulsion force is proportional
        // to the overlap
        var force = options.nodeOverlap * overlap; // Compute the module and components of the force vector
        var distance = Math.sqrt(directionX * directionX + directionY * directionY); // s += "\nDistance: " + distance;
        var forceX = force * directionX / distance;
        var forceY = force * directionY / distance;
    } else {
        // s += "\nNodes do NOT overlap.";
        // If there's no overlap, force is inversely proportional
        // to squared distance
        // Get clipping points for both nodes
        var point1 = findClippingPoint(node1, directionX, directionY);
        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY); // Use clipping points to compute distance
        var distanceX = point2.x - point1.x;
        var distanceY = point2.y - point1.y;
        var distanceSqr = distanceX * distanceX + distanceY * distanceY;
        var distance = Math.sqrt(distanceSqr); // s += "\nDistance: " + distance;
        // Compute the module and components of the force vector
        var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
        var forceX = force * distanceX / distance;
        var forceY = force * distanceY / distance;
    } // Apply force
    if (!node1.isLocked) {
        node1.offsetX -= forceX;
        node1.offsetY -= forceY;
    }
    if (!node2.isLocked) {
        node2.offsetX += forceX;
        node2.offsetY += forceY;
    } // s += "\nForceX: " + forceX + " ForceY: " + forceY;
    // logDebug(s);
    return;
};
/**
 * @brief  : Determines whether two nodes overlap or not
 * @return : Amount of overlapping (0 => no overlap)
 */ var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {
    if (dX > 0) var overlapX = node1.maxX - node2.minX;
    else var overlapX = node2.maxX - node1.minX;
    if (dY > 0) var overlapY = node1.maxY - node2.minY;
    else var overlapY = node2.maxY - node1.minY;
    if (overlapX >= 0 && overlapY >= 0) return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
    else return 0;
};
/**
 * @brief : Finds the point in which an edge (direction dX, dY) intersects
 *          the rectangular bounding box of it's source/target node
 */ var findClippingPoint = function findClippingPoint(node, dX, dY) {
    // Shorcuts
    var X = node.positionX;
    var Y = node.positionY;
    var H = node.height || 1;
    var W = node.width || 1;
    var dirSlope = dY / dX;
    var nodeSlope = H / W; // var s = 'Computing clipping point of node ' + node.id +
    //   " . Height:  " + H + ", Width: " + W +
    //   "\nDirection " + dX + ", " + dY;
    //
    // Compute intersection
    var res = {}; // Case: Vertical direction (up)
    if (0 === dX && 0 < dY) {
        res.x = X; // s += "\nUp direction";
        res.y = Y + H / 2;
        return res;
    } // Case: Vertical direction (down)
    if (0 === dX && 0 > dY) {
        res.x = X;
        res.y = Y + H / 2; // s += "\nDown direction";
        return res;
    } // Case: Intersects the right border
    if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
        res.x = X + W / 2;
        res.y = Y + W * dY / 2 / dX; // s += "\nRightborder";
        return res;
    } // Case: Intersects the left border
    if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
        res.x = X - W / 2;
        res.y = Y - W * dY / 2 / dX; // s += "\nLeftborder";
        return res;
    } // Case: Intersects the top border
    if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
        res.x = X + H * dX / 2 / dY;
        res.y = Y + H / 2; // s += "\nTop border";
        return res;
    } // Case: Intersects the bottom border
    if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
        res.x = X - H * dX / 2 / dY;
        res.y = Y - H / 2; // s += "\nBottom border";
        return res;
    } // s += "\nClipping point found at " + res.x + ", " + res.y;
    // logDebug(s);
    return res;
};
/**
 * @brief : Calculates all edge forces
 */ var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {
    // Iterate over all edges
    for(var i = 0; i < layoutInfo.edgeSize; i++){
        // Get edge, source & target nodes
        var edge = layoutInfo.layoutEdges[i];
        var sourceIx = layoutInfo.idToIndex[edge.sourceId];
        var source = layoutInfo.layoutNodes[sourceIx];
        var targetIx = layoutInfo.idToIndex[edge.targetId];
        var target = layoutInfo.layoutNodes[targetIx]; // Get direction of line connecting both node centers
        var directionX = target.positionX - source.positionX;
        var directionY = target.positionY - source.positionY; // If both centers are the same, do nothing.
        // A random force has already been applied as node repulsion
        if (0 === directionX && 0 === directionY) continue;
         // Get clipping points for both nodes
        var point1 = findClippingPoint(source, directionX, directionY);
        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);
        var lx = point2.x - point1.x;
        var ly = point2.y - point1.y;
        var l = Math.sqrt(lx * lx + ly * ly);
        var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;
        if (0 !== l) {
            var forceX = force * lx / l;
            var forceY = force * ly / l;
        } else {
            var forceX = 0;
            var forceY = 0;
        } // Add this force to target and source nodes
        if (!source.isLocked) {
            source.offsetX += forceX;
            source.offsetY += forceY;
        }
        if (!target.isLocked) {
            target.offsetX -= forceX;
            target.offsetY -= forceY;
        } // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
    // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
    // logDebug(s);
    }
};
/**
 * @brief : Computes gravity forces for all nodes
 */ var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {
    if (options.gravity === 0) return;
    var distThreshold = 1; // var s = 'calculateGravityForces';
    // logDebug(s);
    for(var i = 0; i < layoutInfo.graphSet.length; i++){
        var graph = layoutInfo.graphSet[i];
        var numNodes = graph.length; // s = "Set: " + graph.toString();
        // logDebug(s);
        // Compute graph center
        if (0 === i) {
            var centerX = layoutInfo.clientHeight / 2;
            var centerY = layoutInfo.clientWidth / 2;
        } else {
            // Get Parent node for this graph, and use its position as center
            var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
            var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
            var centerX = parent.positionX;
            var centerY = parent.positionY;
        } // s = "Center found at: " + centerX + ", " + centerY;
        // logDebug(s);
        // Apply force to all nodes in graph
        for(var j = 0; j < numNodes; j++){
            var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]]; // s = "Node: " + node.id;
            if (node.isLocked) continue;
            var dx = centerX - node.positionX;
            var dy = centerY - node.positionY;
            var d = Math.sqrt(dx * dx + dy * dy);
            if (d > distThreshold) {
                var fx = options.gravity * dx / d;
                var fy = options.gravity * dy / d;
                node.offsetX += fx;
                node.offsetY += fy; // s += ": Applied force: " + fx + ", " + fy;
            } // logDebug(s);
        }
    }
};
/**
 * @brief          : This function propagates the existing offsets from
 *                   parent nodes to its descendents.
 * @arg layoutInfo : layoutInfo Object
 * @arg cy         : cytoscape Object
 * @arg options    : Layout options
 */ var propagateForces = function propagateForces(layoutInfo, options) {
    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0; // Points to the start the queue
    var end = -1; // Points to the end of the queue
    // logDebug('propagateForces');
    // Start by visiting the nodes in the root graph
    queue.push.apply(queue, layoutInfo.graphSet[0]);
    end += layoutInfo.graphSet[0].length; // Traverse the graph, level by level,
    while(start <= end){
        // Get the node to visit and remove it from queue
        var nodeId = queue[start++];
        var nodeIndex = layoutInfo.idToIndex[nodeId];
        var node = layoutInfo.layoutNodes[nodeIndex];
        var children = node.children; // We only need to process the node if it's compound
        if (0 < children.length && !node.isLocked) {
            var offX = node.offsetX;
            var offY = node.offsetY; // var s = "Propagating offset from parent node : " + node.id +
            //   ". OffsetX: " + offX + ". OffsetY: " + offY;
            // s += "\n Children: " + children.toString();
            // logDebug(s);
            for(var i = 0; i < children.length; i++){
                var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]]; // Propagate offset
                childNode.offsetX += offX;
                childNode.offsetY += offY; // Add children to queue to be visited
                queue[++end] = children[i];
            } // Reset parent offsets
            node.offsetX = 0;
            node.offsetY = 0;
        }
    }
};
/**
 * @brief : Updates the layout model positions, based on
 *          the accumulated forces
 */ var updatePositions = function updatePositions(layoutInfo, options) {
    // var s = 'Updating positions';
    // logDebug(s);
    // Reset boundaries for compound nodes
    for(var i = 0; i < layoutInfo.nodeSize; i++){
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length) {
            // logDebug("Resetting boundaries of compound node: " + n.id);
            n.maxX = undefined;
            n.minX = undefined;
            n.maxY = undefined;
            n.minY = undefined;
        }
    }
    for(var i = 0; i < layoutInfo.nodeSize; i++){
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length || n.isLocked) continue;
         // s = "Node: " + n.id + " Previous position: (" +
        // n.positionX + ", " + n.positionY + ").";
        // Limit displacement in order to improve stability
        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
        n.positionX += tempForce.x;
        n.positionY += tempForce.y;
        n.offsetX = 0;
        n.offsetY = 0;
        n.minX = n.positionX - n.width;
        n.maxX = n.positionX + n.width;
        n.minY = n.positionY - n.height;
        n.maxY = n.positionY + n.height; // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
        // logDebug(s);
        // Update ancestry boudaries
        updateAncestryBoundaries(n, layoutInfo);
    } // Update size, position of compund nodes
    for(var i = 0; i < layoutInfo.nodeSize; i++){
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length && !n.isLocked) {
            n.positionX = (n.maxX + n.minX) / 2;
            n.positionY = (n.maxY + n.minY) / 2;
            n.width = n.maxX - n.minX;
            n.height = n.maxY - n.minY; // s = "Updating position, size of compound node " + n.id;
        // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
        // s += "\nWidth: " + n.width + ", Height: " + n.height;
        // logDebug(s);
        }
    }
};
/**
 * @brief : Limits a force (forceX, forceY) to be not
 *          greater (in modulo) than max.
 8          Preserves force direction.
  */ var limitForce = function limitForce(forceX, forceY, max) {
    // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
    var force = Math.sqrt(forceX * forceX + forceY * forceY);
    if (force > max) var res = {
        x: max * forceX / force,
        y: max * forceY / force
    };
    else var res = {
        x: forceX,
        y: forceY
    };
     // s += ".\nResult: (" + res.x + ", " + res.y + ")";
    // logDebug(s);
    return res;
};
/**
 * @brief : Function used for keeping track of compound node
 *          sizes, since they should bound all their subnodes.
 */ var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {
    // var s = "Propagating new position/size of node " + node.id;
    var parentId = node.parentId;
    if (null == parentId) // If there's no parent, we are done
    // s += ". No parent node.";
    // logDebug(s);
    return;
     // Get Parent Node
    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
    var flag = false; // MaxX
    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
        p.maxX = node.maxX + p.padRight;
        flag = true; // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
    } // MinX
    if (null == p.minX || node.minX - p.padLeft < p.minX) {
        p.minX = node.minX - p.padLeft;
        flag = true; // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
    } // MaxY
    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
        p.maxY = node.maxY + p.padBottom;
        flag = true; // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
    } // MinY
    if (null == p.minY || node.minY - p.padTop < p.minY) {
        p.minY = node.minY - p.padTop;
        flag = true; // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
    } // If updated boundaries, propagate changes upward
    if (flag) // logDebug(s);
    return updateAncestryBoundaries(p, layoutInfo);
     // s += ". No changes in boundaries/position of parent node " + p.id;
    // logDebug(s);
    return;
};
var separateComponents = function separateComponents(layoutInfo, options) {
    var nodes = layoutInfo.layoutNodes;
    var components = [];
    for(var i = 0; i < nodes.length; i++){
        var node = nodes[i];
        var cid = node.cmptId;
        var component = components[cid] = components[cid] || [];
        component.push(node);
    }
    var totalA = 0;
    for(var i = 0; i < components.length; i++){
        var c = components[i];
        if (!c) continue;
        c.x1 = Infinity;
        c.x2 = -Infinity;
        c.y1 = Infinity;
        c.y2 = -Infinity;
        for(var j = 0; j < c.length; j++){
            var n = c[j];
            c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
            c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
            c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
            c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
        }
        c.w = c.x2 - c.x1;
        c.h = c.y2 - c.y1;
        totalA += c.w * c.h;
    }
    components.sort(function(c1, c2) {
        return c2.w * c2.h - c1.w * c1.h;
    });
    var x = 0;
    var y = 0;
    var usedW = 0;
    var rowH = 0;
    var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;
    for(var i = 0; i < components.length; i++){
        var c = components[i];
        if (!c) continue;
        for(var j = 0; j < c.length; j++){
            var n = c[j];
            if (!n.isLocked) {
                n.positionX += x - c.x1;
                n.positionY += y - c.y1;
            }
        }
        x += c.w + options.componentSpacing;
        usedW += c.w + options.componentSpacing;
        rowH = Math.max(rowH, c.h);
        if (usedW > maxRowW) {
            y += rowH + options.componentSpacing;
            x = 0;
            usedW = 0;
            rowH = 0;
        }
    }
};
var defaults$3 = {
    fit: true,
    // whether to fit the viewport to the graph
    padding: 30,
    // padding used on fit
    boundingBox: undefined,
    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true,
    // prevents node overlap, may overflow boundingBox if not enough space
    avoidOverlapPadding: 10,
    // extra spacing around nodes when avoidOverlap: true
    nodeDimensionsIncludeLabels: false,
    // Excludes the label when calculating node bounding boxes for the layout algorithm
    spacingFactor: undefined,
    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
    condense: false,
    // uses all available space on false, uses minimal space on true
    rows: undefined,
    // force num of rows in the grid
    cols: undefined,
    // force num of columns in the grid
    position: function position(node) {},
    // returns { row, col } for element
    sort: undefined,
    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
    animate: false,
    // whether to transition the node positions
    animationDuration: 500,
    // duration of animation in ms if enabled
    animationEasing: undefined,
    // easing of animation if enabled
    animateFilter: function animateFilter(node, i) {
        return true;
    },
    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
    ready: undefined,
    // callback on layoutready
    stop: undefined,
    // callback on layoutstop
    transform: function transform(node, position) {
        return position;
    } // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function GridLayout(options) {
    this.options = extend({}, defaults$3, options);
}
GridLayout.prototype.run = function() {
    var params = this.options;
    var options = params;
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(":parent");
    if (options.sort) nodes = nodes.sort(options.sort);
    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
        x1: 0,
        y1: 0,
        w: cy.width(),
        h: cy.height()
    });
    if (bb.h === 0 || bb.w === 0) eles.nodes().layoutPositions(this, options, function(ele) {
        return {
            x: bb.x1,
            y: bb.y1
        };
    });
    else {
        // width/height * splits^2 = cells where splits is number of times to split width
        var cells = nodes.size();
        var splits = Math.sqrt(cells * bb.h / bb.w);
        var rows = Math.round(splits);
        var cols = Math.round(bb.w / bb.h * splits);
        var small = function small(val) {
            if (val == null) return Math.min(rows, cols);
            else {
                var min = Math.min(rows, cols);
                if (min == rows) rows = val;
                else cols = val;
            }
        };
        var large = function large(val) {
            if (val == null) return Math.max(rows, cols);
            else {
                var max = Math.max(rows, cols);
                if (max == rows) rows = val;
                else cols = val;
            }
        };
        var oRows = options.rows;
        var oCols = options.cols != null ? options.cols : options.columns; // if rows or columns were set in options, use those values
        if (oRows != null && oCols != null) {
            rows = oRows;
            cols = oCols;
        } else if (oRows != null && oCols == null) {
            rows = oRows;
            cols = Math.ceil(cells / rows);
        } else if (oRows == null && oCols != null) {
            cols = oCols;
            rows = Math.ceil(cells / cols);
        } else if (cols * rows > cells) {
            var sm = small();
            var lg = large(); // reducing the small side takes away the most cells, so try it first
            if ((sm - 1) * lg >= cells) small(sm - 1);
            else if ((lg - 1) * sm >= cells) large(lg - 1);
        } else // if rounding was too low, add rows or columns
        while(cols * rows < cells){
            var _sm = small();
            var _lg = large(); // try to add to larger side first (adds less in multiplication)
            if ((_lg + 1) * _sm >= cells) large(_lg + 1);
            else small(_sm + 1);
        }
        var cellWidth = bb.w / cols;
        var cellHeight = bb.h / rows;
        if (options.condense) {
            cellWidth = 0;
            cellHeight = 0;
        }
        if (options.avoidOverlap) for(var i = 0; i < nodes.length; i++){
            var node = nodes[i];
            var pos = node._private.position;
            if (pos.x == null || pos.y == null) {
                // for bb
                pos.x = 0;
                pos.y = 0;
            }
            var nbb = node.layoutDimensions(options);
            var p = options.avoidOverlapPadding;
            var w = nbb.w + p;
            var h = nbb.h + p;
            cellWidth = Math.max(cellWidth, w);
            cellHeight = Math.max(cellHeight, h);
        }
        var cellUsed = {}; // e.g. 'c-0-2' => true
        var used = function used(row, col) {
            return cellUsed["c-" + row + "-" + col] ? true : false;
        };
        var use = function use(row, col) {
            cellUsed["c-" + row + "-" + col] = true;
        }; // to keep track of current cell position
        var row = 0;
        var col = 0;
        var moveToNextCell = function moveToNextCell() {
            col++;
            if (col >= cols) {
                col = 0;
                row++;
            }
        }; // get a cache of all the manual positions
        var id2manPos = {};
        for(var _i = 0; _i < nodes.length; _i++){
            var _node = nodes[_i];
            var rcPos = options.position(_node);
            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
                // must have at least row or col def'd
                var _pos = {
                    row: rcPos.row,
                    col: rcPos.col
                };
                if (_pos.col === undefined) {
                    // find unused col
                    _pos.col = 0;
                    while(used(_pos.row, _pos.col))_pos.col++;
                } else if (_pos.row === undefined) {
                    // find unused row
                    _pos.row = 0;
                    while(used(_pos.row, _pos.col))_pos.row++;
                }
                id2manPos[_node.id()] = _pos;
                use(_pos.row, _pos.col);
            }
        }
        var getPos = function getPos(element, i) {
            var x, y;
            if (element.locked() || element.isParent()) return false;
             // see if we have a manual position set
            var rcPos = id2manPos[element.id()];
            if (rcPos) {
                x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
                y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
            } else {
                // otherwise set automatically
                while(used(row, col))moveToNextCell();
                x = col * cellWidth + cellWidth / 2 + bb.x1;
                y = row * cellHeight + cellHeight / 2 + bb.y1;
                use(row, col);
                moveToNextCell();
            }
            return {
                x: x,
                y: y
            };
        };
        nodes.layoutPositions(this, options, getPos);
    }
    return this; // chaining
};
var defaults$2 = {
    ready: function ready() {},
    // on layoutready
    stop: function stop() {} // on layoutstop
}; // constructor
// options : object containing layout options
function NullLayout(options) {
    this.options = extend({}, defaults$2, options);
} // runs the layout
NullLayout.prototype.run = function() {
    var options = this.options;
    var eles = options.eles; // elements to consider in the layout
    var layout = this; // cy is automatically populated for us in the constructor
    // (disable eslint for next line as this serves as example layout code to external developers)
    // eslint-disable-next-line no-unused-vars
    options.cy;
    layout.emit("layoutstart"); // puts all nodes at (0, 0)
    // n.b. most layouts would use layoutPositions(), instead of positions() and manual events
    eles.nodes().positions(function() {
        return {
            x: 0,
            y: 0
        };
    }); // trigger layoutready when each node has had its position set at least once
    layout.one("layoutready", options.ready);
    layout.emit("layoutready"); // trigger layoutstop when the layout stops (e.g. finishes)
    layout.one("layoutstop", options.stop);
    layout.emit("layoutstop");
    return this; // chaining
}; // called on continuous layouts to stop them before they finish
NullLayout.prototype.stop = function() {
    return this; // chaining
};
var defaults$1 = {
    positions: undefined,
    // map of (node id) => (position obj); or function(node){ return somPos; }
    zoom: undefined,
    // the zoom level to set (prob want fit = false if set)
    pan: undefined,
    // the pan level to set (prob want fit = false if set)
    fit: true,
    // whether to fit to viewport
    padding: 30,
    // padding on fit
    animate: false,
    // whether to transition the node positions
    animationDuration: 500,
    // duration of animation in ms if enabled
    animationEasing: undefined,
    // easing of animation if enabled
    animateFilter: function animateFilter(node, i) {
        return true;
    },
    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
    ready: undefined,
    // callback on layoutready
    stop: undefined,
    // callback on layoutstop
    transform: function transform(node, position) {
        return position;
    } // transform a given node position. Useful for changing flow direction in discrete layouts
};
function PresetLayout(options) {
    this.options = extend({}, defaults$1, options);
}
PresetLayout.prototype.run = function() {
    var options = this.options;
    var eles = options.eles;
    var nodes = eles.nodes();
    var posIsFn = fn$6(options.positions);
    function getPosition(node) {
        if (options.positions == null) return copyPosition(node.position());
        if (posIsFn) return options.positions(node);
        var pos = options.positions[node._private.data.id];
        if (pos == null) return null;
        return pos;
    }
    nodes.layoutPositions(this, options, function(node, i) {
        var position = getPosition(node);
        if (node.locked() || position == null) return false;
        return position;
    });
    return this; // chaining
};
var defaults = {
    fit: true,
    // whether to fit to viewport
    padding: 30,
    // fit padding
    boundingBox: undefined,
    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    animate: false,
    // whether to transition the node positions
    animationDuration: 500,
    // duration of animation in ms if enabled
    animationEasing: undefined,
    // easing of animation if enabled
    animateFilter: function animateFilter(node, i) {
        return true;
    },
    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
    ready: undefined,
    // callback on layoutready
    stop: undefined,
    // callback on layoutstop
    transform: function transform(node, position) {
        return position;
    } // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function RandomLayout(options) {
    this.options = extend({}, defaults, options);
}
RandomLayout.prototype.run = function() {
    var options = this.options;
    var cy = options.cy;
    var eles = options.eles;
    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
        x1: 0,
        y1: 0,
        w: cy.width(),
        h: cy.height()
    });
    var getPos = function getPos(node, i) {
        return {
            x: bb.x1 + Math.round(Math.random() * bb.w),
            y: bb.y1 + Math.round(Math.random() * bb.h)
        };
    };
    eles.nodes().layoutPositions(this, options, getPos);
    return this; // chaining
};
var layout = [
    {
        name: "breadthfirst",
        impl: BreadthFirstLayout
    },
    {
        name: "circle",
        impl: CircleLayout
    },
    {
        name: "concentric",
        impl: ConcentricLayout
    },
    {
        name: "cose",
        impl: CoseLayout
    },
    {
        name: "grid",
        impl: GridLayout
    },
    {
        name: "null",
        impl: NullLayout
    },
    {
        name: "preset",
        impl: PresetLayout
    },
    {
        name: "random",
        impl: RandomLayout
    }
];
function NullRenderer(options) {
    this.options = options;
    this.notifications = 0; // for testing
}
var noop = function noop() {};
var throwImgErr = function throwImgErr() {
    throw new Error("A headless instance can not render images");
};
NullRenderer.prototype = {
    recalculateRenderedStyle: noop,
    notify: function notify() {
        this.notifications++;
    },
    init: noop,
    isHeadless: function isHeadless() {
        return true;
    },
    png: throwImgErr,
    jpg: throwImgErr
};
var BRp$f = {};
BRp$f.arrowShapeWidth = 0.3;
BRp$f.registerArrowShapes = function() {
    var arrowShapes = this.arrowShapes = {};
    var renderer = this; // Contract for arrow shapes:
    // 0, 0 is arrow tip
    // (0, 1) is direction towards node
    // (1, 0) is right
    //
    // functional api:
    // collide: check x, y in shape
    // roughCollide: called before collide, no false negatives
    // draw: draw
    // spacing: dist(arrowTip, nodeBoundary)
    // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip
    var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {
        var x1 = translation.x - size / 2 - padding;
        var x2 = translation.x + size / 2 + padding;
        var y1 = translation.y - size / 2 - padding;
        var y2 = translation.y + size / 2 + padding;
        var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;
        return inside;
    };
    var transform = function transform(x, y, size, angle, translation) {
        var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
        var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
        var xScaled = xRotated * size;
        var yScaled = yRotated * size;
        var xTranslated = xScaled + translation.x;
        var yTranslated = yScaled + translation.y;
        return {
            x: xTranslated,
            y: yTranslated
        };
    };
    var transformPoints = function transformPoints(pts, size, angle, translation) {
        var retPts = [];
        for(var i = 0; i < pts.length; i += 2){
            var x = pts[i];
            var y = pts[i + 1];
            retPts.push(transform(x, y, size, angle, translation));
        }
        return retPts;
    };
    var pointsToArr = function pointsToArr(pts) {
        var ret = [];
        for(var i = 0; i < pts.length; i++){
            var p = pts[i];
            ret.push(p.x, p.y);
        }
        return ret;
    };
    var standardGap = function standardGap(edge) {
        return edge.pstyle("width").pfValue * edge.pstyle("arrow-scale").pfValue * 2;
    };
    var defineArrowShape = function defineArrowShape(name, defn) {
        if (string(defn)) defn = arrowShapes[defn];
        arrowShapes[name] = extend({
            name: name,
            points: [
                -0.15,
                -0.3,
                0.15,
                -0.3,
                0.15,
                0.3,
                -0.15,
                0.3
            ],
            collide: function collide(x, y, size, angle, translation, padding) {
                var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
                var inside = pointInsidePolygonPoints(x, y, points);
                return inside;
            },
            roughCollide: bbCollide,
            draw: function draw(context, size, angle, translation) {
                var points = transformPoints(this.points, size, angle, translation);
                renderer.arrowShapeImpl("polygon")(context, points);
            },
            spacing: function spacing(edge) {
                return 0;
            },
            gap: standardGap
        }, defn);
    };
    defineArrowShape("none", {
        collide: falsify,
        roughCollide: falsify,
        draw: noop$1,
        spacing: zeroify,
        gap: zeroify
    });
    defineArrowShape("triangle", {
        points: [
            -0.15,
            -0.3,
            0,
            0,
            0.15,
            -0.3
        ]
    });
    defineArrowShape("arrow", "triangle");
    defineArrowShape("triangle-backcurve", {
        points: arrowShapes["triangle"].points,
        controlPoint: [
            0,
            -0.15
        ],
        roughCollide: bbCollide,
        draw: function draw(context, size, angle, translation, edgeWidth) {
            var ptsTrans = transformPoints(this.points, size, angle, translation);
            var ctrlPt = this.controlPoint;
            var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);
            renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
        },
        gap: function gap(edge) {
            return standardGap(edge) * 0.8;
        }
    });
    defineArrowShape("triangle-tee", {
        points: [
            0,
            0,
            0.15,
            -0.3,
            -0.15,
            -0.3,
            0,
            0
        ],
        pointsTee: [
            -0.15,
            -0.4,
            -0.15,
            -0.5,
            0.15,
            -0.5,
            0.15,
            -0.4
        ],
        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));
            var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
            return inside;
        },
        draw: function draw(context, size, angle, translation, edgeWidth) {
            var triPts = transformPoints(this.points, size, angle, translation);
            var teePts = transformPoints(this.pointsTee, size, angle, translation);
            renderer.arrowShapeImpl(this.name)(context, triPts, teePts);
        }
    });
    defineArrowShape("circle-triangle", {
        radius: 0.15,
        pointsTr: [
            0,
            -0.15,
            0.15,
            -0.45,
            -0.15,
            -0.45,
            0,
            -0.15
        ],
        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            var t = translation;
            var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            return pointInsidePolygonPoints(x, y, triPts) || circleInside;
        },
        draw: function draw(context, size, angle, translation, edgeWidth) {
            var triPts = transformPoints(this.pointsTr, size, angle, translation);
            renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);
        },
        spacing: function spacing(edge) {
            return renderer.getArrowWidth(edge.pstyle("width").pfValue, edge.pstyle("arrow-scale").value) * this.radius;
        }
    });
    defineArrowShape("triangle-cross", {
        points: [
            0,
            0,
            0.15,
            -0.3,
            -0.15,
            -0.3,
            0,
            0
        ],
        baseCrossLinePts: [
            -0.15,
            -0.4,
            -0.15,
            -0.4,
            0.15,
            -0.4,
            0.15,
            -0.4
        ],
        crossLinePts: function crossLinePts(size, edgeWidth) {
            // shift points so that the distance between the cross points matches edge width
            var p = this.baseCrossLinePts.slice();
            var shiftFactor = edgeWidth / size;
            var y0 = 3;
            var y1 = 5;
            p[y0] = p[y0] - shiftFactor;
            p[y1] = p[y1] - shiftFactor;
            return p;
        },
        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
            var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
            return inside;
        },
        draw: function draw(context, size, angle, translation, edgeWidth) {
            var triPts = transformPoints(this.points, size, angle, translation);
            var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);
            renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
        }
    });
    defineArrowShape("vee", {
        points: [
            -0.15,
            -0.3,
            0,
            0,
            0.15,
            -0.3,
            0,
            -0.15
        ],
        gap: function gap(edge) {
            return standardGap(edge) * 0.525;
        }
    });
    defineArrowShape("circle", {
        radius: 0.15,
        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            var t = translation;
            var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
            return inside;
        },
        draw: function draw(context, size, angle, translation, edgeWidth) {
            renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);
        },
        spacing: function spacing(edge) {
            return renderer.getArrowWidth(edge.pstyle("width").pfValue, edge.pstyle("arrow-scale").value) * this.radius;
        }
    });
    defineArrowShape("tee", {
        points: [
            -0.15,
            0,
            -0.15,
            -0.1,
            0.15,
            -0.1,
            0.15,
            0
        ],
        spacing: function spacing(edge) {
            return 1;
        },
        gap: function gap(edge) {
            return 1;
        }
    });
    defineArrowShape("square", {
        points: [
            -0.15,
            0.00,
            0.15,
            0.00,
            0.15,
            -0.3,
            -0.15,
            -0.3
        ]
    });
    defineArrowShape("diamond", {
        points: [
            -0.15,
            -0.15,
            0,
            -0.3,
            0.15,
            -0.15,
            0,
            0
        ],
        gap: function gap(edge) {
            return edge.pstyle("width").pfValue * edge.pstyle("arrow-scale").value;
        }
    });
    defineArrowShape("chevron", {
        points: [
            0,
            0,
            -0.15,
            -0.15,
            -0.1,
            -0.2,
            0,
            -0.1,
            0.1,
            -0.2,
            0.15,
            -0.15
        ],
        gap: function gap(edge) {
            return 0.95 * edge.pstyle("width").pfValue * edge.pstyle("arrow-scale").value;
        }
    });
};
var BRp$e = {}; // Project mouse
BRp$e.projectIntoViewport = function(clientX, clientY) {
    var cy = this.cy;
    var offsets = this.findContainerClientCoords();
    var offsetLeft = offsets[0];
    var offsetTop = offsets[1];
    var scale = offsets[4];
    var pan = cy.pan();
    var zoom = cy.zoom();
    var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;
    var y = ((clientY - offsetTop) / scale - pan.y) / zoom;
    return [
        x,
        y
    ];
};
BRp$e.findContainerClientCoords = function() {
    if (this.containerBB) return this.containerBB;
    var container = this.container;
    var rect = container.getBoundingClientRect();
    var style = window$1.getComputedStyle(container);
    var styleValue = function styleValue(name) {
        return parseFloat(style.getPropertyValue(name));
    };
    var padding = {
        left: styleValue("padding-left"),
        right: styleValue("padding-right"),
        top: styleValue("padding-top"),
        bottom: styleValue("padding-bottom")
    };
    var border = {
        left: styleValue("border-left-width"),
        right: styleValue("border-right-width"),
        top: styleValue("border-top-width"),
        bottom: styleValue("border-bottom-width")
    };
    var clientWidth = container.clientWidth;
    var clientHeight = container.clientHeight;
    var paddingHor = padding.left + padding.right;
    var paddingVer = padding.top + padding.bottom;
    var borderHor = border.left + border.right;
    var scale = rect.width / (clientWidth + borderHor);
    var unscaledW = clientWidth - paddingHor;
    var unscaledH = clientHeight - paddingVer;
    var left = rect.left + padding.left + border.left;
    var top = rect.top + padding.top + border.top;
    return this.containerBB = [
        left,
        top,
        unscaledW,
        unscaledH,
        scale
    ];
};
BRp$e.invalidateContainerClientCoordsCache = function() {
    this.containerBB = null;
};
BRp$e.findNearestElement = function(x, y, interactiveElementsOnly, isTouch) {
    return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];
};
BRp$e.findNearestElements = function(x, y, interactiveElementsOnly, isTouch) {
    var self = this;
    var r = this;
    var eles = r.getCachedZSortedEles();
    var near = []; // 1 node max, 1 edge max
    var zoom = r.cy.zoom();
    var hasCompounds = r.cy.hasCompoundNodes();
    var edgeThreshold = (isTouch ? 24 : 8) / zoom;
    var nodeThreshold = (isTouch ? 8 : 2) / zoom;
    var labelThreshold = (isTouch ? 8 : 2) / zoom;
    var minSqDist = Infinity;
    var nearEdge;
    var nearNode;
    if (interactiveElementsOnly) eles = eles.interactive;
    function addEle(ele, sqDist) {
        if (ele.isNode()) {
            if (nearNode) return; // can't replace node
            else {
                nearNode = ele;
                near.push(ele);
            }
        }
        if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {
            if (nearEdge) // then replace existing edge
            // can replace only if same z-index
            {
                if (nearEdge.pstyle("z-compound-depth").value === ele.pstyle("z-compound-depth").value && nearEdge.pstyle("z-compound-depth").value === ele.pstyle("z-compound-depth").value) {
                    for(var i = 0; i < near.length; i++)if (near[i].isEdge()) {
                        near[i] = ele;
                        nearEdge = ele;
                        minSqDist = sqDist != null ? sqDist : minSqDist;
                        break;
                    }
                }
            } else {
                near.push(ele);
                nearEdge = ele;
                minSqDist = sqDist != null ? sqDist : minSqDist;
            }
        }
    }
    function checkNode(node) {
        var width = node.outerWidth() + 2 * nodeThreshold;
        var height = node.outerHeight() + 2 * nodeThreshold;
        var hw = width / 2;
        var hh = height / 2;
        var pos = node.position();
        if (pos.x - hw <= x && x <= pos.x + hw // bb check x
         && pos.y - hh <= y && y <= pos.y + hh // bb check y
        ) {
            var shape = r.nodeShapes[self.getNodeShape(node)];
            if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {
                addEle(node, 0);
                return true;
            }
        }
    }
    function checkEdge(edge) {
        var _p = edge._private;
        var rs = _p.rscratch;
        var styleWidth = edge.pstyle("width").pfValue;
        var scale = edge.pstyle("arrow-scale").value;
        var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre
        var widthSq = width * width;
        var width2 = width * 2;
        var src = _p.source;
        var tgt = _p.target;
        var sqDist;
        if (rs.edgeType === "segments" || rs.edgeType === "straight" || rs.edgeType === "haystack") {
            var pts = rs.allpts;
            for(var i = 0; i + 3 < pts.length; i += 2)if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {
                addEle(edge, sqDist);
                return true;
            }
        } else if (rs.edgeType === "bezier" || rs.edgeType === "multibezier" || rs.edgeType === "self" || rs.edgeType === "compound") {
            var pts = rs.allpts;
            for(var i = 0; i + 5 < rs.allpts.length; i += 4)if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {
                addEle(edge, sqDist);
                return true;
            }
        } // if we're close to the edge but didn't hit it, maybe we hit its arrows
        var src = src || _p.source;
        var tgt = tgt || _p.target;
        var arSize = self.getArrowWidth(styleWidth, scale);
        var arrows = [
            {
                name: "source",
                x: rs.arrowStartX,
                y: rs.arrowStartY,
                angle: rs.srcArrowAngle
            },
            {
                name: "target",
                x: rs.arrowEndX,
                y: rs.arrowEndY,
                angle: rs.tgtArrowAngle
            },
            {
                name: "mid-source",
                x: rs.midX,
                y: rs.midY,
                angle: rs.midsrcArrowAngle
            },
            {
                name: "mid-target",
                x: rs.midX,
                y: rs.midY,
                angle: rs.midtgtArrowAngle
            }
        ];
        for(var i = 0; i < arrows.length; i++){
            var ar = arrows[i];
            var shape = r.arrowShapes[edge.pstyle(ar.name + "-arrow-shape").value];
            var edgeWidth = edge.pstyle("width").pfValue;
            if (shape.roughCollide(x, y, arSize, ar.angle, {
                x: ar.x,
                y: ar.y
            }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {
                x: ar.x,
                y: ar.y
            }, edgeWidth, edgeThreshold)) {
                addEle(edge);
                return true;
            }
        } // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
        if (hasCompounds && near.length > 0) {
            checkNode(src);
            checkNode(tgt);
        }
    }
    function preprop(obj, name, pre) {
        return getPrefixedProperty(obj, name, pre);
    }
    function checkLabel(ele, prefix) {
        var _p = ele._private;
        var th = labelThreshold;
        var prefixDash;
        if (prefix) prefixDash = prefix + "-";
        else prefixDash = "";
        ele.boundingBox();
        var bb = _p.labelBounds[prefix || "main"];
        var text = ele.pstyle(prefixDash + "label").value;
        var eventsEnabled = ele.pstyle("text-events").strValue === "yes";
        if (!eventsEnabled || !text) return;
        var lx = preprop(_p.rscratch, "labelX", prefix);
        var ly = preprop(_p.rscratch, "labelY", prefix);
        var theta = preprop(_p.rscratch, "labelAngle", prefix);
        var ox = ele.pstyle(prefixDash + "text-margin-x").pfValue;
        var oy = ele.pstyle(prefixDash + "text-margin-y").pfValue;
        var lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin
        var lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)
        var ly1 = bb.y1 - th - oy;
        var ly2 = bb.y2 + th - oy;
        if (theta) {
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);
            var rotate = function rotate(x, y) {
                x = x - lx;
                y = y - ly;
                return {
                    x: x * cos - y * sin + lx,
                    y: x * sin + y * cos + ly
                };
            };
            var px1y1 = rotate(lx1, ly1);
            var px1y2 = rotate(lx1, ly2);
            var px2y1 = rotate(lx2, ly1);
            var px2y2 = rotate(lx2, ly2);
            var points = [
                px1y1.x + ox,
                px1y1.y + oy,
                px2y1.x + ox,
                px2y1.y + oy,
                px2y2.x + ox,
                px2y2.y + oy,
                px1y2.x + ox,
                px1y2.y + oy
            ];
            if (pointInsidePolygonPoints(x, y, points)) {
                addEle(ele);
                return true;
            }
        } else // do a cheaper bb check
        if (inBoundingBox(bb, x, y)) {
            addEle(ele);
            return true;
        }
    }
    for(var i = eles.length - 1; i >= 0; i--){
        // reverse order for precedence
        var ele = eles[i];
        if (ele.isNode()) checkNode(ele) || checkLabel(ele);
        else // then edge
        checkEdge(ele) || checkLabel(ele) || checkLabel(ele, "source") || checkLabel(ele, "target");
    }
    return near;
}; // 'Give me everything from this box'
BRp$e.getAllInBox = function(x1, y1, x2, y2) {
    var eles = this.getCachedZSortedEles().interactive;
    var box = [];
    var x1c = Math.min(x1, x2);
    var x2c = Math.max(x1, x2);
    var y1c = Math.min(y1, y2);
    var y2c = Math.max(y1, y2);
    x1 = x1c;
    x2 = x2c;
    y1 = y1c;
    y2 = y2c;
    var boxBb = makeBoundingBox({
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
    });
    for(var e = 0; e < eles.length; e++){
        var ele = eles[e];
        if (ele.isNode()) {
            var node = ele;
            var nodeBb = node.boundingBox({
                includeNodes: true,
                includeEdges: false,
                includeLabels: false
            });
            if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) box.push(node);
        } else {
            var edge = ele;
            var _p = edge._private;
            var rs = _p.rscratch;
            if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) continue;
            if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) continue;
            if (rs.edgeType === "bezier" || rs.edgeType === "multibezier" || rs.edgeType === "self" || rs.edgeType === "compound" || rs.edgeType === "segments" || rs.edgeType === "haystack") {
                var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
                var allInside = true;
                for(var i = 0; i < pts.length; i++)if (!pointInBoundingBox(boxBb, pts[i])) {
                    allInside = false;
                    break;
                }
                if (allInside) box.push(edge);
            } else if (rs.edgeType === "haystack" || rs.edgeType === "straight") box.push(edge);
        }
    }
    return box;
};
var BRp$d = {};
BRp$d.calculateArrowAngles = function(edge) {
    var rs = edge._private.rscratch;
    var isHaystack = rs.edgeType === "haystack";
    var isBezier = rs.edgeType === "bezier";
    var isMultibezier = rs.edgeType === "multibezier";
    var isSegments = rs.edgeType === "segments";
    var isCompound = rs.edgeType === "compound";
    var isSelf = rs.edgeType === "self"; // Displacement gives direction for arrowhead orientation
    var dispX, dispY;
    var startX, startY, endX, endY, midX, midY;
    if (isHaystack) {
        startX = rs.haystackPts[0];
        startY = rs.haystackPts[1];
        endX = rs.haystackPts[2];
        endY = rs.haystackPts[3];
    } else {
        startX = rs.arrowStartX;
        startY = rs.arrowStartY;
        endX = rs.arrowEndX;
        endY = rs.arrowEndY;
    }
    midX = rs.midX;
    midY = rs.midY; // source
    //
    if (isSegments) {
        dispX = startX - rs.segpts[0];
        dispY = startY - rs.segpts[1];
    } else if (isMultibezier || isCompound || isSelf || isBezier) {
        var pts = rs.allpts;
        var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);
        var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);
        dispX = startX - bX;
        dispY = startY - bY;
    } else {
        dispX = startX - midX;
        dispY = startY - midY;
    }
    rs.srcArrowAngle = getAngleFromDisp(dispX, dispY); // mid target
    //
    var midX = rs.midX;
    var midY = rs.midY;
    if (isHaystack) {
        midX = (startX + endX) / 2;
        midY = (startY + endY) / 2;
    }
    dispX = endX - startX;
    dispY = endY - startY;
    if (isSegments) {
        var pts = rs.allpts;
        if (pts.length / 2 % 2 === 0) {
            var i2 = pts.length / 2;
            var i1 = i2 - 2;
            dispX = pts[i2] - pts[i1];
            dispY = pts[i2 + 1] - pts[i1 + 1];
        } else {
            var i2 = pts.length / 2 - 1;
            var i1 = i2 - 2;
            var i3 = i2 + 2;
            dispX = pts[i2] - pts[i1];
            dispY = pts[i2 + 1] - pts[i1 + 1];
        }
    } else if (isMultibezier || isCompound || isSelf) {
        var pts = rs.allpts;
        var cpts = rs.ctrlpts;
        var bp0x, bp0y;
        var bp1x, bp1y;
        if (cpts.length / 2 % 2 === 0) {
            var p0 = pts.length / 2 - 1; // startpt
            var ic = p0 + 2;
            var p1 = ic + 2;
            bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);
            bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);
            bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);
            bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);
        } else {
            var ic = pts.length / 2 - 1; // ctrpt
            var p0 = ic - 2; // startpt
            var p1 = ic + 2; // endpt
            bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);
            bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);
            bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);
            bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);
        }
        dispX = bp1x - bp0x;
        dispY = bp1y - bp0y;
    }
    rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);
    rs.midDispX = dispX;
    rs.midDispY = dispY; // mid source
    //
    dispX *= -1;
    dispY *= -1;
    if (isSegments) {
        var pts = rs.allpts;
        if (pts.length / 2 % 2 === 0) ;
        else {
            var i2 = pts.length / 2 - 1;
            var i3 = i2 + 2;
            dispX = -(pts[i3] - pts[i2]);
            dispY = -(pts[i3 + 1] - pts[i2 + 1]);
        }
    }
    rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY); // target
    //
    if (isSegments) {
        dispX = endX - rs.segpts[rs.segpts.length - 2];
        dispY = endY - rs.segpts[rs.segpts.length - 1];
    } else if (isMultibezier || isCompound || isSelf || isBezier) {
        var pts = rs.allpts;
        var l = pts.length;
        var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);
        var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);
        dispX = endX - bX;
        dispY = endY - bY;
    } else {
        dispX = endX - midX;
        dispY = endY - midY;
    }
    rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);
};
BRp$d.getArrowWidth = BRp$d.getArrowHeight = function(edgeWidth, scale) {
    var cache = this.arrowWidthCache = this.arrowWidthCache || {};
    var cachedVal = cache[edgeWidth + ", " + scale];
    if (cachedVal) return cachedVal;
    cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;
    cache[edgeWidth + ", " + scale] = cachedVal;
    return cachedVal;
};
var BRp$c = {};
BRp$c.findHaystackPoints = function(edges) {
    for(var i = 0; i < edges.length; i++){
        var edge = edges[i];
        var _p = edge._private;
        var rs = _p.rscratch;
        if (!rs.haystack) {
            var angle = Math.random() * 2 * Math.PI;
            rs.source = {
                x: Math.cos(angle),
                y: Math.sin(angle)
            };
            angle = Math.random() * 2 * Math.PI;
            rs.target = {
                x: Math.cos(angle),
                y: Math.sin(angle)
            };
        }
        var src = _p.source;
        var tgt = _p.target;
        var srcPos = src.position();
        var tgtPos = tgt.position();
        var srcW = src.width();
        var tgtW = tgt.width();
        var srcH = src.height();
        var tgtH = tgt.height();
        var radius = edge.pstyle("haystack-radius").value;
        var halfRadius = radius / 2; // b/c have to half width/height
        rs.haystackPts = rs.allpts = [
            rs.source.x * srcW * halfRadius + srcPos.x,
            rs.source.y * srcH * halfRadius + srcPos.y,
            rs.target.x * tgtW * halfRadius + tgtPos.x,
            rs.target.y * tgtH * halfRadius + tgtPos.y
        ];
        rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
        rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2; // always override as haystack in case set to different type previously
        rs.edgeType = "haystack";
        rs.haystack = true;
        this.storeEdgeProjections(edge);
        this.calculateArrowAngles(edge);
        this.recalculateEdgeLabelProjections(edge);
        this.calculateLabelAngles(edge);
    }
};
BRp$c.findSegmentsPoints = function(edge, pairInfo) {
    // Segments (multiple straight lines)
    var rs = edge._private.rscratch;
    var posPts = pairInfo.posPts, intersectionPts = pairInfo.intersectionPts, vectorNormInverse = pairInfo.vectorNormInverse;
    var edgeDistances = edge.pstyle("edge-distances").value;
    var segmentWs = edge.pstyle("segment-weights");
    var segmentDs = edge.pstyle("segment-distances");
    var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
    rs.edgeType = "segments";
    rs.segpts = [];
    for(var s = 0; s < segmentsN; s++){
        var w = segmentWs.pfValue[s];
        var d = segmentDs.pfValue[s];
        var w1 = 1 - w;
        var w2 = w;
        var midptPts = edgeDistances === "node-position" ? posPts : intersectionPts;
        var adjustedMidpt = {
            x: midptPts.x1 * w1 + midptPts.x2 * w2,
            y: midptPts.y1 * w1 + midptPts.y2 * w2
        };
        rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
    }
};
BRp$c.findLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {
    // Self-edge
    var rs = edge._private.rscratch;
    var dirCounts = pairInfo.dirCounts, srcPos = pairInfo.srcPos;
    var ctrlptDists = edge.pstyle("control-point-distances");
    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
    var loopDir = edge.pstyle("loop-direction").pfValue;
    var loopSwp = edge.pstyle("loop-sweep").pfValue;
    var stepSize = edge.pstyle("control-point-step-size").pfValue;
    rs.edgeType = "self";
    var j = i;
    var loopDist = stepSize;
    if (edgeIsUnbundled) {
        j = 0;
        loopDist = ctrlptDist;
    }
    var loopAngle = loopDir - Math.PI / 2;
    var outAngle = loopAngle - loopSwp / 2;
    var inAngle = loopAngle + loopSwp / 2; // increase by step size for overlapping loops, keyed on direction and sweep values
    var dc = String(loopDir + "_" + loopSwp);
    j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];
    rs.ctrlpts = [
        srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1),
        srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1),
        srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1),
        srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)
    ];
};
BRp$c.findCompoundLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {
    // Compound edge
    var rs = edge._private.rscratch;
    rs.edgeType = "compound";
    var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;
    var stepSize = edge.pstyle("control-point-step-size").pfValue;
    var ctrlptDists = edge.pstyle("control-point-distances");
    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
    var j = i;
    var loopDist = stepSize;
    if (edgeIsUnbundled) {
        j = 0;
        loopDist = ctrlptDist;
    }
    var loopW = 50;
    var loopaPos = {
        x: srcPos.x - srcW / 2,
        y: srcPos.y - srcH / 2
    };
    var loopbPos = {
        x: tgtPos.x - tgtW / 2,
        y: tgtPos.y - tgtH / 2
    };
    var loopPos = {
        x: Math.min(loopaPos.x, loopbPos.x),
        y: Math.min(loopaPos.y, loopbPos.y)
    }; // avoids cases with impossible beziers
    var minCompoundStretch = 0.5;
    var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));
    var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));
    rs.ctrlpts = [
        loopPos.x,
        loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,
        loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,
        loopPos.y
    ];
};
BRp$c.findStraightEdgePoints = function(edge) {
    // Straight edge within bundle
    edge._private.rscratch.edgeType = "straight";
};
BRp$c.findBezierPoints = function(edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {
    var rs = edge._private.rscratch;
    var vectorNormInverse = pairInfo.vectorNormInverse, posPts = pairInfo.posPts, intersectionPts = pairInfo.intersectionPts;
    var edgeDistances = edge.pstyle("edge-distances").value;
    var stepSize = edge.pstyle("control-point-step-size").pfValue;
    var ctrlptDists = edge.pstyle("control-point-distances");
    var ctrlptWs = edge.pstyle("control-point-weights");
    var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
    var ctrlptWeight = ctrlptWs.value[0]; // (Multi)bezier
    var multi = edgeIsUnbundled;
    rs.edgeType = multi ? "multibezier" : "bezier";
    rs.ctrlpts = [];
    for(var b = 0; b < bezierN; b++){
        var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);
        var manctrlptDist = void 0;
        var sign = signum(normctrlptDist);
        if (multi) {
            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size
            ctrlptWeight = ctrlptWs.value[b];
        }
        if (edgeIsUnbundled) // multi or single unbundled
        manctrlptDist = ctrlptDist;
        else manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
        var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;
        var w1 = 1 - ctrlptWeight;
        var w2 = ctrlptWeight;
        var midptPts = edgeDistances === "node-position" ? posPts : intersectionPts;
        var adjustedMidpt = {
            x: midptPts.x1 * w1 + midptPts.x2 * w2,
            y: midptPts.y1 * w1 + midptPts.y2 * w2
        };
        rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
    }
};
BRp$c.findTaxiPoints = function(edge, pairInfo) {
    // Taxicab geometry with two turns maximum
    var rs = edge._private.rscratch;
    rs.edgeType = "segments";
    var VERTICAL = "vertical";
    var HORIZONTAL = "horizontal";
    var LEFTWARD = "leftward";
    var RIGHTWARD = "rightward";
    var DOWNWARD = "downward";
    var UPWARD = "upward";
    var AUTO = "auto";
    var posPts = pairInfo.posPts, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;
    var edgeDistances = edge.pstyle("edge-distances").value;
    var dIncludesNodeBody = edgeDistances !== "node-position";
    var taxiDir = edge.pstyle("taxi-direction").value;
    var rawTaxiDir = taxiDir; // unprocessed value
    var taxiTurn = edge.pstyle("taxi-turn");
    var turnIsPercent = taxiTurn.units === "%";
    var taxiTurnPfVal = taxiTurn.pfValue;
    var turnIsNegative = taxiTurnPfVal < 0; // i.e. from target side
    var minD = edge.pstyle("taxi-turn-min-distance").pfValue;
    var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;
    var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;
    var pdx = posPts.x2 - posPts.x1;
    var pdy = posPts.y2 - posPts.y1; // take away the effective w/h from the magnitude of the delta value
    var subDWH = function subDWH(dxy, dwh) {
        if (dxy > 0) return Math.max(dxy - dwh, 0);
        else return Math.min(dxy + dwh, 0);
    };
    var dx = subDWH(pdx, dw);
    var dy = subDWH(pdy, dh);
    var isExplicitDir = false;
    if (rawTaxiDir === AUTO) taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;
    else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {
        taxiDir = VERTICAL;
        isExplicitDir = true;
    } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {
        taxiDir = HORIZONTAL;
        isExplicitDir = true;
    }
    var isVert = taxiDir === VERTICAL;
    var l = isVert ? dy : dx;
    var pl = isVert ? pdy : pdx;
    var sgnL = signum(pl);
    var forcedDir = false;
    if (!(isExplicitDir && (turnIsPercent || turnIsNegative) // forcing in this case would cause weird growing in the opposite direction
    ) && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {
        sgnL *= -1;
        l = sgnL * Math.abs(l);
        forcedDir = true;
    }
    var d;
    if (turnIsPercent) {
        var p = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;
        d = p * l;
    } else {
        var k = taxiTurnPfVal < 0 ? l : 0;
        d = k + taxiTurnPfVal * sgnL;
    }
    var getIsTooClose = function getIsTooClose(d) {
        return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);
    };
    var isTooCloseSrc = getIsTooClose(d);
    var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));
    var isTooClose = isTooCloseSrc || isTooCloseTgt;
    if (isTooClose && !forcedDir) {
        // non-ideal routing
        if (isVert) {
            // vertical fallbacks
            var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;
            var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;
            if (lShapeInsideSrc) {
                // horizontal Z-shape (direction not respected)
                var x = (posPts.x1 + posPts.x2) / 2;
                var y1 = posPts.y1, y2 = posPts.y2;
                rs.segpts = [
                    x,
                    y1,
                    x,
                    y2
                ];
            } else if (lShapeInsideTgt) {
                // vertical Z-shape (distance not respected)
                var y = (posPts.y1 + posPts.y2) / 2;
                var x1 = posPts.x1, x2 = posPts.x2;
                rs.segpts = [
                    x1,
                    y,
                    x2,
                    y
                ];
            } else // L-shape fallback (turn distance not respected, but works well with tree siblings)
            rs.segpts = [
                posPts.x1,
                posPts.y2
            ];
        } else {
            // horizontal fallbacks
            var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;
            var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;
            if (_lShapeInsideSrc) {
                // vertical Z-shape (direction not respected)
                var _y = (posPts.y1 + posPts.y2) / 2;
                var _x = posPts.x1, _x2 = posPts.x2;
                rs.segpts = [
                    _x,
                    _y,
                    _x2,
                    _y
                ];
            } else if (_lShapeInsideTgt) {
                // horizontal Z-shape (turn distance not respected)
                var _x3 = (posPts.x1 + posPts.x2) / 2;
                var _y2 = posPts.y1, _y3 = posPts.y2;
                rs.segpts = [
                    _x3,
                    _y2,
                    _x3,
                    _y3
                ];
            } else // L-shape (turn distance not respected, but works well for tree siblings)
            rs.segpts = [
                posPts.x2,
                posPts.y1
            ];
        }
    } else // ideal routing
    if (isVert) {
        var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);
        var _x4 = posPts.x1, _x5 = posPts.x2;
        rs.segpts = [
            _x4,
            _y4,
            _x5,
            _y4
        ];
    } else {
        // horizontal
        var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);
        var _y5 = posPts.y1, _y6 = posPts.y2;
        rs.segpts = [
            _x6,
            _y5,
            _x6,
            _y6
        ];
    }
};
BRp$c.tryToCorrectInvalidPoints = function(edge, pairInfo) {
    var rs = edge._private.rscratch; // can only correct beziers for now...
    if (rs.edgeType === "bezier") {
        var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH, srcShape = pairInfo.srcShape, tgtShape = pairInfo.tgtShape;
        var badStart = !number$1(rs.startX) || !number$1(rs.startY);
        var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);
        var badEnd = !number$1(rs.endX) || !number$1(rs.endY);
        var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);
        var minCpADistFactor = 3;
        var arrowW = this.getArrowWidth(edge.pstyle("width").pfValue, edge.pstyle("arrow-scale").value) * this.arrowShapeWidth;
        var minCpADist = minCpADistFactor * arrowW;
        var startACpDist = dist({
            x: rs.ctrlpts[0],
            y: rs.ctrlpts[1]
        }, {
            x: rs.startX,
            y: rs.startY
        });
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = dist({
            x: rs.ctrlpts[0],
            y: rs.ctrlpts[1]
        }, {
            x: rs.endX,
            y: rs.endY
        });
        var closeEndACp = endACpDist < minCpADist;
        var overlapping = false;
        if (badStart || badAStart || closeStartACp) {
            overlapping = true; // project control point along line from src centre to outside the src shape
            // (otherwise intersection will yield nothing)
            var cpD = {
                // delta
                x: rs.ctrlpts[0] - srcPos.x,
                y: rs.ctrlpts[1] - srcPos.y
            };
            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line
            var cpM = {
                // normalised delta
                x: cpD.x / cpL,
                y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = {
                // *2 radius guarantees outside shape
                x: rs.ctrlpts[0] + cpM.x * 2 * radius,
                y: rs.ctrlpts[1] + cpM.y * 2 * radius
            };
            var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);
            if (closeStartACp) {
                rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
                rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
            } else {
                rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
                rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
            }
        }
        if (badEnd || badAEnd || closeEndACp) {
            overlapping = true; // project control point along line from tgt centre to outside the tgt shape
            // (otherwise intersection will yield nothing)
            var _cpD = {
                // delta
                x: rs.ctrlpts[0] - tgtPos.x,
                y: rs.ctrlpts[1] - tgtPos.y
            };
            var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line
            var _cpM = {
                // normalised delta
                x: _cpD.x / _cpL,
                y: _cpD.y / _cpL
            };
            var _radius = Math.max(srcW, srcH);
            var _cpProj = {
                // *2 radius guarantees outside shape
                x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,
                y: rs.ctrlpts[1] + _cpM.y * 2 * _radius
            };
            var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0);
            if (closeEndACp) {
                rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);
                rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);
            } else {
                rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;
                rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;
            }
        }
        if (overlapping) // recalc endpts
        this.findEndpoints(edge);
    }
};
BRp$c.storeAllpts = function(edge) {
    var rs = edge._private.rscratch;
    if (rs.edgeType === "multibezier" || rs.edgeType === "bezier" || rs.edgeType === "self" || rs.edgeType === "compound") {
        rs.allpts = [];
        rs.allpts.push(rs.startX, rs.startY);
        for(var b = 0; b + 1 < rs.ctrlpts.length; b += 2){
            // ctrl pt itself
            rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]); // the midpt between ctrlpts as intermediate destination pts
            if (b + 3 < rs.ctrlpts.length) rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
        }
        rs.allpts.push(rs.endX, rs.endY);
        var m1, mt;
        if (rs.ctrlpts.length / 2 % 2 === 0) {
            m1 = rs.allpts.length / 2 - 1;
            rs.midX = rs.allpts[m1];
            rs.midY = rs.allpts[m1 + 1];
        } else {
            m1 = rs.allpts.length / 2 - 3;
            mt = 0.5;
            rs.midX = qbezierAt(rs.allpts[m1], rs.allpts[m1 + 2], rs.allpts[m1 + 4], mt);
            rs.midY = qbezierAt(rs.allpts[m1 + 1], rs.allpts[m1 + 3], rs.allpts[m1 + 5], mt);
        }
    } else if (rs.edgeType === "straight") {
        // need to calc these after endpts
        rs.allpts = [
            rs.startX,
            rs.startY,
            rs.endX,
            rs.endY
        ]; // default midpt for labels etc
        rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
        rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
    } else if (rs.edgeType === "segments") {
        rs.allpts = [];
        rs.allpts.push(rs.startX, rs.startY);
        rs.allpts.push.apply(rs.allpts, rs.segpts);
        rs.allpts.push(rs.endX, rs.endY);
        if (rs.segpts.length % 4 === 0) {
            var i2 = rs.segpts.length / 2;
            var i1 = i2 - 2;
            rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
            rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
        } else {
            var _i = rs.segpts.length / 2 - 1;
            rs.midX = rs.segpts[_i];
            rs.midY = rs.segpts[_i + 1];
        }
    }
};
BRp$c.checkForInvalidEdgeWarning = function(edge) {
    var rs = edge[0]._private.rscratch;
    if (rs.nodesOverlap || number$1(rs.startX) && number$1(rs.startY) && number$1(rs.endX) && number$1(rs.endY)) rs.loggedErr = false;
    else if (!rs.loggedErr) {
        rs.loggedErr = true;
        warn("Edge `" + edge.id() + "` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.");
    }
};
BRp$c.findEdgeControlPoints = function(edges) {
    var _this = this;
    if (!edges || edges.length === 0) return;
    var r = this;
    var cy = r.cy;
    var hasCompounds = cy.hasCompoundNodes();
    var hashTable = {
        map: new Map$1(),
        get: function get(pairId) {
            var map2 = this.map.get(pairId[0]);
            if (map2 != null) return map2.get(pairId[1]);
            else return null;
        },
        set: function set(pairId, val) {
            var map2 = this.map.get(pairId[0]);
            if (map2 == null) {
                map2 = new Map$1();
                this.map.set(pairId[0], map2);
            }
            map2.set(pairId[1], val);
        }
    };
    var pairIds = [];
    var haystackEdges = []; // create a table of edge (src, tgt) => list of edges between them
    for(var i = 0; i < edges.length; i++){
        var edge = edges[i];
        var _p = edge._private;
        var curveStyle = edge.pstyle("curve-style").value; // ignore edges who are not to be displayed
        // they shouldn't take up space
        if (edge.removed() || !edge.takesUpSpace()) continue;
        if (curveStyle === "haystack") {
            haystackEdges.push(edge);
            continue;
        }
        var edgeIsUnbundled = curveStyle === "unbundled-bezier" || curveStyle === "segments" || curveStyle === "straight" || curveStyle === "straight-triangle" || curveStyle === "taxi";
        var edgeIsBezier = curveStyle === "unbundled-bezier" || curveStyle === "bezier";
        var src = _p.source;
        var tgt = _p.target;
        var srcIndex = src.poolIndex();
        var tgtIndex = tgt.poolIndex();
        var pairId = [
            srcIndex,
            tgtIndex
        ].sort();
        var tableEntry = hashTable.get(pairId);
        if (tableEntry == null) {
            tableEntry = {
                eles: []
            };
            hashTable.set(pairId, tableEntry);
            pairIds.push(pairId);
        }
        tableEntry.eles.push(edge);
        if (edgeIsUnbundled) tableEntry.hasUnbundled = true;
        if (edgeIsBezier) tableEntry.hasBezier = true;
    } // for each pair (src, tgt), create the ctrl pts
    // Nested for loop is OK; total number of iterations for both loops = edgeCount
    var _loop = function _loop(p) {
        var pairId = pairIds[p];
        var pairInfo = hashTable.get(pairId);
        var swappedpairInfo = void 0;
        if (!pairInfo.hasUnbundled) {
            var pllEdges = pairInfo.eles[0].parallelEdges().filter(function(e) {
                return e.isBundledBezier();
            });
            clearArray(pairInfo.eles);
            pllEdges.forEach(function(edge) {
                return pairInfo.eles.push(edge);
            }); // for each pair id, the edges should be sorted by index
            pairInfo.eles.sort(function(edge1, edge2) {
                return edge1.poolIndex() - edge2.poolIndex();
            });
        }
        var firstEdge = pairInfo.eles[0];
        var src = firstEdge.source();
        var tgt = firstEdge.target(); // make sure src/tgt distinction is consistent w.r.t. pairId
        if (src.poolIndex() > tgt.poolIndex()) {
            var temp = src;
            src = tgt;
            tgt = temp;
        }
        var srcPos = pairInfo.srcPos = src.position();
        var tgtPos = pairInfo.tgtPos = tgt.position();
        var srcW = pairInfo.srcW = src.outerWidth();
        var srcH = pairInfo.srcH = src.outerHeight();
        var tgtW = pairInfo.tgtW = tgt.outerWidth();
        var tgtH = pairInfo.tgtH = tgt.outerHeight();
        var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];
        var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];
        pairInfo.dirCounts = {
            "north": 0,
            "west": 0,
            "south": 0,
            "east": 0,
            "northwest": 0,
            "southwest": 0,
            "northeast": 0,
            "southeast": 0
        };
        for(var _i2 = 0; _i2 < pairInfo.eles.length; _i2++){
            var _edge = pairInfo.eles[_i2];
            var rs = _edge[0]._private.rscratch;
            var _curveStyle = _edge.pstyle("curve-style").value;
            var _edgeIsUnbundled = _curveStyle === "unbundled-bezier" || _curveStyle === "segments" || _curveStyle === "taxi"; // whether the normalised pair order is the reverse of the edge's src-tgt order
            var edgeIsSwapped = !src.same(_edge.source());
            if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {
                pairInfo.calculatedIntersection = true; // pt outside src shape to calc distance/displacement from src to tgt
                var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);
                var srcIntn = pairInfo.srcIntn = srcOutside; // pt outside tgt shape to calc distance/displacement from src to tgt
                var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);
                var tgtIntn = pairInfo.tgtIntn = tgtOutside;
                var intersectionPts = pairInfo.intersectionPts = {
                    x1: srcOutside[0],
                    x2: tgtOutside[0],
                    y1: srcOutside[1],
                    y2: tgtOutside[1]
                };
                var posPts = pairInfo.posPts = {
                    x1: srcPos.x,
                    x2: tgtPos.x,
                    y1: srcPos.y,
                    y2: tgtPos.y
                };
                var dy = tgtOutside[1] - srcOutside[1];
                var dx = tgtOutside[0] - srcOutside[0];
                var l = Math.sqrt(dx * dx + dy * dy);
                var vector = pairInfo.vector = {
                    x: dx,
                    y: dy
                };
                var vectorNorm = pairInfo.vectorNorm = {
                    x: vector.x / l,
                    y: vector.y / l
                };
                var vectorNormInverse = {
                    x: -vectorNorm.y,
                    y: vectorNorm.x
                }; // if node shapes overlap, then no ctrl pts to draw
                pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y);
                pairInfo.vectorNormInverse = vectorNormInverse;
                swappedpairInfo = {
                    nodesOverlap: pairInfo.nodesOverlap,
                    dirCounts: pairInfo.dirCounts,
                    calculatedIntersection: true,
                    hasBezier: pairInfo.hasBezier,
                    hasUnbundled: pairInfo.hasUnbundled,
                    eles: pairInfo.eles,
                    srcPos: tgtPos,
                    tgtPos: srcPos,
                    srcW: tgtW,
                    srcH: tgtH,
                    tgtW: srcW,
                    tgtH: srcH,
                    srcIntn: tgtIntn,
                    tgtIntn: srcIntn,
                    srcShape: tgtShape,
                    tgtShape: srcShape,
                    posPts: {
                        x1: posPts.x2,
                        y1: posPts.y2,
                        x2: posPts.x1,
                        y2: posPts.y1
                    },
                    intersectionPts: {
                        x1: intersectionPts.x2,
                        y1: intersectionPts.y2,
                        x2: intersectionPts.x1,
                        y2: intersectionPts.y1
                    },
                    vector: {
                        x: -vector.x,
                        y: -vector.y
                    },
                    vectorNorm: {
                        x: -vectorNorm.x,
                        y: -vectorNorm.y
                    },
                    vectorNormInverse: {
                        x: -vectorNormInverse.x,
                        y: -vectorNormInverse.y
                    }
                };
            }
            var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;
            rs.nodesOverlap = passedPairInfo.nodesOverlap;
            rs.srcIntn = passedPairInfo.srcIntn;
            rs.tgtIntn = passedPairInfo.tgtIntn;
            if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
            else if (src === tgt) _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
            else if (_curveStyle === "segments") _this.findSegmentsPoints(_edge, passedPairInfo);
            else if (_curveStyle === "taxi") _this.findTaxiPoints(_edge, passedPairInfo);
            else if (_curveStyle === "straight" || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) _this.findStraightEdgePoints(_edge);
            else _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);
            _this.findEndpoints(_edge);
            _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);
            _this.checkForInvalidEdgeWarning(_edge);
            _this.storeAllpts(_edge);
            _this.storeEdgeProjections(_edge);
            _this.calculateArrowAngles(_edge);
            _this.recalculateEdgeLabelProjections(_edge);
            _this.calculateLabelAngles(_edge);
        } // for pair edges
    };
    for(var p = 0; p < pairIds.length; p++)_loop(p);
     // for pair ids
    // haystacks avoid the expense of pairInfo stuff (intersections etc.)
    this.findHaystackPoints(haystackEdges);
};
function getPts(pts) {
    var retPts = [];
    if (pts == null) return;
    for(var i = 0; i < pts.length; i += 2){
        var x = pts[i];
        var y = pts[i + 1];
        retPts.push({
            x: x,
            y: y
        });
    }
    return retPts;
}
BRp$c.getSegmentPoints = function(edge) {
    var rs = edge[0]._private.rscratch;
    var type = rs.edgeType;
    if (type === "segments") {
        this.recalculateRenderedStyle(edge);
        return getPts(rs.segpts);
    }
};
BRp$c.getControlPoints = function(edge) {
    var rs = edge[0]._private.rscratch;
    var type = rs.edgeType;
    if (type === "bezier" || type === "multibezier" || type === "self" || type === "compound") {
        this.recalculateRenderedStyle(edge);
        return getPts(rs.ctrlpts);
    }
};
BRp$c.getEdgeMidpoint = function(edge) {
    var rs = edge[0]._private.rscratch;
    this.recalculateRenderedStyle(edge);
    return {
        x: rs.midX,
        y: rs.midY
    };
};
var BRp$b = {};
BRp$b.manualEndptToPx = function(node, prop) {
    var r = this;
    var npos = node.position();
    var w = node.outerWidth();
    var h = node.outerHeight();
    if (prop.value.length === 2) {
        var p = [
            prop.pfValue[0],
            prop.pfValue[1]
        ];
        if (prop.units[0] === "%") p[0] = p[0] * w;
        if (prop.units[1] === "%") p[1] = p[1] * h;
        p[0] += npos.x;
        p[1] += npos.y;
        return p;
    } else {
        var angle = prop.pfValue[0];
        angle = -Math.PI / 2 + angle; // start at 12 o'clock
        var l = 2 * Math.max(w, h);
        var _p = [
            npos.x + Math.cos(angle) * l,
            npos.y + Math.sin(angle) * l
        ];
        return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);
    }
};
BRp$b.findEndpoints = function(edge) {
    var r = this;
    var intersect;
    var source = edge.source()[0];
    var target = edge.target()[0];
    var srcPos = source.position();
    var tgtPos = target.position();
    var tgtArShape = edge.pstyle("target-arrow-shape").value;
    var srcArShape = edge.pstyle("source-arrow-shape").value;
    var tgtDist = edge.pstyle("target-distance-from-node").pfValue;
    var srcDist = edge.pstyle("source-distance-from-node").pfValue;
    var curveStyle = edge.pstyle("curve-style").value;
    var rs = edge._private.rscratch;
    var et = rs.edgeType;
    var taxi = curveStyle === "taxi";
    var self = et === "self" || et === "compound";
    var bezier = et === "bezier" || et === "multibezier" || self;
    var multi = et !== "bezier";
    var lines = et === "straight" || et === "segments";
    var segments = et === "segments";
    var hasEndpts = bezier || multi || lines;
    var overrideEndpts = self || taxi;
    var srcManEndpt = edge.pstyle("source-endpoint");
    var srcManEndptVal = overrideEndpts ? "outside-to-node" : srcManEndpt.value;
    var tgtManEndpt = edge.pstyle("target-endpoint");
    var tgtManEndptVal = overrideEndpts ? "outside-to-node" : tgtManEndpt.value;
    rs.srcManEndpt = srcManEndpt;
    rs.tgtManEndpt = tgtManEndpt;
    var p1; // last known point of edge on target side
    var p2; // last known point of edge on source side
    var p1_i; // point to intersect with target shape
    var p2_i; // point to intersect with source shape
    if (bezier) {
        var cpStart = [
            rs.ctrlpts[0],
            rs.ctrlpts[1]
        ];
        var cpEnd = multi ? [
            rs.ctrlpts[rs.ctrlpts.length - 2],
            rs.ctrlpts[rs.ctrlpts.length - 1]
        ] : cpStart;
        p1 = cpEnd;
        p2 = cpStart;
    } else if (lines) {
        var srcArrowFromPt = !segments ? [
            tgtPos.x,
            tgtPos.y
        ] : rs.segpts.slice(0, 2);
        var tgtArrowFromPt = !segments ? [
            srcPos.x,
            srcPos.y
        ] : rs.segpts.slice(rs.segpts.length - 2);
        p1 = tgtArrowFromPt;
        p2 = srcArrowFromPt;
    }
    if (tgtManEndptVal === "inside-to-node") intersect = [
        tgtPos.x,
        tgtPos.y
    ];
    else if (tgtManEndpt.units) intersect = this.manualEndptToPx(target, tgtManEndpt);
    else if (tgtManEndptVal === "outside-to-line") intersect = rs.tgtIntn; // use cached value from ctrlpt calc
    else {
        if (tgtManEndptVal === "outside-to-node" || tgtManEndptVal === "outside-to-node-or-label") p1_i = p1;
        else if (tgtManEndptVal === "outside-to-line" || tgtManEndptVal === "outside-to-line-or-label") p1_i = [
            srcPos.x,
            srcPos.y
        ];
        intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);
        if (tgtManEndptVal === "outside-to-node-or-label" || tgtManEndptVal === "outside-to-line-or-label") {
            var trs = target._private.rscratch;
            var lw = trs.labelWidth;
            var lh = trs.labelHeight;
            var lx = trs.labelX;
            var ly = trs.labelY;
            var lw2 = lw / 2;
            var lh2 = lh / 2;
            var va = target.pstyle("text-valign").value;
            if (va === "top") ly -= lh2;
            else if (va === "bottom") ly += lh2;
            var ha = target.pstyle("text-halign").value;
            if (ha === "left") lx -= lw2;
            else if (ha === "right") lx += lw2;
            var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [
                lx - lw2,
                ly - lh2,
                lx + lw2,
                ly - lh2,
                lx + lw2,
                ly + lh2,
                lx - lw2,
                ly + lh2
            ], tgtPos.x, tgtPos.y);
            if (labelIntersect.length > 0) {
                var refPt = srcPos;
                var intSqdist = sqdist(refPt, array2point(intersect));
                var labIntSqdist = sqdist(refPt, array2point(labelIntersect));
                var minSqDist = intSqdist;
                if (labIntSqdist < intSqdist) {
                    intersect = labelIntersect;
                    minSqDist = labIntSqdist;
                }
                if (labelIntersect.length > 2) {
                    var labInt2SqDist = sqdist(refPt, {
                        x: labelIntersect[2],
                        y: labelIntersect[3]
                    });
                    if (labInt2SqDist < minSqDist) intersect = [
                        labelIntersect[2],
                        labelIntersect[3]
                    ];
                }
            }
        }
    }
    var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
    var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);
    rs.endX = edgeEnd[0];
    rs.endY = edgeEnd[1];
    rs.arrowEndX = arrowEnd[0];
    rs.arrowEndY = arrowEnd[1];
    if (srcManEndptVal === "inside-to-node") intersect = [
        srcPos.x,
        srcPos.y
    ];
    else if (srcManEndpt.units) intersect = this.manualEndptToPx(source, srcManEndpt);
    else if (srcManEndptVal === "outside-to-line") intersect = rs.srcIntn; // use cached value from ctrlpt calc
    else {
        if (srcManEndptVal === "outside-to-node" || srcManEndptVal === "outside-to-node-or-label") p2_i = p2;
        else if (srcManEndptVal === "outside-to-line" || srcManEndptVal === "outside-to-line-or-label") p2_i = [
            tgtPos.x,
            tgtPos.y
        ];
        intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);
        if (srcManEndptVal === "outside-to-node-or-label" || srcManEndptVal === "outside-to-line-or-label") {
            var srs = source._private.rscratch;
            var _lw = srs.labelWidth;
            var _lh = srs.labelHeight;
            var _lx = srs.labelX;
            var _ly = srs.labelY;
            var _lw2 = _lw / 2;
            var _lh2 = _lh / 2;
            var _va = source.pstyle("text-valign").value;
            if (_va === "top") _ly -= _lh2;
            else if (_va === "bottom") _ly += _lh2;
            var _ha = source.pstyle("text-halign").value;
            if (_ha === "left") _lx -= _lw2;
            else if (_ha === "right") _lx += _lw2;
            var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [
                _lx - _lw2,
                _ly - _lh2,
                _lx + _lw2,
                _ly - _lh2,
                _lx + _lw2,
                _ly + _lh2,
                _lx - _lw2,
                _ly + _lh2
            ], srcPos.x, srcPos.y);
            if (_labelIntersect.length > 0) {
                var _refPt = tgtPos;
                var _intSqdist = sqdist(_refPt, array2point(intersect));
                var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));
                var _minSqDist = _intSqdist;
                if (_labIntSqdist < _intSqdist) {
                    intersect = [
                        _labelIntersect[0],
                        _labelIntersect[1]
                    ];
                    _minSqDist = _labIntSqdist;
                }
                if (_labelIntersect.length > 2) {
                    var _labInt2SqDist = sqdist(_refPt, {
                        x: _labelIntersect[2],
                        y: _labelIntersect[3]
                    });
                    if (_labInt2SqDist < _minSqDist) intersect = [
                        _labelIntersect[2],
                        _labelIntersect[3]
                    ];
                }
            }
        }
    }
    var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);
    var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);
    rs.startX = edgeStart[0];
    rs.startY = edgeStart[1];
    rs.arrowStartX = arrowStart[0];
    rs.arrowStartY = arrowStart[1];
    if (hasEndpts) {
        if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) rs.badLine = true;
        else rs.badLine = false;
    }
};
BRp$b.getSourceEndpoint = function(edge) {
    var rs = edge[0]._private.rscratch;
    this.recalculateRenderedStyle(edge);
    switch(rs.edgeType){
        case "haystack":
            return {
                x: rs.haystackPts[0],
                y: rs.haystackPts[1]
            };
        default:
            return {
                x: rs.arrowStartX,
                y: rs.arrowStartY
            };
    }
};
BRp$b.getTargetEndpoint = function(edge) {
    var rs = edge[0]._private.rscratch;
    this.recalculateRenderedStyle(edge);
    switch(rs.edgeType){
        case "haystack":
            return {
                x: rs.haystackPts[2],
                y: rs.haystackPts[3]
            };
        default:
            return {
                x: rs.arrowEndX,
                y: rs.arrowEndY
            };
    }
};
var BRp$a = {};
function pushBezierPts(r, edge, pts) {
    var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {
        return qbezierAt(p1, p2, p3, t);
    };
    var _p = edge._private;
    var bpts = _p.rstyle.bezierPts;
    for(var i = 0; i < r.bezierProjPcts.length; i++){
        var p = r.bezierProjPcts[i];
        bpts.push({
            x: qbezierAt$1(pts[0], pts[2], pts[4], p),
            y: qbezierAt$1(pts[1], pts[3], pts[5], p)
        });
    }
}
BRp$a.storeEdgeProjections = function(edge) {
    var _p = edge._private;
    var rs = _p.rscratch;
    var et = rs.edgeType; // clear the cached points state
    _p.rstyle.bezierPts = null;
    _p.rstyle.linePts = null;
    _p.rstyle.haystackPts = null;
    if (et === "multibezier" || et === "bezier" || et === "self" || et === "compound") {
        _p.rstyle.bezierPts = [];
        for(var i = 0; i + 5 < rs.allpts.length; i += 4)pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
    } else if (et === "segments") {
        var lpts = _p.rstyle.linePts = [];
        for(var i = 0; i + 1 < rs.allpts.length; i += 2)lpts.push({
            x: rs.allpts[i],
            y: rs.allpts[i + 1]
        });
    } else if (et === "haystack") {
        var hpts = rs.haystackPts;
        _p.rstyle.haystackPts = [
            {
                x: hpts[0],
                y: hpts[1]
            },
            {
                x: hpts[2],
                y: hpts[3]
            }
        ];
    }
    _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle("width").pfValue, edge.pstyle("arrow-scale").value) * this.arrowShapeWidth;
};
BRp$a.recalculateEdgeProjections = function(edges) {
    this.findEdgeControlPoints(edges);
};
/* global document */ var BRp$9 = {};
BRp$9.recalculateNodeLabelProjection = function(node) {
    var content = node.pstyle("label").strValue;
    if (emptyString(content)) return;
    var textX, textY;
    var _p = node._private;
    var nodeWidth = node.width();
    var nodeHeight = node.height();
    var padding = node.padding();
    var nodePos = node.position();
    var textHalign = node.pstyle("text-halign").strValue;
    var textValign = node.pstyle("text-valign").strValue;
    var rs = _p.rscratch;
    var rstyle = _p.rstyle;
    switch(textHalign){
        case "left":
            textX = nodePos.x - nodeWidth / 2 - padding;
            break;
        case "right":
            textX = nodePos.x + nodeWidth / 2 + padding;
            break;
        default:
            // e.g. center
            textX = nodePos.x;
    }
    switch(textValign){
        case "top":
            textY = nodePos.y - nodeHeight / 2 - padding;
            break;
        case "bottom":
            textY = nodePos.y + nodeHeight / 2 + padding;
            break;
        default:
            // e.g. middle
            textY = nodePos.y;
    }
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;
    this.calculateLabelAngles(node);
    this.applyLabelDimensions(node);
};
var lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {
    var angle = Math.atan(dy / dx);
    if (dx === 0 && angle < 0) angle = angle * -1;
    return angle;
};
var lineAngle = function lineAngle(p0, p1) {
    var dx = p1.x - p0.x;
    var dy = p1.y - p0.y;
    return lineAngleFromDelta(dx, dy);
};
var bezierAngle = function bezierAngle(p0, p1, p2, t) {
    var t0 = bound(0, t - 0.001, 1);
    var t1 = bound(0, t + 0.001, 1);
    var lp0 = qbezierPtAt(p0, p1, p2, t0);
    var lp1 = qbezierPtAt(p0, p1, p2, t1);
    return lineAngle(lp0, lp1);
};
BRp$9.recalculateEdgeLabelProjections = function(edge) {
    var p;
    var _p = edge._private;
    var rs = _p.rscratch;
    var r = this;
    var content = {
        mid: edge.pstyle("label").strValue,
        source: edge.pstyle("source-label").strValue,
        target: edge.pstyle("target-label").strValue
    };
    if (content.mid || content.source || content.target) ;
    else return; // no labels => no calcs
     // add center point to style so bounding box calculations can use it
    //
    p = {
        x: rs.midX,
        y: rs.midY
    };
    var setRs = function setRs(propName, prefix, value) {
        setPrefixedProperty(_p.rscratch, propName, prefix, value);
        setPrefixedProperty(_p.rstyle, propName, prefix, value);
    };
    setRs("labelX", null, p.x);
    setRs("labelY", null, p.y);
    var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);
    setRs("labelAutoAngle", null, midAngle);
    var createControlPointInfo = function createControlPointInfo() {
        if (createControlPointInfo.cache) return createControlPointInfo.cache;
         // use cache so only 1x per edge
        var ctrlpts = []; // store each ctrlpt info init
        for(var i = 0; i + 5 < rs.allpts.length; i += 4){
            var p0 = {
                x: rs.allpts[i],
                y: rs.allpts[i + 1]
            };
            var p1 = {
                x: rs.allpts[i + 2],
                y: rs.allpts[i + 3]
            }; // ctrlpt
            var p2 = {
                x: rs.allpts[i + 4],
                y: rs.allpts[i + 5]
            };
            ctrlpts.push({
                p0: p0,
                p1: p1,
                p2: p2,
                startDist: 0,
                length: 0,
                segments: []
            });
        }
        var bpts = _p.rstyle.bezierPts;
        var nProjs = r.bezierProjPcts.length;
        function addSegment(cp, p0, p1, t0, t1) {
            var length = dist(p0, p1);
            var prevSegment = cp.segments[cp.segments.length - 1];
            var segment = {
                p0: p0,
                p1: p1,
                t0: t0,
                t1: t1,
                startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
                length: length
            };
            cp.segments.push(segment);
            cp.length += length;
        } // update each ctrlpt with segment info
        for(var _i = 0; _i < ctrlpts.length; _i++){
            var cp = ctrlpts[_i];
            var prevCp = ctrlpts[_i - 1];
            if (prevCp) cp.startDist = prevCp.startDist + prevCp.length;
            addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first
            for(var j = 0; j < nProjs - 1; j++)addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);
            addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last
        }
        return createControlPointInfo.cache = ctrlpts;
    };
    var calculateEndProjection = function calculateEndProjection(prefix) {
        var angle;
        var isSrc = prefix === "source";
        if (!content[prefix]) return;
        var offset = edge.pstyle(prefix + "-text-offset").pfValue;
        switch(rs.edgeType){
            case "self":
            case "compound":
            case "bezier":
            case "multibezier":
                var cps = createControlPointInfo();
                var selected;
                var startDist = 0;
                var totalDist = 0; // find the segment we're on
                for(var i = 0; i < cps.length; i++){
                    var _cp = cps[isSrc ? i : cps.length - 1 - i];
                    for(var j = 0; j < _cp.segments.length; j++){
                        var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];
                        var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;
                        startDist = totalDist;
                        totalDist += _seg.length;
                        if (totalDist >= offset || lastSeg) {
                            selected = {
                                cp: _cp,
                                segment: _seg
                            };
                            break;
                        }
                    }
                    if (selected) break;
                }
                var cp = selected.cp;
                var seg = selected.segment;
                var tSegment = (offset - startDist) / seg.length;
                var segDt = seg.t1 - seg.t0;
                var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;
                t = bound(0, t, 1);
                p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
                angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);
                break;
            case "straight":
            case "segments":
            case "haystack":
                var d = 0, di, d0;
                var p0, p1;
                var l = rs.allpts.length;
                for(var _i2 = 0; _i2 + 3 < l; _i2 += 2){
                    if (isSrc) {
                        p0 = {
                            x: rs.allpts[_i2],
                            y: rs.allpts[_i2 + 1]
                        };
                        p1 = {
                            x: rs.allpts[_i2 + 2],
                            y: rs.allpts[_i2 + 3]
                        };
                    } else {
                        p0 = {
                            x: rs.allpts[l - 2 - _i2],
                            y: rs.allpts[l - 1 - _i2]
                        };
                        p1 = {
                            x: rs.allpts[l - 4 - _i2],
                            y: rs.allpts[l - 3 - _i2]
                        };
                    }
                    di = dist(p0, p1);
                    d0 = d;
                    d += di;
                    if (d >= offset) break;
                }
                var pD = offset - d0;
                var _t = pD / di;
                _t = bound(0, _t, 1);
                p = lineAt(p0, p1, _t);
                angle = lineAngle(p0, p1);
                break;
        }
        setRs("labelX", prefix, p.x);
        setRs("labelY", prefix, p.y);
        setRs("labelAutoAngle", prefix, angle);
    };
    calculateEndProjection("source");
    calculateEndProjection("target");
    this.applyLabelDimensions(edge);
};
BRp$9.applyLabelDimensions = function(ele) {
    this.applyPrefixedLabelDimensions(ele);
    if (ele.isEdge()) {
        this.applyPrefixedLabelDimensions(ele, "source");
        this.applyPrefixedLabelDimensions(ele, "target");
    }
};
BRp$9.applyPrefixedLabelDimensions = function(ele, prefix) {
    var _p = ele._private;
    var text = this.getLabelText(ele, prefix);
    var labelDims = this.calculateLabelDimensions(ele, text);
    var lineHeight = ele.pstyle("line-height").pfValue;
    var textWrap = ele.pstyle("text-wrap").strValue;
    var lines = getPrefixedProperty(_p.rscratch, "labelWrapCachedLines", prefix) || [];
    var numLines = textWrap !== "wrap" ? 1 : Math.max(lines.length, 1);
    var normPerLineHeight = labelDims.height / numLines;
    var labelLineHeight = normPerLineHeight * lineHeight;
    var width = labelDims.width;
    var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;
    setPrefixedProperty(_p.rstyle, "labelWidth", prefix, width);
    setPrefixedProperty(_p.rscratch, "labelWidth", prefix, width);
    setPrefixedProperty(_p.rstyle, "labelHeight", prefix, height);
    setPrefixedProperty(_p.rscratch, "labelHeight", prefix, height);
    setPrefixedProperty(_p.rscratch, "labelLineHeight", prefix, labelLineHeight);
};
BRp$9.getLabelText = function(ele, prefix) {
    var _p = ele._private;
    var pfd = prefix ? prefix + "-" : "";
    var text = ele.pstyle(pfd + "label").strValue;
    var textTransform = ele.pstyle("text-transform").value;
    var rscratch = function rscratch(propName, value) {
        if (value) {
            setPrefixedProperty(_p.rscratch, propName, prefix, value);
            return value;
        } else return getPrefixedProperty(_p.rscratch, propName, prefix);
    }; // for empty text, skip all processing
    if (!text) return "";
    if (textTransform == "none") ;
    else if (textTransform == "uppercase") text = text.toUpperCase();
    else if (textTransform == "lowercase") text = text.toLowerCase();
    var wrapStyle = ele.pstyle("text-wrap").value;
    if (wrapStyle === "wrap") {
        var labelKey = rscratch("labelKey"); // save recalc if the label is the same as before
        if (labelKey != null && rscratch("labelWrapKey") === labelKey) return rscratch("labelWrapCachedText");
        var zwsp = "‚Äã";
        var lines = text.split("\n");
        var maxW = ele.pstyle("text-max-width").pfValue;
        var overflow = ele.pstyle("text-overflow-wrap").value;
        var overflowAny = overflow === "anywhere";
        var wrappedLines = [];
        var wordsRegex = /[\s\u200b]+/;
        var wordSeparator = overflowAny ? "" : " ";
        for(var l = 0; l < lines.length; l++){
            var line = lines[l];
            var lineDims = this.calculateLabelDimensions(ele, line);
            var lineW = lineDims.width;
            if (overflowAny) {
                var processedLine = line.split("").join(zwsp);
                line = processedLine;
            }
            if (lineW > maxW) {
                // line is too long
                var words = line.split(wordsRegex);
                var subline = "";
                for(var w = 0; w < words.length; w++){
                    var word = words[w];
                    var testLine = subline.length === 0 ? word : subline + wordSeparator + word;
                    var testDims = this.calculateLabelDimensions(ele, testLine);
                    var testW = testDims.width;
                    if (testW <= maxW) // word fits on current line
                    subline += word + wordSeparator;
                    else {
                        // word starts new line
                        if (subline) wrappedLines.push(subline);
                        subline = word + wordSeparator;
                    }
                } // if there's remaining text, put it in a wrapped line
                if (!subline.match(/^[\s\u200b]+$/)) wrappedLines.push(subline);
            } else // line is already short enough
            wrappedLines.push(line);
        } // for
        rscratch("labelWrapCachedLines", wrappedLines);
        text = rscratch("labelWrapCachedText", wrappedLines.join("\n"));
        rscratch("labelWrapKey", labelKey);
    } else if (wrapStyle === "ellipsis") {
        var _maxW = ele.pstyle("text-max-width").pfValue;
        var ellipsized = "";
        var ellipsis = "‚Ä¶";
        var incLastCh = false;
        if (this.calculateLabelDimensions(ele, text).width < _maxW) // the label already fits
        return text;
        for(var i = 0; i < text.length; i++){
            var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;
            if (widthWithNextCh > _maxW) break;
            ellipsized += text[i];
            if (i === text.length - 1) incLastCh = true;
        }
        if (!incLastCh) ellipsized += ellipsis;
        return ellipsized;
    } // if ellipsize
    return text;
};
BRp$9.getLabelJustification = function(ele) {
    var justification = ele.pstyle("text-justification").strValue;
    var textHalign = ele.pstyle("text-halign").strValue;
    if (justification === "auto") {
        if (ele.isNode()) switch(textHalign){
            case "left":
                return "right";
            case "right":
                return "left";
            default:
                return "center";
        }
        else return "center";
    } else return justification;
};
BRp$9.calculateLabelDimensions = function(ele, text) {
    var r = this;
    var cacheKey = hashString(text, ele._private.labelDimsKey);
    var cache = r.labelDimCache || (r.labelDimCache = []);
    var existingVal = cache[cacheKey];
    if (existingVal != null) return existingVal;
    var padding = 0; // add padding around text dims, as the measurement isn't that accurate
    var fStyle = ele.pstyle("font-style").strValue;
    var size = ele.pstyle("font-size").pfValue;
    var family = ele.pstyle("font-family").strValue;
    var weight = ele.pstyle("font-weight").strValue;
    var canvas = this.labelCalcCanvas;
    var c2d = this.labelCalcCanvasContext;
    if (!canvas) {
        canvas = this.labelCalcCanvas = document.createElement("canvas");
        c2d = this.labelCalcCanvasContext = canvas.getContext("2d");
        var ds = canvas.style;
        ds.position = "absolute";
        ds.left = "-9999px";
        ds.top = "-9999px";
        ds.zIndex = "-1";
        ds.visibility = "hidden";
        ds.pointerEvents = "none";
    }
    c2d.font = "".concat(fStyle, " ").concat(weight, " ").concat(size, "px ").concat(family);
    var width = 0;
    var height = 0;
    var lines = text.split("\n");
    for(var i = 0; i < lines.length; i++){
        var line = lines[i];
        var metrics = c2d.measureText(line);
        var w = Math.ceil(metrics.width);
        var h = size;
        width = Math.max(w, width);
        height += h;
    }
    width += padding;
    height += padding;
    return cache[cacheKey] = {
        width: width,
        height: height
    };
};
BRp$9.calculateLabelAngle = function(ele, prefix) {
    var _p = ele._private;
    var rs = _p.rscratch;
    var isEdge = ele.isEdge();
    var prefixDash = prefix ? prefix + "-" : "";
    var rot = ele.pstyle(prefixDash + "text-rotation");
    var rotStr = rot.strValue;
    if (rotStr === "none") return 0;
    else if (isEdge && rotStr === "autorotate") return rs.labelAutoAngle;
    else if (rotStr === "autorotate") return 0;
    else return rot.pfValue;
};
BRp$9.calculateLabelAngles = function(ele) {
    var r = this;
    var isEdge = ele.isEdge();
    var _p = ele._private;
    var rs = _p.rscratch;
    rs.labelAngle = r.calculateLabelAngle(ele);
    if (isEdge) {
        rs.sourceLabelAngle = r.calculateLabelAngle(ele, "source");
        rs.targetLabelAngle = r.calculateLabelAngle(ele, "target");
    }
};
var BRp$8 = {};
var TOO_SMALL_CUT_RECT = 28;
var warnedCutRect = false;
BRp$8.getNodeShape = function(node) {
    var r = this;
    var shape = node.pstyle("shape").value;
    if (shape === "cutrectangle" && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {
        if (!warnedCutRect) {
            warn("The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead");
            warnedCutRect = true;
        }
        return "rectangle";
    }
    if (node.isParent()) {
        if (shape === "rectangle" || shape === "roundrectangle" || shape === "round-rectangle" || shape === "cutrectangle" || shape === "cut-rectangle" || shape === "barrel") return shape;
        else return "rectangle";
    }
    if (shape === "polygon") {
        var points = node.pstyle("shape-polygon-points").value;
        return r.nodeShapes.makePolygon(points).name;
    }
    return shape;
};
var BRp$7 = {};
BRp$7.registerCalculationListeners = function() {
    var cy = this.cy;
    var elesToUpdate = cy.collection();
    var r = this;
    var enqueue = function enqueue(eles) {
        var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        elesToUpdate.merge(eles);
        if (dirtyStyleCaches) for(var i = 0; i < eles.length; i++){
            var ele = eles[i];
            var _p = ele._private;
            var rstyle = _p.rstyle;
            rstyle.clean = false;
            rstyle.cleanConnected = false;
        }
    };
    r.binder(cy).on("bounds.* dirty.*", function onDirtyBounds(e) {
        var ele = e.target;
        enqueue(ele);
    }).on("style.* background.*", function onDirtyStyle(e) {
        var ele = e.target;
        enqueue(ele, false);
    });
    var updateEleCalcs = function updateEleCalcs(willDraw) {
        if (willDraw) {
            var fns = r.onUpdateEleCalcsFns; // because we need to have up-to-date style (e.g. stylesheet mappers)
            // before calculating rendered style (and pstyle might not be called yet)
            elesToUpdate.cleanStyle();
            for(var i = 0; i < elesToUpdate.length; i++){
                var ele = elesToUpdate[i];
                var rstyle = ele._private.rstyle;
                if (ele.isNode() && !rstyle.cleanConnected) {
                    enqueue(ele.connectedEdges());
                    rstyle.cleanConnected = true;
                }
            }
            if (fns) for(var _i = 0; _i < fns.length; _i++){
                var fn = fns[_i];
                fn(willDraw, elesToUpdate);
            }
            r.recalculateRenderedStyle(elesToUpdate);
            elesToUpdate = cy.collection();
        }
    };
    r.flushRenderedStyleQueue = function() {
        updateEleCalcs(true);
    };
    r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);
};
BRp$7.onUpdateEleCalcs = function(fn) {
    var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];
    fns.push(fn);
};
BRp$7.recalculateRenderedStyle = function(eles, useCache) {
    var isCleanConnected = function isCleanConnected(ele) {
        return ele._private.rstyle.cleanConnected;
    };
    var edges = [];
    var nodes = []; // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()
    if (this.destroyed) return;
     // use cache by default for perf
    if (useCache === undefined) useCache = true;
    for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        var _p = ele._private;
        var rstyle = _p.rstyle; // an edge may be implicitly dirty b/c of one of its connected nodes
        // (and a request for recalc may come in between frames)
        if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) rstyle.clean = false;
         // only update if dirty and in graph
        if (useCache && rstyle.clean || ele.removed()) continue;
         // only update if not display: none
        if (ele.pstyle("display").value === "none") continue;
        if (_p.group === "nodes") nodes.push(ele);
        else // edges
        edges.push(ele);
        rstyle.clean = true;
    } // update node data from projections
    for(var _i2 = 0; _i2 < nodes.length; _i2++){
        var _ele = nodes[_i2];
        var _p2 = _ele._private;
        var _rstyle = _p2.rstyle;
        var pos = _ele.position();
        this.recalculateNodeLabelProjection(_ele);
        _rstyle.nodeX = pos.x;
        _rstyle.nodeY = pos.y;
        _rstyle.nodeW = _ele.pstyle("width").pfValue;
        _rstyle.nodeH = _ele.pstyle("height").pfValue;
    }
    this.recalculateEdgeProjections(edges); // update edge data from projections
    for(var _i3 = 0; _i3 < edges.length; _i3++){
        var _ele2 = edges[_i3];
        var _p3 = _ele2._private;
        var _rstyle2 = _p3.rstyle;
        var rs = _p3.rscratch; // update rstyle positions
        _rstyle2.srcX = rs.arrowStartX;
        _rstyle2.srcY = rs.arrowStartY;
        _rstyle2.tgtX = rs.arrowEndX;
        _rstyle2.tgtY = rs.arrowEndY;
        _rstyle2.midX = rs.midX;
        _rstyle2.midY = rs.midY;
        _rstyle2.labelAngle = rs.labelAngle;
        _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;
        _rstyle2.targetLabelAngle = rs.targetLabelAngle;
    }
};
var BRp$6 = {};
BRp$6.updateCachedGrabbedEles = function() {
    var eles = this.cachedZSortedEles;
    if (!eles) // just let this be recalculated on the next z sort tick
    return;
    eles.drag = [];
    eles.nondrag = [];
    var grabTargets = [];
    for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        var rs = ele._private.rscratch;
        if (ele.grabbed() && !ele.isParent()) grabTargets.push(ele);
        else if (rs.inDragLayer) eles.drag.push(ele);
        else eles.nondrag.push(ele);
    } // put the grab target nodes last so it's on top of its neighbourhood
    for(var i = 0; i < grabTargets.length; i++){
        var ele = grabTargets[i];
        eles.drag.push(ele);
    }
};
BRp$6.invalidateCachedZSortedEles = function() {
    this.cachedZSortedEles = null;
};
BRp$6.getCachedZSortedEles = function(forceRecalc) {
    if (forceRecalc || !this.cachedZSortedEles) {
        var eles = this.cy.mutableElements().toArray();
        eles.sort(zIndexSort);
        eles.interactive = eles.filter(function(ele) {
            return ele.interactive();
        });
        this.cachedZSortedEles = eles;
        this.updateCachedGrabbedEles();
    } else eles = this.cachedZSortedEles;
    return eles;
};
var BRp$5 = {};
[
    BRp$e,
    BRp$d,
    BRp$c,
    BRp$b,
    BRp$a,
    BRp$9,
    BRp$8,
    BRp$7,
    BRp$6
].forEach(function(props) {
    extend(BRp$5, props);
});
var BRp$4 = {};
BRp$4.getCachedImage = function(url, crossOrigin, onLoad) {
    var r = this;
    var imageCache = r.imageCache = r.imageCache || {};
    var cache = imageCache[url];
    if (cache) {
        if (!cache.image.complete) cache.image.addEventListener("load", onLoad);
        return cache.image;
    } else {
        cache = imageCache[url] = imageCache[url] || {};
        var image = cache.image = new Image(); // eslint-disable-line no-undef
        image.addEventListener("load", onLoad);
        image.addEventListener("error", function() {
            image.error = true;
        }); // #1582 safari doesn't load data uris with crossOrigin properly
        // https://bugs.webkit.org/show_bug.cgi?id=123978
        var dataUriPrefix = "data:";
        var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;
        if (!isDataUri) image.crossOrigin = crossOrigin; // prevent tainted canvas
        image.src = url;
        return image;
    }
};
var BRp$3 = {};
/* global document, window, ResizeObserver, MutationObserver */ BRp$3.registerBinding = function(target, event, handler, useCapture) {
    // eslint-disable-line no-unused-vars
    var args = Array.prototype.slice.apply(arguments, [
        1
    ]); // copy
    var b = this.binder(target);
    return b.on.apply(b, args);
};
BRp$3.binder = function(tgt) {
    var r = this;
    var tgtIsDom = tgt === window || tgt === document || tgt === document.body || domElement(tgt);
    if (r.supportsPassiveEvents == null) {
        // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
        var supportsPassive = false;
        try {
            var opts = Object.defineProperty({}, "passive", {
                get: function get() {
                    supportsPassive = true;
                    return true;
                }
            });
            window.addEventListener("test", null, opts);
        } catch (err) {}
        r.supportsPassiveEvents = supportsPassive;
    }
    var on = function on(event, handler, useCapture) {
        var args = Array.prototype.slice.call(arguments);
        if (tgtIsDom && r.supportsPassiveEvents) // replace useCapture w/ opts obj
        args[2] = {
            capture: useCapture != null ? useCapture : false,
            passive: false,
            once: false
        };
        r.bindings.push({
            target: tgt,
            args: args
        });
        (tgt.addEventListener || tgt.on).apply(tgt, args);
        return this;
    };
    return {
        on: on,
        addEventListener: on,
        addListener: on,
        bind: on
    };
};
BRp$3.nodeIsDraggable = function(node) {
    return node && node.isNode() && !node.locked() && node.grabbable();
};
BRp$3.nodeIsGrabbable = function(node) {
    return this.nodeIsDraggable(node) && node.interactive();
};
BRp$3.load = function() {
    var r = this;
    var isSelected = function isSelected(ele) {
        return ele.selected();
    };
    var triggerEvents = function triggerEvents(target, names, e, position) {
        if (target == null) target = r.cy;
        for(var i = 0; i < names.length; i++){
            var name = names[i];
            target.emit({
                originalEvent: e,
                type: name,
                position: position
            });
        }
    };
    var isMultSelKeyDown = function isMultSelKeyDown(e) {
        return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
    };
    var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {
        var allowPassthrough = true;
        if (r.cy.hasCompoundNodes() && down && down.pannable()) // a grabbable compound node below the ele => no passthrough panning
        for(var i = 0; downs && i < downs.length; i++){
            var down = downs[i]; //if any parent node in event hierarchy isn't pannable, reject passthrough
            if (down.isNode() && down.isParent() && !down.pannable()) {
                allowPassthrough = false;
                break;
            }
        }
        else allowPassthrough = true;
        return allowPassthrough;
    };
    var setGrabbed = function setGrabbed(ele) {
        ele[0]._private.grabbed = true;
    };
    var setFreed = function setFreed(ele) {
        ele[0]._private.grabbed = false;
    };
    var setInDragLayer = function setInDragLayer(ele) {
        ele[0]._private.rscratch.inDragLayer = true;
    };
    var setOutDragLayer = function setOutDragLayer(ele) {
        ele[0]._private.rscratch.inDragLayer = false;
    };
    var setGrabTarget = function setGrabTarget(ele) {
        ele[0]._private.rscratch.isGrabTarget = true;
    };
    var removeGrabTarget = function removeGrabTarget(ele) {
        ele[0]._private.rscratch.isGrabTarget = false;
    };
    var addToDragList = function addToDragList(ele, opts) {
        var list = opts.addToList;
        var listHasEle = list.has(ele);
        if (!listHasEle && ele.grabbable() && !ele.locked()) {
            list.merge(ele);
            setGrabbed(ele);
        }
    }; // helper function to determine which child nodes and inner edges
    // of a compound node to be dragged as well as the grabbed and selected nodes
    var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {
        if (!node.cy().hasCompoundNodes()) return;
        if (opts.inDragLayer == null && opts.addToList == null) return;
         // nothing to do
        var innerNodes = node.descendants();
        if (opts.inDragLayer) {
            innerNodes.forEach(setInDragLayer);
            innerNodes.connectedEdges().forEach(setInDragLayer);
        }
        if (opts.addToList) addToDragList(innerNodes, opts);
    }; // adds the given nodes and its neighbourhood to the drag layer
    var addNodesToDrag = function addNodesToDrag(nodes, opts) {
        opts = opts || {};
        var hasCompoundNodes = nodes.cy().hasCompoundNodes();
        if (opts.inDragLayer) {
            nodes.forEach(setInDragLayer);
            nodes.neighborhood().stdFilter(function(ele) {
                return !hasCompoundNodes || ele.isEdge();
            }).forEach(setInDragLayer);
        }
        if (opts.addToList) nodes.forEach(function(ele) {
            addToDragList(ele, opts);
        });
        addDescendantsToDrag(nodes, opts); // always add to drag
        // also add nodes and edges related to the topmost ancestor
        updateAncestorsInDragLayer(nodes, {
            inDragLayer: opts.inDragLayer
        });
        r.updateCachedGrabbedEles();
    };
    var addNodeToDrag = addNodesToDrag;
    var freeDraggedElements = function freeDraggedElements(grabbedEles) {
        if (!grabbedEles) return;
         // just go over all elements rather than doing a bunch of (possibly expensive) traversals
        r.getCachedZSortedEles().forEach(function(ele) {
            setFreed(ele);
            setOutDragLayer(ele);
            removeGrabTarget(ele);
        });
        r.updateCachedGrabbedEles();
    }; // helper function to determine which ancestor nodes and edges should go
    // to the drag layer (or should be removed from drag layer).
    var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {
        if (opts.inDragLayer == null && opts.addToList == null) return;
         // nothing to do
        if (!node.cy().hasCompoundNodes()) return;
         // find top-level parent
        var parent = node.ancestors().orphans(); // no parent node: no nodes to add to the drag layer
        if (parent.same(node)) return;
        var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());
        var edges = nodes.connectedEdges();
        if (opts.inDragLayer) {
            edges.forEach(setInDragLayer);
            nodes.forEach(setInDragLayer);
        }
        if (opts.addToList) nodes.forEach(function(ele) {
            addToDragList(ele, opts);
        });
    };
    var blurActiveDomElement = function blurActiveDomElement() {
        if (document.activeElement != null && document.activeElement.blur != null) document.activeElement.blur();
    };
    var haveMutationsApi = typeof MutationObserver !== "undefined";
    var haveResizeObserverApi = typeof ResizeObserver !== "undefined"; // watch for when the cy container is removed from the dom
    if (haveMutationsApi) {
        r.removeObserver = new MutationObserver(function(mutns) {
            // eslint-disable-line no-undef
            for(var i = 0; i < mutns.length; i++){
                var mutn = mutns[i];
                var rNodes = mutn.removedNodes;
                if (rNodes) for(var j = 0; j < rNodes.length; j++){
                    var rNode = rNodes[j];
                    if (rNode === r.container) {
                        r.destroy();
                        break;
                    }
                }
            }
        });
        if (r.container.parentNode) r.removeObserver.observe(r.container.parentNode, {
            childList: true
        });
    } else r.registerBinding(r.container, "DOMNodeRemoved", function(e) {
        // eslint-disable-line no-unused-vars
        r.destroy();
    });
    var onResize = debounce__default["default"](function() {
        r.cy.resize();
    }, 100);
    if (haveMutationsApi) {
        r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef
        r.styleObserver.observe(r.container, {
            attributes: true
        });
    } // auto resize
    r.registerBinding(window, "resize", onResize); // eslint-disable-line no-undef
    if (haveResizeObserverApi) {
        r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef
        r.resizeObserver.observe(r.container);
    }
    var forEachUp = function forEachUp(domEle, fn) {
        while(domEle != null){
            fn(domEle);
            domEle = domEle.parentNode;
        }
    };
    var invalidateCoords = function invalidateCoords() {
        r.invalidateContainerClientCoordsCache();
    };
    forEachUp(r.container, function(domEle) {
        r.registerBinding(domEle, "transitionend", invalidateCoords);
        r.registerBinding(domEle, "animationend", invalidateCoords);
        r.registerBinding(domEle, "scroll", invalidateCoords);
    }); // stop right click menu from appearing on cy
    r.registerBinding(r.container, "contextmenu", function(e) {
        e.preventDefault();
    });
    var inBoxSelection = function inBoxSelection() {
        return r.selection[4] !== 0;
    };
    var eventInContainer = function eventInContainer(e) {
        // save cycles if mouse events aren't to be captured
        var containerPageCoords = r.findContainerClientCoords();
        var x = containerPageCoords[0];
        var y = containerPageCoords[1];
        var width = containerPageCoords[2];
        var height = containerPageCoords[3];
        var positions = e.touches ? e.touches : [
            e
        ];
        var atLeastOnePosInside = false;
        for(var i = 0; i < positions.length; i++){
            var p = positions[i];
            if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {
                atLeastOnePosInside = true;
                break;
            }
        }
        if (!atLeastOnePosInside) return false;
        var container = r.container;
        var target = e.target;
        var tParent = target.parentNode;
        var containerIsTarget = false;
        while(tParent){
            if (tParent === container) {
                containerIsTarget = true;
                break;
            }
            tParent = tParent.parentNode;
        }
        if (!containerIsTarget) return false;
         // if target is outisde cy container, then this event is not for us
        return true;
    }; // Primary key
    r.registerBinding(r.container, "mousedown", function mousedownHandler(e) {
        if (!eventInContainer(e)) return;
        e.preventDefault();
        blurActiveDomElement();
        r.hoverData.capture = true;
        r.hoverData.which = e.which;
        var cy = r.cy;
        var gpos = [
            e.clientX,
            e.clientY
        ];
        var pos = r.projectIntoViewport(gpos[0], gpos[1]);
        var select = r.selection;
        var nears = r.findNearestElements(pos[0], pos[1], true, false);
        var near = nears[0];
        var draggedElements = r.dragData.possibleDragElements;
        r.hoverData.mdownPos = pos;
        r.hoverData.mdownGPos = gpos;
        var checkForTaphold = function checkForTaphold() {
            r.hoverData.tapholdCancelled = false;
            clearTimeout(r.hoverData.tapholdTimeout);
            r.hoverData.tapholdTimeout = setTimeout(function() {
                if (r.hoverData.tapholdCancelled) return;
                else {
                    var ele = r.hoverData.down;
                    if (ele) ele.emit({
                        originalEvent: e,
                        type: "taphold",
                        position: {
                            x: pos[0],
                            y: pos[1]
                        }
                    });
                    else cy.emit({
                        originalEvent: e,
                        type: "taphold",
                        position: {
                            x: pos[0],
                            y: pos[1]
                        }
                    });
                }
            }, r.tapholdDuration);
        }; // Right click button
        if (e.which == 3) {
            r.hoverData.cxtStarted = true;
            var cxtEvt = {
                originalEvent: e,
                type: "cxttapstart",
                position: {
                    x: pos[0],
                    y: pos[1]
                }
            };
            if (near) {
                near.activate();
                near.emit(cxtEvt);
                r.hoverData.down = near;
            } else cy.emit(cxtEvt);
            r.hoverData.downTime = new Date().getTime();
            r.hoverData.cxtDragged = false; // Primary button
        } else if (e.which == 1) {
            if (near) near.activate();
             // Element dragging
            // If something is under the cursor and it is draggable, prepare to grab it
            if (near != null) {
                if (r.nodeIsGrabbable(near)) {
                    var makeEvent = function makeEvent(type) {
                        return {
                            originalEvent: e,
                            type: type,
                            position: {
                                x: pos[0],
                                y: pos[1]
                            }
                        };
                    };
                    var triggerGrab = function triggerGrab(ele) {
                        ele.emit(makeEvent("grab"));
                    };
                    setGrabTarget(near);
                    if (!near.selected()) {
                        draggedElements = r.dragData.possibleDragElements = cy.collection();
                        addNodeToDrag(near, {
                            addToList: draggedElements
                        });
                        near.emit(makeEvent("grabon")).emit(makeEvent("grab"));
                    } else {
                        draggedElements = r.dragData.possibleDragElements = cy.collection();
                        var selectedNodes = cy.$(function(ele) {
                            return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);
                        });
                        addNodesToDrag(selectedNodes, {
                            addToList: draggedElements
                        });
                        near.emit(makeEvent("grabon"));
                        selectedNodes.forEach(triggerGrab);
                    }
                    r.redrawHint("eles", true);
                    r.redrawHint("drag", true);
                }
            }
            r.hoverData.down = near;
            r.hoverData.downs = nears;
            r.hoverData.downTime = new Date().getTime();
            triggerEvents(near, [
                "mousedown",
                "tapstart",
                "vmousedown"
            ], e, {
                x: pos[0],
                y: pos[1]
            });
            if (near == null) {
                select[4] = 1;
                r.data.bgActivePosistion = {
                    x: pos[0],
                    y: pos[1]
                };
                r.redrawHint("select", true);
                r.redraw();
            } else if (near.pannable()) select[4] = 1; // for future pan
            checkForTaphold();
        } // Initialize selection box coordinates
        select[0] = select[2] = pos[0];
        select[1] = select[3] = pos[1];
    }, false);
    r.registerBinding(window, "mousemove", function mousemoveHandler(e) {
        // eslint-disable-line no-undef
        var capture = r.hoverData.capture;
        if (!capture && !eventInContainer(e)) return;
        var preventDefault = false;
        var cy = r.cy;
        var zoom = cy.zoom();
        var gpos = [
            e.clientX,
            e.clientY
        ];
        var pos = r.projectIntoViewport(gpos[0], gpos[1]);
        var mdownPos = r.hoverData.mdownPos;
        var mdownGPos = r.hoverData.mdownGPos;
        var select = r.selection;
        var near = null;
        if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) near = r.findNearestElement(pos[0], pos[1], true, false);
        var last = r.hoverData.last;
        var down = r.hoverData.down;
        var disp = [
            pos[0] - select[2],
            pos[1] - select[3]
        ];
        var draggedElements = r.dragData.possibleDragElements;
        var isOverThresholdDrag;
        if (mdownGPos) {
            var dx = gpos[0] - mdownGPos[0];
            var dx2 = dx * dx;
            var dy = gpos[1] - mdownGPos[1];
            var dy2 = dy * dy;
            var dist2 = dx2 + dy2;
            r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
        }
        var multSelKeyDown = isMultSelKeyDown(e);
        if (isOverThresholdDrag) r.hoverData.tapholdCancelled = true;
        var updateDragDelta = function updateDragDelta() {
            var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];
            if (dragDelta.length === 0) {
                dragDelta.push(disp[0]);
                dragDelta.push(disp[1]);
            } else {
                dragDelta[0] += disp[0];
                dragDelta[1] += disp[1];
            }
        };
        preventDefault = true;
        triggerEvents(near, [
            "mousemove",
            "vmousemove",
            "tapdrag"
        ], e, {
            x: pos[0],
            y: pos[1]
        });
        var goIntoBoxMode = function goIntoBoxMode() {
            r.data.bgActivePosistion = undefined;
            if (!r.hoverData.selecting) cy.emit({
                originalEvent: e,
                type: "boxstart",
                position: {
                    x: pos[0],
                    y: pos[1]
                }
            });
            select[4] = 1;
            r.hoverData.selecting = true;
            r.redrawHint("select", true);
            r.redraw();
        }; // trigger context drag if rmouse down
        if (r.hoverData.which === 3) // but only if over threshold
        {
            if (isOverThresholdDrag) {
                var cxtEvt = {
                    originalEvent: e,
                    type: "cxtdrag",
                    position: {
                        x: pos[0],
                        y: pos[1]
                    }
                };
                if (down) down.emit(cxtEvt);
                else cy.emit(cxtEvt);
                r.hoverData.cxtDragged = true;
                if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {
                    if (r.hoverData.cxtOver) r.hoverData.cxtOver.emit({
                        originalEvent: e,
                        type: "cxtdragout",
                        position: {
                            x: pos[0],
                            y: pos[1]
                        }
                    });
                    r.hoverData.cxtOver = near;
                    if (near) near.emit({
                        originalEvent: e,
                        type: "cxtdragover",
                        position: {
                            x: pos[0],
                            y: pos[1]
                        }
                    });
                }
            } // Check if we are drag panning the entire graph
        } else if (r.hoverData.dragging) {
            preventDefault = true;
            if (cy.panningEnabled() && cy.userPanningEnabled()) {
                var deltaP;
                if (r.hoverData.justStartedPan) {
                    var mdPos = r.hoverData.mdownPos;
                    deltaP = {
                        x: (pos[0] - mdPos[0]) * zoom,
                        y: (pos[1] - mdPos[1]) * zoom
                    };
                    r.hoverData.justStartedPan = false;
                } else deltaP = {
                    x: disp[0] * zoom,
                    y: disp[1] * zoom
                };
                cy.panBy(deltaP);
                cy.emit("dragpan");
                r.hoverData.dragged = true;
            } // Needs reproject due to pan changing viewport
            pos = r.projectIntoViewport(e.clientX, e.clientY); // Checks primary button down & out of time & mouse not moved much
        } else if (select[4] == 1 && (down == null || down.pannable())) {
            if (isOverThresholdDrag) {
                if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) goIntoBoxMode();
                else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
                    var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);
                    if (allowPassthrough) {
                        r.hoverData.dragging = true;
                        r.hoverData.justStartedPan = true;
                        select[4] = 0;
                        r.data.bgActivePosistion = array2point(mdownPos);
                        r.redrawHint("select", true);
                        r.redraw();
                    }
                }
                if (down && down.pannable() && down.active()) down.unactivate();
            }
        } else {
            if (down && down.pannable() && down.active()) down.unactivate();
            if ((!down || !down.grabbed()) && near != last) {
                if (last) triggerEvents(last, [
                    "mouseout",
                    "tapdragout"
                ], e, {
                    x: pos[0],
                    y: pos[1]
                });
                if (near) triggerEvents(near, [
                    "mouseover",
                    "tapdragover"
                ], e, {
                    x: pos[0],
                    y: pos[1]
                });
                r.hoverData.last = near;
            }
            if (down) {
                if (isOverThresholdDrag) {
                    // then we can take action
                    if (cy.boxSelectionEnabled() && multSelKeyDown) {
                        // then selection overrides
                        if (down && down.grabbed()) {
                            freeDraggedElements(draggedElements);
                            down.emit("freeon");
                            draggedElements.emit("free");
                            if (r.dragData.didDrag) {
                                down.emit("dragfreeon");
                                draggedElements.emit("dragfree");
                            }
                        }
                        goIntoBoxMode();
                    } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {
                        // drag node
                        var justStartedDrag = !r.dragData.didDrag;
                        if (justStartedDrag) r.redrawHint("eles", true);
                        r.dragData.didDrag = true; // indicate that we actually did drag the node
                        // now, add the elements to the drag layer if not done already
                        if (!r.hoverData.draggingEles) addNodesToDrag(draggedElements, {
                            inDragLayer: true
                        });
                        var totalShift = {
                            x: 0,
                            y: 0
                        };
                        if (number$1(disp[0]) && number$1(disp[1])) {
                            totalShift.x += disp[0];
                            totalShift.y += disp[1];
                            if (justStartedDrag) {
                                var dragDelta = r.hoverData.dragDelta;
                                if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {
                                    totalShift.x += dragDelta[0];
                                    totalShift.y += dragDelta[1];
                                }
                            }
                        }
                        r.hoverData.draggingEles = true;
                        draggedElements.silentShift(totalShift).emit("position drag");
                        r.redrawHint("drag", true);
                        r.redraw();
                    }
                } else // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
                updateDragDelta();
            } // prevent the dragging from triggering text selection on the page
            preventDefault = true;
        }
        select[2] = pos[0];
        select[3] = pos[1];
        if (preventDefault) {
            if (e.stopPropagation) e.stopPropagation();
            if (e.preventDefault) e.preventDefault();
            return false;
        }
    }, false);
    var clickTimeout, didDoubleClick, prevClickTimeStamp;
    r.registerBinding(window, "mouseup", function mouseupHandler(e) {
        // eslint-disable-line no-undef
        var capture = r.hoverData.capture;
        if (!capture) return;
        r.hoverData.capture = false;
        var cy = r.cy;
        var pos = r.projectIntoViewport(e.clientX, e.clientY);
        var select = r.selection;
        var near = r.findNearestElement(pos[0], pos[1], true, false);
        var draggedElements = r.dragData.possibleDragElements;
        var down = r.hoverData.down;
        var multSelKeyDown = isMultSelKeyDown(e);
        if (r.data.bgActivePosistion) {
            r.redrawHint("select", true);
            r.redraw();
        }
        r.hoverData.tapholdCancelled = true;
        r.data.bgActivePosistion = undefined; // not active bg now
        if (down) down.unactivate();
        if (r.hoverData.which === 3) {
            var cxtEvt = {
                originalEvent: e,
                type: "cxttapend",
                position: {
                    x: pos[0],
                    y: pos[1]
                }
            };
            if (down) down.emit(cxtEvt);
            else cy.emit(cxtEvt);
            if (!r.hoverData.cxtDragged) {
                var cxtTap = {
                    originalEvent: e,
                    type: "cxttap",
                    position: {
                        x: pos[0],
                        y: pos[1]
                    }
                };
                if (down) down.emit(cxtTap);
                else cy.emit(cxtTap);
            }
            r.hoverData.cxtDragged = false;
            r.hoverData.which = null;
        } else if (r.hoverData.which === 1) {
            triggerEvents(near, [
                "mouseup",
                "tapend",
                "vmouseup"
            ], e, {
                x: pos[0],
                y: pos[1]
            });
            if (!r.dragData.didDrag && !r.hoverData.dragged && !r.hoverData.selecting && !r.hoverData.isOverThresholdDrag // didn't move too much
            ) {
                triggerEvents(down, [
                    "click",
                    "tap",
                    "vclick"
                ], e, {
                    x: pos[0],
                    y: pos[1]
                });
                didDoubleClick = false;
                if (e.timeStamp - prevClickTimeStamp <= cy.multiClickDebounceTime()) {
                    clickTimeout && clearTimeout(clickTimeout);
                    didDoubleClick = true;
                    prevClickTimeStamp = null;
                    triggerEvents(down, [
                        "dblclick",
                        "dbltap",
                        "vdblclick"
                    ], e, {
                        x: pos[0],
                        y: pos[1]
                    });
                } else {
                    clickTimeout = setTimeout(function() {
                        if (didDoubleClick) return;
                        triggerEvents(down, [
                            "oneclick",
                            "onetap",
                            "voneclick"
                        ], e, {
                            x: pos[0],
                            y: pos[1]
                        });
                    }, cy.multiClickDebounceTime());
                    prevClickTimeStamp = e.timeStamp;
                }
            } // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
            if (down == null // not mousedown on node
             && !r.dragData.didDrag // didn't move the node around
             && !r.hoverData.selecting // not box selection
             && !r.hoverData.dragged // didn't pan
             && !isMultSelKeyDown(e)) {
                cy.$(isSelected).unselect([
                    "tapunselect"
                ]);
                if (draggedElements.length > 0) r.redrawHint("eles", true);
                r.dragData.possibleDragElements = draggedElements = cy.collection();
            } // Single selection
            if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {
                if (near != null && near._private.selectable) {
                    if (r.hoverData.dragging) ;
                    else if (cy.selectionType() === "additive" || multSelKeyDown) {
                        if (near.selected()) near.unselect([
                            "tapunselect"
                        ]);
                        else near.select([
                            "tapselect"
                        ]);
                    } else if (!multSelKeyDown) {
                        cy.$(isSelected).unmerge(near).unselect([
                            "tapunselect"
                        ]);
                        near.select([
                            "tapselect"
                        ]);
                    }
                    r.redrawHint("eles", true);
                }
            }
            if (r.hoverData.selecting) {
                var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
                r.redrawHint("select", true);
                if (box.length > 0) r.redrawHint("eles", true);
                cy.emit({
                    type: "boxend",
                    originalEvent: e,
                    position: {
                        x: pos[0],
                        y: pos[1]
                    }
                });
                var eleWouldBeSelected = function eleWouldBeSelected(ele) {
                    return ele.selectable() && !ele.selected();
                };
                if (cy.selectionType() === "additive") box.emit("box").stdFilter(eleWouldBeSelected).select().emit("boxselect");
                else {
                    if (!multSelKeyDown) cy.$(isSelected).unmerge(box).unselect();
                    box.emit("box").stdFilter(eleWouldBeSelected).select().emit("boxselect");
                } // always need redraw in case eles unselectable
                r.redraw();
            } // Cancel drag pan
            if (r.hoverData.dragging) {
                r.hoverData.dragging = false;
                r.redrawHint("select", true);
                r.redrawHint("eles", true);
                r.redraw();
            }
            if (!select[4]) {
                r.redrawHint("drag", true);
                r.redrawHint("eles", true);
                var downWasGrabbed = down && down.grabbed();
                freeDraggedElements(draggedElements);
                if (downWasGrabbed) {
                    down.emit("freeon");
                    draggedElements.emit("free");
                    if (r.dragData.didDrag) {
                        down.emit("dragfreeon");
                        draggedElements.emit("dragfree");
                    }
                }
            }
        } // else not right mouse
        select[4] = 0;
        r.hoverData.down = null;
        r.hoverData.cxtStarted = false;
        r.hoverData.draggingEles = false;
        r.hoverData.selecting = false;
        r.hoverData.isOverThresholdDrag = false;
        r.dragData.didDrag = false;
        r.hoverData.dragged = false;
        r.hoverData.dragDelta = [];
        r.hoverData.mdownPos = null;
        r.hoverData.mdownGPos = null;
    }, false);
    var wheelHandler = function wheelHandler(e) {
        if (r.scrollingPage) return;
         // while scrolling, ignore wheel-to-zoom
        var cy = r.cy;
        var zoom = cy.zoom();
        var pan = cy.pan();
        var pos = r.projectIntoViewport(e.clientX, e.clientY);
        var rpos = [
            pos[0] * zoom + pan.x,
            pos[1] * zoom + pan.y
        ];
        if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {
            // if pan dragging or cxt dragging, wheel movements make no zoom
            e.preventDefault();
            return;
        }
        if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
            e.preventDefault();
            r.data.wheelZooming = true;
            clearTimeout(r.data.wheelTimeout);
            r.data.wheelTimeout = setTimeout(function() {
                r.data.wheelZooming = false;
                r.redrawHint("eles", true);
                r.redraw();
            }, 150);
            var diff;
            if (e.deltaY != null) diff = e.deltaY / -250;
            else if (e.wheelDeltaY != null) diff = e.wheelDeltaY / 1000;
            else diff = e.wheelDelta / 1000;
            diff = diff * r.wheelSensitivity;
            var needsWheelFix = e.deltaMode === 1;
            if (needsWheelFix) // fixes slow wheel events on ff/linux and ff/windows
            diff *= 33;
            var newZoom = cy.zoom() * Math.pow(10, diff);
            if (e.type === "gesturechange") newZoom = r.gestureStartZoom * e.scale;
            cy.zoom({
                level: newZoom,
                renderedPosition: {
                    x: rpos[0],
                    y: rpos[1]
                }
            });
            cy.emit(e.type === "gesturechange" ? "pinchzoom" : "scrollzoom");
        }
    }; // Functions to help with whether mouse wheel should trigger zooming
    // --
    r.registerBinding(r.container, "wheel", wheelHandler, true); // disable nonstandard wheel events
    // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
    // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
    // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox
    r.registerBinding(window, "scroll", function scrollHandler(e) {
        // eslint-disable-line no-unused-vars
        r.scrollingPage = true;
        clearTimeout(r.scrollingPageTimeout);
        r.scrollingPageTimeout = setTimeout(function() {
            r.scrollingPage = false;
        }, 250);
    }, true); // desktop safari pinch to zoom start
    r.registerBinding(r.container, "gesturestart", function gestureStartHandler(e) {
        r.gestureStartZoom = r.cy.zoom();
        if (!r.hasTouchStarted) // don't affect touch devices like iphone
        e.preventDefault();
    }, true);
    r.registerBinding(r.container, "gesturechange", function(e) {
        if (!r.hasTouchStarted) // don't affect touch devices like iphone
        wheelHandler(e);
    }, true); // Functions to help with handling mouseout/mouseover on the Cytoscape container
    // Handle mouseout on Cytoscape container
    r.registerBinding(r.container, "mouseout", function mouseOutHandler(e) {
        var pos = r.projectIntoViewport(e.clientX, e.clientY);
        r.cy.emit({
            originalEvent: e,
            type: "mouseout",
            position: {
                x: pos[0],
                y: pos[1]
            }
        });
    }, false);
    r.registerBinding(r.container, "mouseover", function mouseOverHandler(e) {
        var pos = r.projectIntoViewport(e.clientX, e.clientY);
        r.cy.emit({
            originalEvent: e,
            type: "mouseover",
            position: {
                x: pos[0],
                y: pos[1]
            }
        });
    }, false);
    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
    var center1, modelCenter1; // center point on start pinch to zoom
    var offsetLeft, offsetTop;
    var containerWidth, containerHeight;
    var twoFingersStartInside;
    var distance = function distance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    };
    var distanceSq = function distanceSq(x1, y1, x2, y2) {
        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    };
    var touchstartHandler;
    r.registerBinding(r.container, "touchstart", touchstartHandler = function touchstartHandler(e) {
        r.hasTouchStarted = true;
        if (!eventInContainer(e)) return;
        blurActiveDomElement();
        r.touchData.capture = true;
        r.data.bgActivePosistion = undefined;
        var cy = r.cy;
        var now = r.touchData.now;
        var earlier = r.touchData.earlier;
        if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
            now[0] = pos[0];
            now[1] = pos[1];
        }
        if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
            now[2] = pos[0];
            now[3] = pos[1];
        }
        if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
            now[4] = pos[0];
            now[5] = pos[1];
        } // record starting points for pinch-to-zoom
        if (e.touches[1]) {
            r.touchData.singleTouchMoved = true;
            freeDraggedElements(r.dragData.touchDragEles);
            var offsets = r.findContainerClientCoords();
            offsetLeft = offsets[0];
            offsetTop = offsets[1];
            containerWidth = offsets[2];
            containerHeight = offsets[3];
            f1x1 = e.touches[0].clientX - offsetLeft;
            f1y1 = e.touches[0].clientY - offsetTop;
            f2x1 = e.touches[1].clientX - offsetLeft;
            f2y1 = e.touches[1].clientY - offsetTop;
            twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;
            var pan = cy.pan();
            var zoom = cy.zoom();
            distance1 = distance(f1x1, f1y1, f2x1, f2y1);
            distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
            center1 = [
                (f1x1 + f2x1) / 2,
                (f1y1 + f2y1) / 2
            ];
            modelCenter1 = [
                (center1[0] - pan.x) / zoom,
                (center1[1] - pan.y) / zoom
            ]; // consider context tap
            var cxtDistThreshold = 200;
            var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
            if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {
                var near1 = r.findNearestElement(now[0], now[1], true, true);
                var near2 = r.findNearestElement(now[2], now[3], true, true);
                if (near1 && near1.isNode()) {
                    near1.activate().emit({
                        originalEvent: e,
                        type: "cxttapstart",
                        position: {
                            x: now[0],
                            y: now[1]
                        }
                    });
                    r.touchData.start = near1;
                } else if (near2 && near2.isNode()) {
                    near2.activate().emit({
                        originalEvent: e,
                        type: "cxttapstart",
                        position: {
                            x: now[0],
                            y: now[1]
                        }
                    });
                    r.touchData.start = near2;
                } else cy.emit({
                    originalEvent: e,
                    type: "cxttapstart",
                    position: {
                        x: now[0],
                        y: now[1]
                    }
                });
                if (r.touchData.start) r.touchData.start._private.grabbed = false;
                r.touchData.cxt = true;
                r.touchData.cxtDragged = false;
                r.data.bgActivePosistion = undefined;
                r.redraw();
                return;
            }
        }
        if (e.touches[2]) // ignore
        // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)
        {
            if (cy.boxSelectionEnabled()) e.preventDefault();
        } else if (e.touches[1]) ;
        else if (e.touches[0]) {
            var nears = r.findNearestElements(now[0], now[1], true, true);
            var near = nears[0];
            if (near != null) {
                near.activate();
                r.touchData.start = near;
                r.touchData.starts = nears;
                if (r.nodeIsGrabbable(near)) {
                    var draggedEles = r.dragData.touchDragEles = cy.collection();
                    var selectedNodes = null;
                    r.redrawHint("eles", true);
                    r.redrawHint("drag", true);
                    if (near.selected()) {
                        // reset drag elements, since near will be added again
                        selectedNodes = cy.$(function(ele) {
                            return ele.selected() && r.nodeIsGrabbable(ele);
                        });
                        addNodesToDrag(selectedNodes, {
                            addToList: draggedEles
                        });
                    } else addNodeToDrag(near, {
                        addToList: draggedEles
                    });
                    setGrabTarget(near);
                    var makeEvent = function makeEvent(type) {
                        return {
                            originalEvent: e,
                            type: type,
                            position: {
                                x: now[0],
                                y: now[1]
                            }
                        };
                    };
                    near.emit(makeEvent("grabon"));
                    if (selectedNodes) selectedNodes.forEach(function(n) {
                        n.emit(makeEvent("grab"));
                    });
                    else near.emit(makeEvent("grab"));
                }
            }
            triggerEvents(near, [
                "touchstart",
                "tapstart",
                "vmousedown"
            ], e, {
                x: now[0],
                y: now[1]
            });
            if (near == null) {
                r.data.bgActivePosistion = {
                    x: pos[0],
                    y: pos[1]
                };
                r.redrawHint("select", true);
                r.redraw();
            } // Tap, taphold
            // -----
            r.touchData.singleTouchMoved = false;
            r.touchData.singleTouchStartTime = +new Date();
            clearTimeout(r.touchData.tapholdTimeout);
            r.touchData.tapholdTimeout = setTimeout(function() {
                if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect
                 && !r.touchData.selecting // box selection shouldn't allow taphold through
                ) triggerEvents(r.touchData.start, [
                    "taphold"
                ], e, {
                    x: now[0],
                    y: now[1]
                });
            }, r.tapholdDuration);
        }
        if (e.touches.length >= 1) {
            var sPos = r.touchData.startPosition = [];
            for(var i = 0; i < now.length; i++)sPos[i] = earlier[i] = now[i];
            var touch0 = e.touches[0];
            r.touchData.startGPosition = [
                touch0.clientX,
                touch0.clientY
            ];
        }
    }, false);
    var touchmoveHandler;
    r.registerBinding(window, "touchmove", touchmoveHandler = function touchmoveHandler(e) {
        // eslint-disable-line no-undef
        var capture = r.touchData.capture;
        if (!capture && !eventInContainer(e)) return;
        var select = r.selection;
        var cy = r.cy;
        var now = r.touchData.now;
        var earlier = r.touchData.earlier;
        var zoom = cy.zoom();
        if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
            now[0] = pos[0];
            now[1] = pos[1];
        }
        if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
            now[2] = pos[0];
            now[3] = pos[1];
        }
        if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
            now[4] = pos[0];
            now[5] = pos[1];
        }
        var startGPos = r.touchData.startGPosition;
        var isOverThresholdDrag;
        if (capture && e.touches[0] && startGPos) {
            var disp = [];
            for(var j = 0; j < now.length; j++)disp[j] = now[j] - earlier[j];
            var dx = e.touches[0].clientX - startGPos[0];
            var dx2 = dx * dx;
            var dy = e.touches[0].clientY - startGPos[1];
            var dy2 = dy * dy;
            var dist2 = dx2 + dy2;
            isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
        } // context swipe cancelling
        if (capture && r.touchData.cxt) {
            e.preventDefault();
            var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
            var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop; // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
            var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
            var factorSq = distance2Sq / distance1Sq;
            var distThreshold = 150;
            var distThresholdSq = distThreshold * distThreshold;
            var factorThreshold = 1.5;
            var factorThresholdSq = factorThreshold * factorThreshold; // cancel ctx gestures if the distance b/t the fingers increases
            if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
                r.touchData.cxt = false;
                r.data.bgActivePosistion = undefined;
                r.redrawHint("select", true);
                var cxtEvt = {
                    originalEvent: e,
                    type: "cxttapend",
                    position: {
                        x: now[0],
                        y: now[1]
                    }
                };
                if (r.touchData.start) {
                    r.touchData.start.unactivate().emit(cxtEvt);
                    r.touchData.start = null;
                } else cy.emit(cxtEvt);
            }
        } // context swipe
        if (capture && r.touchData.cxt) {
            var cxtEvt = {
                originalEvent: e,
                type: "cxtdrag",
                position: {
                    x: now[0],
                    y: now[1]
                }
            };
            r.data.bgActivePosistion = undefined;
            r.redrawHint("select", true);
            if (r.touchData.start) r.touchData.start.emit(cxtEvt);
            else cy.emit(cxtEvt);
            if (r.touchData.start) r.touchData.start._private.grabbed = false;
            r.touchData.cxtDragged = true;
            var near = r.findNearestElement(now[0], now[1], true, true);
            if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {
                if (r.touchData.cxtOver) r.touchData.cxtOver.emit({
                    originalEvent: e,
                    type: "cxtdragout",
                    position: {
                        x: now[0],
                        y: now[1]
                    }
                });
                r.touchData.cxtOver = near;
                if (near) near.emit({
                    originalEvent: e,
                    type: "cxtdragover",
                    position: {
                        x: now[0],
                        y: now[1]
                    }
                });
            } // box selection
        } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {
            e.preventDefault();
            r.data.bgActivePosistion = undefined;
            this.lastThreeTouch = +new Date();
            if (!r.touchData.selecting) cy.emit({
                originalEvent: e,
                type: "boxstart",
                position: {
                    x: now[0],
                    y: now[1]
                }
            });
            r.touchData.selecting = true;
            r.touchData.didSelect = true;
            select[4] = 1;
            if (!select || select.length === 0 || select[0] === undefined) {
                select[0] = (now[0] + now[2] + now[4]) / 3;
                select[1] = (now[1] + now[3] + now[5]) / 3;
                select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
                select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
            } else {
                select[2] = (now[0] + now[2] + now[4]) / 3;
                select[3] = (now[1] + now[3] + now[5]) / 3;
            }
            r.redrawHint("select", true);
            r.redraw(); // pinch to zoom
        } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom
         && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
            // two fingers => pinch to zoom
            e.preventDefault();
            r.data.bgActivePosistion = undefined;
            r.redrawHint("select", true);
            var draggedEles = r.dragData.touchDragEles;
            if (draggedEles) {
                r.redrawHint("drag", true);
                for(var i = 0; i < draggedEles.length; i++){
                    var de_p = draggedEles[i]._private;
                    de_p.grabbed = false;
                    de_p.rscratch.inDragLayer = false;
                }
            }
            var _start = r.touchData.start; // (x2, y2) for fingers 1 and 2
            var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
            var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
            var distance2 = distance(f1x2, f1y2, f2x2, f2y2); // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
            // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
            var factor = distance2 / distance1;
            if (twoFingersStartInside) {
                // delta finger1
                var df1x = f1x2 - f1x1;
                var df1y = f1y2 - f1y1; // delta finger 2
                var df2x = f2x2 - f2x1;
                var df2y = f2y2 - f2y1; // translation is the normalised vector of the two fingers movement
                // i.e. so pinching cancels out and moving together pans
                var tx = (df1x + df2x) / 2;
                var ty = (df1y + df2y) / 2; // now calculate the zoom
                var zoom1 = cy.zoom();
                var zoom2 = zoom1 * factor;
                var pan1 = cy.pan(); // the model center point converted to the current rendered pos
                var ctrx = modelCenter1[0] * zoom1 + pan1.x;
                var ctry = modelCenter1[1] * zoom1 + pan1.y;
                var pan2 = {
                    x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
                    y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
                }; // remove dragged eles
                if (_start && _start.active()) {
                    var draggedEles = r.dragData.touchDragEles;
                    freeDraggedElements(draggedEles);
                    r.redrawHint("drag", true);
                    r.redrawHint("eles", true);
                    _start.unactivate().emit("freeon");
                    draggedEles.emit("free");
                    if (r.dragData.didDrag) {
                        _start.emit("dragfreeon");
                        draggedEles.emit("dragfree");
                    }
                }
                cy.viewport({
                    zoom: zoom2,
                    pan: pan2,
                    cancelOnFailedZoom: true
                });
                cy.emit("pinchzoom");
                distance1 = distance2;
                f1x1 = f1x2;
                f1y1 = f1y2;
                f2x1 = f2x2;
                f2y1 = f2y2;
                r.pinching = true;
            } // Re-project
            if (e.touches[0]) {
                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
                now[0] = pos[0];
                now[1] = pos[1];
            }
            if (e.touches[1]) {
                var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
                now[2] = pos[0];
                now[3] = pos[1];
            }
            if (e.touches[2]) {
                var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
                now[4] = pos[0];
                now[5] = pos[1];
            }
        } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning
        ) {
            var start = r.touchData.start;
            var last = r.touchData.last;
            var near;
            if (!r.hoverData.draggingEles && !r.swipePanning) near = r.findNearestElement(now[0], now[1], true, true);
            if (capture && start != null) e.preventDefault();
             // dragging nodes
            if (capture && start != null && r.nodeIsDraggable(start)) {
                if (isOverThresholdDrag) {
                    // then dragging can happen
                    var draggedEles = r.dragData.touchDragEles;
                    var justStartedDrag = !r.dragData.didDrag;
                    if (justStartedDrag) addNodesToDrag(draggedEles, {
                        inDragLayer: true
                    });
                    r.dragData.didDrag = true;
                    var totalShift = {
                        x: 0,
                        y: 0
                    };
                    if (number$1(disp[0]) && number$1(disp[1])) {
                        totalShift.x += disp[0];
                        totalShift.y += disp[1];
                        if (justStartedDrag) {
                            r.redrawHint("eles", true);
                            var dragDelta = r.touchData.dragDelta;
                            if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {
                                totalShift.x += dragDelta[0];
                                totalShift.y += dragDelta[1];
                            }
                        }
                    }
                    r.hoverData.draggingEles = true;
                    draggedEles.silentShift(totalShift).emit("position drag");
                    r.redrawHint("drag", true);
                    if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) r.redrawHint("eles", true);
                    r.redraw();
                } else {
                    // otherise keep track of drag delta for later
                    var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];
                    if (dragDelta.length === 0) {
                        dragDelta.push(disp[0]);
                        dragDelta.push(disp[1]);
                    } else {
                        dragDelta[0] += disp[0];
                        dragDelta[1] += disp[1];
                    }
                }
            } // touchmove
            triggerEvents(start || near, [
                "touchmove",
                "tapdrag",
                "vmousemove"
            ], e, {
                x: now[0],
                y: now[1]
            });
            if ((!start || !start.grabbed()) && near != last) {
                if (last) last.emit({
                    originalEvent: e,
                    type: "tapdragout",
                    position: {
                        x: now[0],
                        y: now[1]
                    }
                });
                if (near) near.emit({
                    originalEvent: e,
                    type: "tapdragover",
                    position: {
                        x: now[0],
                        y: now[1]
                    }
                });
            }
            r.touchData.last = near;
            if (capture) {
                for(var i = 0; i < now.length; i++)if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) r.touchData.singleTouchMoved = true;
            } // panning
            if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {
                var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);
                if (allowPassthrough) {
                    e.preventDefault();
                    if (!r.data.bgActivePosistion) r.data.bgActivePosistion = array2point(r.touchData.startPosition);
                    if (r.swipePanning) {
                        cy.panBy({
                            x: disp[0] * zoom,
                            y: disp[1] * zoom
                        });
                        cy.emit("dragpan");
                    } else if (isOverThresholdDrag) {
                        r.swipePanning = true;
                        cy.panBy({
                            x: dx * zoom,
                            y: dy * zoom
                        });
                        cy.emit("dragpan");
                        if (start) {
                            start.unactivate();
                            r.redrawHint("select", true);
                            r.touchData.start = null;
                        }
                    }
                } // Re-project
                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
                now[0] = pos[0];
                now[1] = pos[1];
            }
        }
        for(var j = 0; j < now.length; j++)earlier[j] = now[j];
         // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning
        if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {
            r.data.bgActivePosistion = undefined;
            r.redrawHint("select", true);
            r.redraw();
        }
    }, false);
    var touchcancelHandler;
    r.registerBinding(window, "touchcancel", touchcancelHandler = function touchcancelHandler(e) {
        // eslint-disable-line no-unused-vars
        var start = r.touchData.start;
        r.touchData.capture = false;
        if (start) start.unactivate();
    });
    var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;
    r.registerBinding(window, "touchend", touchendHandler = function touchendHandler(e) {
        // eslint-disable-line no-unused-vars
        var start = r.touchData.start;
        var capture = r.touchData.capture;
        if (capture) {
            if (e.touches.length === 0) r.touchData.capture = false;
            e.preventDefault();
        } else return;
        var select = r.selection;
        r.swipePanning = false;
        r.hoverData.draggingEles = false;
        var cy = r.cy;
        var zoom = cy.zoom();
        var now = r.touchData.now;
        var earlier = r.touchData.earlier;
        if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
            now[0] = pos[0];
            now[1] = pos[1];
        }
        if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
            now[2] = pos[0];
            now[3] = pos[1];
        }
        if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
            now[4] = pos[0];
            now[5] = pos[1];
        }
        if (start) start.unactivate();
        var ctxTapend;
        if (r.touchData.cxt) {
            ctxTapend = {
                originalEvent: e,
                type: "cxttapend",
                position: {
                    x: now[0],
                    y: now[1]
                }
            };
            if (start) start.emit(ctxTapend);
            else cy.emit(ctxTapend);
            if (!r.touchData.cxtDragged) {
                var ctxTap = {
                    originalEvent: e,
                    type: "cxttap",
                    position: {
                        x: now[0],
                        y: now[1]
                    }
                };
                if (start) start.emit(ctxTap);
                else cy.emit(ctxTap);
            }
            if (r.touchData.start) r.touchData.start._private.grabbed = false;
            r.touchData.cxt = false;
            r.touchData.start = null;
            r.redraw();
            return;
        } // no more box selection if we don't have three fingers
        if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {
            r.touchData.selecting = false;
            var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
            select[0] = undefined;
            select[1] = undefined;
            select[2] = undefined;
            select[3] = undefined;
            select[4] = 0;
            r.redrawHint("select", true);
            cy.emit({
                type: "boxend",
                originalEvent: e,
                position: {
                    x: now[0],
                    y: now[1]
                }
            });
            var eleWouldBeSelected = function eleWouldBeSelected(ele) {
                return ele.selectable() && !ele.selected();
            };
            box.emit("box").stdFilter(eleWouldBeSelected).select().emit("boxselect");
            if (box.nonempty()) r.redrawHint("eles", true);
            r.redraw();
        }
        if (start != null) start.unactivate();
        if (e.touches[2]) {
            r.data.bgActivePosistion = undefined;
            r.redrawHint("select", true);
        } else if (e.touches[1]) ;
        else if (e.touches[0]) ;
        else if (!e.touches[0]) {
            r.data.bgActivePosistion = undefined;
            r.redrawHint("select", true);
            var draggedEles = r.dragData.touchDragEles;
            if (start != null) {
                var startWasGrabbed = start._private.grabbed;
                freeDraggedElements(draggedEles);
                r.redrawHint("drag", true);
                r.redrawHint("eles", true);
                if (startWasGrabbed) {
                    start.emit("freeon");
                    draggedEles.emit("free");
                    if (r.dragData.didDrag) {
                        start.emit("dragfreeon");
                        draggedEles.emit("dragfree");
                    }
                }
                triggerEvents(start, [
                    "touchend",
                    "tapend",
                    "vmouseup",
                    "tapdragout"
                ], e, {
                    x: now[0],
                    y: now[1]
                });
                start.unactivate();
                r.touchData.start = null;
            } else {
                var near = r.findNearestElement(now[0], now[1], true, true);
                triggerEvents(near, [
                    "touchend",
                    "tapend",
                    "vmouseup",
                    "tapdragout"
                ], e, {
                    x: now[0],
                    y: now[1]
                });
            }
            var dx = r.touchData.startPosition[0] - now[0];
            var dx2 = dx * dx;
            var dy = r.touchData.startPosition[1] - now[1];
            var dy2 = dy * dy;
            var dist2 = dx2 + dy2;
            var rdist2 = dist2 * zoom * zoom; // Tap event, roughly same as mouse click event for touch
            if (!r.touchData.singleTouchMoved) {
                if (!start) cy.$(":selected").unselect([
                    "tapunselect"
                ]);
                triggerEvents(start, [
                    "tap",
                    "vclick"
                ], e, {
                    x: now[0],
                    y: now[1]
                });
                didDoubleTouch = false;
                if (e.timeStamp - prevTouchTimeStamp <= cy.multiClickDebounceTime()) {
                    touchTimeout && clearTimeout(touchTimeout);
                    didDoubleTouch = true;
                    prevTouchTimeStamp = null;
                    triggerEvents(start, [
                        "dbltap",
                        "vdblclick"
                    ], e, {
                        x: now[0],
                        y: now[1]
                    });
                } else {
                    touchTimeout = setTimeout(function() {
                        if (didDoubleTouch) return;
                        triggerEvents(start, [
                            "onetap",
                            "voneclick"
                        ], e, {
                            x: now[0],
                            y: now[1]
                        });
                    }, cy.multiClickDebounceTime());
                    prevTouchTimeStamp = e.timeStamp;
                }
            } // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
            if (start != null && !r.dragData.didDrag // didn't drag nodes around
             && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection
            ) {
                if (cy.selectionType() === "single") {
                    cy.$(isSelected).unmerge(start).unselect([
                        "tapunselect"
                    ]);
                    start.select([
                        "tapselect"
                    ]);
                } else if (start.selected()) start.unselect([
                    "tapunselect"
                ]);
                else start.select([
                    "tapselect"
                ]);
                r.redrawHint("eles", true);
            }
            r.touchData.singleTouchMoved = true;
        }
        for(var j = 0; j < now.length; j++)earlier[j] = now[j];
        r.dragData.didDrag = false; // reset for next touchstart
        if (e.touches.length === 0) {
            r.touchData.dragDelta = [];
            r.touchData.startPosition = null;
            r.touchData.startGPosition = null;
            r.touchData.didSelect = false;
        }
        if (e.touches.length < 2) {
            if (e.touches.length === 1) // the old start global pos'n may not be the same finger that remains
            r.touchData.startGPosition = [
                e.touches[0].clientX,
                e.touches[0].clientY
            ];
            r.pinching = false;
            r.redrawHint("eles", true);
            r.redraw();
        } //r.redraw();
    }, false); // fallback compatibility layer for ms pointer events
    if (typeof TouchEvent === "undefined") {
        var pointers = [];
        var makeTouch = function makeTouch(e) {
            return {
                clientX: e.clientX,
                clientY: e.clientY,
                force: 1,
                identifier: e.pointerId,
                pageX: e.pageX,
                pageY: e.pageY,
                radiusX: e.width / 2,
                radiusY: e.height / 2,
                screenX: e.screenX,
                screenY: e.screenY,
                target: e.target
            };
        };
        var makePointer = function makePointer(e) {
            return {
                event: e,
                touch: makeTouch(e)
            };
        };
        var addPointer = function addPointer(e) {
            pointers.push(makePointer(e));
        };
        var removePointer = function removePointer(e) {
            for(var i = 0; i < pointers.length; i++){
                var p = pointers[i];
                if (p.event.pointerId === e.pointerId) {
                    pointers.splice(i, 1);
                    return;
                }
            }
        };
        var updatePointer = function updatePointer(e) {
            var p = pointers.filter(function(p) {
                return p.event.pointerId === e.pointerId;
            })[0];
            p.event = e;
            p.touch = makeTouch(e);
        };
        var addTouchesToEvent = function addTouchesToEvent(e) {
            e.touches = pointers.map(function(p) {
                return p.touch;
            });
        };
        var pointerIsMouse = function pointerIsMouse(e) {
            return e.pointerType === "mouse" || e.pointerType === 4;
        };
        r.registerBinding(r.container, "pointerdown", function(e) {
            if (pointerIsMouse(e)) return;
             // mouse already handled
            e.preventDefault();
            addPointer(e);
            addTouchesToEvent(e);
            touchstartHandler(e);
        });
        r.registerBinding(r.container, "pointerup", function(e) {
            if (pointerIsMouse(e)) return;
             // mouse already handled
            removePointer(e);
            addTouchesToEvent(e);
            touchendHandler(e);
        });
        r.registerBinding(r.container, "pointercancel", function(e) {
            if (pointerIsMouse(e)) return;
             // mouse already handled
            removePointer(e);
            addTouchesToEvent(e);
            touchcancelHandler(e);
        });
        r.registerBinding(r.container, "pointermove", function(e) {
            if (pointerIsMouse(e)) return;
             // mouse already handled
            e.preventDefault();
            updatePointer(e);
            addTouchesToEvent(e);
            touchmoveHandler(e);
        });
    }
};
var BRp$2 = {};
BRp$2.generatePolygon = function(name, points) {
    return this.nodeShapes[name] = {
        renderer: this,
        name: name,
        points: points,
        draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl("polygon", context, centerX, centerY, width, height, this.points);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [
                0,
                -1
            ], padding);
        }
    };
};
BRp$2.generateEllipse = function() {
    return this.nodeShapes["ellipse"] = {
        renderer: this,
        name: "ellipse",
        draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            return checkInEllipse(x, y, width, height, centerX, centerY, padding);
        }
    };
};
BRp$2.generateRoundPolygon = function(name, points) {
    // Pre-compute control points
    // Since these points depend on the radius length (which in turns depend on the width/height of the node) we will only pre-compute
    // the unit vectors.
    // For simplicity the layout will be:
    // [ p0, UnitVectorP0P1, p1, UniVectorP1P2, ..., pn, UnitVectorPnP0 ]
    var allPoints = new Array(points.length * 2);
    for(var i = 0; i < points.length / 2; i++){
        var sourceIndex = i * 2;
        var destIndex = void 0;
        if (i < points.length / 2 - 1) destIndex = (i + 1) * 2;
        else destIndex = 0;
        allPoints[i * 4] = points[sourceIndex];
        allPoints[i * 4 + 1] = points[sourceIndex + 1];
        var xDest = points[destIndex] - points[sourceIndex];
        var yDest = points[destIndex + 1] - points[sourceIndex + 1];
        var norm = Math.sqrt(xDest * xDest + yDest * yDest);
        allPoints[i * 4 + 2] = xDest / norm;
        allPoints[i * 4 + 3] = yDest / norm;
    }
    return this.nodeShapes[name] = {
        renderer: this,
        name: name,
        points: allPoints,
        draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl("round-polygon", context, centerX, centerY, width, height, this.points);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height);
        }
    };
};
BRp$2.generateRoundRectangle = function() {
    return this.nodeShapes["round-rectangle"] = this.nodeShapes["roundrectangle"] = {
        renderer: this,
        name: "round-rectangle",
        points: generateUnitNgonPointsFitToSquare(4, 0),
        draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            var cornerRadius = getRoundRectangleRadius(width, height);
            var diam = cornerRadius * 2; // Check hBox
            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [
                0,
                -1
            ], padding)) return true;
             // Check vBox
            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [
                0,
                -1
            ], padding)) return true;
             // Check top left quarter circle
            if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) return true;
             // Check top right quarter circle
            if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) return true;
             // Check bottom right quarter circle
            if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) return true;
             // Check bottom left quarter circle
            if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) return true;
            return false;
        }
    };
};
BRp$2.generateCutRectangle = function() {
    return this.nodeShapes["cut-rectangle"] = this.nodeShapes["cutrectangle"] = {
        renderer: this,
        name: "cut-rectangle",
        cornerLength: getCutRectangleCornerLength(),
        points: generateUnitNgonPointsFitToSquare(4, 0),
        draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
        },
        generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {
            var cl = this.cornerLength;
            var hh = height / 2;
            var hw = width / 2;
            var xBegin = centerX - hw;
            var xEnd = centerX + hw;
            var yBegin = centerY - hh;
            var yEnd = centerY + hh; // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]
            return {
                topLeft: [
                    xBegin,
                    yBegin + cl,
                    xBegin + cl,
                    yBegin,
                    xBegin + cl,
                    yBegin + cl
                ],
                topRight: [
                    xEnd - cl,
                    yBegin,
                    xEnd,
                    yBegin + cl,
                    xEnd - cl,
                    yBegin + cl
                ],
                bottomRight: [
                    xEnd,
                    yEnd - cl,
                    xEnd - cl,
                    yEnd,
                    xEnd - cl,
                    yEnd - cl
                ],
                bottomLeft: [
                    xBegin + cl,
                    yEnd,
                    xBegin,
                    yEnd - cl,
                    xBegin + cl,
                    yEnd - cl
                ]
            };
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
            var pts = [].concat.apply([], [
                cPts.topLeft.splice(0, 4),
                cPts.topRight.splice(0, 4),
                cPts.bottomRight.splice(0, 4),
                cPts.bottomLeft.splice(0, 4)
            ]);
            return polygonIntersectLine(x, y, pts, nodeX, nodeY);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            // Check hBox
            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [
                0,
                -1
            ], padding)) return true;
             // Check vBox
            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [
                0,
                -1
            ], padding)) return true;
            var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
            return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);
        }
    };
};
BRp$2.generateBarrel = function() {
    return this.nodeShapes["barrel"] = {
        renderer: this,
        name: "barrel",
        points: generateUnitNgonPointsFitToSquare(4, 0),
        draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            // use two fixed t values for the bezier curve approximation
            var t0 = 0.15;
            var t1 = 0.5;
            var t2 = 0.85;
            var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
            var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {
                // approximate curve pts based on the two t values
                var m0 = qbezierPtAt({
                    x: pts[0],
                    y: pts[1]
                }, {
                    x: pts[2],
                    y: pts[3]
                }, {
                    x: pts[4],
                    y: pts[5]
                }, t0);
                var m1 = qbezierPtAt({
                    x: pts[0],
                    y: pts[1]
                }, {
                    x: pts[2],
                    y: pts[3]
                }, {
                    x: pts[4],
                    y: pts[5]
                }, t1);
                var m2 = qbezierPtAt({
                    x: pts[0],
                    y: pts[1]
                }, {
                    x: pts[2],
                    y: pts[3]
                }, {
                    x: pts[4],
                    y: pts[5]
                }, t2);
                return [
                    pts[0],
                    pts[1],
                    m0.x,
                    m0.y,
                    m1.x,
                    m1.y,
                    m2.x,
                    m2.y,
                    pts[4],
                    pts[5]
                ];
            };
            var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));
            return polygonIntersectLine(x, y, pts, nodeX, nodeY);
        },
        generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {
            var hh = height / 2;
            var hw = width / 2;
            var xBegin = centerX - hw;
            var xEnd = centerX + hw;
            var yBegin = centerY - hh;
            var yEnd = centerY + hh;
            var curveConstants = getBarrelCurveConstants(width, height);
            var hOffset = curveConstants.heightOffset;
            var wOffset = curveConstants.widthOffset;
            var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width; // points are in clockwise order, inner (imaginary) control pt on [4, 5]
            var pts = {
                topLeft: [
                    xBegin,
                    yBegin + hOffset,
                    xBegin + ctrlPtXOffset,
                    yBegin,
                    xBegin + wOffset,
                    yBegin
                ],
                topRight: [
                    xEnd - wOffset,
                    yBegin,
                    xEnd - ctrlPtXOffset,
                    yBegin,
                    xEnd,
                    yBegin + hOffset
                ],
                bottomRight: [
                    xEnd,
                    yEnd - hOffset,
                    xEnd - ctrlPtXOffset,
                    yEnd,
                    xEnd - wOffset,
                    yEnd
                ],
                bottomLeft: [
                    xBegin + wOffset,
                    yEnd,
                    xBegin + ctrlPtXOffset,
                    yEnd,
                    xBegin,
                    yEnd - hOffset
                ]
            };
            pts.topLeft.isTop = true;
            pts.topRight.isTop = true;
            pts.bottomLeft.isBottom = true;
            pts.bottomRight.isBottom = true;
            return pts;
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            var curveConstants = getBarrelCurveConstants(width, height);
            var hOffset = curveConstants.heightOffset;
            var wOffset = curveConstants.widthOffset; // Check hBox
            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [
                0,
                -1
            ], padding)) return true;
             // Check vBox
            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [
                0,
                -1
            ], padding)) return true;
            var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);
            var getCurveT = function getCurveT(x, y, curvePts) {
                var x0 = curvePts[4];
                var x1 = curvePts[2];
                var x2 = curvePts[0];
                var y0 = curvePts[5]; // var y1 = curvePts[ 3 ];
                var y2 = curvePts[1];
                var xMin = Math.min(x0, x2);
                var xMax = Math.max(x0, x2);
                var yMin = Math.min(y0, y2);
                var yMax = Math.max(y0, y2);
                if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
                    var coeff = bezierPtsToQuadCoeff(x0, x1, x2);
                    var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);
                    var validRoots = roots.filter(function(r) {
                        return 0 <= r && r <= 1;
                    });
                    if (validRoots.length > 0) return validRoots[0];
                }
                return null;
            };
            var curveRegions = Object.keys(barrelCurvePts);
            for(var i = 0; i < curveRegions.length; i++){
                var corner = curveRegions[i];
                var cornerPts = barrelCurvePts[corner];
                var t = getCurveT(x, y, cornerPts);
                if (t == null) continue;
                var y0 = cornerPts[5];
                var y1 = cornerPts[3];
                var y2 = cornerPts[1];
                var bezY = qbezierAt(y0, y1, y2, t);
                if (cornerPts.isTop && bezY <= y) return true;
                if (cornerPts.isBottom && y <= bezY) return true;
            }
            return false;
        }
    };
};
BRp$2.generateBottomRoundrectangle = function() {
    return this.nodeShapes["bottom-round-rectangle"] = this.nodeShapes["bottomroundrectangle"] = {
        renderer: this,
        name: "bottom-round-rectangle",
        points: generateUnitNgonPointsFitToSquare(4, 0),
        draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
        },
        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            var topStartX = nodeX - (width / 2 + padding);
            var topStartY = nodeY - (height / 2 + padding);
            var topEndY = topStartY;
            var topEndX = nodeX + (width / 2 + padding);
            var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
            if (topIntersections.length > 0) return topIntersections;
            return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
        },
        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            var cornerRadius = getRoundRectangleRadius(width, height);
            var diam = 2 * cornerRadius; // Check hBox
            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [
                0,
                -1
            ], padding)) return true;
             // Check vBox
            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [
                0,
                -1
            ], padding)) return true;
             // check non-rounded top side
            var outerWidth = width / 2 + 2 * padding;
            var outerHeight = height / 2 + 2 * padding;
            var points = [
                centerX - outerWidth,
                centerY - outerHeight,
                centerX - outerWidth,
                centerY,
                centerX + outerWidth,
                centerY,
                centerX + outerWidth,
                centerY - outerHeight
            ];
            if (pointInsidePolygonPoints(x, y, points)) return true;
             // Check bottom right quarter circle
            if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) return true;
             // Check bottom left quarter circle
            if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) return true;
            return false;
        }
    };
};
BRp$2.registerNodeShapes = function() {
    var nodeShapes = this.nodeShapes = {};
    var renderer = this;
    this.generateEllipse();
    this.generatePolygon("triangle", generateUnitNgonPointsFitToSquare(3, 0));
    this.generateRoundPolygon("round-triangle", generateUnitNgonPointsFitToSquare(3, 0));
    this.generatePolygon("rectangle", generateUnitNgonPointsFitToSquare(4, 0));
    nodeShapes["square"] = nodeShapes["rectangle"];
    this.generateRoundRectangle();
    this.generateCutRectangle();
    this.generateBarrel();
    this.generateBottomRoundrectangle();
    var diamondPoints = [
        0,
        1,
        1,
        0,
        0,
        -1,
        -1,
        0
    ];
    this.generatePolygon("diamond", diamondPoints);
    this.generateRoundPolygon("round-diamond", diamondPoints);
    this.generatePolygon("pentagon", generateUnitNgonPointsFitToSquare(5, 0));
    this.generateRoundPolygon("round-pentagon", generateUnitNgonPointsFitToSquare(5, 0));
    this.generatePolygon("hexagon", generateUnitNgonPointsFitToSquare(6, 0));
    this.generateRoundPolygon("round-hexagon", generateUnitNgonPointsFitToSquare(6, 0));
    this.generatePolygon("heptagon", generateUnitNgonPointsFitToSquare(7, 0));
    this.generateRoundPolygon("round-heptagon", generateUnitNgonPointsFitToSquare(7, 0));
    this.generatePolygon("octagon", generateUnitNgonPointsFitToSquare(8, 0));
    this.generateRoundPolygon("round-octagon", generateUnitNgonPointsFitToSquare(8, 0));
    var star5Points = new Array(20);
    var outerPoints = generateUnitNgonPoints(5, 0);
    var innerPoints = generateUnitNgonPoints(5, Math.PI / 5); // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;
    for(var i = 0; i < innerPoints.length / 2; i++){
        innerPoints[i * 2] *= innerRadius;
        innerPoints[i * 2 + 1] *= innerRadius;
    }
    for(var i = 0; i < 5; i++){
        star5Points[i * 4] = outerPoints[i * 2];
        star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];
        star5Points[i * 4 + 2] = innerPoints[i * 2];
        star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
    }
    star5Points = fitPolygonToSquare(star5Points);
    this.generatePolygon("star", star5Points);
    this.generatePolygon("vee", [
        -1,
        -1,
        0,
        -0.333,
        1,
        -1,
        0,
        1
    ]);
    this.generatePolygon("rhomboid", [
        -1,
        -1,
        0.333,
        -1,
        1,
        1,
        -0.333,
        1
    ]);
    this.nodeShapes["concavehexagon"] = this.generatePolygon("concave-hexagon", [
        -1,
        -0.95,
        -0.75,
        0,
        -1,
        0.95,
        1,
        0.95,
        0.75,
        0,
        1,
        -0.95
    ]);
    var tagPoints = [
        -1,
        -1,
        0.25,
        -1,
        1,
        0,
        0.25,
        1,
        -1,
        1
    ];
    this.generatePolygon("tag", tagPoints);
    this.generateRoundPolygon("round-tag", tagPoints);
    nodeShapes.makePolygon = function(points) {
        // use caching on user-specified polygons so they are as fast as native shapes
        var key = points.join("$");
        var name = "polygon-" + key;
        var shape;
        if (shape = this[name]) // got cached shape
        return shape;
         // create and cache new shape
        return renderer.generatePolygon(name, points);
    };
};
var BRp$1 = {};
BRp$1.timeToRender = function() {
    return this.redrawTotalTime / this.redrawCount;
};
BRp$1.redraw = function(options) {
    options = options || staticEmptyObject();
    var r = this;
    if (r.averageRedrawTime === undefined) r.averageRedrawTime = 0;
    if (r.lastRedrawTime === undefined) r.lastRedrawTime = 0;
    if (r.lastDrawTime === undefined) r.lastDrawTime = 0;
    r.requestedFrame = true;
    r.renderOptions = options;
};
BRp$1.beforeRender = function(fn, priority) {
    // the renderer can't add tick callbacks when destroyed
    if (this.destroyed) return;
    if (priority == null) error("Priority is not optional for beforeRender");
    var cbs = this.beforeRenderCallbacks;
    cbs.push({
        fn: fn,
        priority: priority
    }); // higher priority callbacks executed first
    cbs.sort(function(a, b) {
        return b.priority - a.priority;
    });
};
var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {
    var cbs = r.beforeRenderCallbacks;
    for(var i = 0; i < cbs.length; i++)cbs[i].fn(willDraw, startTime);
};
BRp$1.startRenderLoop = function() {
    var r = this;
    var cy = r.cy;
    if (r.renderLoopStarted) return;
    else r.renderLoopStarted = true;
    var renderFn = function renderFn(requestTime) {
        if (r.destroyed) return;
        if (cy.batching()) ;
        else if (r.requestedFrame && !r.skipFrame) {
            beforeRenderCallbacks(r, true, requestTime);
            var startTime = performanceNow();
            r.render(r.renderOptions);
            var endTime = r.lastDrawTime = performanceNow();
            if (r.averageRedrawTime === undefined) r.averageRedrawTime = endTime - startTime;
            if (r.redrawCount === undefined) r.redrawCount = 0;
            r.redrawCount++;
            if (r.redrawTotalTime === undefined) r.redrawTotalTime = 0;
            var duration = endTime - startTime;
            r.redrawTotalTime += duration;
            r.lastRedrawTime = duration; // use a weighted average with a bias from the previous average so we don't spike so easily
            r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;
            r.requestedFrame = false;
        } else beforeRenderCallbacks(r, false, requestTime);
        r.skipFrame = false;
        requestAnimationFrame(renderFn);
    };
    requestAnimationFrame(renderFn);
};
var BaseRenderer = function BaseRenderer(options) {
    this.init(options);
};
var BR = BaseRenderer;
var BRp = BR.prototype;
BRp.clientFunctions = [
    "redrawHint",
    "render",
    "renderTo",
    "matchCanvasSize",
    "nodeShapeImpl",
    "arrowShapeImpl"
];
BRp.init = function(options) {
    var r = this;
    r.options = options;
    r.cy = options.cy;
    var ctr = r.container = options.cy.container(); // prepend a stylesheet in the head such that
    if (window$1) {
        var document1 = window$1.document;
        var head = document1.head;
        var stylesheetId = "__________cytoscape_stylesheet";
        var className = "__________cytoscape_container";
        var stylesheetAlreadyExists = document1.getElementById(stylesheetId) != null;
        if (ctr.className.indexOf(className) < 0) ctr.className = (ctr.className || "") + " " + className;
        if (!stylesheetAlreadyExists) {
            var stylesheet = document1.createElement("style");
            stylesheet.id = stylesheetId;
            stylesheet.innerHTML = "." + className + " { position: relative; }";
            head.insertBefore(stylesheet, head.children[0]); // first so lowest priority
        }
        var computedStyle = window$1.getComputedStyle(ctr);
        var position = computedStyle.getPropertyValue("position");
        if (position === "static") warn("A Cytoscape container has style position:static and so can not use UI extensions properly");
    }
    r.selection = [
        undefined,
        undefined,
        undefined,
        undefined,
        0
    ]; // Coordinates for selection box, plus enabled flag
    r.bezierProjPcts = [
        0.05,
        0.225,
        0.4,
        0.5,
        0.6,
        0.775,
        0.95
    ]; //--Pointer-related data
    r.hoverData = {
        down: null,
        last: null,
        downTime: null,
        triggerMode: null,
        dragging: false,
        initialPan: [
            null,
            null
        ],
        capture: false
    };
    r.dragData = {
        possibleDragElements: []
    };
    r.touchData = {
        start: null,
        capture: false,
        // These 3 fields related to tap, taphold events
        startPosition: [
            null,
            null,
            null,
            null,
            null,
            null
        ],
        singleTouchStartTime: null,
        singleTouchMoved: true,
        now: [
            null,
            null,
            null,
            null,
            null,
            null
        ],
        earlier: [
            null,
            null,
            null,
            null,
            null,
            null
        ]
    };
    r.redraws = 0;
    r.showFps = options.showFps;
    r.debug = options.debug;
    r.hideEdgesOnViewport = options.hideEdgesOnViewport;
    r.textureOnViewport = options.textureOnViewport;
    r.wheelSensitivity = options.wheelSensitivity;
    r.motionBlurEnabled = options.motionBlur; // on by default
    r.forcedPixelRatio = number$1(options.pixelRatio) ? options.pixelRatio : null;
    r.motionBlur = options.motionBlur; // for initial kick off
    r.motionBlurOpacity = options.motionBlurOpacity;
    r.motionBlurTransparency = 1 - r.motionBlurOpacity;
    r.motionBlurPxRatio = 1;
    r.mbPxRBlurry = 1; //0.8;
    r.minMbLowQualFrames = 4;
    r.fullQualityMb = false;
    r.clearedForMotionBlur = [];
    r.desktopTapThreshold = options.desktopTapThreshold;
    r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
    r.touchTapThreshold = options.touchTapThreshold;
    r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
    r.tapholdDuration = 500;
    r.bindings = [];
    r.beforeRenderCallbacks = [];
    r.beforeRenderPriorities = {
        // higher priority execs before lower one
        animations: 400,
        eleCalcs: 300,
        eleTxrDeq: 200,
        lyrTxrDeq: 150,
        lyrTxrSkip: 100
    };
    r.registerNodeShapes();
    r.registerArrowShapes();
    r.registerCalculationListeners();
};
BRp.notify = function(eventName, eles) {
    var r = this;
    var cy = r.cy; // the renderer can't be notified after it's destroyed
    if (this.destroyed) return;
    if (eventName === "init") {
        r.load();
        return;
    }
    if (eventName === "destroy") {
        r.destroy();
        return;
    }
    if (eventName === "add" || eventName === "remove" || eventName === "move" && cy.hasCompoundNodes() || eventName === "load" || eventName === "zorder" || eventName === "mount") r.invalidateCachedZSortedEles();
    if (eventName === "viewport") r.redrawHint("select", true);
    if (eventName === "load" || eventName === "resize" || eventName === "mount") {
        r.invalidateContainerClientCoordsCache();
        r.matchCanvasSize(r.container);
    }
    r.redrawHint("eles", true);
    r.redrawHint("drag", true);
    this.startRenderLoop();
    this.redraw();
};
BRp.destroy = function() {
    var r = this;
    r.destroyed = true;
    r.cy.stopAnimationLoop();
    for(var i = 0; i < r.bindings.length; i++){
        var binding = r.bindings[i];
        var b = binding;
        var tgt = b.target;
        (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
    }
    r.bindings = [];
    r.beforeRenderCallbacks = [];
    r.onUpdateEleCalcsFns = [];
    if (r.removeObserver) r.removeObserver.disconnect();
    if (r.styleObserver) r.styleObserver.disconnect();
    if (r.resizeObserver) r.resizeObserver.disconnect();
    if (r.labelCalcDiv) try {
        document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef
    } catch (e) {}
};
BRp.isHeadless = function() {
    return false;
};
[
    BRp$f,
    BRp$5,
    BRp$4,
    BRp$3,
    BRp$2,
    BRp$1
].forEach(function(props) {
    extend(BRp, props);
});
var fullFpsTime = 1000 / 60; // assume 60 frames per second
var defs = {
    setupDequeueing: function setupDequeueing(opts) {
        return function setupDequeueingImpl() {
            var self = this;
            var r = this.renderer;
            if (self.dequeueingSetup) return;
            else self.dequeueingSetup = true;
            var queueRedraw = debounce__default["default"](function() {
                r.redrawHint("eles", true);
                r.redrawHint("drag", true);
                r.redraw();
            }, opts.deqRedrawThreshold);
            var dequeue = function dequeue(willDraw, frameStartTime) {
                var startTime = performanceNow();
                var avgRenderTime = r.averageRedrawTime;
                var renderTime = r.lastRedrawTime;
                var deqd = [];
                var extent = r.cy.extent();
                var pixelRatio = r.getPixelRatio(); // if we aren't in a tick that causes a draw, then the rendered style
                // queue won't automatically be flushed before dequeueing starts
                if (!willDraw) r.flushRenderedStyleQueue();
                while(true){
                    // eslint-disable-line no-constant-condition
                    var now = performanceNow();
                    var duration = now - startTime;
                    var frameDuration = now - frameStartTime;
                    if (renderTime < fullFpsTime) {
                        // if we're rendering faster than the ideal fps, then do dequeueing
                        // during all of the remaining frame time
                        var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);
                        if (frameDuration >= opts.deqFastCost * timeAvailable) break;
                    } else {
                        if (willDraw) {
                            if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) break;
                        } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) break;
                    }
                    var thisDeqd = opts.deq(self, pixelRatio, extent);
                    if (thisDeqd.length > 0) for(var i = 0; i < thisDeqd.length; i++)deqd.push(thisDeqd[i]);
                    else break;
                } // callbacks on dequeue
                if (deqd.length > 0) {
                    opts.onDeqd(self, deqd);
                    if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) queueRedraw();
                }
            };
            var priority = opts.priority || noop$1;
            r.beforeRender(dequeue, priority(self));
        };
    }
};
// Uses keys so elements may share the same cache.
var ElementTextureCacheLookup = /*#__PURE__*/ function() {
    function ElementTextureCacheLookup(getKey) {
        var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;
        _classCallCheck(this, ElementTextureCacheLookup);
        this.idsByKey = new Map$1();
        this.keyForId = new Map$1();
        this.cachesByLvl = new Map$1();
        this.lvls = [];
        this.getKey = getKey;
        this.doesEleInvalidateKey = doesEleInvalidateKey;
    }
    _createClass(ElementTextureCacheLookup, [
        {
            key: "getIdsFor",
            value: function getIdsFor(key) {
                if (key == null) error("Can not get id list for null key");
                var idsByKey = this.idsByKey;
                var ids = this.idsByKey.get(key);
                if (!ids) {
                    ids = new Set$1();
                    idsByKey.set(key, ids);
                }
                return ids;
            }
        },
        {
            key: "addIdForKey",
            value: function addIdForKey(key, id) {
                if (key != null) this.getIdsFor(key).add(id);
            }
        },
        {
            key: "deleteIdForKey",
            value: function deleteIdForKey(key, id) {
                if (key != null) this.getIdsFor(key)["delete"](id);
            }
        },
        {
            key: "getNumberOfIdsForKey",
            value: function getNumberOfIdsForKey(key) {
                if (key == null) return 0;
                else return this.getIdsFor(key).size;
            }
        },
        {
            key: "updateKeyMappingFor",
            value: function updateKeyMappingFor(ele) {
                var id = ele.id();
                var prevKey = this.keyForId.get(id);
                var currKey = this.getKey(ele);
                this.deleteIdForKey(prevKey, id);
                this.addIdForKey(currKey, id);
                this.keyForId.set(id, currKey);
            }
        },
        {
            key: "deleteKeyMappingFor",
            value: function deleteKeyMappingFor(ele) {
                var id = ele.id();
                var prevKey = this.keyForId.get(id);
                this.deleteIdForKey(prevKey, id);
                this.keyForId["delete"](id);
            }
        },
        {
            key: "keyHasChangedFor",
            value: function keyHasChangedFor(ele) {
                var id = ele.id();
                var prevKey = this.keyForId.get(id);
                var newKey = this.getKey(ele);
                return prevKey !== newKey;
            }
        },
        {
            key: "isInvalid",
            value: function isInvalid(ele) {
                return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);
            }
        },
        {
            key: "getCachesAt",
            value: function getCachesAt(lvl) {
                var cachesByLvl = this.cachesByLvl, lvls = this.lvls;
                var caches = cachesByLvl.get(lvl);
                if (!caches) {
                    caches = new Map$1();
                    cachesByLvl.set(lvl, caches);
                    lvls.push(lvl);
                }
                return caches;
            }
        },
        {
            key: "getCache",
            value: function getCache(key, lvl) {
                return this.getCachesAt(lvl).get(key);
            }
        },
        {
            key: "get",
            value: function get(ele, lvl) {
                var key = this.getKey(ele);
                var cache = this.getCache(key, lvl); // getting for an element may need to add to the id list b/c eles can share keys
                if (cache != null) this.updateKeyMappingFor(ele);
                return cache;
            }
        },
        {
            key: "getForCachedKey",
            value: function getForCachedKey(ele, lvl) {
                var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key
                var cache = this.getCache(key, lvl);
                return cache;
            }
        },
        {
            key: "hasCache",
            value: function hasCache(key, lvl) {
                return this.getCachesAt(lvl).has(key);
            }
        },
        {
            key: "has",
            value: function has(ele, lvl) {
                var key = this.getKey(ele);
                return this.hasCache(key, lvl);
            }
        },
        {
            key: "setCache",
            value: function setCache(key, lvl, cache) {
                cache.key = key;
                this.getCachesAt(lvl).set(key, cache);
            }
        },
        {
            key: "set",
            value: function set(ele, lvl, cache) {
                var key = this.getKey(ele);
                this.setCache(key, lvl, cache);
                this.updateKeyMappingFor(ele);
            }
        },
        {
            key: "deleteCache",
            value: function deleteCache(key, lvl) {
                this.getCachesAt(lvl)["delete"](key);
            }
        },
        {
            key: "delete",
            value: function _delete(ele, lvl) {
                var key = this.getKey(ele);
                this.deleteCache(key, lvl);
            }
        },
        {
            key: "invalidateKey",
            value: function invalidateKey(key) {
                var _this = this;
                this.lvls.forEach(function(lvl) {
                    return _this.deleteCache(key, lvl);
                });
            } // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)
        },
        {
            key: "invalidate",
            value: function invalidate(ele) {
                var id = ele.id();
                var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)
                this.deleteKeyMappingFor(ele);
                var entireKeyInvalidated = this.doesEleInvalidateKey(ele);
                if (entireKeyInvalidated) // clear mapping for current key
                this.invalidateKey(key);
                return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;
            }
        }
    ]);
    return ElementTextureCacheLookup;
}();
var minTxrH = 25; // the size of the texture cache for small height eles (special case)
var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up
var minLvl$1 = -4; // when scaling smaller than that we don't need to re-render
var maxLvl$1 = 3; // when larger than this scale just render directly (caching is not helpful)
var maxZoom$1 = 7.99; // beyond this zoom level, layered textures are not used
var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps
var defTxrWidth = 1024; // default/minimum texture width
var maxTxrW = 1024; // the maximum width of a texture
var maxTxrH = 1024; // the maximum height of a texture
var minUtility = 0.2; // if usage of texture is less than this, it is retired
var maxFullness = 0.8; // fullness of texture after which queue removal is checked
var maxFullnessChecks = 10; // dequeued after this many checks
var deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost$1 = 0.9; // % of frame time to be used when >60fps
var deqRedrawThreshold$1 = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch
var getTxrReasons = {
    dequeue: "dequeue",
    downscale: "downscale",
    highQuality: "highQuality"
};
var initDefaults = defaults$g({
    getKey: null,
    doesEleInvalidateKey: falsify,
    drawElement: null,
    getBoundingBox: null,
    getRotationPoint: null,
    getRotationOffset: null,
    isVisible: trueify,
    allowEdgeTxrCaching: true,
    allowParentTxrCaching: true
});
var ElementTextureCache = function ElementTextureCache(renderer, initOptions) {
    var self = this;
    self.renderer = renderer;
    self.onDequeues = [];
    var opts = initDefaults(initOptions);
    extend(self, opts);
    self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);
    self.setupDequeueing();
};
var ETCp = ElementTextureCache.prototype;
ETCp.reasons = getTxrReasons; // the list of textures in which new subtextures for elements can be placed
ETCp.getTextureQueue = function(txrH) {
    var self = this;
    self.eleImgCaches = self.eleImgCaches || {};
    return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];
}; // the list of usused textures which can be recycled (in use in texture queue)
ETCp.getRetiredTextureQueue = function(txrH) {
    var self = this;
    var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
    var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];
    return rtxtrQ;
}; // queue of element draw requests at different scale levels
ETCp.getElementQueue = function() {
    var self = this;
    var q = self.eleCacheQueue = self.eleCacheQueue || new Heap__default["default"](function(a, b) {
        return b.reqs - a.reqs;
    });
    return q;
}; // queue of element draw requests at different scale levels (element id lookup)
ETCp.getElementKeyToQueue = function() {
    var self = this;
    var k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};
    return k2q;
};
ETCp.getElement = function(ele, bb, pxRatio, lvl, reason) {
    var self = this;
    var r = this.renderer;
    var zoom = r.cy.zoom();
    var lookup = this.lookup;
    if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) return null;
    if (!self.allowEdgeTxrCaching && ele.isEdge() || !self.allowParentTxrCaching && ele.isParent()) return null;
    if (lvl == null) lvl = Math.ceil(log2(zoom * pxRatio));
    if (lvl < minLvl$1) lvl = minLvl$1;
    else if (zoom >= maxZoom$1 || lvl > maxLvl$1) return null;
    var scale = Math.pow(2, lvl);
    var eleScaledH = bb.h * scale;
    var eleScaledW = bb.w * scale;
    var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);
    if (!this.isVisible(ele, scaledLabelShown)) return null;
    var eleCache = lookup.get(ele, lvl); // if this get was on an unused/invalidated cache, then restore the texture usage metric
    if (eleCache && eleCache.invalidated) {
        eleCache.invalidated = false;
        eleCache.texture.invalidatedWidth -= eleCache.width;
    }
    if (eleCache) return eleCache;
    var txrH; // which texture height this ele belongs to
    if (eleScaledH <= minTxrH) txrH = minTxrH;
    else if (eleScaledH <= txrStepH) txrH = txrStepH;
    else txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
    if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) return null; // caching large elements is not efficient
    var txrQ = self.getTextureQueue(txrH); // first try the second last one in case it has space at the end
    var txr = txrQ[txrQ.length - 2];
    var addNewTxr = function addNewTxr() {
        return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);
    }; // try the last one if there is no second last one
    if (!txr) txr = txrQ[txrQ.length - 1];
     // if the last one doesn't exist, we need a first one
    if (!txr) txr = addNewTxr();
     // if there's no room in the current texture, we need a new one
    if (txr.width - txr.usedWidth < eleScaledW) txr = addNewTxr();
    var scalableFrom = function scalableFrom(otherCache) {
        return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
    };
    var deqing = reason && reason === getTxrReasons.dequeue;
    var highQualityReq = reason && reason === getTxrReasons.highQuality;
    var downscaleReq = reason && reason === getTxrReasons.downscale;
    var higherCache; // the nearest cache with a higher level
    for(var l = lvl + 1; l <= maxLvl$1; l++){
        var c = lookup.get(ele, l);
        if (c) {
            higherCache = c;
            break;
        }
    }
    var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;
    var downscale = function downscale() {
        txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
    }; // reset ele area in texture
    txr.context.setTransform(1, 0, 0, 1, 0, 0);
    txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);
    if (scalableFrom(oneUpCache)) // then we can relatively cheaply rescale the existing image w/o rerendering
    downscale();
    else if (scalableFrom(higherCache)) {
        // then use the higher cache for now and queue the next level down
        // to cheaply scale towards the smaller level
        if (highQualityReq) {
            for(var _l = higherCache.level; _l > lvl; _l--)oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);
            downscale();
        } else {
            self.queueElement(ele, higherCache.level - 1);
            return higherCache;
        }
    } else {
        var lowerCache; // the nearest cache with a lower level
        if (!deqing && !highQualityReq && !downscaleReq) for(var _l2 = lvl - 1; _l2 >= minLvl$1; _l2--){
            var _c = lookup.get(ele, _l2);
            if (_c) {
                lowerCache = _c;
                break;
            }
        }
        if (scalableFrom(lowerCache)) {
            // then use the lower quality cache for now and queue the better one for later
            self.queueElement(ele, lvl);
            return lowerCache;
        }
        txr.context.translate(txr.usedWidth, 0);
        txr.context.scale(scale, scale);
        this.drawElement(txr.context, ele, bb, scaledLabelShown, false);
        txr.context.scale(1 / scale, 1 / scale);
        txr.context.translate(-txr.usedWidth, 0);
    }
    eleCache = {
        x: txr.usedWidth,
        texture: txr,
        level: lvl,
        scale: scale,
        width: eleScaledW,
        height: eleScaledH,
        scaledLabelShown: scaledLabelShown
    };
    txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);
    txr.eleCaches.push(eleCache);
    lookup.set(ele, lvl, eleCache);
    self.checkTextureFullness(txr);
    return eleCache;
};
ETCp.invalidateElements = function(eles) {
    for(var i = 0; i < eles.length; i++)this.invalidateElement(eles[i]);
};
ETCp.invalidateElement = function(ele) {
    var self = this;
    var lookup = self.lookup;
    var caches = [];
    var invalid = lookup.isInvalid(ele);
    if (!invalid) return; // override the invalidation request if the element key has not changed
    for(var lvl = minLvl$1; lvl <= maxLvl$1; lvl++){
        var cache = lookup.getForCachedKey(ele, lvl);
        if (cache) caches.push(cache);
    }
    var noOtherElesUseCache = lookup.invalidate(ele);
    if (noOtherElesUseCache) for(var i = 0; i < caches.length; i++){
        var _cache = caches[i];
        var txr = _cache.texture; // remove space from the texture it belongs to
        txr.invalidatedWidth += _cache.width; // mark the cache as invalidated
        _cache.invalidated = true; // retire the texture if its utility is low
        self.checkTextureUtility(txr);
    }
     // remove from queue since the old req was for the old state
    self.removeFromQueue(ele);
};
ETCp.checkTextureUtility = function(txr) {
    // invalidate all entries in the cache if the cache size is small
    if (txr.invalidatedWidth >= minUtility * txr.width) this.retireTexture(txr);
};
ETCp.checkTextureFullness = function(txr) {
    // if texture has been mostly filled and passed over several times, remove
    // it from the queue so we don't need to waste time looking at it to put new things
    var self = this;
    var txrQ = self.getTextureQueue(txr.height);
    if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) removeFromArray(txrQ, txr);
    else txr.fullnessChecks++;
};
ETCp.retireTexture = function(txr) {
    var self = this;
    var txrH = txr.height;
    var txrQ = self.getTextureQueue(txrH);
    var lookup = this.lookup; // retire the texture from the active / searchable queue:
    removeFromArray(txrQ, txr);
    txr.retired = true; // remove the refs from the eles to the caches:
    var eleCaches = txr.eleCaches;
    for(var i = 0; i < eleCaches.length; i++){
        var eleCache = eleCaches[i];
        lookup.deleteCache(eleCache.key, eleCache.level);
    }
    clearArray(eleCaches); // add the texture to a retired queue so it can be recycled in future:
    var rtxtrQ = self.getRetiredTextureQueue(txrH);
    rtxtrQ.push(txr);
};
ETCp.addTexture = function(txrH, minW) {
    var self = this;
    var txrQ = self.getTextureQueue(txrH);
    var txr = {};
    txrQ.push(txr);
    txr.eleCaches = [];
    txr.height = txrH;
    txr.width = Math.max(defTxrWidth, minW);
    txr.usedWidth = 0;
    txr.invalidatedWidth = 0;
    txr.fullnessChecks = 0;
    txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);
    txr.context = txr.canvas.getContext("2d");
    return txr;
};
ETCp.recycleTexture = function(txrH, minW) {
    var self = this;
    var txrQ = self.getTextureQueue(txrH);
    var rtxtrQ = self.getRetiredTextureQueue(txrH);
    for(var i = 0; i < rtxtrQ.length; i++){
        var txr = rtxtrQ[i];
        if (txr.width >= minW) {
            txr.retired = false;
            txr.usedWidth = 0;
            txr.invalidatedWidth = 0;
            txr.fullnessChecks = 0;
            clearArray(txr.eleCaches);
            txr.context.setTransform(1, 0, 0, 1, 0, 0);
            txr.context.clearRect(0, 0, txr.width, txr.height);
            removeFromArray(rtxtrQ, txr);
            txrQ.push(txr);
            return txr;
        }
    }
};
ETCp.queueElement = function(ele, lvl) {
    var self = this;
    var q = self.getElementQueue();
    var k2q = self.getElementKeyToQueue();
    var key = this.getKey(ele);
    var existingReq = k2q[key];
    if (existingReq) {
        // use the max lvl b/c in between lvls are cheap to make
        existingReq.level = Math.max(existingReq.level, lvl);
        existingReq.eles.merge(ele);
        existingReq.reqs++;
        q.updateItem(existingReq);
    } else {
        var req = {
            eles: ele.spawn().merge(ele),
            level: lvl,
            reqs: 1,
            key: key
        };
        q.push(req);
        k2q[key] = req;
    }
};
ETCp.dequeue = function(pxRatio) {
    var self = this;
    var q = self.getElementQueue();
    var k2q = self.getElementKeyToQueue();
    var dequeued = [];
    var lookup = self.lookup;
    for(var i = 0; i < maxDeqSize$1; i++){
        if (q.size() > 0) {
            var req = q.pop();
            var key = req.key;
            var ele = req.eles[0]; // all eles have the same key
            var cacheExists = lookup.hasCache(ele, req.level); // clear out the key to req lookup
            k2q[key] = null; // dequeueing isn't necessary with an existing cache
            if (cacheExists) continue;
            dequeued.push(req);
            var bb = self.getBoundingBox(ele);
            self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
        } else break;
    }
    return dequeued;
};
ETCp.removeFromQueue = function(ele) {
    var self = this;
    var q = self.getElementQueue();
    var k2q = self.getElementKeyToQueue();
    var key = this.getKey(ele);
    var req = k2q[key];
    if (req != null) {
        if (req.eles.length === 1) {
            // remove if last ele in the req
            // bring to front of queue
            req.reqs = MAX_INT$1;
            q.updateItem(req);
            q.pop(); // remove from queue
            k2q[key] = null; // remove from lookup map
        } else // otherwise just remove ele from req
        req.eles.unmerge(ele);
    }
};
ETCp.onDequeue = function(fn) {
    this.onDequeues.push(fn);
};
ETCp.offDequeue = function(fn) {
    removeFromArray(this.onDequeues, fn);
};
ETCp.setupDequeueing = defs.setupDequeueing({
    deqRedrawThreshold: deqRedrawThreshold$1,
    deqCost: deqCost$1,
    deqAvgCost: deqAvgCost$1,
    deqNoDrawCost: deqNoDrawCost$1,
    deqFastCost: deqFastCost$1,
    deq: function deq(self, pxRatio, extent) {
        return self.dequeue(pxRatio, extent);
    },
    onDeqd: function onDeqd(self, deqd) {
        for(var i = 0; i < self.onDequeues.length; i++){
            var fn = self.onDequeues[i];
            fn(deqd);
        }
    },
    shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {
        for(var i = 0; i < deqd.length; i++){
            var eles = deqd[i].eles;
            for(var j = 0; j < eles.length; j++){
                var bb = eles[j].boundingBox();
                if (boundingBoxesIntersect(bb, extent)) return true;
            }
        }
        return false;
    },
    priority: function priority(self) {
        return self.renderer.beforeRenderPriorities.eleTxrDeq;
    }
});
var defNumLayers = 1; // default number of layers to use
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch
var invalidThreshold = 250; // time threshold for disabling b/c of invalidations
var maxLayerArea = 16000000; // layers can't be bigger than this
var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)
// var log = function(){ console.log.apply( console, arguments ); };
var LayeredTextureCache = function LayeredTextureCache(renderer) {
    var self = this;
    var r = self.renderer = renderer;
    var cy = r.cy;
    self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]
    self.firstGet = true;
    self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;
    self.skipping = false;
    self.eleTxrDeqs = cy.collection();
    self.scheduleElementRefinement = debounce__default["default"](function() {
        self.refineElementTextures(self.eleTxrDeqs);
        self.eleTxrDeqs.unmerge(self.eleTxrDeqs);
    }, refineEleDebounceTime);
    r.beforeRender(function(willDraw, now) {
        if (now - self.lastInvalidationTime <= invalidThreshold) self.skipping = true;
        else self.skipping = false;
    }, r.beforeRenderPriorities.lyrTxrSkip);
    var qSort = function qSort(a, b) {
        return b.reqs - a.reqs;
    };
    self.layersQueue = new Heap__default["default"](qSort);
    self.setupDequeueing();
};
var LTCp = LayeredTextureCache.prototype;
var layerIdPool = 0;
var MAX_INT = Math.pow(2, 53) - 1;
LTCp.makeLayer = function(bb, lvl) {
    var scale = Math.pow(2, lvl);
    var w = Math.ceil(bb.w * scale);
    var h = Math.ceil(bb.h * scale);
    var canvas = this.renderer.makeOffscreenCanvas(w, h);
    var layer = {
        id: layerIdPool = ++layerIdPool % MAX_INT,
        bb: bb,
        level: lvl,
        width: w,
        height: h,
        canvas: canvas,
        context: canvas.getContext("2d"),
        eles: [],
        elesQueue: [],
        reqs: 0
    }; // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);
    var cxt = layer.context;
    var dx = -layer.bb.x1;
    var dy = -layer.bb.y1; // do the transform on creation to save cycles (it's the same for all eles)
    cxt.scale(scale, scale);
    cxt.translate(dx, dy);
    return layer;
};
LTCp.getLayers = function(eles, pxRatio, lvl) {
    var self = this;
    var r = self.renderer;
    var cy = r.cy;
    var zoom = cy.zoom();
    var firstGet = self.firstGet;
    self.firstGet = false; // log('--\nget layers with %s eles', eles.length);
    //log eles.map(function(ele){ return ele.id() }) );
    if (lvl == null) {
        lvl = Math.ceil(log2(zoom * pxRatio));
        if (lvl < minLvl) lvl = minLvl;
        else if (zoom >= maxZoom || lvl > maxLvl) return null;
    }
    self.validateLayersElesOrdering(lvl, eles);
    var layersByLvl = self.layersByLevel;
    var scale = Math.pow(2, lvl);
    var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
    var bb;
    var lvlComplete = self.levelIsComplete(lvl, eles);
    var tmpLayers;
    var checkTempLevels = function checkTempLevels() {
        var canUseAsTmpLvl = function canUseAsTmpLvl(l) {
            self.validateLayersElesOrdering(l, eles);
            if (self.levelIsComplete(l, eles)) {
                tmpLayers = layersByLvl[l];
                return true;
            }
        };
        var checkLvls = function checkLvls(dir) {
            if (tmpLayers) return;
            for(var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir){
                if (canUseAsTmpLvl(l)) break;
            }
        };
        checkLvls(1);
        checkLvls(-1); // remove the invalid layers; they will be replaced as needed later in this function
        for(var i = layers.length - 1; i >= 0; i--){
            var layer = layers[i];
            if (layer.invalid) removeFromArray(layers, layer);
        }
    };
    if (!lvlComplete) // if the current level is incomplete, then use the closest, best quality layerset temporarily
    // and later queue the current layerset so we can get the proper quality level soon
    checkTempLevels();
    else // log('level complete, using existing layers\n--');
    return layers;
    var getBb = function getBb() {
        if (!bb) {
            bb = makeBoundingBox();
            for(var i = 0; i < eles.length; i++)updateBoundingBox(bb, eles[i].boundingBox());
        }
        return bb;
    };
    var makeLayer = function makeLayer(opts) {
        opts = opts || {};
        var after = opts.after;
        getBb();
        var area = bb.w * scale * (bb.h * scale);
        if (area > maxLayerArea) return null;
        var layer = self.makeLayer(bb, lvl);
        if (after != null) {
            var index = layers.indexOf(after) + 1;
            layers.splice(index, 0, layer);
        } else if (opts.insert === undefined || opts.insert) // no after specified => first layer made so put at start
        layers.unshift(layer);
         // if( tmpLayers ){
        //self.queueLayer( layer );
        // }
        return layer;
    };
    if (self.skipping && !firstGet) // log('skip layers');
    return null;
     // log('do layers');
    var layer = null;
    var maxElesPerLayer = eles.length / defNumLayers;
    var allowLazyQueueing = !firstGet;
    for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        var rs = ele._private.rscratch;
        var caches = rs.imgLayerCaches = rs.imgLayerCaches || {}; // log('look at ele', ele.id());
        var existingLayer = caches[lvl];
        if (existingLayer) {
            // reuse layer for later eles
            // log('reuse layer for', ele.id());
            layer = existingLayer;
            continue;
        }
        if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
            // log('make new layer for ele %s', ele.id());
            layer = makeLayer({
                insert: true,
                after: layer
            }); // if now layer can be built then we can't use layers at this level
            if (!layer) return null;
             // log('new layer with id %s', layer.id);
        }
        if (tmpLayers || allowLazyQueueing) // log('queue ele %s in layer %s', ele.id(), layer.id);
        self.queueLayer(layer, ele);
        else // log('draw ele %s in layer %s', ele.id(), layer.id);
        self.drawEleInLayer(layer, ele, lvl, pxRatio);
        layer.eles.push(ele);
        caches[lvl] = layer;
    } // log('--');
    if (tmpLayers) // then we only queued the current layerset and can't draw it yet
    return tmpLayers;
    if (allowLazyQueueing) // log('lazy queue level', lvl);
    return null;
    return layers;
}; // a layer may want to use an ele cache of a higher level to avoid blurriness
// so the layer level might not equal the ele level
LTCp.getEleLevelForLayerLevel = function(lvl, pxRatio) {
    return lvl;
};
LTCp.drawEleInLayer = function(layer, ele, lvl, pxRatio) {
    var self = this;
    var r = this.renderer;
    var context = layer.context;
    var bb = ele.boundingBox();
    if (bb.w === 0 || bb.h === 0 || !ele.visible()) return;
    lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);
    r.setImgSmoothing(context, false);
    r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);
    r.setImgSmoothing(context, true);
};
LTCp.levelIsComplete = function(lvl, eles) {
    var self = this;
    var layers = self.layersByLevel[lvl];
    if (!layers || layers.length === 0) return false;
    var numElesInLayers = 0;
    for(var i = 0; i < layers.length; i++){
        var layer = layers[i]; // if there are any eles needed to be drawn yet, the level is not complete
        if (layer.reqs > 0) return false;
         // if the layer is invalid, the level is not complete
        if (layer.invalid) return false;
        numElesInLayers += layer.eles.length;
    } // we should have exactly the number of eles passed in to be complete
    if (numElesInLayers !== eles.length) return false;
    return true;
};
LTCp.validateLayersElesOrdering = function(lvl, eles) {
    var layers = this.layersByLevel[lvl];
    if (!layers) return;
     // if in a layer the eles are not in the same order, then the layer is invalid
    // (i.e. there is an ele in between the eles in the layer)
    for(var i = 0; i < layers.length; i++){
        var layer = layers[i];
        var offset = -1; // find the offset
        for(var j = 0; j < eles.length; j++)if (layer.eles[0] === eles[j]) {
            offset = j;
            break;
        }
        if (offset < 0) {
            // then the layer has nonexistant elements and is invalid
            this.invalidateLayer(layer);
            continue;
        } // the eles in the layer must be in the same continuous order, else the layer is invalid
        var o = offset;
        for(var j = 0; j < layer.eles.length; j++)if (layer.eles[j] !== eles[o + j]) {
            // log('invalidate based on ordering', layer.id);
            this.invalidateLayer(layer);
            break;
        }
    }
};
LTCp.updateElementsInLayers = function(eles, update) {
    var self = this;
    var isEles = element(eles[0]); // collect udpated elements (cascaded from the layers) and update each
    // layer itself along the way
    for(var i = 0; i < eles.length; i++){
        var req = isEles ? null : eles[i];
        var ele = isEles ? eles[i] : eles[i].ele;
        var rs = ele._private.rscratch;
        var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};
        for(var l = minLvl; l <= maxLvl; l++){
            var layer = caches[l];
            if (!layer) continue;
             // if update is a request from the ele cache, then it affects only
            // the matching level
            if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) continue;
            update(layer, ele, req);
        }
    }
};
LTCp.haveLayers = function() {
    var self = this;
    var haveLayers = false;
    for(var l = minLvl; l <= maxLvl; l++){
        var layers = self.layersByLevel[l];
        if (layers && layers.length > 0) {
            haveLayers = true;
            break;
        }
    }
    return haveLayers;
};
LTCp.invalidateElements = function(eles) {
    var self = this;
    if (eles.length === 0) return;
    self.lastInvalidationTime = performanceNow(); // log('update invalidate layer time from eles');
    if (eles.length === 0 || !self.haveLayers()) return;
    self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {
        self.invalidateLayer(layer);
    });
};
LTCp.invalidateLayer = function(layer) {
    // log('update invalidate layer time');
    this.lastInvalidationTime = performanceNow();
    if (layer.invalid) return;
     // save cycles
    var lvl = layer.level;
    var eles = layer.eles;
    var layers = this.layersByLevel[lvl]; // log('invalidate layer', layer.id );
    removeFromArray(layers, layer); // layer.eles = [];
    layer.elesQueue = [];
    layer.invalid = true;
    if (layer.replacement) layer.replacement.invalid = true;
    for(var i = 0; i < eles.length; i++){
        var caches = eles[i]._private.rscratch.imgLayerCaches;
        if (caches) caches[lvl] = null;
    }
};
LTCp.refineElementTextures = function(eles) {
    var self = this; // log('refine', eles.length);
    self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {
        var rLyr = layer.replacement;
        if (!rLyr) {
            rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);
            rLyr.replaces = layer;
            rLyr.eles = layer.eles; // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
        }
        if (!rLyr.reqs) for(var i = 0; i < rLyr.eles.length; i++)self.queueLayer(rLyr, rLyr.eles[i]);
         // log('queue replacement layer refinement', rLyr.id);
    });
};
LTCp.enqueueElementRefinement = function(ele) {
    this.eleTxrDeqs.merge(ele);
    this.scheduleElementRefinement();
};
LTCp.queueLayer = function(layer, ele) {
    var self = this;
    var q = self.layersQueue;
    var elesQ = layer.elesQueue;
    var hasId = elesQ.hasId = elesQ.hasId || {}; // if a layer is going to be replaced, queuing is a waste of time
    if (layer.replacement) return;
    if (ele) {
        if (hasId[ele.id()]) return;
        elesQ.push(ele);
        hasId[ele.id()] = true;
    }
    if (layer.reqs) {
        layer.reqs++;
        q.updateItem(layer);
    } else {
        layer.reqs = 1;
        q.push(layer);
    }
};
LTCp.dequeue = function(pxRatio) {
    var self = this;
    var q = self.layersQueue;
    var deqd = [];
    var eleDeqs = 0;
    while(eleDeqs < maxDeqSize){
        if (q.size() === 0) break;
        var layer = q.peek(); // if a layer has been or will be replaced, then don't waste time with it
        if (layer.replacement) {
            // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
            q.pop();
            continue;
        } // if this is a replacement layer that has been superceded, then forget it
        if (layer.replaces && layer !== layer.replaces.replacement) {
            // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
            q.pop();
            continue;
        }
        if (layer.invalid) {
            // log('replacement layer %s is invalid; dequeued', layer.id);
            q.pop();
            continue;
        }
        var ele = layer.elesQueue.shift();
        if (ele) {
            // log('dequeue layer %s', layer.id);
            self.drawEleInLayer(layer, ele, layer.level, pxRatio);
            eleDeqs++;
        }
        if (deqd.length === 0) // we need only one entry in deqd to queue redrawing etc
        deqd.push(true);
         // if the layer has all its eles done, then remove from the queue
        if (layer.elesQueue.length === 0) {
            q.pop();
            layer.reqs = 0; // log('dequeue of layer %s complete', layer.id);
            // when a replacement layer is dequeued, it replaces the old layer in the level
            if (layer.replaces) self.applyLayerReplacement(layer);
            self.requestRedraw();
        }
    }
    return deqd;
};
LTCp.applyLayerReplacement = function(layer) {
    var self = this;
    var layersInLevel = self.layersByLevel[layer.level];
    var replaced = layer.replaces;
    var index = layersInLevel.indexOf(replaced); // if the replaced layer is not in the active list for the level, then replacing
    // refs would be a mistake (i.e. overwriting the true active layer)
    if (index < 0 || replaced.invalid) // log('replacement layer would have no effect', layer.id);
    return;
    layersInLevel[index] = layer; // replace level ref
    // replace refs in eles
    for(var i = 0; i < layer.eles.length; i++){
        var _p = layer.eles[i]._private;
        var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};
        if (cache) cache[layer.level] = layer;
    } // log('apply replacement layer %s over %s', layer.id, replaced.id);
    self.requestRedraw();
};
LTCp.requestRedraw = debounce__default["default"](function() {
    var r = this.renderer;
    r.redrawHint("eles", true);
    r.redrawHint("drag", true);
    r.redraw();
}, 100);
LTCp.setupDequeueing = defs.setupDequeueing({
    deqRedrawThreshold: deqRedrawThreshold,
    deqCost: deqCost,
    deqAvgCost: deqAvgCost,
    deqNoDrawCost: deqNoDrawCost,
    deqFastCost: deqFastCost,
    deq: function deq(self, pxRatio) {
        return self.dequeue(pxRatio);
    },
    onDeqd: noop$1,
    shouldRedraw: trueify,
    priority: function priority(self) {
        return self.renderer.beforeRenderPriorities.lyrTxrDeq;
    }
});
var CRp$a = {};
var impl;
function polygon(context, points) {
    for(var i = 0; i < points.length; i++){
        var pt = points[i];
        context.lineTo(pt.x, pt.y);
    }
}
function triangleBackcurve(context, points, controlPoint) {
    var firstPt;
    for(var i = 0; i < points.length; i++){
        var pt = points[i];
        if (i === 0) firstPt = pt;
        context.lineTo(pt.x, pt.y);
    }
    context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
}
function triangleTee(context, trianglePoints, teePoints) {
    if (context.beginPath) context.beginPath();
    var triPts = trianglePoints;
    for(var i = 0; i < triPts.length; i++){
        var pt = triPts[i];
        context.lineTo(pt.x, pt.y);
    }
    var teePts = teePoints;
    var firstTeePt = teePoints[0];
    context.moveTo(firstTeePt.x, firstTeePt.y);
    for(var i = 1; i < teePts.length; i++){
        var pt = teePts[i];
        context.lineTo(pt.x, pt.y);
    }
    if (context.closePath) context.closePath();
}
function circleTriangle(context, trianglePoints, rx, ry, r) {
    if (context.beginPath) context.beginPath();
    context.arc(rx, ry, r, 0, Math.PI * 2, false);
    var triPts = trianglePoints;
    var firstTrPt = triPts[0];
    context.moveTo(firstTrPt.x, firstTrPt.y);
    for(var i = 0; i < triPts.length; i++){
        var pt = triPts[i];
        context.lineTo(pt.x, pt.y);
    }
    if (context.closePath) context.closePath();
}
function circle(context, rx, ry, r) {
    context.arc(rx, ry, r, 0, Math.PI * 2, false);
}
CRp$a.arrowShapeImpl = function(name) {
    return (impl || (impl = {
        "polygon": polygon,
        "triangle-backcurve": triangleBackcurve,
        "triangle-tee": triangleTee,
        "circle-triangle": circleTriangle,
        "triangle-cross": triangleTee,
        "circle": circle
    }))[name];
};
var CRp$9 = {};
CRp$9.drawElement = function(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {
    var r = this;
    if (ele.isNode()) r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
    else r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
};
CRp$9.drawElementOverlay = function(context, ele) {
    var r = this;
    if (ele.isNode()) r.drawNodeOverlay(context, ele);
    else r.drawEdgeOverlay(context, ele);
};
CRp$9.drawElementUnderlay = function(context, ele) {
    var r = this;
    if (ele.isNode()) r.drawNodeUnderlay(context, ele);
    else r.drawEdgeUnderlay(context, ele);
};
CRp$9.drawCachedElementPortion = function(context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {
    var r = this;
    var bb = eleTxrCache.getBoundingBox(ele);
    if (bb.w === 0 || bb.h === 0) return;
     // ignore zero size case
    var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);
    if (eleCache != null) {
        var opacity = getOpacity(r, ele);
        if (opacity === 0) return;
        var theta = getRotation(r, ele);
        var x1 = bb.x1, y1 = bb.y1, w = bb.w, h = bb.h;
        var x, y, sx, sy, smooth;
        if (theta !== 0) {
            var rotPt = eleTxrCache.getRotationPoint(ele);
            sx = rotPt.x;
            sy = rotPt.y;
            context.translate(sx, sy);
            context.rotate(theta);
            smooth = r.getImgSmoothing(context);
            if (!smooth) r.setImgSmoothing(context, true);
            var off = eleTxrCache.getRotationOffset(ele);
            x = off.x;
            y = off.y;
        } else {
            x = x1;
            y = y1;
        }
        var oldGlobalAlpha;
        if (opacity !== 1) {
            oldGlobalAlpha = context.globalAlpha;
            context.globalAlpha = oldGlobalAlpha * opacity;
        }
        context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);
        if (opacity !== 1) context.globalAlpha = oldGlobalAlpha;
        if (theta !== 0) {
            context.rotate(-theta);
            context.translate(-sx, -sy);
            if (!smooth) r.setImgSmoothing(context, false);
        }
    } else eleTxrCache.drawElement(context, ele); // direct draw fallback
};
var getZeroRotation = function getZeroRotation() {
    return 0;
};
var getLabelRotation = function getLabelRotation(r, ele) {
    return r.getTextAngle(ele, null);
};
var getSourceLabelRotation = function getSourceLabelRotation(r, ele) {
    return r.getTextAngle(ele, "source");
};
var getTargetLabelRotation = function getTargetLabelRotation(r, ele) {
    return r.getTextAngle(ele, "target");
};
var getOpacity = function getOpacity(r, ele) {
    return ele.effectiveOpacity();
};
var getTextOpacity = function getTextOpacity(e, ele) {
    return ele.pstyle("text-opacity").pfValue * ele.effectiveOpacity();
};
CRp$9.drawCachedElement = function(context, ele, pxRatio, extent, lvl, requestHighQuality) {
    var r = this;
    var _r$data = r.data, eleTxrCache = _r$data.eleTxrCache, lblTxrCache = _r$data.lblTxrCache, slbTxrCache = _r$data.slbTxrCache, tlbTxrCache = _r$data.tlbTxrCache;
    var bb = ele.boundingBox();
    var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;
    if (bb.w === 0 || bb.h === 0 || !ele.visible()) return;
    if (!extent || boundingBoxesIntersect(bb, extent)) {
        var isEdge = ele.isEdge();
        var badLine = ele.element()._private.rscratch.badLine;
        r.drawElementUnderlay(context, ele);
        r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);
        if (!isEdge || !badLine) r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);
        if (isEdge && !badLine) {
            r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);
            r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);
        }
        r.drawElementOverlay(context, ele);
    }
};
CRp$9.drawElements = function(context, eles) {
    var r = this;
    for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        r.drawElement(context, ele);
    }
};
CRp$9.drawCachedElements = function(context, eles, pxRatio, extent) {
    var r = this;
    for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        r.drawCachedElement(context, ele, pxRatio, extent);
    }
};
CRp$9.drawCachedNodes = function(context, eles, pxRatio, extent) {
    var r = this;
    for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        if (!ele.isNode()) continue;
        r.drawCachedElement(context, ele, pxRatio, extent);
    }
};
CRp$9.drawLayeredElements = function(context, eles, pxRatio, extent) {
    var r = this;
    var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);
    if (layers) for(var i = 0; i < layers.length; i++){
        var layer = layers[i];
        var bb = layer.bb;
        if (bb.w === 0 || bb.h === 0) continue;
        context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
    }
    else // fall back on plain caching if no layers
    r.drawCachedElements(context, eles, pxRatio, extent);
};
/* global Path2D */ var CRp$8 = {};
CRp$8.drawEdge = function(context, edge, shiftToOriginWithBb) {
    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var r = this;
    var rs = edge._private.rscratch;
    if (shouldDrawOpacity && !edge.visible()) return;
     // if bezier ctrl pts can not be calculated, then die
    if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) // isNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
    var bb;
    if (shiftToOriginWithBb) {
        bb = shiftToOriginWithBb;
        context.translate(-bb.x1, -bb.y1);
    }
    var opacity = shouldDrawOpacity ? edge.pstyle("opacity").value : 1;
    var lineOpacity = shouldDrawOpacity ? edge.pstyle("line-opacity").value : 1;
    var curveStyle = edge.pstyle("curve-style").value;
    var lineStyle = edge.pstyle("line-style").value;
    var edgeWidth = edge.pstyle("width").pfValue;
    var lineCap = edge.pstyle("line-cap").value;
    var effectiveLineOpacity = opacity * lineOpacity; // separate arrow opacity would require arrow-opacity property
    var effectiveArrowOpacity = opacity * lineOpacity;
    var drawLine = function drawLine() {
        var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;
        if (curveStyle === "straight-triangle") {
            r.eleStrokeStyle(context, edge, strokeOpacity);
            r.drawEdgeTrianglePath(edge, context, rs.allpts);
        } else {
            context.lineWidth = edgeWidth;
            context.lineCap = lineCap;
            r.eleStrokeStyle(context, edge, strokeOpacity);
            r.drawEdgePath(edge, context, rs.allpts, lineStyle);
            context.lineCap = "butt"; // reset for other drawing functions
        }
    };
    var drawOverlay = function drawOverlay() {
        if (!shouldDrawOverlay) return;
        r.drawEdgeOverlay(context, edge);
    };
    var drawUnderlay = function drawUnderlay() {
        if (!shouldDrawOverlay) return;
        r.drawEdgeUnderlay(context, edge);
    };
    var drawArrows = function drawArrows() {
        var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;
        r.drawArrowheads(context, edge, arrowOpacity);
    };
    var drawText = function drawText() {
        r.drawElementText(context, edge, null, drawLabel);
    };
    context.lineJoin = "round";
    var ghost = edge.pstyle("ghost").value === "yes";
    if (ghost) {
        var gx = edge.pstyle("ghost-offset-x").pfValue;
        var gy = edge.pstyle("ghost-offset-y").pfValue;
        var ghostOpacity = edge.pstyle("ghost-opacity").value;
        var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;
        context.translate(gx, gy);
        drawLine(effectiveGhostOpacity);
        drawArrows(effectiveGhostOpacity);
        context.translate(-gx, -gy);
    }
    drawUnderlay();
    drawLine();
    drawArrows();
    drawOverlay();
    drawText();
    if (shiftToOriginWithBb) context.translate(bb.x1, bb.y1);
};
var drawEdgeOverlayUnderlay = function drawEdgeOverlayUnderlay(overlayOrUnderlay) {
    if (![
        "overlay",
        "underlay"
    ].includes(overlayOrUnderlay)) throw new Error("Invalid state");
    return function(context, edge) {
        if (!edge.visible()) return;
        var opacity = edge.pstyle("".concat(overlayOrUnderlay, "-opacity")).value;
        if (opacity === 0) return;
        var r = this;
        var usePaths = r.usePaths();
        var rs = edge._private.rscratch;
        var padding = edge.pstyle("".concat(overlayOrUnderlay, "-padding")).pfValue;
        var width = 2 * padding;
        var color = edge.pstyle("".concat(overlayOrUnderlay, "-color")).value;
        context.lineWidth = width;
        if (rs.edgeType === "self" && !usePaths) context.lineCap = "butt";
        else context.lineCap = "round";
        r.colorStrokeStyle(context, color[0], color[1], color[2], opacity);
        r.drawEdgePath(edge, context, rs.allpts, "solid");
    };
};
CRp$8.drawEdgeOverlay = drawEdgeOverlayUnderlay("overlay");
CRp$8.drawEdgeUnderlay = drawEdgeOverlayUnderlay("underlay");
CRp$8.drawEdgePath = function(edge, context, pts, type) {
    var rs = edge._private.rscratch;
    var canvasCxt = context;
    var path;
    var pathCacheHit = false;
    var usePaths = this.usePaths();
    var lineDashPattern = edge.pstyle("line-dash-pattern").pfValue;
    var lineDashOffset = edge.pstyle("line-dash-offset").pfValue;
    if (usePaths) {
        var pathCacheKey = pts.join("$");
        var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;
        if (keyMatches) {
            path = context = rs.pathCache;
            pathCacheHit = true;
        } else {
            path = context = new Path2D();
            rs.pathCacheKey = pathCacheKey;
            rs.pathCache = path;
        }
    }
    if (canvasCxt.setLineDash) // for very outofdate browsers
    switch(type){
        case "dotted":
            canvasCxt.setLineDash([
                1,
                1
            ]);
            break;
        case "dashed":
            canvasCxt.setLineDash(lineDashPattern);
            canvasCxt.lineDashOffset = lineDashOffset;
            break;
        case "solid":
            canvasCxt.setLineDash([]);
            break;
    }
    if (!pathCacheHit && !rs.badLine) {
        if (context.beginPath) context.beginPath();
        context.moveTo(pts[0], pts[1]);
        switch(rs.edgeType){
            case "bezier":
            case "self":
            case "compound":
            case "multibezier":
                for(var i = 2; i + 3 < pts.length; i += 4)context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);
                break;
            case "straight":
            case "segments":
            case "haystack":
                for(var _i = 2; _i + 1 < pts.length; _i += 2)context.lineTo(pts[_i], pts[_i + 1]);
                break;
        }
    }
    context = canvasCxt;
    if (usePaths) context.stroke(path);
    else context.stroke();
     // reset any line dashes
    if (context.setLineDash) // for very outofdate browsers
    context.setLineDash([]);
};
CRp$8.drawEdgeTrianglePath = function(edge, context, pts) {
    // use line stroke style for triangle fill style
    context.fillStyle = context.strokeStyle;
    var edgeWidth = edge.pstyle("width").pfValue;
    for(var i = 0; i + 1 < pts.length; i += 2){
        var vector = [
            pts[i + 2] - pts[i],
            pts[i + 3] - pts[i + 1]
        ];
        var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
        var normal = [
            vector[1] / length,
            -vector[0] / length
        ];
        var triangleHead = [
            normal[0] * edgeWidth / 2,
            normal[1] * edgeWidth / 2
        ];
        context.beginPath();
        context.moveTo(pts[i] - triangleHead[0], pts[i + 1] - triangleHead[1]);
        context.lineTo(pts[i] + triangleHead[0], pts[i + 1] + triangleHead[1]);
        context.lineTo(pts[i + 2], pts[i + 3]);
        context.closePath();
        context.fill();
    }
};
CRp$8.drawArrowheads = function(context, edge, opacity) {
    var rs = edge._private.rscratch;
    var isHaystack = rs.edgeType === "haystack";
    if (!isHaystack) this.drawArrowhead(context, edge, "source", rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
    this.drawArrowhead(context, edge, "mid-target", rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);
    this.drawArrowhead(context, edge, "mid-source", rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);
    if (!isHaystack) this.drawArrowhead(context, edge, "target", rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
};
CRp$8.drawArrowhead = function(context, edge, prefix, x, y, angle, opacity) {
    if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) return;
    var self = this;
    var arrowShape = edge.pstyle(prefix + "-arrow-shape").value;
    if (arrowShape === "none") return;
    var arrowClearFill = edge.pstyle(prefix + "-arrow-fill").value === "hollow" ? "both" : "filled";
    var arrowFill = edge.pstyle(prefix + "-arrow-fill").value;
    var edgeWidth = edge.pstyle("width").pfValue;
    var edgeOpacity = edge.pstyle("opacity").value;
    if (opacity === undefined) opacity = edgeOpacity;
    var gco = context.globalCompositeOperation;
    if (opacity !== 1 || arrowFill === "hollow") {
        // then extra clear is needed
        context.globalCompositeOperation = "destination-out";
        self.colorFillStyle(context, 255, 255, 255, 1);
        self.colorStrokeStyle(context, 255, 255, 255, 1);
        self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);
        context.globalCompositeOperation = gco;
    } // otherwise, the opaque arrow clears it for free :)
    var color = edge.pstyle(prefix + "-arrow-color").value;
    self.colorFillStyle(context, color[0], color[1], color[2], opacity);
    self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);
    self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, x, y, angle);
};
CRp$8.drawArrowShape = function(edge, context, fill, edgeWidth, shape, x, y, angle) {
    var r = this;
    var usePaths = this.usePaths() && shape !== "triangle-cross";
    var pathCacheHit = false;
    var path;
    var canvasContext = context;
    var translation = {
        x: x,
        y: y
    };
    var scale = edge.pstyle("arrow-scale").value;
    var size = this.getArrowWidth(edgeWidth, scale);
    var shapeImpl = r.arrowShapes[shape];
    if (usePaths) {
        var cache = r.arrowPathCache = r.arrowPathCache || [];
        var key = hashString(shape);
        var cachedPath = cache[key];
        if (cachedPath != null) {
            path = context = cachedPath;
            pathCacheHit = true;
        } else {
            path = context = new Path2D();
            cache[key] = path;
        }
    }
    if (!pathCacheHit) {
        if (context.beginPath) context.beginPath();
        if (usePaths) // store in the path cache with values easily manipulated later
        shapeImpl.draw(context, 1, 0, {
            x: 0,
            y: 0
        }, 1);
        else shapeImpl.draw(context, size, angle, translation, edgeWidth);
        if (context.closePath) context.closePath();
    }
    context = canvasContext;
    if (usePaths) {
        // set transform to arrow position/orientation
        context.translate(x, y);
        context.rotate(angle);
        context.scale(size, size);
    }
    if (fill === "filled" || fill === "both") {
        if (usePaths) context.fill(path);
        else context.fill();
    }
    if (fill === "hollow" || fill === "both") {
        context.lineWidth = (shapeImpl.matchEdgeWidth ? edgeWidth : 1) / (usePaths ? size : 1);
        context.lineJoin = "miter";
        if (usePaths) context.stroke(path);
        else context.stroke();
    }
    if (usePaths) {
        // reset transform by applying inverse
        context.scale(1 / size, 1 / size);
        context.rotate(-angle);
        context.translate(-x, -y);
    }
};
var CRp$7 = {};
CRp$7.safeDrawImage = function(context, img, ix, iy, iw, ih, x, y, w, h) {
    // detect problematic cases for old browsers with bad images (cheaper than try-catch)
    if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) return;
    try {
        context.drawImage(img, ix, iy, iw, ih, x, y, w, h);
    } catch (e) {
        warn(e);
    }
};
CRp$7.drawInscribedImage = function(context, img, node, index, nodeOpacity) {
    var r = this;
    var pos = node.position();
    var nodeX = pos.x;
    var nodeY = pos.y;
    var styleObj = node.cy().style();
    var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
    var fit = getIndexedStyle(node, "background-fit", "value", index);
    var repeat = getIndexedStyle(node, "background-repeat", "value", index);
    var nodeW = node.width();
    var nodeH = node.height();
    var paddingX2 = node.padding() * 2;
    var nodeTW = nodeW + (getIndexedStyle(node, "background-width-relative-to", "value", index) === "inner" ? 0 : paddingX2);
    var nodeTH = nodeH + (getIndexedStyle(node, "background-height-relative-to", "value", index) === "inner" ? 0 : paddingX2);
    var rs = node._private.rscratch;
    var clip = getIndexedStyle(node, "background-clip", "value", index);
    var shouldClip = clip === "node";
    var imgOpacity = getIndexedStyle(node, "background-image-opacity", "value", index) * nodeOpacity;
    var smooth = getIndexedStyle(node, "background-image-smoothing", "value", index);
    var imgW = img.width || img.cachedW;
    var imgH = img.height || img.cachedH; // workaround for broken browsers like ie
    if (null == imgW || null == imgH) {
        document.body.appendChild(img); // eslint-disable-line no-undef
        imgW = img.cachedW = img.width || img.offsetWidth;
        imgH = img.cachedH = img.height || img.offsetHeight;
        document.body.removeChild(img); // eslint-disable-line no-undef
    }
    var w = imgW;
    var h = imgH;
    if (getIndexedStyle(node, "background-width", "value", index) !== "auto") {
        if (getIndexedStyle(node, "background-width", "units", index) === "%") w = getIndexedStyle(node, "background-width", "pfValue", index) * nodeTW;
        else w = getIndexedStyle(node, "background-width", "pfValue", index);
    }
    if (getIndexedStyle(node, "background-height", "value", index) !== "auto") {
        if (getIndexedStyle(node, "background-height", "units", index) === "%") h = getIndexedStyle(node, "background-height", "pfValue", index) * nodeTH;
        else h = getIndexedStyle(node, "background-height", "pfValue", index);
    }
    if (w === 0 || h === 0) return; // no point in drawing empty image (and chrome is broken in this case)
    if (fit === "contain") {
        var scale = Math.min(nodeTW / w, nodeTH / h);
        w *= scale;
        h *= scale;
    } else if (fit === "cover") {
        var scale = Math.max(nodeTW / w, nodeTH / h);
        w *= scale;
        h *= scale;
    }
    var x = nodeX - nodeTW / 2; // left
    var posXUnits = getIndexedStyle(node, "background-position-x", "units", index);
    var posXPfVal = getIndexedStyle(node, "background-position-x", "pfValue", index);
    if (posXUnits === "%") x += (nodeTW - w) * posXPfVal;
    else x += posXPfVal;
    var offXUnits = getIndexedStyle(node, "background-offset-x", "units", index);
    var offXPfVal = getIndexedStyle(node, "background-offset-x", "pfValue", index);
    if (offXUnits === "%") x += (nodeTW - w) * offXPfVal;
    else x += offXPfVal;
    var y = nodeY - nodeTH / 2; // top
    var posYUnits = getIndexedStyle(node, "background-position-y", "units", index);
    var posYPfVal = getIndexedStyle(node, "background-position-y", "pfValue", index);
    if (posYUnits === "%") y += (nodeTH - h) * posYPfVal;
    else y += posYPfVal;
    var offYUnits = getIndexedStyle(node, "background-offset-y", "units", index);
    var offYPfVal = getIndexedStyle(node, "background-offset-y", "pfValue", index);
    if (offYUnits === "%") y += (nodeTH - h) * offYPfVal;
    else y += offYPfVal;
    if (rs.pathCache) {
        x -= nodeX;
        y -= nodeY;
        nodeX = 0;
        nodeY = 0;
    }
    var gAlpha = context.globalAlpha;
    context.globalAlpha = imgOpacity;
    var smoothingEnabled = r.getImgSmoothing(context);
    var isSmoothingSwitched = false;
    if (smooth === "no" && smoothingEnabled) {
        r.setImgSmoothing(context, false);
        isSmoothingSwitched = true;
    } else if (smooth === "yes" && !smoothingEnabled) {
        r.setImgSmoothing(context, true);
        isSmoothingSwitched = true;
    }
    if (repeat === "no-repeat") {
        if (shouldClip) {
            context.save();
            if (rs.pathCache) context.clip(rs.pathCache);
            else {
                r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
                context.clip();
            }
        }
        r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);
        if (shouldClip) context.restore();
    } else {
        var pattern = context.createPattern(img, repeat);
        context.fillStyle = pattern;
        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
        context.translate(x, y);
        context.fill();
        context.translate(-x, -y);
    }
    context.globalAlpha = gAlpha;
    if (isSmoothingSwitched) r.setImgSmoothing(context, smoothingEnabled);
};
var CRp$6 = {};
CRp$6.eleTextBiggerThanMin = function(ele, scale) {
    if (!scale) {
        var zoom = ele.cy().zoom();
        var pxRatio = this.getPixelRatio();
        var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level
        scale = Math.pow(2, lvl);
    }
    var computedSize = ele.pstyle("font-size").pfValue * scale;
    var minSize = ele.pstyle("min-zoomed-font-size").pfValue;
    if (computedSize < minSize) return false;
    return true;
};
CRp$6.drawElementText = function(context, ele, shiftToOriginWithBb, force, prefix) {
    var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var r = this;
    if (force == null) {
        if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) return;
    } else if (force === false) return;
    if (ele.isNode()) {
        var label = ele.pstyle("label");
        if (!label || !label.value) return;
        var justification = r.getLabelJustification(ele);
        context.textAlign = justification;
        context.textBaseline = "bottom";
    } else {
        var badLine = ele.element()._private.rscratch.badLine;
        var _label = ele.pstyle("label");
        var srcLabel = ele.pstyle("source-label");
        var tgtLabel = ele.pstyle("target-label");
        if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) return;
        context.textAlign = "center";
        context.textBaseline = "bottom";
    }
    var applyRotation = !shiftToOriginWithBb;
    var bb;
    if (shiftToOriginWithBb) {
        bb = shiftToOriginWithBb;
        context.translate(-bb.x1, -bb.y1);
    }
    if (prefix == null) {
        r.drawText(context, ele, null, applyRotation, useEleOpacity);
        if (ele.isEdge()) {
            r.drawText(context, ele, "source", applyRotation, useEleOpacity);
            r.drawText(context, ele, "target", applyRotation, useEleOpacity);
        }
    } else r.drawText(context, ele, prefix, applyRotation, useEleOpacity);
    if (shiftToOriginWithBb) context.translate(bb.x1, bb.y1);
};
CRp$6.getFontCache = function(context) {
    var cache;
    this.fontCaches = this.fontCaches || [];
    for(var i = 0; i < this.fontCaches.length; i++){
        cache = this.fontCaches[i];
        if (cache.context === context) return cache;
    }
    cache = {
        context: context
    };
    this.fontCaches.push(cache);
    return cache;
}; // set up canvas context with font
// returns transformed text string
CRp$6.setupTextStyle = function(context, ele) {
    var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    // Font style
    var labelStyle = ele.pstyle("font-style").strValue;
    var labelSize = ele.pstyle("font-size").pfValue + "px";
    var labelFamily = ele.pstyle("font-family").strValue;
    var labelWeight = ele.pstyle("font-weight").strValue;
    var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle("text-opacity").value : 1;
    var outlineOpacity = ele.pstyle("text-outline-opacity").value * opacity;
    var color = ele.pstyle("color").value;
    var outlineColor = ele.pstyle("text-outline-color").value;
    context.font = labelStyle + " " + labelWeight + " " + labelSize + " " + labelFamily;
    context.lineJoin = "round"; // so text outlines aren't jagged
    this.colorFillStyle(context, color[0], color[1], color[2], opacity);
    this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
}; // TODO ensure re-used
function roundRect(ctx, x, y, width, height) {
    var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
}
CRp$6.getTextAngle = function(ele, prefix) {
    var theta;
    var _p = ele._private;
    var rscratch = _p.rscratch;
    var pdash = prefix ? prefix + "-" : "";
    var rotation = ele.pstyle(pdash + "text-rotation");
    var textAngle = getPrefixedProperty(rscratch, "labelAngle", prefix);
    if (rotation.strValue === "autorotate") theta = ele.isEdge() ? textAngle : 0;
    else if (rotation.strValue === "none") theta = 0;
    else theta = rotation.pfValue;
    return theta;
};
CRp$6.drawText = function(context, ele, prefix) {
    var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var _p = ele._private;
    var rscratch = _p.rscratch;
    var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;
    if (useEleOpacity && (parentOpacity === 0 || ele.pstyle("text-opacity").value === 0)) return;
     // use 'main' as an alias for the main label (i.e. null prefix)
    if (prefix === "main") prefix = null;
    var textX = getPrefixedProperty(rscratch, "labelX", prefix);
    var textY = getPrefixedProperty(rscratch, "labelY", prefix);
    var orgTextX, orgTextY; // used for rotation
    var text = this.getLabelText(ele, prefix);
    if (text != null && text !== "" && !isNaN(textX) && !isNaN(textY)) {
        this.setupTextStyle(context, ele, useEleOpacity);
        var pdash = prefix ? prefix + "-" : "";
        var textW = getPrefixedProperty(rscratch, "labelWidth", prefix);
        var textH = getPrefixedProperty(rscratch, "labelHeight", prefix);
        var marginX = ele.pstyle(pdash + "text-margin-x").pfValue;
        var marginY = ele.pstyle(pdash + "text-margin-y").pfValue;
        var isEdge = ele.isEdge();
        var halign = ele.pstyle("text-halign").value;
        var valign = ele.pstyle("text-valign").value;
        if (isEdge) {
            halign = "center";
            valign = "center";
        }
        textX += marginX;
        textY += marginY;
        var theta;
        if (!applyRotation) theta = 0;
        else theta = this.getTextAngle(ele, prefix);
        if (theta !== 0) {
            orgTextX = textX;
            orgTextY = textY;
            context.translate(orgTextX, orgTextY);
            context.rotate(theta);
            textX = 0;
            textY = 0;
        }
        switch(valign){
            case "top":
                break;
            case "center":
                textY += textH / 2;
                break;
            case "bottom":
                textY += textH;
                break;
        }
        var backgroundOpacity = ele.pstyle("text-background-opacity").value;
        var borderOpacity = ele.pstyle("text-border-opacity").value;
        var textBorderWidth = ele.pstyle("text-border-width").pfValue;
        var backgroundPadding = ele.pstyle("text-background-padding").pfValue;
        if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
            var bgX = textX - backgroundPadding;
            switch(halign){
                case "left":
                    bgX -= textW;
                    break;
                case "center":
                    bgX -= textW / 2;
                    break;
            }
            var bgY = textY - textH - backgroundPadding;
            var bgW = textW + 2 * backgroundPadding;
            var bgH = textH + 2 * backgroundPadding;
            if (backgroundOpacity > 0) {
                var textFill = context.fillStyle;
                var textBackgroundColor = ele.pstyle("text-background-color").value;
                context.fillStyle = "rgba(" + textBackgroundColor[0] + "," + textBackgroundColor[1] + "," + textBackgroundColor[2] + "," + backgroundOpacity * parentOpacity + ")";
                var styleShape = ele.pstyle("text-background-shape").strValue;
                if (styleShape.indexOf("round") === 0) roundRect(context, bgX, bgY, bgW, bgH, 2);
                else context.fillRect(bgX, bgY, bgW, bgH);
                context.fillStyle = textFill;
            }
            if (textBorderWidth > 0 && borderOpacity > 0) {
                var textStroke = context.strokeStyle;
                var textLineWidth = context.lineWidth;
                var textBorderColor = ele.pstyle("text-border-color").value;
                var textBorderStyle = ele.pstyle("text-border-style").value;
                context.strokeStyle = "rgba(" + textBorderColor[0] + "," + textBorderColor[1] + "," + textBorderColor[2] + "," + borderOpacity * parentOpacity + ")";
                context.lineWidth = textBorderWidth;
                if (context.setLineDash) // for very outofdate browsers
                switch(textBorderStyle){
                    case "dotted":
                        context.setLineDash([
                            1,
                            1
                        ]);
                        break;
                    case "dashed":
                        context.setLineDash([
                            4,
                            2
                        ]);
                        break;
                    case "double":
                        context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders
                        context.setLineDash([]);
                        break;
                    case "solid":
                        context.setLineDash([]);
                        break;
                }
                context.strokeRect(bgX, bgY, bgW, bgH);
                if (textBorderStyle === "double") {
                    var whiteWidth = textBorderWidth / 2;
                    context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);
                }
                if (context.setLineDash) // for very outofdate browsers
                context.setLineDash([]);
                context.lineWidth = textLineWidth;
                context.strokeStyle = textStroke;
            }
        }
        var lineWidth = 2 * ele.pstyle("text-outline-width").pfValue; // *2 b/c the stroke is drawn centred on the middle
        if (lineWidth > 0) context.lineWidth = lineWidth;
        if (ele.pstyle("text-wrap").value === "wrap") {
            var lines = getPrefixedProperty(rscratch, "labelWrapCachedLines", prefix);
            var lineHeight = getPrefixedProperty(rscratch, "labelLineHeight", prefix);
            var halfTextW = textW / 2;
            var justification = this.getLabelJustification(ele);
            if (justification === "auto") ;
            else if (halign === "left") {
                // auto justification : right
                if (justification === "left") textX += -textW;
                else if (justification === "center") textX += -halfTextW;
                 // else same as auto
            } else if (halign === "center") {
                // auto justfication : center
                if (justification === "left") textX += -halfTextW;
                else if (justification === "right") textX += halfTextW;
                 // else same as auto
            } else if (halign === "right") {
                // auto justification : left
                if (justification === "center") textX += halfTextW;
                else if (justification === "right") textX += textW;
                 // else same as auto
            }
            switch(valign){
                case "top":
                    textY -= (lines.length - 1) * lineHeight;
                    break;
                case "center":
                case "bottom":
                    textY -= (lines.length - 1) * lineHeight;
                    break;
            }
            for(var l = 0; l < lines.length; l++){
                if (lineWidth > 0) context.strokeText(lines[l], textX, textY);
                context.fillText(lines[l], textX, textY);
                textY += lineHeight;
            }
        } else {
            if (lineWidth > 0) context.strokeText(text, textX, textY);
            context.fillText(text, textX, textY);
        }
        if (theta !== 0) {
            context.rotate(-theta);
            context.translate(-orgTextX, -orgTextY);
        }
    }
};
/* global Path2D */ var CRp$5 = {};
CRp$5.drawNode = function(context, node, shiftToOriginWithBb) {
    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var r = this;
    var nodeWidth, nodeHeight;
    var _p = node._private;
    var rs = _p.rscratch;
    var pos = node.position();
    if (!number$1(pos.x) || !number$1(pos.y)) return; // can't draw node with undefined position
    if (shouldDrawOpacity && !node.visible()) return;
    var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;
    var usePaths = r.usePaths();
    var path;
    var pathCacheHit = false;
    var padding = node.padding();
    nodeWidth = node.width() + 2 * padding;
    nodeHeight = node.height() + 2 * padding; //
    // setup shift
    var bb;
    if (shiftToOriginWithBb) {
        bb = shiftToOriginWithBb;
        context.translate(-bb.x1, -bb.y1);
    } //
    // load bg image
    var bgImgProp = node.pstyle("background-image");
    var urls = bgImgProp.value;
    var urlDefined = new Array(urls.length);
    var image = new Array(urls.length);
    var numImages = 0;
    for(var i = 0; i < urls.length; i++){
        var url = urls[i];
        var defd = urlDefined[i] = url != null && url !== "none";
        if (defd) {
            var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, "background-image-crossorigin", "value", i);
            numImages++; // get image, and if not loaded then ask to redraw when later loaded
            image[i] = r.getCachedImage(url, bgImgCrossOrigin, function() {
                _p.backgroundTimestamp = Date.now();
                node.emitAndNotify("background");
            });
        }
    } //
    // setup styles
    var darkness = node.pstyle("background-blacken").value;
    var borderWidth = node.pstyle("border-width").pfValue;
    var bgOpacity = node.pstyle("background-opacity").value * eleOpacity;
    var borderColor = node.pstyle("border-color").value;
    var borderStyle = node.pstyle("border-style").value;
    var borderOpacity = node.pstyle("border-opacity").value * eleOpacity;
    context.lineJoin = "miter"; // so borders are square with the node shape
    var setupShapeColor = function setupShapeColor() {
        var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;
        r.eleFillStyle(context, node, bgOpy);
    };
    var setupBorderColor = function setupBorderColor() {
        var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;
        r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
    }; //
    // setup shape
    var styleShape = node.pstyle("shape").strValue;
    var shapePts = node.pstyle("shape-polygon-points").pfValue;
    if (usePaths) {
        context.translate(pos.x, pos.y);
        var pathCache = r.nodePathCache = r.nodePathCache || [];
        var key = hashStrings(styleShape === "polygon" ? styleShape + "," + shapePts.join(",") : styleShape, "" + nodeHeight, "" + nodeWidth);
        var cachedPath = pathCache[key];
        if (cachedPath != null) {
            path = cachedPath;
            pathCacheHit = true;
            rs.pathCache = path;
        } else {
            path = new Path2D();
            pathCache[key] = rs.pathCache = path;
        }
    }
    var drawShape = function drawShape() {
        if (!pathCacheHit) {
            var npos = pos;
            if (usePaths) npos = {
                x: 0,
                y: 0
            };
            r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);
        }
        if (usePaths) context.fill(path);
        else context.fill();
    };
    var drawImages = function drawImages() {
        var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
        var inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var prevBging = _p.backgrounding;
        var totalCompleted = 0;
        for(var _i = 0; _i < image.length; _i++){
            var bgContainment = node.cy().style().getIndexedStyle(node, "background-image-containment", "value", _i);
            if (inside && bgContainment === "over" || !inside && bgContainment === "inside") {
                totalCompleted++;
                continue;
            }
            if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
                totalCompleted++;
                r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
            }
        }
        _p.backgrounding = !(totalCompleted === numImages);
        if (prevBging !== _p.backgrounding) // update style b/c :backgrounding state changed
        node.updateStyle(false);
    };
    var drawPie = function drawPie() {
        var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;
        if (r.hasPie(node)) {
            r.drawPie(context, node, pieOpacity); // redraw/restore path if steps after pie need it
            if (redrawShape) {
                if (!usePaths) r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);
            }
        }
    };
    var darken = function darken() {
        var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
        var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
        var c = darkness > 0 ? 0 : 255;
        if (darkness !== 0) {
            r.colorFillStyle(context, c, c, c, opacity);
            if (usePaths) context.fill(path);
            else context.fill();
        }
    };
    var drawBorder = function drawBorder() {
        if (borderWidth > 0) {
            context.lineWidth = borderWidth;
            context.lineCap = "butt";
            if (context.setLineDash) // for very outofdate browsers
            switch(borderStyle){
                case "dotted":
                    context.setLineDash([
                        1,
                        1
                    ]);
                    break;
                case "dashed":
                    context.setLineDash([
                        4,
                        2
                    ]);
                    break;
                case "solid":
                case "double":
                    context.setLineDash([]);
                    break;
            }
            if (usePaths) context.stroke(path);
            else context.stroke();
            if (borderStyle === "double") {
                context.lineWidth = borderWidth / 3;
                var gco = context.globalCompositeOperation;
                context.globalCompositeOperation = "destination-out";
                if (usePaths) context.stroke(path);
                else context.stroke();
                context.globalCompositeOperation = gco;
            } // reset in case we changed the border style
            if (context.setLineDash) // for very outofdate browsers
            context.setLineDash([]);
        }
    };
    var drawOverlay = function drawOverlay() {
        if (shouldDrawOverlay) r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);
    };
    var drawUnderlay = function drawUnderlay() {
        if (shouldDrawOverlay) r.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);
    };
    var drawText = function drawText() {
        r.drawElementText(context, node, null, drawLabel);
    };
    var ghost = node.pstyle("ghost").value === "yes";
    if (ghost) {
        var gx = node.pstyle("ghost-offset-x").pfValue;
        var gy = node.pstyle("ghost-offset-y").pfValue;
        var ghostOpacity = node.pstyle("ghost-opacity").value;
        var effGhostOpacity = ghostOpacity * eleOpacity;
        context.translate(gx, gy);
        setupShapeColor(ghostOpacity * bgOpacity);
        drawShape();
        drawImages(effGhostOpacity, true);
        setupBorderColor(ghostOpacity * borderOpacity);
        drawBorder();
        drawPie(darkness !== 0 || borderWidth !== 0);
        drawImages(effGhostOpacity, false);
        darken(effGhostOpacity);
        context.translate(-gx, -gy);
    }
    if (usePaths) context.translate(-pos.x, -pos.y);
    drawUnderlay();
    if (usePaths) context.translate(pos.x, pos.y);
    setupShapeColor();
    drawShape();
    drawImages(eleOpacity, true);
    setupBorderColor();
    drawBorder();
    drawPie(darkness !== 0 || borderWidth !== 0);
    drawImages(eleOpacity, false);
    darken();
    if (usePaths) context.translate(-pos.x, -pos.y);
    drawText();
    drawOverlay(); //
    // clean up shift
    if (shiftToOriginWithBb) context.translate(bb.x1, bb.y1);
};
var drawNodeOverlayUnderlay = function drawNodeOverlayUnderlay(overlayOrUnderlay) {
    if (![
        "overlay",
        "underlay"
    ].includes(overlayOrUnderlay)) throw new Error("Invalid state");
    return function(context, node, pos, nodeWidth, nodeHeight) {
        var r = this;
        if (!node.visible()) return;
        var padding = node.pstyle("".concat(overlayOrUnderlay, "-padding")).pfValue;
        var opacity = node.pstyle("".concat(overlayOrUnderlay, "-opacity")).value;
        var color = node.pstyle("".concat(overlayOrUnderlay, "-color")).value;
        var shape = node.pstyle("".concat(overlayOrUnderlay, "-shape")).value;
        if (opacity > 0) {
            pos = pos || node.position();
            if (nodeWidth == null || nodeHeight == null) {
                var _padding = node.padding();
                nodeWidth = node.width() + 2 * _padding;
                nodeHeight = node.height() + 2 * _padding;
            }
            r.colorFillStyle(context, color[0], color[1], color[2], opacity);
            r.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2);
            context.fill();
        }
    };
};
CRp$5.drawNodeOverlay = drawNodeOverlayUnderlay("overlay");
CRp$5.drawNodeUnderlay = drawNodeOverlayUnderlay("underlay"); // does the node have at least one pie piece?
CRp$5.hasPie = function(node) {
    node = node[0]; // ensure ele ref
    return node._private.hasPie;
};
CRp$5.drawPie = function(context, node, nodeOpacity, pos) {
    node = node[0]; // ensure ele ref
    pos = pos || node.position();
    var cyStyle = node.cy().style();
    var pieSize = node.pstyle("pie-size");
    var x = pos.x;
    var y = pos.y;
    var nodeW = node.width();
    var nodeH = node.height();
    var radius = Math.min(nodeW, nodeH) / 2; // must fit in node
    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
    var usePaths = this.usePaths();
    if (usePaths) {
        x = 0;
        y = 0;
    }
    if (pieSize.units === "%") radius = radius * pieSize.pfValue;
    else if (pieSize.pfValue !== undefined) radius = pieSize.pfValue / 2;
    for(var i = 1; i <= cyStyle.pieBackgroundN; i++){
        // 1..N
        var size = node.pstyle("pie-" + i + "-background-size").value;
        var color = node.pstyle("pie-" + i + "-background-color").value;
        var opacity = node.pstyle("pie-" + i + "-background-opacity").value * nodeOpacity;
        var percent = size / 100; // map integer range [0, 100] to [0, 1]
        // percent can't push beyond 1
        if (percent + lastPercent > 1) percent = 1 - lastPercent;
        var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
        var angleDelta = 2 * Math.PI * percent;
        var angleEnd = angleStart + angleDelta; // ignore if
        // - zero size
        // - we're already beyond the full circle
        // - adding the current slice would go beyond the full circle
        if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) continue;
        context.beginPath();
        context.moveTo(x, y);
        context.arc(x, y, radius, angleStart, angleEnd);
        context.closePath();
        this.colorFillStyle(context, color[0], color[1], color[2], opacity);
        context.fill();
        lastPercent += percent;
    }
};
var CRp$4 = {};
var motionBlurDelay = 100; // var isFirefox = typeof InstallTrigger !== 'undefined';
CRp$4.getPixelRatio = function() {
    var context = this.data.contexts[0];
    if (this.forcedPixelRatio != null) return this.forcedPixelRatio;
    var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
};
CRp$4.paintCache = function(context) {
    var caches = this.paintCaches = this.paintCaches || [];
    var needToCreateCache = true;
    var cache;
    for(var i = 0; i < caches.length; i++){
        cache = caches[i];
        if (cache.context === context) {
            needToCreateCache = false;
            break;
        }
    }
    if (needToCreateCache) {
        cache = {
            context: context
        };
        caches.push(cache);
    }
    return cache;
};
CRp$4.createGradientStyleFor = function(context, shapeStyleName, ele, fill, opacity) {
    var gradientStyle;
    var usePaths = this.usePaths();
    var colors = ele.pstyle(shapeStyleName + "-gradient-stop-colors").value, positions = ele.pstyle(shapeStyleName + "-gradient-stop-positions").pfValue;
    if (fill === "radial-gradient") {
        if (ele.isEdge()) {
            var start = ele.sourceEndpoint(), end = ele.targetEndpoint(), mid = ele.midpoint();
            var d1 = dist(start, mid);
            var d2 = dist(end, mid);
            gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));
        } else {
            var pos = usePaths ? {
                x: 0,
                y: 0
            } : ele.position(), width = ele.paddedWidth(), height = ele.paddedHeight();
            gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));
        }
    } else if (ele.isEdge()) {
        var _start = ele.sourceEndpoint(), _end = ele.targetEndpoint();
        gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);
    } else {
        var _pos = usePaths ? {
            x: 0,
            y: 0
        } : ele.position(), _width = ele.paddedWidth(), _height = ele.paddedHeight(), halfWidth = _width / 2, halfHeight = _height / 2;
        var direction = ele.pstyle("background-gradient-direction").value;
        switch(direction){
            case "to-bottom":
                gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);
                break;
            case "to-top":
                gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);
                break;
            case "to-left":
                gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);
                break;
            case "to-right":
                gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);
                break;
            case "to-bottom-right":
            case "to-right-bottom":
                gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);
                break;
            case "to-top-right":
            case "to-right-top":
                gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);
                break;
            case "to-bottom-left":
            case "to-left-bottom":
                gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);
                break;
            case "to-top-left":
            case "to-left-top":
                gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);
                break;
        }
    }
    if (!gradientStyle) return null; // invalid gradient style
    var hasPositions = positions.length === colors.length;
    var length = colors.length;
    for(var i = 0; i < length; i++)gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), "rgba(" + colors[i][0] + "," + colors[i][1] + "," + colors[i][2] + "," + opacity + ")");
    return gradientStyle;
};
CRp$4.gradientFillStyle = function(context, ele, fill, opacity) {
    var gradientStyle = this.createGradientStyleFor(context, "background", ele, fill, opacity);
    if (!gradientStyle) return null; // error
    context.fillStyle = gradientStyle;
};
CRp$4.colorFillStyle = function(context, r, g, b, a) {
    context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a + ")"; // turn off for now, seems context does its own caching
// var cache = this.paintCache(context);
// var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
// if( cache.fillStyle !== fillStyle ){
//   context.fillStyle = cache.fillStyle = fillStyle;
// }
};
CRp$4.eleFillStyle = function(context, ele, opacity) {
    var backgroundFill = ele.pstyle("background-fill").value;
    if (backgroundFill === "linear-gradient" || backgroundFill === "radial-gradient") this.gradientFillStyle(context, ele, backgroundFill, opacity);
    else {
        var backgroundColor = ele.pstyle("background-color").value;
        this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);
    }
};
CRp$4.gradientStrokeStyle = function(context, ele, fill, opacity) {
    var gradientStyle = this.createGradientStyleFor(context, "line", ele, fill, opacity);
    if (!gradientStyle) return null; // error
    context.strokeStyle = gradientStyle;
};
CRp$4.colorStrokeStyle = function(context, r, g, b, a) {
    context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + a + ")"; // turn off for now, seems context does its own caching
// var cache = this.paintCache(context);
// var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
// if( cache.strokeStyle !== strokeStyle ){
//   context.strokeStyle = cache.strokeStyle = strokeStyle;
// }
};
CRp$4.eleStrokeStyle = function(context, ele, opacity) {
    var lineFill = ele.pstyle("line-fill").value;
    if (lineFill === "linear-gradient" || lineFill === "radial-gradient") this.gradientStrokeStyle(context, ele, lineFill, opacity);
    else {
        var lineColor = ele.pstyle("line-color").value;
        this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);
    }
}; // Resize canvas
CRp$4.matchCanvasSize = function(container) {
    var r = this;
    var data = r.data;
    var bb = r.findContainerClientCoords();
    var width = bb[2];
    var height = bb[3];
    var pixelRatio = r.getPixelRatio();
    var mbPxRatio = r.motionBlurPxRatio;
    if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) pixelRatio = mbPxRatio;
    var canvasWidth = width * pixelRatio;
    var canvasHeight = height * pixelRatio;
    var canvas;
    if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) return; // save cycles if same
    r.fontCaches = null; // resizing resets the style
    var canvasContainer = data.canvasContainer;
    canvasContainer.style.width = width + "px";
    canvasContainer.style.height = height + "px";
    for(var i = 0; i < r.CANVAS_LAYERS; i++){
        canvas = data.canvases[i];
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
    }
    for(var i = 0; i < r.BUFFER_COUNT; i++){
        canvas = data.bufferCanvases[i];
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
    }
    r.textureMult = 1;
    if (pixelRatio <= 1) {
        canvas = data.bufferCanvases[r.TEXTURE_BUFFER];
        r.textureMult = 2;
        canvas.width = canvasWidth * r.textureMult;
        canvas.height = canvasHeight * r.textureMult;
    }
    r.canvasWidth = canvasWidth;
    r.canvasHeight = canvasHeight;
};
CRp$4.renderTo = function(cxt, zoom, pan, pxRatio) {
    this.render({
        forcedContext: cxt,
        forcedZoom: zoom,
        forcedPan: pan,
        drawAllLayers: true,
        forcedPxRatio: pxRatio
    });
};
CRp$4.render = function(options) {
    options = options || staticEmptyObject();
    var forcedContext = options.forcedContext;
    var drawAllLayers = options.drawAllLayers;
    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
    var forcedZoom = options.forcedZoom;
    var forcedPan = options.forcedPan;
    var r = this;
    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
    var cy = r.cy;
    var data = r.data;
    var needDraw = data.canvasNeedsRedraw;
    var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
    var mbPxRatio = r.motionBlurPxRatio;
    var hasCompoundNodes = cy.hasCompoundNodes();
    var inNodeDragGesture = r.hoverData.draggingEles;
    var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
    var motionBlurFadeEffect = motionBlur;
    if (!forcedContext) {
        if (r.prevPxRatio !== pixelRatio) {
            r.invalidateContainerClientCoordsCache();
            r.matchCanvasSize(r.container);
            r.redrawHint("eles", true);
            r.redrawHint("drag", true);
        }
        r.prevPxRatio = pixelRatio;
    }
    if (!forcedContext && r.motionBlurTimeout) clearTimeout(r.motionBlurTimeout);
    if (motionBlur) {
        if (r.mbFrames == null) r.mbFrames = 0;
        r.mbFrames++;
        if (r.mbFrames < 3) // need several frames before even high quality motionblur
        motionBlurFadeEffect = false;
         // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
        if (r.mbFrames > r.minMbLowQualFrames) //r.fullQualityMb = false;
        r.motionBlurPxRatio = r.mbPxRBlurry;
    }
    if (r.clearingMotionBlur) r.motionBlurPxRatio = 1;
     // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
    // because a rogue async texture frame would clear needDraw
    if (r.textureDrawLastFrame && !textureDraw) {
        needDraw[r.NODE] = true;
        needDraw[r.SELECT_BOX] = true;
    }
    var style = cy.style();
    var zoom = cy.zoom();
    var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
    var pan = cy.pan();
    var effectivePan = {
        x: pan.x,
        y: pan.y
    };
    var vp = {
        zoom: zoom,
        pan: {
            x: pan.x,
            y: pan.y
        }
    };
    var prevVp = r.prevViewport;
    var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y; // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
    if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) r.motionBlurPxRatio = 1;
    if (forcedPan) effectivePan = forcedPan;
     // apply pixel ratio
    effectiveZoom *= pixelRatio;
    effectivePan.x *= pixelRatio;
    effectivePan.y *= pixelRatio;
    var eles = r.getCachedZSortedEles();
    function mbclear(context, x, y, w, h) {
        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = "destination-out";
        r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);
        context.fillRect(x, y, w, h);
        context.globalCompositeOperation = gco;
    }
    function setContextTransform(context, clear) {
        var ePan, eZoom, w, h;
        if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {
            ePan = {
                x: pan.x * mbPxRatio,
                y: pan.y * mbPxRatio
            };
            eZoom = zoom * mbPxRatio;
            w = r.canvasWidth * mbPxRatio;
            h = r.canvasHeight * mbPxRatio;
        } else {
            ePan = effectivePan;
            eZoom = effectiveZoom;
            w = r.canvasWidth;
            h = r.canvasHeight;
        }
        context.setTransform(1, 0, 0, 1, 0, 0);
        if (clear === "motionBlur") mbclear(context, 0, 0, w, h);
        else if (!forcedContext && (clear === undefined || clear)) context.clearRect(0, 0, w, h);
        if (!drawAllLayers) {
            context.translate(ePan.x, ePan.y);
            context.scale(eZoom, eZoom);
        }
        if (forcedPan) context.translate(forcedPan.x, forcedPan.y);
        if (forcedZoom) context.scale(forcedZoom, forcedZoom);
    }
    if (!textureDraw) r.textureDrawLastFrame = false;
    if (textureDraw) {
        r.textureDrawLastFrame = true;
        if (!r.textureCache) {
            r.textureCache = {};
            r.textureCache.bb = cy.mutableElements().boundingBox();
            r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];
            var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];
            cxt.setTransform(1, 0, 0, 1, 0, 0);
            cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
            r.render({
                forcedContext: cxt,
                drawOnlyNodeLayer: true,
                forcedPxRatio: pixelRatio * r.textureMult
            });
            var vp = r.textureCache.viewport = {
                zoom: cy.zoom(),
                pan: cy.pan(),
                width: r.canvasWidth,
                height: r.canvasHeight
            };
            vp.mpan = {
                x: (0 - vp.pan.x) / vp.zoom,
                y: (0 - vp.pan.y) / vp.zoom
            };
        }
        needDraw[r.DRAG] = false;
        needDraw[r.NODE] = false;
        var context = data.contexts[r.NODE];
        var texture = r.textureCache.texture;
        var vp = r.textureCache.viewport;
        context.setTransform(1, 0, 0, 1, 0, 0);
        if (motionBlur) mbclear(context, 0, 0, vp.width, vp.height);
        else context.clearRect(0, 0, vp.width, vp.height);
        var outsideBgColor = style.core("outside-texture-bg-color").value;
        var outsideBgOpacity = style.core("outside-texture-bg-opacity").value;
        r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
        context.fillRect(0, 0, vp.width, vp.height);
        var zoom = cy.zoom();
        setContextTransform(context, false);
        context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
        context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
    } else if (r.textureOnViewport && !forcedContext) // clear the cache since we don't need it
    r.textureCache = null;
    var extent = cy.extent();
    var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();
    var hideEdges = r.hideEdgesOnViewport && vpManip;
    var needMbClear = [];
    needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;
    if (needMbClear[r.NODE]) r.clearedForMotionBlur[r.NODE] = true;
    needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;
    if (needMbClear[r.DRAG]) r.clearedForMotionBlur[r.DRAG] = true;
    if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {
        var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
        var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);
        var clear = motionBlur && !useBuffer ? "motionBlur" : undefined;
        setContextTransform(context, clear);
        if (hideEdges) r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);
        else r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);
        if (r.debug) r.drawDebugPoints(context, eles.nondrag);
        if (!drawAllLayers && !motionBlur) needDraw[r.NODE] = false;
    }
    if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {
        var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
        var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);
        setContextTransform(context, motionBlur && !useBuffer ? "motionBlur" : undefined);
        if (hideEdges) r.drawCachedNodes(context, eles.drag, pixelRatio, extent);
        else r.drawCachedElements(context, eles.drag, pixelRatio, extent);
        if (r.debug) r.drawDebugPoints(context, eles.drag);
        if (!drawAllLayers && !motionBlur) needDraw[r.DRAG] = false;
    }
    if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {
        var context = forcedContext || data.contexts[r.SELECT_BOX];
        setContextTransform(context);
        if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
            var zoom = r.cy.zoom();
            var borderWidth = style.core("selection-box-border-width").value / zoom;
            context.lineWidth = borderWidth;
            context.fillStyle = "rgba(" + style.core("selection-box-color").value[0] + "," + style.core("selection-box-color").value[1] + "," + style.core("selection-box-color").value[2] + "," + style.core("selection-box-opacity").value + ")";
            context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
            if (borderWidth > 0) {
                context.strokeStyle = "rgba(" + style.core("selection-box-border-color").value[0] + "," + style.core("selection-box-border-color").value[1] + "," + style.core("selection-box-border-color").value[2] + "," + style.core("selection-box-opacity").value + ")";
                context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
            }
        }
        if (data.bgActivePosistion && !r.hoverData.selecting) {
            var zoom = r.cy.zoom();
            var pos = data.bgActivePosistion;
            context.fillStyle = "rgba(" + style.core("active-bg-color").value[0] + "," + style.core("active-bg-color").value[1] + "," + style.core("active-bg-color").value[2] + "," + style.core("active-bg-opacity").value + ")";
            context.beginPath();
            context.arc(pos.x, pos.y, style.core("active-bg-size").pfValue / zoom, 0, 2 * Math.PI);
            context.fill();
        }
        var timeToRender = r.lastRedrawTime;
        if (r.showFps && timeToRender) {
            timeToRender = Math.round(timeToRender);
            var fps = Math.round(1000 / timeToRender);
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.fillStyle = "rgba(255, 0, 0, 0.75)";
            context.strokeStyle = "rgba(255, 0, 0, 0.75)";
            context.lineWidth = 1;
            context.fillText("1 frame = " + timeToRender + " ms = " + fps + " fps", 0, 20);
            var maxFps = 60;
            context.strokeRect(0, 30, 250, 20);
            context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);
        }
        if (!drawAllLayers) needDraw[r.SELECT_BOX] = false;
    } // motionblur: blit rendered blurry frames
    if (motionBlur && mbPxRatio !== 1) {
        var cxtNode = data.contexts[r.NODE];
        var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];
        var cxtDrag = data.contexts[r.DRAG];
        var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];
        var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {
            cxt.setTransform(1, 0, 0, 1, 0, 0);
            if (needClear || !motionBlurFadeEffect) cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
            else mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);
            var pxr = mbPxRatio;
            cxt.drawImage(txt, 0, 0, r.canvasWidth * pxr, r.canvasHeight * pxr, 0, 0, r.canvasWidth, r.canvasHeight // w, h
            );
        };
        if (needDraw[r.NODE] || needMbClear[r.NODE]) {
            drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);
            needDraw[r.NODE] = false;
        }
        if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {
            drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);
            needDraw[r.DRAG] = false;
        }
    }
    r.prevViewport = vp;
    if (r.clearingMotionBlur) {
        r.clearingMotionBlur = false;
        r.motionBlurCleared = true;
        r.motionBlur = true;
    }
    if (motionBlur) r.motionBlurTimeout = setTimeout(function() {
        r.motionBlurTimeout = null;
        r.clearedForMotionBlur[r.NODE] = false;
        r.clearedForMotionBlur[r.DRAG] = false;
        r.motionBlur = false;
        r.clearingMotionBlur = !textureDraw;
        r.mbFrames = 0;
        needDraw[r.NODE] = true;
        needDraw[r.DRAG] = true;
        r.redraw();
    }, motionBlurDelay);
    if (!forcedContext) cy.emit("render");
};
var CRp$3 = {}; // @O Polygon drawing
CRp$3.drawPolygonPath = function(context, x, y, width, height, points) {
    var halfW = width / 2;
    var halfH = height / 2;
    if (context.beginPath) context.beginPath();
    context.moveTo(x + halfW * points[0], y + halfH * points[1]);
    for(var i = 1; i < points.length / 2; i++)context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);
    context.closePath();
};
CRp$3.drawRoundPolygonPath = function(context, x, y, width, height, points) {
    var halfW = width / 2;
    var halfH = height / 2;
    var cornerRadius = getRoundPolygonRadius(width, height);
    if (context.beginPath) context.beginPath();
    for(var _i = 0; _i < points.length / 4; _i++){
        var sourceUv = void 0, destUv = void 0;
        if (_i === 0) sourceUv = points.length - 2;
        else sourceUv = _i * 4 - 2;
        destUv = _i * 4 + 2;
        var px = x + halfW * points[_i * 4];
        var py = y + halfH * points[_i * 4 + 1];
        var cosTheta = -points[sourceUv] * points[destUv] - points[sourceUv + 1] * points[destUv + 1];
        var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
        var cp0x = px - offset * points[sourceUv];
        var cp0y = py - offset * points[sourceUv + 1];
        var cp1x = px + offset * points[destUv];
        var cp1y = py + offset * points[destUv + 1];
        if (_i === 0) context.moveTo(cp0x, cp0y);
        else context.lineTo(cp0x, cp0y);
        context.arcTo(px, py, cp1x, cp1y, cornerRadius);
    }
    context.closePath();
}; // Round rectangle drawing
CRp$3.drawRoundRectanglePath = function(context, x, y, width, height) {
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerRadius = getRoundRectangleRadius(width, height);
    if (context.beginPath) context.beginPath();
     // Start at top middle
    context.moveTo(x, y - halfHeight); // Arc from middle top to right side
    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius); // Arc from right side to bottom
    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius); // Arc from bottom to left side
    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius); // Arc from left side to topBorder
    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius); // Join line
    context.lineTo(x, y - halfHeight);
    context.closePath();
};
CRp$3.drawBottomRoundRectanglePath = function(context, x, y, width, height) {
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerRadius = getRoundRectangleRadius(width, height);
    if (context.beginPath) context.beginPath();
     // Start at top middle
    context.moveTo(x, y - halfHeight);
    context.lineTo(x + halfWidth, y - halfHeight);
    context.lineTo(x + halfWidth, y);
    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
    context.lineTo(x - halfWidth, y - halfHeight);
    context.lineTo(x, y - halfHeight);
    context.closePath();
};
CRp$3.drawCutRectanglePath = function(context, x, y, width, height) {
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerLength = getCutRectangleCornerLength();
    if (context.beginPath) context.beginPath();
    context.moveTo(x - halfWidth + cornerLength, y - halfHeight);
    context.lineTo(x + halfWidth - cornerLength, y - halfHeight);
    context.lineTo(x + halfWidth, y - halfHeight + cornerLength);
    context.lineTo(x + halfWidth, y + halfHeight - cornerLength);
    context.lineTo(x + halfWidth - cornerLength, y + halfHeight);
    context.lineTo(x - halfWidth + cornerLength, y + halfHeight);
    context.lineTo(x - halfWidth, y + halfHeight - cornerLength);
    context.lineTo(x - halfWidth, y - halfHeight + cornerLength);
    context.closePath();
};
CRp$3.drawBarrelPath = function(context, x, y, width, height) {
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var xBegin = x - halfWidth;
    var xEnd = x + halfWidth;
    var yBegin = y - halfHeight;
    var yEnd = y + halfHeight;
    var barrelCurveConstants = getBarrelCurveConstants(width, height);
    var wOffset = barrelCurveConstants.widthOffset;
    var hOffset = barrelCurveConstants.heightOffset;
    var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;
    if (context.beginPath) context.beginPath();
    context.moveTo(xBegin, yBegin + hOffset);
    context.lineTo(xBegin, yEnd - hOffset);
    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);
    context.lineTo(xEnd - wOffset, yEnd);
    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);
    context.lineTo(xEnd, yBegin + hOffset);
    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);
    context.lineTo(xBegin + wOffset, yBegin);
    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);
    context.closePath();
};
var sin0 = Math.sin(0);
var cos0 = Math.cos(0);
var sin = {};
var cos = {};
var ellipseStepSize = Math.PI / 40;
for(var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize){
    sin[i] = Math.sin(i);
    cos[i] = Math.cos(i);
}
CRp$3.drawEllipsePath = function(context, centerX, centerY, width, height) {
    if (context.beginPath) context.beginPath();
    if (context.ellipse) context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
    else {
        var xPos, yPos;
        var rw = width / 2;
        var rh = height / 2;
        for(var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize){
            xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
            yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;
            if (i === 0) context.moveTo(xPos, yPos);
            else context.lineTo(xPos, yPos);
        }
    }
    context.closePath();
};
/* global atob, ArrayBuffer, Uint8Array, Blob */ var CRp$2 = {};
CRp$2.createBuffer = function(w, h) {
    var buffer = document.createElement("canvas"); // eslint-disable-line no-undef
    buffer.width = w;
    buffer.height = h;
    return [
        buffer,
        buffer.getContext("2d")
    ];
};
CRp$2.bufferCanvasImage = function(options) {
    var cy = this.cy;
    var eles = cy.mutableElements();
    var bb = eles.boundingBox();
    var ctrRect = this.findContainerClientCoords();
    var width = options.full ? Math.ceil(bb.w) : ctrRect[2];
    var height = options.full ? Math.ceil(bb.h) : ctrRect[3];
    var specdMaxDims = number$1(options.maxWidth) || number$1(options.maxHeight);
    var pxRatio = this.getPixelRatio();
    var scale = 1;
    if (options.scale !== undefined) {
        width *= options.scale;
        height *= options.scale;
        scale = options.scale;
    } else if (specdMaxDims) {
        var maxScaleW = Infinity;
        var maxScaleH = Infinity;
        if (number$1(options.maxWidth)) maxScaleW = scale * options.maxWidth / width;
        if (number$1(options.maxHeight)) maxScaleH = scale * options.maxHeight / height;
        scale = Math.min(maxScaleW, maxScaleH);
        width *= scale;
        height *= scale;
    }
    if (!specdMaxDims) {
        width *= pxRatio;
        height *= pxRatio;
        scale *= pxRatio;
    }
    var buffCanvas = document.createElement("canvas"); // eslint-disable-line no-undef
    buffCanvas.width = width;
    buffCanvas.height = height;
    buffCanvas.style.width = width + "px";
    buffCanvas.style.height = height + "px";
    var buffCxt = buffCanvas.getContext("2d"); // Rasterize the layers, but only if container has nonzero size
    if (width > 0 && height > 0) {
        buffCxt.clearRect(0, 0, width, height);
        buffCxt.globalCompositeOperation = "source-over";
        var zsortedEles = this.getCachedZSortedEles();
        if (options.full) {
            // draw the full bounds of the graph
            buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);
            buffCxt.scale(scale, scale);
            this.drawElements(buffCxt, zsortedEles);
            buffCxt.scale(1 / scale, 1 / scale);
            buffCxt.translate(bb.x1 * scale, bb.y1 * scale);
        } else {
            // draw the current view
            var pan = cy.pan();
            var translation = {
                x: pan.x * scale,
                y: pan.y * scale
            };
            scale *= cy.zoom();
            buffCxt.translate(translation.x, translation.y);
            buffCxt.scale(scale, scale);
            this.drawElements(buffCxt, zsortedEles);
            buffCxt.scale(1 / scale, 1 / scale);
            buffCxt.translate(-translation.x, -translation.y);
        } // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs
        if (options.bg) {
            buffCxt.globalCompositeOperation = "destination-over";
            buffCxt.fillStyle = options.bg;
            buffCxt.rect(0, 0, width, height);
            buffCxt.fill();
        }
    }
    return buffCanvas;
};
function b64ToBlob(b64, mimeType) {
    var bytes = atob(b64);
    var buff = new ArrayBuffer(bytes.length);
    var buffUint8 = new Uint8Array(buff);
    for(var i = 0; i < bytes.length; i++)buffUint8[i] = bytes.charCodeAt(i);
    return new Blob([
        buff
    ], {
        type: mimeType
    });
}
function b64UriToB64(b64uri) {
    var i = b64uri.indexOf(",");
    return b64uri.substr(i + 1);
}
function output(options, canvas, mimeType) {
    var getB64Uri = function getB64Uri() {
        return canvas.toDataURL(mimeType, options.quality);
    };
    switch(options.output){
        case "blob-promise":
            return new Promise$1(function(resolve, reject) {
                try {
                    canvas.toBlob(function(blob) {
                        if (blob != null) resolve(blob);
                        else reject(new Error("`canvas.toBlob()` sent a null value in its callback"));
                    }, mimeType, options.quality);
                } catch (err) {
                    reject(err);
                }
            });
        case "blob":
            return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);
        case "base64":
            return b64UriToB64(getB64Uri());
        case "base64uri":
        default:
            return getB64Uri();
    }
}
CRp$2.png = function(options) {
    return output(options, this.bufferCanvasImage(options), "image/png");
};
CRp$2.jpg = function(options) {
    return output(options, this.bufferCanvasImage(options), "image/jpeg");
};
var CRp$1 = {};
CRp$1.nodeShapeImpl = function(name, context, centerX, centerY, width, height, points) {
    switch(name){
        case "ellipse":
            return this.drawEllipsePath(context, centerX, centerY, width, height);
        case "polygon":
            return this.drawPolygonPath(context, centerX, centerY, width, height, points);
        case "round-polygon":
            return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points);
        case "roundrectangle":
        case "round-rectangle":
            return this.drawRoundRectanglePath(context, centerX, centerY, width, height);
        case "cutrectangle":
        case "cut-rectangle":
            return this.drawCutRectanglePath(context, centerX, centerY, width, height);
        case "bottomroundrectangle":
        case "bottom-round-rectangle":
            return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);
        case "barrel":
            return this.drawBarrelPath(context, centerX, centerY, width, height);
    }
};
var CR = CanvasRenderer;
var CRp = CanvasRenderer.prototype;
CRp.CANVAS_LAYERS = 3; //
CRp.SELECT_BOX = 0;
CRp.DRAG = 1;
CRp.NODE = 2;
CRp.BUFFER_COUNT = 3; //
CRp.TEXTURE_BUFFER = 0;
CRp.MOTIONBLUR_BUFFER_NODE = 1;
CRp.MOTIONBLUR_BUFFER_DRAG = 2;
function CanvasRenderer(options) {
    var r = this;
    r.data = {
        canvases: new Array(CRp.CANVAS_LAYERS),
        contexts: new Array(CRp.CANVAS_LAYERS),
        canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),
        bufferCanvases: new Array(CRp.BUFFER_COUNT),
        bufferContexts: new Array(CRp.CANVAS_LAYERS)
    };
    var tapHlOffAttr = "-webkit-tap-highlight-color";
    var tapHlOffStyle = "rgba(0,0,0,0)";
    r.data.canvasContainer = document.createElement("div"); // eslint-disable-line no-undef
    var containerStyle = r.data.canvasContainer.style;
    r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;
    containerStyle.position = "relative";
    containerStyle.zIndex = "0";
    containerStyle.overflow = "hidden";
    var container = options.cy.container();
    container.appendChild(r.data.canvasContainer);
    container.style[tapHlOffAttr] = tapHlOffStyle;
    var styleMap = {
        "-webkit-user-select": "none",
        "-moz-user-select": "-moz-none",
        "user-select": "none",
        "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
        "outline-style": "none"
    };
    if (ms()) {
        styleMap["-ms-touch-action"] = "none";
        styleMap["touch-action"] = "none";
    }
    for(var i = 0; i < CRp.CANVAS_LAYERS; i++){
        var canvas = r.data.canvases[i] = document.createElement("canvas"); // eslint-disable-line no-undef
        r.data.contexts[i] = canvas.getContext("2d");
        Object.keys(styleMap).forEach(function(k) {
            canvas.style[k] = styleMap[k];
        });
        canvas.style.position = "absolute";
        canvas.setAttribute("data-id", "layer" + i);
        canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);
        r.data.canvasContainer.appendChild(canvas);
        r.data.canvasNeedsRedraw[i] = false;
    }
    r.data.topCanvas = r.data.canvases[0];
    r.data.canvases[CRp.NODE].setAttribute("data-id", "layer" + CRp.NODE + "-node");
    r.data.canvases[CRp.SELECT_BOX].setAttribute("data-id", "layer" + CRp.SELECT_BOX + "-selectbox");
    r.data.canvases[CRp.DRAG].setAttribute("data-id", "layer" + CRp.DRAG + "-drag");
    for(var i = 0; i < CRp.BUFFER_COUNT; i++){
        r.data.bufferCanvases[i] = document.createElement("canvas"); // eslint-disable-line no-undef
        r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext("2d");
        r.data.bufferCanvases[i].style.position = "absolute";
        r.data.bufferCanvases[i].setAttribute("data-id", "buffer" + i);
        r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
        r.data.bufferCanvases[i].style.visibility = "hidden"; //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
    }
    r.pathsEnabled = true;
    var emptyBb = makeBoundingBox();
    var getBoxCenter = function getBoxCenter(bb) {
        return {
            x: (bb.x1 + bb.x2) / 2,
            y: (bb.y1 + bb.y2) / 2
        };
    };
    var getCenterOffset = function getCenterOffset(bb) {
        return {
            x: -bb.w / 2,
            y: -bb.h / 2
        };
    };
    var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {
        var _p = ele[0]._private;
        var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;
        return !same;
    };
    var getStyleKey = function getStyleKey(ele) {
        return ele[0]._private.nodeKey;
    };
    var getLabelKey = function getLabelKey(ele) {
        return ele[0]._private.labelStyleKey;
    };
    var getSourceLabelKey = function getSourceLabelKey(ele) {
        return ele[0]._private.sourceLabelStyleKey;
    };
    var getTargetLabelKey = function getTargetLabelKey(ele) {
        return ele[0]._private.targetLabelStyleKey;
    };
    var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {
        return r.drawElement(context, ele, bb, false, false, useEleOpacity);
    };
    var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
        return r.drawElementText(context, ele, bb, scaledLabelShown, "main", useEleOpacity);
    };
    var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
        return r.drawElementText(context, ele, bb, scaledLabelShown, "source", useEleOpacity);
    };
    var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
        return r.drawElementText(context, ele, bb, scaledLabelShown, "target", useEleOpacity);
    };
    var getElementBox = function getElementBox(ele) {
        ele.boundingBox();
        return ele[0]._private.bodyBounds;
    };
    var getLabelBox = function getLabelBox(ele) {
        ele.boundingBox();
        return ele[0]._private.labelBounds.main || emptyBb;
    };
    var getSourceLabelBox = function getSourceLabelBox(ele) {
        ele.boundingBox();
        return ele[0]._private.labelBounds.source || emptyBb;
    };
    var getTargetLabelBox = function getTargetLabelBox(ele) {
        ele.boundingBox();
        return ele[0]._private.labelBounds.target || emptyBb;
    };
    var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {
        return scaledLabelShown;
    };
    var getElementRotationPoint = function getElementRotationPoint(ele) {
        return getBoxCenter(getElementBox(ele));
    };
    var addTextMargin = function addTextMargin(prefix, pt, ele) {
        var pre = prefix ? prefix + "-" : "";
        return {
            x: pt.x + ele.pstyle(pre + "text-margin-x").pfValue,
            y: pt.y + ele.pstyle(pre + "text-margin-y").pfValue
        };
    };
    var getRsPt = function getRsPt(ele, x, y) {
        var rs = ele[0]._private.rscratch;
        return {
            x: rs[x],
            y: rs[y]
        };
    };
    var getLabelRotationPoint = function getLabelRotationPoint(ele) {
        return addTextMargin("", getRsPt(ele, "labelX", "labelY"), ele);
    };
    var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {
        return addTextMargin("source", getRsPt(ele, "sourceLabelX", "sourceLabelY"), ele);
    };
    var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {
        return addTextMargin("target", getRsPt(ele, "targetLabelX", "targetLabelY"), ele);
    };
    var getElementRotationOffset = function getElementRotationOffset(ele) {
        return getCenterOffset(getElementBox(ele));
    };
    var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {
        return getCenterOffset(getSourceLabelBox(ele));
    };
    var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {
        return getCenterOffset(getTargetLabelBox(ele));
    };
    var getLabelRotationOffset = function getLabelRotationOffset(ele) {
        var bb = getLabelBox(ele);
        var p = getCenterOffset(getLabelBox(ele));
        if (ele.isNode()) {
            switch(ele.pstyle("text-halign").value){
                case "left":
                    p.x = -bb.w;
                    break;
                case "right":
                    p.x = 0;
                    break;
            }
            switch(ele.pstyle("text-valign").value){
                case "top":
                    p.y = -bb.h;
                    break;
                case "bottom":
                    p.y = 0;
                    break;
            }
        }
        return p;
    };
    var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {
        getKey: getStyleKey,
        doesEleInvalidateKey: backgroundTimestampHasChanged,
        drawElement: drawElement,
        getBoundingBox: getElementBox,
        getRotationPoint: getElementRotationPoint,
        getRotationOffset: getElementRotationOffset,
        allowEdgeTxrCaching: false,
        allowParentTxrCaching: false
    });
    var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {
        getKey: getLabelKey,
        drawElement: drawLabel,
        getBoundingBox: getLabelBox,
        getRotationPoint: getLabelRotationPoint,
        getRotationOffset: getLabelRotationOffset,
        isVisible: isLabelVisibleAtScale
    });
    var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {
        getKey: getSourceLabelKey,
        drawElement: drawSourceLabel,
        getBoundingBox: getSourceLabelBox,
        getRotationPoint: getSourceLabelRotationPoint,
        getRotationOffset: getSourceLabelRotationOffset,
        isVisible: isLabelVisibleAtScale
    });
    var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {
        getKey: getTargetLabelKey,
        drawElement: drawTargetLabel,
        getBoundingBox: getTargetLabelBox,
        getRotationPoint: getTargetLabelRotationPoint,
        getRotationOffset: getTargetLabelRotationOffset,
        isVisible: isLabelVisibleAtScale
    });
    var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);
    r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {
        // each cache should check for sub-key diff to see that the update affects that cache particularly
        eleTxrCache.invalidateElements(eles);
        lblTxrCache.invalidateElements(eles);
        slbTxrCache.invalidateElements(eles);
        tlbTxrCache.invalidateElements(eles); // any change invalidates the layers
        lyrTxrCache.invalidateElements(eles); // update the old bg timestamp so diffs can be done in the ele txr caches
        for(var _i = 0; _i < eles.length; _i++){
            var _p = eles[_i]._private;
            _p.oldBackgroundTimestamp = _p.backgroundTimestamp;
        }
    });
    var refineInLayers = function refineInLayers(reqs) {
        for(var i = 0; i < reqs.length; i++)lyrTxrCache.enqueueElementRefinement(reqs[i].ele);
    };
    eleTxrCache.onDequeue(refineInLayers);
    lblTxrCache.onDequeue(refineInLayers);
    slbTxrCache.onDequeue(refineInLayers);
    tlbTxrCache.onDequeue(refineInLayers);
}
CRp.redrawHint = function(group, bool) {
    var r = this;
    switch(group){
        case "eles":
            r.data.canvasNeedsRedraw[CRp.NODE] = bool;
            break;
        case "drag":
            r.data.canvasNeedsRedraw[CRp.DRAG] = bool;
            break;
        case "select":
            r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;
            break;
    }
}; // whether to use Path2D caching for drawing
var pathsImpld = typeof Path2D !== "undefined";
CRp.path2dEnabled = function(on) {
    if (on === undefined) return this.pathsEnabled;
    this.pathsEnabled = on ? true : false;
};
CRp.usePaths = function() {
    return pathsImpld && this.pathsEnabled;
};
CRp.setImgSmoothing = function(context, bool) {
    if (context.imageSmoothingEnabled != null) context.imageSmoothingEnabled = bool;
    else {
        context.webkitImageSmoothingEnabled = bool;
        context.mozImageSmoothingEnabled = bool;
        context.msImageSmoothingEnabled = bool;
    }
};
CRp.getImgSmoothing = function(context) {
    if (context.imageSmoothingEnabled != null) return context.imageSmoothingEnabled;
    else return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;
};
CRp.makeOffscreenCanvas = function(width, height) {
    var canvas;
    if ((typeof OffscreenCanvas === "undefined" ? "undefined" : _typeof(OffscreenCanvas)) !== "undefined") canvas = new OffscreenCanvas(width, height);
    else {
        canvas = document.createElement("canvas"); // eslint-disable-line no-undef
        canvas.width = width;
        canvas.height = height;
    }
    return canvas;
};
[
    CRp$a,
    CRp$9,
    CRp$8,
    CRp$7,
    CRp$6,
    CRp$5,
    CRp$4,
    CRp$3,
    CRp$2,
    CRp$1
].forEach(function(props) {
    extend(CRp, props);
});
var renderer = [
    {
        name: "null",
        impl: NullRenderer
    },
    {
        name: "base",
        impl: BR
    },
    {
        name: "canvas",
        impl: CR
    }
];
var incExts = [
    {
        type: "layout",
        extensions: layout
    },
    {
        type: "renderer",
        extensions: renderer
    }
];
var extensions = {}; // registered modules for extensions, indexed by name
var modules = {};
function setExtension(type, name, registrant) {
    var ext = registrant;
    var overrideErr = function overrideErr(field) {
        warn("Can not register `" + name + "` for `" + type + "` since `" + field + "` already exists in the prototype and can not be overridden");
    };
    if (type === "core") {
        if (Core.prototype[name]) return overrideErr(name);
        else Core.prototype[name] = registrant;
    } else if (type === "collection") {
        if (Collection.prototype[name]) return overrideErr(name);
        else Collection.prototype[name] = registrant;
    } else if (type === "layout") {
        // fill in missing layout functions in the prototype
        var Layout = function Layout(options) {
            this.options = options;
            registrant.call(this, options); // make sure layout has _private for use w/ std apis like .on()
            if (!plainObject(this._private)) this._private = {};
            this._private.cy = options.cy;
            this._private.listeners = [];
            this.createEmitter();
        };
        var layoutProto = Layout.prototype = Object.create(registrant.prototype);
        var optLayoutFns = [];
        for(var i = 0; i < optLayoutFns.length; i++){
            var fnName = optLayoutFns[i];
            layoutProto[fnName] = layoutProto[fnName] || function() {
                return this;
            };
        } // either .start() or .run() is defined, so autogen the other
        if (layoutProto.start && !layoutProto.run) layoutProto.run = function() {
            this.start();
            return this;
        };
        else if (!layoutProto.start && layoutProto.run) layoutProto.start = function() {
            this.run();
            return this;
        };
        var regStop = registrant.prototype.stop;
        layoutProto.stop = function() {
            var opts = this.options;
            if (opts && opts.animate) {
                var anis = this.animations;
                if (anis) for(var _i = 0; _i < anis.length; _i++)anis[_i].stop();
            }
            if (regStop) regStop.call(this);
            else this.emit("layoutstop");
            return this;
        };
        if (!layoutProto.destroy) layoutProto.destroy = function() {
            return this;
        };
        layoutProto.cy = function() {
            return this._private.cy;
        };
        var getCy = function getCy(layout) {
            return layout._private.cy;
        };
        var emitterOpts = {
            addEventFields: function addEventFields(layout, evt) {
                evt.layout = layout;
                evt.cy = getCy(layout);
                evt.target = layout;
            },
            bubble: function bubble() {
                return true;
            },
            parent: function parent(layout) {
                return getCy(layout);
            }
        };
        extend(layoutProto, {
            createEmitter: function createEmitter() {
                this._private.emitter = new Emitter(emitterOpts, this);
                return this;
            },
            emitter: function emitter() {
                return this._private.emitter;
            },
            on: function on(evt, cb) {
                this.emitter().on(evt, cb);
                return this;
            },
            one: function one(evt, cb) {
                this.emitter().one(evt, cb);
                return this;
            },
            once: function once(evt, cb) {
                this.emitter().one(evt, cb);
                return this;
            },
            removeListener: function removeListener(evt, cb) {
                this.emitter().removeListener(evt, cb);
                return this;
            },
            removeAllListeners: function removeAllListeners() {
                this.emitter().removeAllListeners();
                return this;
            },
            emit: function emit(evt, params) {
                this.emitter().emit(evt, params);
                return this;
            }
        });
        define.eventAliasesOn(layoutProto);
        ext = Layout; // replace with our wrapped layout
    } else if (type === "renderer" && name !== "null" && name !== "base") {
        // user registered renderers inherit from base
        var BaseRenderer = getExtension("renderer", "base");
        var bProto = BaseRenderer.prototype;
        var RegistrantRenderer = registrant;
        var rProto = registrant.prototype;
        var Renderer = function Renderer() {
            BaseRenderer.apply(this, arguments);
            RegistrantRenderer.apply(this, arguments);
        };
        var proto = Renderer.prototype;
        for(var pName in bProto){
            var pVal = bProto[pName];
            var existsInR = rProto[pName] != null;
            if (existsInR) return overrideErr(pName);
            proto[pName] = pVal; // take impl from base
        }
        for(var _pName in rProto)proto[_pName] = rProto[_pName]; // take impl from registrant
        bProto.clientFunctions.forEach(function(name) {
            proto[name] = proto[name] || function() {
                error("Renderer does not implement `renderer." + name + "()` on its prototype");
            };
        });
        ext = Renderer;
    } else if (type === "__proto__" || type === "constructor" || type === "prototype") // to avoid potential prototype pollution
    return error(type + " is an illegal type to be registered, possibly lead to prototype pollutions");
    return setMap({
        map: extensions,
        keys: [
            type,
            name
        ],
        value: ext
    });
}
function getExtension(type, name) {
    return getMap({
        map: extensions,
        keys: [
            type,
            name
        ]
    });
}
function setModule(type, name, moduleType, moduleName, registrant) {
    return setMap({
        map: modules,
        keys: [
            type,
            name,
            moduleType,
            moduleName
        ],
        value: registrant
    });
}
function getModule(type, name, moduleType, moduleName) {
    return getMap({
        map: modules,
        keys: [
            type,
            name,
            moduleType,
            moduleName
        ]
    });
}
var extension = function extension() {
    // e.g. extension('renderer', 'svg')
    if (arguments.length === 2) return getExtension.apply(null, arguments);
    else if (arguments.length === 3) return setExtension.apply(null, arguments);
    else if (arguments.length === 4) return getModule.apply(null, arguments);
    else if (arguments.length === 5) return setModule.apply(null, arguments);
    else error("Invalid extension access syntax");
}; // allows a core instance to access extensions internally
Core.prototype.extension = extension; // included extensions
incExts.forEach(function(group) {
    group.extensions.forEach(function(ext) {
        setExtension(group.type, ext.name, ext.impl);
    });
});
// (useful for init)
var Stylesheet = function Stylesheet() {
    if (!(this instanceof Stylesheet)) return new Stylesheet();
    this.length = 0;
};
var sheetfn = Stylesheet.prototype;
sheetfn.instanceString = function() {
    return "stylesheet";
}; // just store the selector to be parsed later
sheetfn.selector = function(selector) {
    var i = this.length++;
    this[i] = {
        selector: selector,
        properties: []
    };
    return this; // chaining
}; // just store the property to be parsed later
sheetfn.css = function(name, value) {
    var i = this.length - 1;
    if (string(name)) this[i].properties.push({
        name: name,
        value: value
    });
    else if (plainObject(name)) {
        var map = name;
        var propNames = Object.keys(map);
        for(var j = 0; j < propNames.length; j++){
            var key = propNames[j];
            var mapVal = map[key];
            if (mapVal == null) continue;
            var prop = Style.properties[key] || Style.properties[dash2camel(key)];
            if (prop == null) continue;
            var _name = prop.name;
            var _value = mapVal;
            this[i].properties.push({
                name: _name,
                value: _value
            });
        }
    }
    return this; // chaining
};
sheetfn.style = sheetfn.css; // generate a real style object from the dummy stylesheet
sheetfn.generateStyle = function(cy) {
    var style = new Style(cy);
    return this.appendToStyle(style);
}; // append a dummy stylesheet object on a real style object
sheetfn.appendToStyle = function(style) {
    for(var i = 0; i < this.length; i++){
        var context = this[i];
        var selector = context.selector;
        var props = context.properties;
        style.selector(selector); // apply selector
        for(var j = 0; j < props.length; j++){
            var prop = props[j];
            style.css(prop.name, prop.value); // apply property
        }
    }
    return style;
};
var version = "3.22.1";
var cytoscape = function cytoscape(options) {
    // if no options specified, use default
    if (options === undefined) options = {};
     // create instance
    if (plainObject(options)) return new Core(options);
    else if (string(options)) return extension.apply(extension, arguments);
}; // e.g. cytoscape.use( require('cytoscape-foo'), bar )
cytoscape.use = function(ext) {
    var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext
    args.unshift(cytoscape); // cytoscape is first arg to ext
    ext.apply(null, args);
    return this;
};
cytoscape.warnings = function(bool) {
    return warnings(bool);
}; // replaced by build system
cytoscape.version = version; // expose public apis (mostly for extensions)
cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;
module.exports = cytoscape;

},{"lodash/debounce":"bv6vy","heap":"j0cbr","lodash/get":"8UELX","lodash/set":"uwDF1","lodash/toPath":"hH9yA"}],"bv6vy":[function(require,module,exports) {
var isObject = require("./isObject"), now = require("./now"), toNumber = require("./toNumber");
/** Error message constants. */ var FUNC_ERROR_TEXT = "Expected a function";
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */ function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) return trailingEdge(time);
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) return invokeFunc(time);
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) clearTimeout(timerId);
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) return leadingEdge(lastCallTime);
            if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) timerId = setTimeout(timerExpired, wait);
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
}
module.exports = debounce;

},{"./isObject":"cGhqJ","./now":"kOH6e","./toNumber":"12NaH"}],"cGhqJ":[function(require,module,exports) {
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
}
module.exports = isObject;

},{}],"kOH6e":[function(require,module,exports) {
var root = require("./_root");
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */ var now = function() {
    return root.Date.now();
};
module.exports = now;

},{"./_root":"dSYUs"}],"dSYUs":[function(require,module,exports) {
var freeGlobal = require("./_freeGlobal");
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
module.exports = root;

},{"./_freeGlobal":"kAk32"}],"kAk32":[function(require,module,exports) {
var global = arguments[3];
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
module.exports = freeGlobal;

},{}],"12NaH":[function(require,module,exports) {
var baseTrim = require("./_baseTrim"), isObject = require("./isObject"), isSymbol = require("./isSymbol");
/** Used as references for various `Number` constants. */ var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == "number") return value;
    if (isSymbol(value)) return NAN;
    if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") return value === 0 ? value : +value;
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = toNumber;

},{"./_baseTrim":"eUJZ3","./isObject":"cGhqJ","./isSymbol":"i3BHC"}],"eUJZ3":[function(require,module,exports) {
var trimmedEndIndex = require("./_trimmedEndIndex");
/** Used to match leading whitespace. */ var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */ function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
module.exports = baseTrim;

},{"./_trimmedEndIndex":"hHJmS"}],"hHJmS":[function(require,module,exports) {
/** Used to match a single whitespace character. */ var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */ function trimmedEndIndex(string) {
    var index = string.length;
    while(index-- && reWhitespace.test(string.charAt(index)));
    return index;
}
module.exports = trimmedEndIndex;

},{}],"i3BHC":[function(require,module,exports) {
var baseGetTag = require("./_baseGetTag"), isObjectLike = require("./isObjectLike");
/** `Object#toString` result references. */ var symbolTag = "[object Symbol]";
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
module.exports = isSymbol;

},{"./_baseGetTag":"lOnbo","./isObjectLike":"3BLi4"}],"lOnbo":[function(require,module,exports) {
var Symbol = require("./_Symbol"), getRawTag = require("./_getRawTag"), objectToString = require("./_objectToString");
/** `Object#toString` result references. */ var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) return value === undefined ? undefinedTag : nullTag;
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
module.exports = baseGetTag;

},{"./_Symbol":"7lsL9","./_getRawTag":"995sO","./_objectToString":"bmE3g"}],"7lsL9":[function(require,module,exports) {
var root = require("./_root");
/** Built-in value references. */ var Symbol = root.Symbol;
module.exports = Symbol;

},{"./_root":"dSYUs"}],"995sO":[function(require,module,exports) {
var Symbol = require("./_Symbol");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) value[symToStringTag] = tag;
        else delete value[symToStringTag];
    }
    return result;
}
module.exports = getRawTag;

},{"./_Symbol":"7lsL9"}],"bmE3g":[function(require,module,exports) {
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
module.exports = objectToString;

},{}],"3BLi4":[function(require,module,exports) {
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == "object";
}
module.exports = isObjectLike;

},{}],"j0cbr":[function(require,module,exports) {
module.exports = require("./lib/heap");

},{"./lib/heap":"gZPHW"}],"gZPHW":[function(require,module,exports) {
// Generated by CoffeeScript 1.8.0
(function() {
    var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;
    floor = Math.floor, min = Math.min;
    /*
  Default comparison function to be used
   */ defaultCmp = function(x, y) {
        if (x < y) return -1;
        if (x > y) return 1;
        return 0;
    };
    /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */ insort = function(a, x, lo, hi, cmp) {
        var mid;
        if (lo == null) lo = 0;
        if (cmp == null) cmp = defaultCmp;
        if (lo < 0) throw new Error("lo must be non-negative");
        if (hi == null) hi = a.length;
        while(lo < hi){
            mid = floor((lo + hi) / 2);
            if (cmp(x, a[mid]) < 0) hi = mid;
            else lo = mid + 1;
        }
        return [].splice.apply(a, [
            lo,
            lo - lo
        ].concat(x)), x;
    };
    /*
  Push item onto heap, maintaining the heap invariant.
   */ heappush = function(array, item, cmp) {
        if (cmp == null) cmp = defaultCmp;
        array.push(item);
        return _siftdown(array, 0, array.length - 1, cmp);
    };
    /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */ heappop = function(array, cmp) {
        var lastelt, returnitem;
        if (cmp == null) cmp = defaultCmp;
        lastelt = array.pop();
        if (array.length) {
            returnitem = array[0];
            array[0] = lastelt;
            _siftup(array, 0, cmp);
        } else returnitem = lastelt;
        return returnitem;
    };
    /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */ heapreplace = function(array, item, cmp) {
        var returnitem;
        if (cmp == null) cmp = defaultCmp;
        returnitem = array[0];
        array[0] = item;
        _siftup(array, 0, cmp);
        return returnitem;
    };
    /*
  Fast version of a heappush followed by a heappop.
   */ heappushpop = function(array, item, cmp) {
        var _ref;
        if (cmp == null) cmp = defaultCmp;
        if (array.length && cmp(array[0], item) < 0) {
            _ref = [
                array[0],
                item
            ], item = _ref[0], array[0] = _ref[1];
            _siftup(array, 0, cmp);
        }
        return item;
    };
    /*
  Transform list into a heap, in-place, in O(array.length) time.
   */ heapify = function(array, cmp) {
        var i, _i, _j, _len, _ref, _ref1, _results, _results1;
        if (cmp == null) cmp = defaultCmp;
        _ref1 = (function() {
            _results1 = [];
            for(var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--)_results1.push(_j);
            return _results1;
        }).apply(this).reverse();
        _results = [];
        for(_i = 0, _len = _ref1.length; _i < _len; _i++){
            i = _ref1[_i];
            _results.push(_siftup(array, i, cmp));
        }
        return _results;
    };
    /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */ updateItem = function(array, item, cmp) {
        var pos;
        if (cmp == null) cmp = defaultCmp;
        pos = array.indexOf(item);
        if (pos === -1) return;
        _siftdown(array, 0, pos, cmp);
        return _siftup(array, pos, cmp);
    };
    /*
  Find the n largest elements in a dataset.
   */ nlargest = function(array, n, cmp) {
        var elem, result, _i, _len, _ref;
        if (cmp == null) cmp = defaultCmp;
        result = array.slice(0, n);
        if (!result.length) return result;
        heapify(result, cmp);
        _ref = array.slice(n);
        for(_i = 0, _len = _ref.length; _i < _len; _i++){
            elem = _ref[_i];
            heappushpop(result, elem, cmp);
        }
        return result.sort(cmp).reverse();
    };
    /*
  Find the n smallest elements in a dataset.
   */ nsmallest = function(array, n, cmp) {
        var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
        if (cmp == null) cmp = defaultCmp;
        if (n * 10 <= array.length) {
            result = array.slice(0, n).sort(cmp);
            if (!result.length) return result;
            los = result[result.length - 1];
            _ref = array.slice(n);
            for(_i = 0, _len = _ref.length; _i < _len; _i++){
                elem = _ref[_i];
                if (cmp(elem, los) < 0) {
                    insort(result, elem, 0, null, cmp);
                    result.pop();
                    los = result[result.length - 1];
                }
            }
            return result;
        }
        heapify(array, cmp);
        _results = [];
        for(i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j)_results.push(heappop(array, cmp));
        return _results;
    };
    _siftdown = function(array, startpos, pos, cmp) {
        var newitem, parent, parentpos;
        if (cmp == null) cmp = defaultCmp;
        newitem = array[pos];
        while(pos > startpos){
            parentpos = pos - 1 >> 1;
            parent = array[parentpos];
            if (cmp(newitem, parent) < 0) {
                array[pos] = parent;
                pos = parentpos;
                continue;
            }
            break;
        }
        return array[pos] = newitem;
    };
    _siftup = function(array, pos, cmp) {
        var childpos, endpos, newitem, rightpos, startpos;
        if (cmp == null) cmp = defaultCmp;
        endpos = array.length;
        startpos = pos;
        newitem = array[pos];
        childpos = 2 * pos + 1;
        while(childpos < endpos){
            rightpos = childpos + 1;
            if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) childpos = rightpos;
            array[pos] = array[childpos];
            pos = childpos;
            childpos = 2 * pos + 1;
        }
        array[pos] = newitem;
        return _siftdown(array, startpos, pos, cmp);
    };
    Heap = function() {
        Heap.push = heappush;
        Heap.pop = heappop;
        Heap.replace = heapreplace;
        Heap.pushpop = heappushpop;
        Heap.heapify = heapify;
        Heap.updateItem = updateItem;
        Heap.nlargest = nlargest;
        Heap.nsmallest = nsmallest;
        function Heap(cmp) {
            this.cmp = cmp != null ? cmp : defaultCmp;
            this.nodes = [];
        }
        Heap.prototype.push = function(x) {
            return heappush(this.nodes, x, this.cmp);
        };
        Heap.prototype.pop = function() {
            return heappop(this.nodes, this.cmp);
        };
        Heap.prototype.peek = function() {
            return this.nodes[0];
        };
        Heap.prototype.contains = function(x) {
            return this.nodes.indexOf(x) !== -1;
        };
        Heap.prototype.replace = function(x) {
            return heapreplace(this.nodes, x, this.cmp);
        };
        Heap.prototype.pushpop = function(x) {
            return heappushpop(this.nodes, x, this.cmp);
        };
        Heap.prototype.heapify = function() {
            return heapify(this.nodes, this.cmp);
        };
        Heap.prototype.updateItem = function(x) {
            return updateItem(this.nodes, x, this.cmp);
        };
        Heap.prototype.clear = function() {
            return this.nodes = [];
        };
        Heap.prototype.empty = function() {
            return this.nodes.length === 0;
        };
        Heap.prototype.size = function() {
            return this.nodes.length;
        };
        Heap.prototype.clone = function() {
            var heap;
            heap = new Heap();
            heap.nodes = this.nodes.slice(0);
            return heap;
        };
        Heap.prototype.toArray = function() {
            return this.nodes.slice(0);
        };
        Heap.prototype.insert = Heap.prototype.push;
        Heap.prototype.top = Heap.prototype.peek;
        Heap.prototype.front = Heap.prototype.peek;
        Heap.prototype.has = Heap.prototype.contains;
        Heap.prototype.copy = Heap.prototype.clone;
        return Heap;
    }();
    (function(root, factory) {
        if (typeof define === "function" && define.amd) return define([], factory);
        else return module.exports = factory();
    })(this, function() {
        return Heap;
    });
}).call(this);

},{}],"8UELX":[function(require,module,exports) {
var baseGet = require("./_baseGet");
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */ function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
}
module.exports = get;

},{"./_baseGet":"kMRe3"}],"kMRe3":[function(require,module,exports) {
var castPath = require("./_castPath"), toKey = require("./_toKey");
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */ function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while(object != null && index < length)object = object[toKey(path[index++])];
    return index && index == length ? object : undefined;
}
module.exports = baseGet;

},{"./_castPath":"apxk5","./_toKey":"bEgue"}],"apxk5":[function(require,module,exports) {
var isArray = require("./isArray"), isKey = require("./_isKey"), stringToPath = require("./_stringToPath"), toString = require("./toString");
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */ function castPath(value, object) {
    if (isArray(value)) return value;
    return isKey(value, object) ? [
        value
    ] : stringToPath(toString(value));
}
module.exports = castPath;

},{"./isArray":"dZaTH","./_isKey":"4wPWG","./_stringToPath":"1m1j5","./toString":"joIdQ"}],"dZaTH":[function(require,module,exports) {
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
module.exports = isArray;

},{}],"4wPWG":[function(require,module,exports) {
var isArray = require("./isArray"), isSymbol = require("./isSymbol");
/** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */ function isKey(value, object) {
    if (isArray(value)) return false;
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) return true;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
module.exports = isKey;

},{"./isArray":"dZaTH","./isSymbol":"i3BHC"}],"1m1j5":[function(require,module,exports) {
var memoizeCapped = require("./_memoizeCapped");
/** Used to match property names within property paths. */ var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */ var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */ ) result.push("");
    string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
});
module.exports = stringToPath;

},{"./_memoizeCapped":"j3xlQ"}],"j3xlQ":[function(require,module,exports) {
var memoize = require("./memoize");
/** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */ function memoizeCapped(func) {
    var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) cache.clear();
        return key;
    });
    var cache = result.cache;
    return result;
}
module.exports = memoizeCapped;

},{"./memoize":"azHKC"}],"azHKC":[function(require,module,exports) {
var MapCache = require("./_MapCache");
/** Error message constants. */ var FUNC_ERROR_TEXT = "Expected a function";
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */ function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") throw new TypeError(FUNC_ERROR_TEXT);
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) return cache.get(key);
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
}
// Expose `MapCache`.
memoize.Cache = MapCache;
module.exports = memoize;

},{"./_MapCache":"664I1"}],"664I1":[function(require,module,exports) {
var mapCacheClear = require("./_mapCacheClear"), mapCacheDelete = require("./_mapCacheDelete"), mapCacheGet = require("./_mapCacheGet"), mapCacheHas = require("./_mapCacheHas"), mapCacheSet = require("./_mapCacheSet");
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

},{"./_mapCacheClear":"7kHs4","./_mapCacheDelete":"4ny9y","./_mapCacheGet":"gVeFY","./_mapCacheHas":"idSOY","./_mapCacheSet":"lXUJT"}],"7kHs4":[function(require,module,exports) {
var Hash = require("./_Hash"), ListCache = require("./_ListCache"), Map = require("./_Map");
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
module.exports = mapCacheClear;

},{"./_Hash":"jFMT5","./_ListCache":"3UZeo","./_Map":"8YjF4"}],"jFMT5":[function(require,module,exports) {
var hashClear = require("./_hashClear"), hashDelete = require("./_hashDelete"), hashGet = require("./_hashGet"), hashHas = require("./_hashHas"), hashSet = require("./_hashSet");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

},{"./_hashClear":"f2NRo","./_hashDelete":"cCdgz","./_hashGet":"eKqTO","./_hashHas":"ghnqP","./_hashSet":"6i99R"}],"f2NRo":[function(require,module,exports) {
var nativeCreate = require("./_nativeCreate");
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
}
module.exports = hashClear;

},{"./_nativeCreate":"6i8Uf"}],"6i8Uf":[function(require,module,exports) {
var getNative = require("./_getNative");
/* Built-in method references that are verified to be native. */ var nativeCreate = getNative(Object, "create");
module.exports = nativeCreate;

},{"./_getNative":"9PCIl"}],"9PCIl":[function(require,module,exports) {
var baseIsNative = require("./_baseIsNative"), getValue = require("./_getValue");
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
module.exports = getNative;

},{"./_baseIsNative":"2U9Pn","./_getValue":"kKx5I"}],"2U9Pn":[function(require,module,exports) {
var isFunction = require("./isFunction"), isMasked = require("./_isMasked"), isObject = require("./isObject"), toSource = require("./_toSource");
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
module.exports = baseIsNative;

},{"./isFunction":"cfti6","./_isMasked":"cMDzi","./isObject":"cGhqJ","./_toSource":"bYHc7"}],"cfti6":[function(require,module,exports) {
var baseGetTag = require("./_baseGetTag"), isObject = require("./isObject");
/** `Object#toString` result references. */ var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    if (!isObject(value)) return false;
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
module.exports = isFunction;

},{"./_baseGetTag":"lOnbo","./isObject":"cGhqJ"}],"cMDzi":[function(require,module,exports) {
var coreJsData = require("./_coreJsData");
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
module.exports = isMasked;

},{"./_coreJsData":"6gJwQ"}],"6gJwQ":[function(require,module,exports) {
var root = require("./_root");
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
module.exports = coreJsData;

},{"./_root":"dSYUs"}],"bYHc7":[function(require,module,exports) {
/** Used for built-in method references. */ var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e1) {}
    }
    return "";
}
module.exports = toSource;

},{}],"kKx5I":[function(require,module,exports) {
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
module.exports = getValue;

},{}],"cCdgz":[function(require,module,exports) {
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
module.exports = hashDelete;

},{}],"eKqTO":[function(require,module,exports) {
var nativeCreate = require("./_nativeCreate");
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
module.exports = hashGet;

},{"./_nativeCreate":"6i8Uf"}],"ghnqP":[function(require,module,exports) {
var nativeCreate = require("./_nativeCreate");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
module.exports = hashHas;

},{"./_nativeCreate":"6i8Uf"}],"6i99R":[function(require,module,exports) {
var nativeCreate = require("./_nativeCreate");
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
module.exports = hashSet;

},{"./_nativeCreate":"6i8Uf"}],"3UZeo":[function(require,module,exports) {
var listCacheClear = require("./_listCacheClear"), listCacheDelete = require("./_listCacheDelete"), listCacheGet = require("./_listCacheGet"), listCacheHas = require("./_listCacheHas"), listCacheSet = require("./_listCacheSet");
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

},{"./_listCacheClear":"7AKQv","./_listCacheDelete":"j2Z5O","./_listCacheGet":"6Zrrs","./_listCacheHas":"i1CBK","./_listCacheSet":"2Rcur"}],"7AKQv":[function(require,module,exports) {
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
module.exports = listCacheClear;

},{}],"j2Z5O":[function(require,module,exports) {
var assocIndexOf = require("./_assocIndexOf");
/** Used for built-in method references. */ var arrayProto = Array.prototype;
/** Built-in value references. */ var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    --this.size;
    return true;
}
module.exports = listCacheDelete;

},{"./_assocIndexOf":"cRVsl"}],"cRVsl":[function(require,module,exports) {
var eq = require("./eq");
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
module.exports = assocIndexOf;

},{"./eq":"aVz5f"}],"aVz5f":[function(require,module,exports) {
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
module.exports = eq;

},{}],"6Zrrs":[function(require,module,exports) {
var assocIndexOf = require("./_assocIndexOf");
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
module.exports = listCacheGet;

},{"./_assocIndexOf":"cRVsl"}],"i1CBK":[function(require,module,exports) {
var assocIndexOf = require("./_assocIndexOf");
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
module.exports = listCacheHas;

},{"./_assocIndexOf":"cRVsl"}],"2Rcur":[function(require,module,exports) {
var assocIndexOf = require("./_assocIndexOf");
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else data[index][1] = value;
    return this;
}
module.exports = listCacheSet;

},{"./_assocIndexOf":"cRVsl"}],"8YjF4":[function(require,module,exports) {
var getNative = require("./_getNative"), root = require("./_root");
/* Built-in method references that are verified to be native. */ var Map = getNative(root, "Map");
module.exports = Map;

},{"./_getNative":"9PCIl","./_root":"dSYUs"}],"4ny9y":[function(require,module,exports) {
var getMapData = require("./_getMapData");
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
}
module.exports = mapCacheDelete;

},{"./_getMapData":"aptgk"}],"aptgk":[function(require,module,exports) {
var isKeyable = require("./_isKeyable");
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
module.exports = getMapData;

},{"./_isKeyable":"icylN"}],"icylN":[function(require,module,exports) {
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
module.exports = isKeyable;

},{}],"gVeFY":[function(require,module,exports) {
var getMapData = require("./_getMapData");
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
module.exports = mapCacheGet;

},{"./_getMapData":"aptgk"}],"idSOY":[function(require,module,exports) {
var getMapData = require("./_getMapData");
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
module.exports = mapCacheHas;

},{"./_getMapData":"aptgk"}],"lXUJT":[function(require,module,exports) {
var getMapData = require("./_getMapData");
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
module.exports = mapCacheSet;

},{"./_getMapData":"aptgk"}],"joIdQ":[function(require,module,exports) {
var baseToString = require("./_baseToString");
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? "" : baseToString(value);
}
module.exports = toString;

},{"./_baseToString":"goDP8"}],"goDP8":[function(require,module,exports) {
var Symbol = require("./_Symbol"), arrayMap = require("./_arrayMap"), isArray = require("./isArray"), isSymbol = require("./isSymbol");
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == "string") return value;
    if (isArray(value)) // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + "";
    if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
module.exports = baseToString;

},{"./_Symbol":"7lsL9","./_arrayMap":"imI5Z","./isArray":"dZaTH","./isSymbol":"i3BHC"}],"imI5Z":[function(require,module,exports) {
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */ function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while(++index < length)result[index] = iteratee(array[index], index, array);
    return result;
}
module.exports = arrayMap;

},{}],"bEgue":[function(require,module,exports) {
var isSymbol = require("./isSymbol");
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) return value;
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
module.exports = toKey;

},{"./isSymbol":"i3BHC"}],"uwDF1":[function(require,module,exports) {
var baseSet = require("./_baseSet");
/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */ function set(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
}
module.exports = set;

},{"./_baseSet":"5Mi1g"}],"5Mi1g":[function(require,module,exports) {
var assignValue = require("./_assignValue"), castPath = require("./_castPath"), isIndex = require("./_isIndex"), isObject = require("./isObject"), toKey = require("./_toKey");
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */ function baseSet(object, path, value, customizer) {
    if (!isObject(object)) return object;
    path = castPath(path, object);
    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
    while(nested != null && ++index < length){
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") return object;
        if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined;
            if (newValue === undefined) newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
    }
    return object;
}
module.exports = baseSet;

},{"./_assignValue":"5M3eX","./_castPath":"apxk5","./_isIndex":"aJpx0","./isObject":"cGhqJ","./_toKey":"bEgue"}],"5M3eX":[function(require,module,exports) {
var baseAssignValue = require("./_baseAssignValue"), eq = require("./eq");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) baseAssignValue(object, key, value);
}
module.exports = assignValue;

},{"./_baseAssignValue":"fprBU","./eq":"aVz5f"}],"fprBU":[function(require,module,exports) {
var defineProperty = require("./_defineProperty");
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
    });
    else object[key] = value;
}
module.exports = baseAssignValue;

},{"./_defineProperty":"cZOnw"}],"cZOnw":[function(require,module,exports) {
var getNative = require("./_getNative");
var defineProperty = function() {
    try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
    } catch (e) {}
}();
module.exports = defineProperty;

},{"./_getNative":"9PCIl"}],"aJpx0":[function(require,module,exports) {
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
module.exports = isIndex;

},{}],"hH9yA":[function(require,module,exports) {
var arrayMap = require("./_arrayMap"), copyArray = require("./_copyArray"), isArray = require("./isArray"), isSymbol = require("./isSymbol"), stringToPath = require("./_stringToPath"), toKey = require("./_toKey"), toString = require("./toString");
/**
 * Converts `value` to a property path array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {*} value The value to convert.
 * @returns {Array} Returns the new property path array.
 * @example
 *
 * _.toPath('a.b.c');
 * // => ['a', 'b', 'c']
 *
 * _.toPath('a[0].b.c');
 * // => ['a', '0', 'b', 'c']
 */ function toPath(value) {
    if (isArray(value)) return arrayMap(value, toKey);
    return isSymbol(value) ? [
        value
    ] : copyArray(stringToPath(toString(value)));
}
module.exports = toPath;

},{"./_arrayMap":"imI5Z","./_copyArray":"jJ8fu","./isArray":"dZaTH","./isSymbol":"i3BHC","./_stringToPath":"1m1j5","./_toKey":"bEgue","./toString":"joIdQ"}],"jJ8fu":[function(require,module,exports) {
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */ function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length)array[index] = source[index];
    return array;
}
module.exports = copyArray;

},{}],"6GhNo":[function(require,module,exports) {
(function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory(require("cose-base"));
})(self, function(__WEBPACK_EXTERNAL_MODULE__281__) {
    return /******/ (()=>{
        /******/ "use strict";
        /******/ var __webpack_modules__ = {
            /***/ 658: (module1)=>{
                // Simple, internal Object.assign() polyfill for options objects etc.
                module1.exports = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {
                    for(var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)srcs[_key - 1] = arguments[_key];
                    srcs.forEach(function(src) {
                        Object.keys(src).forEach(function(k) {
                            return tgt[k] = src[k];
                        });
                    });
                    return tgt;
                };
            /***/ },
            /***/ 548: (module1, __unused_webpack_exports, __webpack_require__)=>{
                /*
 * Auxiliary functions
 */ var LinkedList = __webpack_require__(281).layoutBase.LinkedList;
                var auxiliary = {};
                // get the top most nodes
                auxiliary.getTopMostNodes = function(nodes) {
                    var nodesMap = {};
                    for(var i = 0; i < nodes.length; i++)nodesMap[nodes[i].id()] = true;
                    var roots = nodes.filter(function(ele, i) {
                        if (typeof ele === "number") ele = i;
                        var parent = ele.parent()[0];
                        while(parent != null){
                            if (nodesMap[parent.id()]) return false;
                            parent = parent.parent()[0];
                        }
                        return true;
                    });
                    return roots;
                };
                // find disconnected components and create dummy nodes that connect them
                auxiliary.connectComponents = function(cy, eles, topMostNodes, dummyNodes) {
                    var queue = new LinkedList();
                    var visited = new Set();
                    var visitedTopMostNodes = [];
                    var currentNeighbor = void 0;
                    var minDegreeNode = void 0;
                    var minDegree = void 0;
                    var isConnected = false;
                    var count = 1;
                    var nodesConnectedToDummy = [];
                    var components = [];
                    var _loop = function _loop() {
                        var cmpt = cy.collection();
                        components.push(cmpt);
                        var currentNode = topMostNodes[0];
                        var childrenOfCurrentNode = cy.collection();
                        childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));
                        visitedTopMostNodes.push(currentNode);
                        childrenOfCurrentNode.forEach(function(node) {
                            queue.push(node);
                            visited.add(node);
                            cmpt.merge(node);
                        });
                        var _loop2 = function _loop2() {
                            currentNode = queue.shift();
                            // Traverse all neighbors of this node
                            var neighborNodes = cy.collection();
                            currentNode.neighborhood().nodes().forEach(function(node) {
                                if (eles.intersection(currentNode.edgesWith(node)).length > 0) neighborNodes.merge(node);
                            });
                            for(var i = 0; i < neighborNodes.length; i++){
                                var neighborNode = neighborNodes[i];
                                currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));
                                if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {
                                    var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());
                                    childrenOfNeighbor.forEach(function(node) {
                                        queue.push(node);
                                        visited.add(node);
                                        cmpt.merge(node);
                                        if (topMostNodes.has(node)) visitedTopMostNodes.push(node);
                                    });
                                }
                            }
                        };
                        while(queue.length != 0)_loop2();
                        cmpt.forEach(function(node) {
                            eles.intersection(node.connectedEdges()).forEach(function(e) {
                                // connectedEdges() usually cached
                                if (cmpt.has(e.source()) && cmpt.has(e.target())) // has() is cheap
                                cmpt.merge(e); // forEach() only considers nodes -- sets N at call time
                            });
                        });
                        if (visitedTopMostNodes.length == topMostNodes.length) isConnected = true;
                        if (!isConnected || isConnected && count > 1) {
                            minDegreeNode = visitedTopMostNodes[0];
                            minDegree = minDegreeNode.connectedEdges().length;
                            visitedTopMostNodes.forEach(function(node) {
                                if (node.connectedEdges().length < minDegree) {
                                    minDegree = node.connectedEdges().length;
                                    minDegreeNode = node;
                                }
                            });
                            nodesConnectedToDummy.push(minDegreeNode.id());
                            // TO DO: Check efficiency of this part
                            var temp = cy.collection();
                            temp.merge(visitedTopMostNodes[0]);
                            visitedTopMostNodes.forEach(function(node) {
                                temp.merge(node);
                            });
                            visitedTopMostNodes = [];
                            topMostNodes = topMostNodes.difference(temp);
                            count++;
                        }
                    };
                    do _loop();
                    while (!isConnected);
                    if (dummyNodes) {
                        if (nodesConnectedToDummy.length > 0) dummyNodes.set("dummy" + (dummyNodes.size + 1), nodesConnectedToDummy);
                    }
                    return components;
                };
                auxiliary.calcBoundingBox = function(parentNode, xCoords, yCoords, nodeIndexes) {
                    // calculate bounds
                    var left = Number.MAX_SAFE_INTEGER;
                    var right = Number.MIN_SAFE_INTEGER;
                    var top = Number.MAX_SAFE_INTEGER;
                    var bottom = Number.MIN_SAFE_INTEGER;
                    var nodeLeft = void 0;
                    var nodeRight = void 0;
                    var nodeTop = void 0;
                    var nodeBottom = void 0;
                    var nodes = parentNode.descendants().not(":parent");
                    var s = nodes.length;
                    for(var i = 0; i < s; i++){
                        var node = nodes[i];
                        nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;
                        nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;
                        nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;
                        nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;
                        if (left > nodeLeft) left = nodeLeft;
                        if (right < nodeRight) right = nodeRight;
                        if (top > nodeTop) top = nodeTop;
                        if (bottom < nodeBottom) bottom = nodeBottom;
                    }
                    var boundingBox = {};
                    boundingBox.topLeftX = left;
                    boundingBox.topLeftY = top;
                    boundingBox.width = right - left;
                    boundingBox.height = bottom - top;
                    return boundingBox;
                };
                module1.exports = auxiliary;
            /***/ },
            /***/ 816: (module1, __unused_webpack_exports, __webpack_require__)=>{
                /**
  The implementation of the postprocessing part that applies CoSE layout over the spectral layout
*/ var aux = __webpack_require__(548);
                var CoSELayout = __webpack_require__(281).CoSELayout;
                var CoSENode = __webpack_require__(281).CoSENode;
                var PointD = __webpack_require__(281).layoutBase.PointD;
                var DimensionD = __webpack_require__(281).layoutBase.DimensionD;
                var LayoutConstants = __webpack_require__(281).layoutBase.LayoutConstants;
                var FDLayoutConstants = __webpack_require__(281).layoutBase.FDLayoutConstants;
                var CoSEConstants = __webpack_require__(281).CoSEConstants;
                // main function that cose layout is processed
                var coseLayout = function coseLayout(options, spectralResult) {
                    var eles = options.eles;
                    var nodes = eles.nodes();
                    var edges = eles.edges();
                    var nodeIndexes = void 0;
                    var xCoords = void 0;
                    var yCoords = void 0;
                    var idToLNode = {};
                    if (options.randomize) {
                        nodeIndexes = spectralResult["nodeIndexes"];
                        xCoords = spectralResult["xCoords"];
                        yCoords = spectralResult["yCoords"];
                    }
                    var isFn = function isFn(fn) {
                        return typeof fn === "function";
                    };
                    var optFn = function optFn(opt, ele) {
                        if (isFn(opt)) return opt(ele);
                        else return opt;
                    };
                    /**** Postprocessing functions ****/ // transfer cytoscape nodes to cose nodes
                    var processChildrenList = function processChildrenList(parent, children, layout, options) {
                        var size = children.length;
                        for(var i = 0; i < size; i++){
                            var theChild = children[i];
                            var children_of_children = theChild.children();
                            var theNode = void 0;
                            var dimensions = theChild.layoutDimensions({
                                nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels
                            });
                            if (theChild.outerWidth() != null && theChild.outerHeight() != null) {
                                if (options.randomize) {
                                    if (!theChild.isParent()) theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));
                                    else {
                                        var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);
                                        theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));
                                    }
                                } else theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position("x") - dimensions.w / 2, theChild.position("y") - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));
                            } else theNode = parent.add(new CoSENode(this.graphManager));
                            // Attach id to the layout node and repulsion value
                            theNode.id = theChild.data("id");
                            theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);
                            // Attach the paddings of cy node to layout node
                            theNode.paddingLeft = parseInt(theChild.css("padding"));
                            theNode.paddingTop = parseInt(theChild.css("padding"));
                            theNode.paddingRight = parseInt(theChild.css("padding"));
                            theNode.paddingBottom = parseInt(theChild.css("padding"));
                            //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions
                            //These properties will be used while updating bounds of compounds during iterations or tiling
                            //and will be used for simple nodes while transferring final positions to cytoscape
                            if (options.nodeDimensionsIncludeLabels) {
                                theNode.labelWidth = theChild.boundingBox({
                                    includeLabels: true,
                                    includeNodes: false,
                                    includeOverlays: false
                                }).w;
                                theNode.labelHeight = theChild.boundingBox({
                                    includeLabels: true,
                                    includeNodes: false,
                                    includeOverlays: false
                                }).h;
                                theNode.labelPosVertical = theChild.css("text-valign");
                                theNode.labelPosHorizontal = theChild.css("text-halign");
                            }
                            // Map the layout node
                            idToLNode[theChild.data("id")] = theNode;
                            if (isNaN(theNode.rect.x)) theNode.rect.x = 0;
                            if (isNaN(theNode.rect.y)) theNode.rect.y = 0;
                            if (children_of_children != null && children_of_children.length > 0) {
                                var theNewGraph = void 0;
                                theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);
                                processChildrenList(theNewGraph, children_of_children, layout, options);
                            }
                        }
                    };
                    // transfer cytoscape edges to cose edges
                    var processEdges = function processEdges(layout, gm, edges) {
                        var idealLengthTotal = 0;
                        var edgeCount = 0;
                        for(var i = 0; i < edges.length; i++){
                            var edge = edges[i];
                            var sourceNode = idToLNode[edge.data("source")];
                            var targetNode = idToLNode[edge.data("target")];
                            if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {
                                var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);
                                e1.id = edge.id();
                                e1.idealLength = optFn(options.idealEdgeLength, edge);
                                e1.edgeElasticity = optFn(options.edgeElasticity, edge);
                                idealLengthTotal += e1.idealLength;
                                edgeCount++;
                            }
                        }
                        // we need to update the ideal edge length constant with the avg. ideal length value after processing edges
                        // in case there is no edge, use other options
                        if (options.idealEdgeLength != null) {
                            if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;
                            else if (!isFn(options.idealEdgeLength)) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;
                            else CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;
                            // we need to update these constant values based on the ideal edge length constant
                            CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;
                            CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;
                        }
                    };
                    // transfer cytoscape constraints to cose layout
                    var processConstraints = function processConstraints(layout, options) {
                        // get nodes to be fixed
                        if (options.fixedNodeConstraint) layout.constraints["fixedNodeConstraint"] = options.fixedNodeConstraint;
                        // get nodes to be aligned
                        if (options.alignmentConstraint) layout.constraints["alignmentConstraint"] = options.alignmentConstraint;
                        // get nodes to be relatively placed
                        if (options.relativePlacementConstraint) layout.constraints["relativePlacementConstraint"] = options.relativePlacementConstraint;
                    };
                    /**** Apply postprocessing ****/ if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;
                    if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;
                    if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;
                    if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;
                    if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;
                    if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;
                    if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;
                    if (options.quality == "proof") LayoutConstants.QUALITY = 2;
                    else LayoutConstants.QUALITY = 0;
                    CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;
                    CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;
                    CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;
                    CoSEConstants.TILE = options.tile;
                    CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === "function" ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;
                    CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === "function" ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;
                    CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;
                    CoSEConstants.PURE_INCREMENTAL = !options.randomize;
                    LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;
                    // This part is for debug/demo purpose
                    if (options.step == "transformed") {
                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;
                        CoSEConstants.ENFORCE_CONSTRAINTS = false;
                        CoSEConstants.APPLY_LAYOUT = false;
                    }
                    if (options.step == "enforced") {
                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;
                        CoSEConstants.ENFORCE_CONSTRAINTS = true;
                        CoSEConstants.APPLY_LAYOUT = false;
                    }
                    if (options.step == "cose") {
                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;
                        CoSEConstants.ENFORCE_CONSTRAINTS = false;
                        CoSEConstants.APPLY_LAYOUT = true;
                    }
                    if (options.step == "all") {
                        if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;
                        else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;
                        CoSEConstants.ENFORCE_CONSTRAINTS = true;
                        CoSEConstants.APPLY_LAYOUT = true;
                    }
                    if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;
                    else CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;
                    var coseLayout = new CoSELayout();
                    var gm = coseLayout.newGraphManager();
                    processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);
                    processEdges(coseLayout, gm, edges);
                    processConstraints(coseLayout, options);
                    coseLayout.runLayout();
                    return idToLNode;
                };
                module1.exports = {
                    coseLayout: coseLayout
                };
            /***/ },
            /***/ 212: (module1, __unused_webpack_exports, __webpack_require__)=>{
                var _createClass = function() {
                    function defineProperties(target, props) {
                        for(var i = 0; i < props.length; i++){
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }
                /**
  The implementation of the fcose layout algorithm
*/ var assign = __webpack_require__(658);
                var aux = __webpack_require__(548);
                var _require = __webpack_require__(657), spectralLayout = _require.spectralLayout;
                var _require2 = __webpack_require__(816), coseLayout = _require2.coseLayout;
                var defaults = Object.freeze({
                    // 'draft', 'default' or 'proof' 
                    // - 'draft' only applies spectral layout 
                    // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)
                    // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) 
                    quality: "default",
                    // Use random node positions at beginning of layout
                    // if this is set to false, then quality option must be "proof"
                    randomize: true,
                    // Whether or not to animate the layout
                    animate: true,
                    // Duration of animation in ms, if enabled
                    animationDuration: 1000,
                    // Easing of animation, if enabled
                    animationEasing: undefined,
                    // Fit the viewport to the repositioned nodes
                    fit: true,
                    // Padding around layout
                    padding: 30,
                    // Whether to include labels in node dimensions. Valid in "proof" quality
                    nodeDimensionsIncludeLabels: false,
                    // Whether or not simple nodes (non-compound nodes) are of uniform dimensions
                    uniformNodeDimensions: false,
                    // Whether to pack disconnected components - valid only if randomize: true
                    packComponents: true,
                    // Layout step - all, transformed, enforced, cose - for debug purpose only
                    step: "all",
                    /* spectral layout options */ // False for random, true for greedy
                    samplingType: true,
                    // Sample size to construct distance matrix
                    sampleSize: 25,
                    // Separation amount between nodes
                    nodeSeparation: 75,
                    // Power iteration tolerance
                    piTol: 0.0000001,
                    /* CoSE layout options */ // Node repulsion (non overlapping) multiplier
                    nodeRepulsion: function nodeRepulsion(node) {
                        return 4500;
                    },
                    // Ideal edge (non nested) length
                    idealEdgeLength: function idealEdgeLength(edge) {
                        return 50;
                    },
                    // Divisor to compute edge forces
                    edgeElasticity: function edgeElasticity(edge) {
                        return 0.45;
                    },
                    // Nesting factor (multiplier) to compute ideal edge length for nested edges
                    nestingFactor: 0.1,
                    // Gravity force (constant)
                    gravity: 0.25,
                    // Maximum number of iterations to perform
                    numIter: 2500,
                    // For enabling tiling
                    tile: true,
                    // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
                    tilingPaddingVertical: 10,
                    // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
                    tilingPaddingHorizontal: 10,
                    // Gravity range (constant) for compounds
                    gravityRangeCompound: 1.5,
                    // Gravity force (constant) for compounds
                    gravityCompound: 1.0,
                    // Gravity range (constant)
                    gravityRange: 3.8,
                    // Initial cooling factor for incremental layout  
                    initialEnergyOnIncremental: 0.3,
                    /* constraint options */ // Fix required nodes to predefined positions
                    // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]
                    fixedNodeConstraint: undefined,
                    // Align required nodes in vertical/horizontal direction
                    // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}
                    alignmentConstraint: undefined,
                    // Place two nodes relatively in vertical/horizontal direction 
                    // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]
                    relativePlacementConstraint: undefined,
                    /* layout event callbacks */ ready: function ready() {},
                    stop: function stop() {} // on layoutstop
                });
                var Layout = function() {
                    function Layout(options) {
                        _classCallCheck(this, Layout);
                        this.options = assign({}, defaults, options);
                    }
                    _createClass(Layout, [
                        {
                            key: "run",
                            value: function run() {
                                var layout = this;
                                var options = this.options;
                                var cy = options.cy;
                                var eles = options.eles;
                                var spectralResult = [];
                                var xCoords = void 0;
                                var yCoords = void 0;
                                var coseResult = [];
                                var components = void 0;
                                // basic validity check for constraint inputs 
                                if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) options.fixedNodeConstraint = undefined;
                                if (options.alignmentConstraint) {
                                    if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) options.alignmentConstraint.vertical = undefined;
                                    if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) options.alignmentConstraint.horizontal = undefined;
                                }
                                if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) options.relativePlacementConstraint = undefined;
                                // if any constraint exists, set some options
                                var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;
                                if (constraintExist) {
                                    // constraints work with these options
                                    options.tile = false;
                                    options.packComponents = false;
                                }
                                // decide component packing is enabled or not
                                var layUtil = void 0;
                                var packingEnabled = false;
                                if (cy.layoutUtilities && options.packComponents) {
                                    layUtil = cy.layoutUtilities("get");
                                    if (!layUtil) layUtil = cy.layoutUtilities();
                                    packingEnabled = true;
                                }
                                if (eles.nodes().length > 0) {
                                    // if packing is not enabled, perform layout on the whole graph
                                    if (!packingEnabled) {
                                        if (options.randomize) {
                                            var result = spectralLayout(options); // apply spectral layout        
                                            spectralResult.push(result);
                                        }
                                        // apply cose layout as postprocessing
                                        if (options.quality == "default" || options.quality == "proof") coseResult.push(coseLayout(options, spectralResult[0]));
                                    } else {
                                        // packing is enabled
                                        var topMostNodes = aux.getTopMostNodes(options.eles.nodes());
                                        components = aux.connectComponents(cy, options.eles, topMostNodes);
                                        //send each component to spectral layout
                                        if (options.randomize) components.forEach(function(component) {
                                            options.eles = component;
                                            spectralResult.push(spectralLayout(options));
                                        });
                                        if (options.quality == "default" || options.quality == "proof") {
                                            var toBeTiledNodes = cy.collection();
                                            if (options.tile) {
                                                // behave nodes to be tiled as one component
                                                var nodeIndexes = new Map();
                                                var _xCoords = [];
                                                var _yCoords = [];
                                                var count = 0;
                                                var tempSpectralResult = {
                                                    nodeIndexes: nodeIndexes,
                                                    xCoords: _xCoords,
                                                    yCoords: _yCoords
                                                };
                                                var indexesToBeDeleted = [];
                                                components.forEach(function(component, index) {
                                                    if (component.edges().length == 0) {
                                                        component.nodes().forEach(function(node, i) {
                                                            toBeTiledNodes.merge(component.nodes()[i]);
                                                            if (!node.isParent()) {
                                                                tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);
                                                                tempSpectralResult.xCoords.push(component.nodes()[0].position().x);
                                                                tempSpectralResult.yCoords.push(component.nodes()[0].position().y);
                                                            }
                                                        });
                                                        indexesToBeDeleted.push(index);
                                                    }
                                                });
                                                if (toBeTiledNodes.length > 1) {
                                                    components.push(toBeTiledNodes);
                                                    spectralResult.push(tempSpectralResult);
                                                    for(var i = indexesToBeDeleted.length - 1; i >= 0; i--){
                                                        components.splice(indexesToBeDeleted[i], 1);
                                                        spectralResult.splice(indexesToBeDeleted[i], 1);
                                                    }
                                                }
                                            }
                                            components.forEach(function(component, index) {
                                                // send each component to cose layout
                                                options.eles = component;
                                                coseResult.push(coseLayout(options, spectralResult[index]));
                                            });
                                        }
                                        // packing
                                        if (components.length > 1) {
                                            var subgraphs = [];
                                            components.forEach(function(component, index) {
                                                var nodeIndexes = void 0;
                                                if (options.quality == "draft") nodeIndexes = spectralResult[index].nodeIndexes;
                                                var subgraph = {};
                                                subgraph.nodes = [];
                                                subgraph.edges = [];
                                                var nodeIndex = void 0;
                                                component.nodes().forEach(function(node) {
                                                    if (options.quality == "draft") {
                                                        if (!node.isParent()) {
                                                            nodeIndex = nodeIndexes.get(node.id());
                                                            subgraph.nodes.push({
                                                                x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2,
                                                                y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2,
                                                                width: node.boundingbox().w,
                                                                height: node.boundingbox().h
                                                            });
                                                        } else {
                                                            var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);
                                                            subgraph.nodes.push({
                                                                x: parentInfo.topLeftX,
                                                                y: parentInfo.topLeftY,
                                                                width: parentInfo.width,
                                                                height: parentInfo.height
                                                            });
                                                        }
                                                    } else subgraph.nodes.push({
                                                        x: coseResult[index][node.id()].getLeft(),
                                                        y: coseResult[index][node.id()].getTop(),
                                                        width: coseResult[index][node.id()].getWidth(),
                                                        height: coseResult[index][node.id()].getHeight()
                                                    });
                                                });
                                                component.edges().forEach(function(edge) {
                                                    var source = edge.source();
                                                    var target = edge.target();
                                                    if (options.quality == "draft") {
                                                        var sourceNodeIndex = nodeIndexes.get(source.id());
                                                        var targetNodeIndex = nodeIndexes.get(target.id());
                                                        var sourceCenter = [];
                                                        var targetCenter = [];
                                                        if (source.isParent()) {
                                                            var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);
                                                            sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);
                                                            sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);
                                                        } else {
                                                            sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);
                                                            sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);
                                                        }
                                                        if (target.isParent()) {
                                                            var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);
                                                            targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);
                                                            targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);
                                                        } else {
                                                            targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);
                                                            targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);
                                                        }
                                                        subgraph.edges.push({
                                                            startX: sourceCenter[0],
                                                            startY: sourceCenter[1],
                                                            endX: targetCenter[0],
                                                            endY: targetCenter[1]
                                                        });
                                                    } else subgraph.edges.push({
                                                        startX: coseResult[index][source.id()].getCenterX(),
                                                        startY: coseResult[index][source.id()].getCenterY(),
                                                        endX: coseResult[index][target.id()].getCenterX(),
                                                        endY: coseResult[index][target.id()].getCenterY()
                                                    });
                                                });
                                                subgraphs.push(subgraph);
                                            });
                                            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;
                                            if (options.quality == "draft") spectralResult.forEach(function(result, index) {
                                                var newXCoords = result.xCoords.map(function(x) {
                                                    return x + shiftResult[index].dx;
                                                });
                                                var newYCoords = result.yCoords.map(function(y) {
                                                    return y + shiftResult[index].dy;
                                                });
                                                result.xCoords = newXCoords;
                                                result.yCoords = newYCoords;
                                            });
                                            else coseResult.forEach(function(result, index) {
                                                Object.keys(result).forEach(function(item) {
                                                    var nodeRectangle = result[item];
                                                    nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[index].dx, nodeRectangle.getCenterY() + shiftResult[index].dy);
                                                });
                                            });
                                        }
                                    }
                                    // move graph to its original position because spectral moves it to origin
                                    if (options.randomize && !options.fixedNodeConstraint) {
                                        var minXCoord = Number.POSITIVE_INFINITY;
                                        var maxXCoord = Number.NEGATIVE_INFINITY;
                                        var minYCoord = Number.POSITIVE_INFINITY;
                                        var maxYCoord = Number.NEGATIVE_INFINITY;
                                        if (options.quality == "draft") {
                                            spectralResult.forEach(function(result) {
                                                result.xCoords.forEach(function(value) {
                                                    if (value < minXCoord) minXCoord = value;
                                                    if (value > maxXCoord) maxXCoord = value;
                                                });
                                                result.yCoords.forEach(function(value) {
                                                    if (value < minYCoord) minYCoord = value;
                                                    if (value > maxYCoord) maxYCoord = value;
                                                });
                                            });
                                            var boundingBox = options.eles.boundingBox();
                                            var diffOnX = boundingBox.x1 + boundingBox.w / 2 - (maxXCoord + minXCoord) / 2;
                                            var diffOnY = boundingBox.y1 + boundingBox.h / 2 - (maxYCoord + minYCoord) / 2;
                                            spectralResult.forEach(function(result) {
                                                result.xCoords = result.xCoords.map(function(x) {
                                                    return x + diffOnX;
                                                });
                                                result.yCoords = result.yCoords.map(function(y) {
                                                    return y + diffOnY;
                                                });
                                            });
                                        } else {
                                            coseResult.forEach(function(result) {
                                                Object.keys(result).forEach(function(item) {
                                                    var node = result[item];
                                                    if (node.getCenterX() < minXCoord) minXCoord = node.getCenterX();
                                                    if (node.getCenterX() > maxXCoord) maxXCoord = node.getCenterX();
                                                    if (node.getCenterY() < minYCoord) minYCoord = node.getCenterY();
                                                    if (node.getCenterY() > maxYCoord) maxYCoord = node.getCenterY();
                                                });
                                            });
                                            var _boundingBox = options.eles.boundingBox();
                                            var _diffOnX = _boundingBox.x1 + _boundingBox.w / 2 - (maxXCoord + minXCoord) / 2;
                                            var _diffOnY = _boundingBox.y1 + _boundingBox.h / 2 - (maxYCoord + minYCoord) / 2;
                                            coseResult.forEach(function(result, index) {
                                                Object.keys(result).forEach(function(item) {
                                                    var node = result[item];
                                                    node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);
                                                });
                                            });
                                        }
                                    }
                                }
                                // get each element's calculated position
                                var getPositions = function getPositions(ele, i) {
                                    if (options.quality == "default" || options.quality == "proof") {
                                        if (typeof ele === "number") ele = i;
                                        var pos = void 0;
                                        var node = void 0;
                                        var theId = ele.data("id");
                                        coseResult.forEach(function(result) {
                                            if (theId in result) {
                                                pos = {
                                                    x: result[theId].getRect().getCenterX(),
                                                    y: result[theId].getRect().getCenterY()
                                                };
                                                node = result[theId];
                                            }
                                        });
                                        if (options.nodeDimensionsIncludeLabels) {
                                            if (node.labelWidth) {
                                                if (node.labelPosHorizontal == "left") pos.x += node.labelWidth / 2;
                                                else if (node.labelPosHorizontal == "right") pos.x -= node.labelWidth / 2;
                                            }
                                            if (node.labelHeight) {
                                                if (node.labelPosVertical == "top") pos.y += node.labelHeight / 2;
                                                else if (node.labelPosVertical == "bottom") pos.y -= node.labelHeight / 2;
                                            }
                                        }
                                        return {
                                            x: pos.x,
                                            y: pos.y
                                        };
                                    } else {
                                        var _pos = void 0;
                                        spectralResult.forEach(function(result) {
                                            var index = result.nodeIndexes.get(ele.id());
                                            if (index != undefined) _pos = {
                                                x: result.xCoords[index],
                                                y: result.yCoords[index]
                                            };
                                        });
                                        if (_pos == undefined) _pos = {
                                            x: ele.position("x"),
                                            y: ele.position("y")
                                        };
                                        return {
                                            x: _pos.x,
                                            y: _pos.y
                                        };
                                    }
                                };
                                // quality = "draft" and randomize = false are contradictive so in that case positions don't change
                                if (options.quality == "default" || options.quality == "proof" || options.randomize) {
                                    // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)
                                    options.eles = eles;
                                    eles.nodes().not(":parent").layoutPositions(layout, options, getPositions);
                                } else console.log("If randomize option is set to false, then quality option must be 'default' or 'proof'.");
                            }
                        }
                    ]);
                    return Layout;
                }();
                module1.exports = Layout;
            /***/ },
            /***/ 657: (module1, __unused_webpack_exports, __webpack_require__)=>{
                /**
  The implementation of the spectral layout that is the first part of the fcose layout algorithm
*/ var aux = __webpack_require__(548);
                var Matrix = __webpack_require__(281).layoutBase.Matrix;
                var SVD = __webpack_require__(281).layoutBase.SVD;
                // main function that spectral layout is processed
                var spectralLayout = function spectralLayout(options) {
                    var cy = options.cy;
                    var eles = options.eles;
                    var nodes = eles.nodes();
                    var parentNodes = eles.nodes(":parent");
                    var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors
                    var nodeIndexes = new Map(); // map to keep indexes to nodes
                    var parentChildMap = new Map(); // mapping btw. compound and its representative node 
                    var allNodesNeighborhood = []; // array to keep neighborhood of all nodes
                    var xCoords = [];
                    var yCoords = [];
                    var samplesColumn = []; // sampled vertices
                    var minDistancesColumn = [];
                    var C = []; // column sampling matrix
                    var PHI = []; // intersection of column and row sampling matrices 
                    var INV = []; // inverse of PHI 
                    var firstSample = void 0; // the first sampled node
                    var nodeSize = void 0;
                    var infinity = 100000000;
                    var small = 0.000000001;
                    var piTol = options.piTol;
                    var samplingType = options.samplingType; // false for random, true for greedy
                    var nodeSeparation = options.nodeSeparation;
                    var sampleSize = void 0;
                    /**** Spectral-preprocessing functions ****/ /**** Spectral layout functions ****/ // determine which columns to be sampled
                    var randomSampleCR = function randomSampleCR() {
                        var sample = 0;
                        var count = 0;
                        var flag = false;
                        while(count < sampleSize){
                            sample = Math.floor(Math.random() * nodeSize);
                            flag = false;
                            for(var i = 0; i < count; i++)if (samplesColumn[i] == sample) {
                                flag = true;
                                break;
                            }
                            if (!flag) {
                                samplesColumn[count] = sample;
                                count++;
                            } else continue;
                        }
                    };
                    // takes the index of the node(pivot) to initiate BFS as a parameter
                    var BFS = function BFS(pivot, index, samplingMethod) {
                        var path = []; // the front of the path
                        var front = 0; // the back of the path
                        var back = 0;
                        var current = 0;
                        var temp = void 0;
                        var distance = [];
                        var max_dist = 0; // the furthest node to be returned
                        var max_ind = 1;
                        for(var i = 0; i < nodeSize; i++)distance[i] = infinity;
                        path[back] = pivot;
                        distance[pivot] = 0;
                        while(back >= front){
                            current = path[front++];
                            var neighbors = allNodesNeighborhood[current];
                            for(var _i = 0; _i < neighbors.length; _i++){
                                temp = nodeIndexes.get(neighbors[_i]);
                                if (distance[temp] == infinity) {
                                    distance[temp] = distance[current] + 1;
                                    path[++back] = temp;
                                }
                            }
                            C[current][index] = distance[current] * nodeSeparation;
                        }
                        if (samplingMethod) {
                            for(var _i2 = 0; _i2 < nodeSize; _i2++)if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];
                            for(var _i3 = 0; _i3 < nodeSize; _i3++)if (minDistancesColumn[_i3] > max_dist) {
                                max_dist = minDistancesColumn[_i3];
                                max_ind = _i3;
                            }
                        }
                        return max_ind;
                    };
                    // apply BFS to all nodes or selected samples
                    var allBFS = function allBFS(samplingMethod) {
                        var sample = void 0;
                        if (!samplingMethod) {
                            randomSampleCR();
                            // call BFS
                            for(var i = 0; i < sampleSize; i++)BFS(samplesColumn[i], i, samplingMethod, false);
                        } else {
                            sample = Math.floor(Math.random() * nodeSize);
                            firstSample = sample;
                            for(var _i4 = 0; _i4 < nodeSize; _i4++)minDistancesColumn[_i4] = infinity;
                            for(var _i5 = 0; _i5 < sampleSize; _i5++){
                                samplesColumn[_i5] = sample;
                                sample = BFS(sample, _i5, samplingMethod);
                            }
                        }
                        // form the squared distances for C
                        for(var _i6 = 0; _i6 < nodeSize; _i6++)for(var j = 0; j < sampleSize; j++)C[_i6][j] *= C[_i6][j];
                        // form PHI
                        for(var _i7 = 0; _i7 < sampleSize; _i7++)PHI[_i7] = [];
                        for(var _i8 = 0; _i8 < sampleSize; _i8++)for(var _j = 0; _j < sampleSize; _j++)PHI[_i8][_j] = C[samplesColumn[_j]][_i8];
                    };
                    // perform the SVD algorithm and apply a regularization step
                    var sample = function sample() {
                        var SVDResult = SVD.svd(PHI);
                        var a_q = SVDResult.S;
                        var a_u = SVDResult.U;
                        var a_v = SVDResult.V;
                        var max_s = a_q[0] * a_q[0] * a_q[0];
                        var a_Sig = [];
                        //  regularization
                        for(var i = 0; i < sampleSize; i++){
                            a_Sig[i] = [];
                            for(var j = 0; j < sampleSize; j++){
                                a_Sig[i][j] = 0;
                                if (i == j) a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));
                            }
                        }
                        INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));
                    };
                    // calculate final coordinates 
                    var powerIteration = function powerIteration() {
                        // two largest eigenvalues
                        var theta1 = void 0;
                        var theta2 = void 0;
                        // initial guesses for eigenvectors
                        var Y1 = [];
                        var Y2 = [];
                        var V1 = [];
                        var V2 = [];
                        for(var i = 0; i < nodeSize; i++){
                            Y1[i] = Math.random();
                            Y2[i] = Math.random();
                        }
                        Y1 = Matrix.normalize(Y1);
                        Y2 = Matrix.normalize(Y2);
                        var count = 0;
                        // to keep track of the improvement ratio in power iteration
                        var current = small;
                        var previous = small;
                        var temp = void 0;
                        while(true){
                            count++;
                            for(var _i9 = 0; _i9 < nodeSize; _i9++)V1[_i9] = Y1[_i9];
                            Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));
                            theta1 = Matrix.dotProduct(V1, Y1);
                            Y1 = Matrix.normalize(Y1);
                            current = Matrix.dotProduct(V1, Y1);
                            temp = Math.abs(current / previous);
                            if (temp <= 1 + piTol && temp >= 1) break;
                            previous = current;
                        }
                        for(var _i10 = 0; _i10 < nodeSize; _i10++)V1[_i10] = Y1[_i10];
                        count = 0;
                        previous = small;
                        while(true){
                            count++;
                            for(var _i11 = 0; _i11 < nodeSize; _i11++)V2[_i11] = Y2[_i11];
                            V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));
                            Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));
                            theta2 = Matrix.dotProduct(V2, Y2);
                            Y2 = Matrix.normalize(Y2);
                            current = Matrix.dotProduct(V2, Y2);
                            temp = Math.abs(current / previous);
                            if (temp <= 1 + piTol && temp >= 1) break;
                            previous = current;
                        }
                        for(var _i12 = 0; _i12 < nodeSize; _i12++)V2[_i12] = Y2[_i12];
                        // theta1 now contains dominant eigenvalue
                        // theta2 now contains the second-largest eigenvalue
                        // V1 now contains theta1's eigenvector
                        // V2 now contains theta2's eigenvector
                        //populate the two vectors
                        xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));
                        yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));
                    };
                    /**** Preparation for spectral layout (Preprocessing) ****/ // connect disconnected components (first top level, then inside of each compound node)
                    aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);
                    parentNodes.forEach(function(ele) {
                        aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);
                    });
                    // assign indexes to nodes (first real, then dummy nodes)
                    var index = 0;
                    for(var i = 0; i < nodes.length; i++)if (!nodes[i].isParent()) nodeIndexes.set(nodes[i].id(), index++);
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;
                    try {
                        for(var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var key = _step.value;
                            nodeIndexes.set(key, index++);
                        }
                    // instantiate the neighborhood matrix
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) _iterator.return();
                        } finally{
                            if (_didIteratorError) throw _iteratorError;
                        }
                    }
                    for(var _i13 = 0; _i13 < nodeIndexes.size; _i13++)allNodesNeighborhood[_i13] = [];
                    // form a parent-child map to keep representative node of each compound node  
                    parentNodes.forEach(function(ele) {
                        var children = ele.children().intersection(eles);
                        //      let random = 0;
                        while(children.nodes(":childless").length == 0)//        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly
                        children = children.nodes()[0].children().intersection(eles);
                        //  select the representative node - we can apply different methods here
                        //      random = Math.floor(Math.random() * children.nodes(":childless").length);
                        var index = 0;
                        var min = children.nodes(":childless")[0].connectedEdges().length;
                        children.nodes(":childless").forEach(function(ele2, i) {
                            if (ele2.connectedEdges().length < min) {
                                min = ele2.connectedEdges().length;
                                index = i;
                            }
                        });
                        parentChildMap.set(ele.id(), children.nodes(":childless")[index].id());
                    });
                    // add neighborhood relations (first real, then dummy nodes)
                    nodes.forEach(function(ele) {
                        var eleIndex = void 0;
                        if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));
                        else eleIndex = nodeIndexes.get(ele.id());
                        ele.neighborhood().nodes().forEach(function(node) {
                            if (eles.intersection(ele.edgesWith(node)).length > 0) {
                                if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));
                                else allNodesNeighborhood[eleIndex].push(node.id());
                            }
                        });
                    });
                    var _loop = function _loop(_key) {
                        var eleIndex = nodeIndexes.get(_key);
                        var disconnectedId = void 0;
                        dummyNodes.get(_key).forEach(function(id) {
                            if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);
                            else disconnectedId = id;
                            allNodesNeighborhood[eleIndex].push(disconnectedId);
                            allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);
                        });
                    };
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;
                    try {
                        for(var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                            var _key = _step2.value;
                            _loop(_key);
                        }
                    // nodeSize now only considers the size of transformed graph
                    } catch (err1) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err1;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) _iterator2.return();
                        } finally{
                            if (_didIteratorError2) throw _iteratorError2;
                        }
                    }
                    nodeSize = nodeIndexes.size;
                    var spectralResult = void 0;
                    // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem
                    // So skip spectral and layout the graph with cose
                    if (nodeSize > 2) {
                        // if # of nodes in transformed graph is smaller than sample size,
                        // then use # of nodes as sample size
                        sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;
                        // instantiates the partial matrices that will be used in spectral layout
                        for(var _i14 = 0; _i14 < nodeSize; _i14++)C[_i14] = [];
                        for(var _i15 = 0; _i15 < sampleSize; _i15++)INV[_i15] = [];
                        /**** Apply spectral layout ****/ if (options.quality == "draft" || options.step == "all") {
                            allBFS(samplingType);
                            sample();
                            powerIteration();
                            spectralResult = {
                                nodeIndexes: nodeIndexes,
                                xCoords: xCoords,
                                yCoords: yCoords
                            };
                        } else {
                            nodeIndexes.forEach(function(value, key) {
                                xCoords.push(cy.getElementById(key).position("x"));
                                yCoords.push(cy.getElementById(key).position("y"));
                            });
                            spectralResult = {
                                nodeIndexes: nodeIndexes,
                                xCoords: xCoords,
                                yCoords: yCoords
                            };
                        }
                        return spectralResult;
                    } else {
                        var iterator = nodeIndexes.keys();
                        var firstNode = cy.getElementById(iterator.next().value);
                        var firstNodePos = firstNode.position();
                        var firstNodeWidth = firstNode.outerWidth();
                        xCoords.push(firstNodePos.x);
                        yCoords.push(firstNodePos.y);
                        if (nodeSize == 2) {
                            var secondNode = cy.getElementById(iterator.next().value);
                            var secondNodeWidth = secondNode.outerWidth();
                            xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);
                            yCoords.push(firstNodePos.y);
                        }
                        spectralResult = {
                            nodeIndexes: nodeIndexes,
                            xCoords: xCoords,
                            yCoords: yCoords
                        };
                        return spectralResult;
                    }
                };
                module1.exports = {
                    spectralLayout: spectralLayout
                };
            /***/ },
            /***/ 579: (module1, __unused_webpack_exports, __webpack_require__)=>{
                var impl = __webpack_require__(212);
                // registers the extension on a cytoscape lib ref
                var register = function register(cytoscape1) {
                    if (!cytoscape1) return;
                     // can't register if cytoscape unspecified
                    cytoscape1("layout", "fcose", impl); // register with cytoscape.js
                };
                if (typeof cytoscape !== "undefined") // expose to global cytoscape (i.e. window.cytoscape)
                register(cytoscape);
                module1.exports = register;
            /***/ },
            /***/ 281: (module1)=>{
                module1.exports = __WEBPACK_EXTERNAL_MODULE__281__;
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __webpack_require__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) /******/ return cachedModule.exports;
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId](module1, module1.exports, __webpack_require__);
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /******/ // startup
        /******/ // Load entry module and return exports
        /******/ // This entry module is referenced by other modules so it can't be inlined
        /******/ var __webpack_exports__ = __webpack_require__(579);
        /******/ /******/ return __webpack_exports__;
    /******/ })();
});

},{"cose-base":"1X6HI"}],"1X6HI":[function(require,module,exports) {
(function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory(require("layout-base"));
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
    return /******/ function(modules) {
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/ /******/ // The require function
        /******/ function __webpack_require__(moduleId) {
            /******/ /******/ // Check if module is in cache
            /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: false,
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __webpack_require__);
            /******/ /******/ // Flag the module as loaded
            /******/ module1.l = true;
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)
        /******/ __webpack_require__.m = modules;
        /******/ /******/ // expose the module cache
        /******/ __webpack_require__.c = installedModules;
        /******/ /******/ // identity function for calling harmony imports with the correct context
        /******/ __webpack_require__.i = function(value) {
            return value;
        };
        /******/ /******/ // define getter function for harmony exports
        /******/ __webpack_require__.d = function(exports, name, getter) {
            /******/ if (!__webpack_require__.o(exports, name)) /******/ Object.defineProperty(exports, name, {
                /******/ configurable: false,
                /******/ enumerable: true,
                /******/ get: getter
            });
        /******/ };
        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = function(module1) {
            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {
                return module1["default"];
            } : /******/ function getModuleExports() {
                return module1;
            };
            /******/ __webpack_require__.d(getter, "a", getter);
            /******/ return getter;
        /******/ };
        /******/ /******/ // Object.prototype.hasOwnProperty.call
        /******/ __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/ /******/ // __webpack_public_path__
        /******/ __webpack_require__.p = "";
        /******/ /******/ // Load entry module and return exports
        /******/ return __webpack_require__(__webpack_require__.s = 8);
    /******/ }([
        /* 0 */ /***/ function(module1, exports) {
            module1.exports = __WEBPACK_EXTERNAL_MODULE_0__;
        /***/ },
        /* 1 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;
            function CoSEConstants() {}
            //CoSEConstants inherits static props in FDLayoutConstants
            for(var prop in FDLayoutConstants)CoSEConstants[prop] = FDLayoutConstants[prop];
            CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;
            CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;
            CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;
            CoSEConstants.TILE = true;
            CoSEConstants.TILING_PADDING_VERTICAL = 10;
            CoSEConstants.TILING_PADDING_HORIZONTAL = 10;
            CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;
            CoSEConstants.ENFORCE_CONSTRAINTS = true;
            CoSEConstants.APPLY_LAYOUT = true;
            CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;
            CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint
            // This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or 
            // an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.
            CoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;
            module1.exports = CoSEConstants;
        /***/ },
        /* 2 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;
            function CoSEEdge(source, target, vEdge) {
                FDLayoutEdge.call(this, source, target, vEdge);
            }
            CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);
            for(var prop in FDLayoutEdge)CoSEEdge[prop] = FDLayoutEdge[prop];
            module1.exports = CoSEEdge;
        /***/ },
        /* 3 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var LGraph = __webpack_require__(0).LGraph;
            function CoSEGraph(parent, graphMgr, vGraph) {
                LGraph.call(this, parent, graphMgr, vGraph);
            }
            CoSEGraph.prototype = Object.create(LGraph.prototype);
            for(var prop in LGraph)CoSEGraph[prop] = LGraph[prop];
            module1.exports = CoSEGraph;
        /***/ },
        /* 4 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var LGraphManager = __webpack_require__(0).LGraphManager;
            function CoSEGraphManager(layout) {
                LGraphManager.call(this, layout);
            }
            CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);
            for(var prop in LGraphManager)CoSEGraphManager[prop] = LGraphManager[prop];
            module1.exports = CoSEGraphManager;
        /***/ },
        /* 5 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var FDLayoutNode = __webpack_require__(0).FDLayoutNode;
            var IMath = __webpack_require__(0).IMath;
            function CoSENode(gm, loc, size, vNode) {
                FDLayoutNode.call(this, gm, loc, size, vNode);
            }
            CoSENode.prototype = Object.create(FDLayoutNode.prototype);
            for(var prop in FDLayoutNode)CoSENode[prop] = FDLayoutNode[prop];
            CoSENode.prototype.calculateDisplacement = function() {
                var layout = this.graphManager.getLayout();
                // this check is for compound nodes that contain fixed nodes
                if (this.getChild() != null && this.fixedNodeWeight) {
                    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;
                    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;
                } else {
                    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;
                    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;
                }
                if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);
                if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);
                // non-empty compound node, propogate movement to children as well
                if (this.child && this.child.getNodes().length > 0) this.propogateDisplacementToChildren(this.displacementX, this.displacementY);
            };
            CoSENode.prototype.propogateDisplacementToChildren = function(dX, dY) {
                var nodes = this.getChild().getNodes();
                var node;
                for(var i = 0; i < nodes.length; i++){
                    node = nodes[i];
                    if (node.getChild() == null) {
                        node.displacementX += dX;
                        node.displacementY += dY;
                    } else node.propogateDisplacementToChildren(dX, dY);
                }
            };
            CoSENode.prototype.move = function() {
                var layout = this.graphManager.getLayout();
                // a simple node or an empty compound node, move it
                if (this.child == null || this.child.getNodes().length == 0) {
                    this.moveBy(this.displacementX, this.displacementY);
                    layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);
                }
                this.springForceX = 0;
                this.springForceY = 0;
                this.repulsionForceX = 0;
                this.repulsionForceY = 0;
                this.gravitationForceX = 0;
                this.gravitationForceY = 0;
                this.displacementX = 0;
                this.displacementY = 0;
            };
            CoSENode.prototype.setPred1 = function(pred11) {
                this.pred1 = pred11;
            };
            CoSENode.prototype.getPred1 = function() {
                return pred1;
            };
            CoSENode.prototype.getPred2 = function() {
                return pred2;
            };
            CoSENode.prototype.setNext = function(next1) {
                this.next = next1;
            };
            CoSENode.prototype.getNext = function() {
                return next;
            };
            CoSENode.prototype.setProcessed = function(processed1) {
                this.processed = processed1;
            };
            CoSENode.prototype.isProcessed = function() {
                return processed;
            };
            module1.exports = CoSENode;
        /***/ },
        /* 6 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];
                    return arr2;
                } else return Array.from(arr);
            }
            var CoSEConstants = __webpack_require__(1);
            var LinkedList = __webpack_require__(0).LinkedList;
            var Matrix = __webpack_require__(0).Matrix;
            var SVD = __webpack_require__(0).SVD;
            function ConstraintHandler() {}
            ConstraintHandler.handleConstraints = function(layout) {
                //  let layout = this.graphManager.getLayout();
                // get constraints from layout
                var constraints = {};
                constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;
                constraints.alignmentConstraint = layout.constraints.alignmentConstraint;
                constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;
                var idToNodeMap = new Map();
                var nodeIndexes = new Map();
                var xCoords = [];
                var yCoords = [];
                var allNodes = layout.getAllNodes();
                var index = 0;
                // fill index map and coordinates
                for(var i = 0; i < allNodes.length; i++){
                    var node = allNodes[i];
                    if (node.getChild() == null) {
                        nodeIndexes.set(node.id, index++);
                        xCoords.push(node.getCenterX());
                        yCoords.push(node.getCenterY());
                        idToNodeMap.set(node.id, node);
                    }
                }
                // if there exists relative placement constraint without gap value, set it to default 
                if (constraints.relativePlacementConstraint) constraints.relativePlacementConstraint.forEach(function(constraint) {
                    if (!constraint.gap && constraint.gap != 0) {
                        if (constraint.left) constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;
                        else constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;
                    }
                });
                /* auxiliary functions */ // calculate difference between two position objects
                var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {
                    return {
                        x: pos1.x - pos2.x,
                        y: pos1.y - pos2.y
                    };
                };
                // calculate average position of the nodes
                var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {
                    var xPosSum = 0;
                    var yPosSum = 0;
                    nodeIdSet.forEach(function(nodeId) {
                        xPosSum += xCoords[nodeIndexes.get(nodeId)];
                        yPosSum += yCoords[nodeIndexes.get(nodeId)];
                    });
                    return {
                        x: xPosSum / nodeIdSet.size,
                        y: yPosSum / nodeIdSet.size
                    };
                };
                // find an appropriate positioning for the nodes in a given graph according to relative placement constraints
                // this function also takes the fixed nodes and alignment constraints into account
                // graph: dag to be evaluated, direction: "horizontal" or "vertical", 
                // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  
                var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {
                    // find union of two sets
                    function setUnion(setA, setB) {
                        var union = new Set(setA);
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;
                        try {
                            for(var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var elem = _step.value;
                                union.add(elem);
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) _iterator.return();
                            } finally{
                                if (_didIteratorError) throw _iteratorError;
                            }
                        }
                        return union;
                    }
                    // find indegree count for each node
                    var inDegrees = new Map();
                    graph.forEach(function(value, key) {
                        inDegrees.set(key, 0);
                    });
                    graph.forEach(function(value, key) {
                        value.forEach(function(adjacent) {
                            inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);
                        });
                    });
                    var positionMap = new Map(); // keeps the position for each node
                    var pastMap = new Map(); // keeps the predecessors(past) of a node
                    var queue = new LinkedList();
                    inDegrees.forEach(function(value, key) {
                        if (value == 0) {
                            queue.push(key);
                            if (!fixedNodes) {
                                if (direction == "horizontal") positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));
                                else positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));
                            }
                        } else positionMap.set(key, Number.NEGATIVE_INFINITY);
                        if (fixedNodes) pastMap.set(key, new Set([
                            key
                        ]));
                    });
                    // align sources of each component in enforcement phase
                    if (fixedNodes) componentSources.forEach(function(component) {
                        var fixedIds = [];
                        component.forEach(function(nodeId) {
                            if (fixedNodes.has(nodeId)) fixedIds.push(nodeId);
                        });
                        if (fixedIds.length > 0) {
                            var position = 0;
                            fixedIds.forEach(function(fixedId) {
                                if (direction == "horizontal") {
                                    positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));
                                    position += positionMap.get(fixedId);
                                } else {
                                    positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));
                                    position += positionMap.get(fixedId);
                                }
                            });
                            position = position / fixedIds.length;
                            component.forEach(function(nodeId) {
                                if (!fixedNodes.has(nodeId)) positionMap.set(nodeId, position);
                            });
                        } else {
                            var _position = 0;
                            component.forEach(function(nodeId) {
                                if (direction == "horizontal") _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);
                                else _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);
                            });
                            _position = _position / component.length;
                            component.forEach(function(nodeId) {
                                positionMap.set(nodeId, _position);
                            });
                        }
                    });
                    // calculate positions of the nodes
                    var _loop = function _loop() {
                        var currentNode = queue.shift();
                        var neighbors = graph.get(currentNode);
                        neighbors.forEach(function(neighbor) {
                            if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {
                                if (fixedNodes && fixedNodes.has(neighbor.id)) {
                                    var fixedPosition = void 0;
                                    if (direction == "horizontal") fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);
                                    else fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);
                                    positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work
                                    if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {
                                        var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;
                                        pastMap.get(currentNode).forEach(function(nodeId) {
                                            positionMap.set(nodeId, positionMap.get(nodeId) - diff);
                                        });
                                    }
                                } else positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);
                            }
                            inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);
                            if (inDegrees.get(neighbor.id) == 0) queue.push(neighbor.id);
                            if (fixedNodes) pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));
                        });
                    };
                    while(queue.length != 0)_loop();
                    // readjust position of the nodes after enforcement
                    if (fixedNodes) {
                        // find indegree count for each node
                        var sinkNodes = new Set();
                        graph.forEach(function(value, key) {
                            if (value.length == 0) sinkNodes.add(key);
                        });
                        var _components = [];
                        pastMap.forEach(function(value, key) {
                            if (sinkNodes.has(key)) {
                                var isFixedComponent = false;
                                var _iteratorNormalCompletion2 = true;
                                var _didIteratorError2 = false;
                                var _iteratorError2 = undefined;
                                try {
                                    for(var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                                        var nodeId = _step2.value;
                                        if (fixedNodes.has(nodeId)) isFixedComponent = true;
                                    }
                                } catch (err) {
                                    _didIteratorError2 = true;
                                    _iteratorError2 = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion2 && _iterator2.return) _iterator2.return();
                                    } finally{
                                        if (_didIteratorError2) throw _iteratorError2;
                                    }
                                }
                                if (!isFixedComponent) {
                                    var isExist = false;
                                    var existAt = void 0;
                                    _components.forEach(function(component, index) {
                                        if (component.has([].concat(_toConsumableArray(value))[0])) {
                                            isExist = true;
                                            existAt = index;
                                        }
                                    });
                                    if (!isExist) _components.push(new Set(value));
                                    else value.forEach(function(ele) {
                                        _components[existAt].add(ele);
                                    });
                                }
                            }
                        });
                        _components.forEach(function(component, index) {
                            var minBefore = Number.POSITIVE_INFINITY;
                            var minAfter = Number.POSITIVE_INFINITY;
                            var maxBefore = Number.NEGATIVE_INFINITY;
                            var maxAfter = Number.NEGATIVE_INFINITY;
                            var _iteratorNormalCompletion3 = true;
                            var _didIteratorError3 = false;
                            var _iteratorError3 = undefined;
                            try {
                                for(var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                                    var nodeId = _step3.value;
                                    var posBefore = void 0;
                                    if (direction == "horizontal") posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);
                                    else posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);
                                    var posAfter = positionMap.get(nodeId);
                                    if (posBefore < minBefore) minBefore = posBefore;
                                    if (posBefore > maxBefore) maxBefore = posBefore;
                                    if (posAfter < minAfter) minAfter = posAfter;
                                    if (posAfter > maxAfter) maxAfter = posAfter;
                                }
                            } catch (err) {
                                _didIteratorError3 = true;
                                _iteratorError3 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion3 && _iterator3.return) _iterator3.return();
                                } finally{
                                    if (_didIteratorError3) throw _iteratorError3;
                                }
                            }
                            var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;
                            var _iteratorNormalCompletion4 = true;
                            var _didIteratorError4 = false;
                            var _iteratorError4 = undefined;
                            try {
                                for(var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true){
                                    var _nodeId = _step4.value;
                                    positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);
                                }
                            } catch (err1) {
                                _didIteratorError4 = true;
                                _iteratorError4 = err1;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion4 && _iterator4.return) _iterator4.return();
                                } finally{
                                    if (_didIteratorError4) throw _iteratorError4;
                                }
                            }
                        });
                    }
                    return positionMap;
                };
                // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints
                // or if there are only rel. placement contraints where the largest component isn't sufficiently large
                var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {
                    // variables to count votes
                    var reflectOnY = 0, notReflectOnY = 0;
                    var reflectOnX = 0, notReflectOnX = 0;
                    relativePlacementConstraints.forEach(function(constraint) {
                        if (constraint.left) xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;
                        else yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;
                    });
                    if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) for(var _i = 0; _i < nodeIndexes.size; _i++){
                        xCoords[_i] = -1 * xCoords[_i];
                        yCoords[_i] = -1 * yCoords[_i];
                    }
                    else if (reflectOnY > notReflectOnY) for(var _i2 = 0; _i2 < nodeIndexes.size; _i2++)xCoords[_i2] = -1 * xCoords[_i2];
                    else if (reflectOnX > notReflectOnX) for(var _i3 = 0; _i3 < nodeIndexes.size; _i3++)yCoords[_i3] = -1 * yCoords[_i3];
                };
                // find weakly connected components in undirected graph
                var findComponents = function findComponents(graph) {
                    // find weakly connected components in dag
                    var components = [];
                    var queue = new LinkedList();
                    var visited = new Set();
                    var count = 0;
                    graph.forEach(function(value, key) {
                        if (!visited.has(key)) {
                            components[count] = [];
                            var _currentNode = key;
                            queue.push(_currentNode);
                            visited.add(_currentNode);
                            components[count].push(_currentNode);
                            while(queue.length != 0){
                                _currentNode = queue.shift();
                                var neighbors = graph.get(_currentNode);
                                neighbors.forEach(function(neighbor) {
                                    if (!visited.has(neighbor.id)) {
                                        queue.push(neighbor.id);
                                        visited.add(neighbor.id);
                                        components[count].push(neighbor.id);
                                    }
                                });
                            }
                            count++;
                        }
                    });
                    return components;
                };
                // return undirected version of given dag
                var dagToUndirected = function dagToUndirected(dag) {
                    var undirected = new Map();
                    dag.forEach(function(value, key) {
                        undirected.set(key, []);
                    });
                    dag.forEach(function(value, key) {
                        value.forEach(function(adjacent) {
                            undirected.get(key).push(adjacent);
                            undirected.get(adjacent.id).push({
                                id: key,
                                gap: adjacent.gap,
                                direction: adjacent.direction
                            });
                        });
                    });
                    return undirected;
                };
                // return reversed (directions inverted) version of given dag
                var dagToReversed = function dagToReversed(dag) {
                    var reversed = new Map();
                    dag.forEach(function(value, key) {
                        reversed.set(key, []);
                    });
                    dag.forEach(function(value, key) {
                        value.forEach(function(adjacent) {
                            reversed.get(adjacent.id).push({
                                id: key,
                                gap: adjacent.gap,
                                direction: adjacent.direction
                            });
                        });
                    });
                    return reversed;
                };
                /****  apply transformation to the initial draft layout to better align with constrained nodes ****/ // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout
                // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications 
                /* construct source and target configurations */ var targetMatrix = []; // A - target configuration
                var sourceMatrix = []; // B - source configuration 
                var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)
                var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary
                var fixedNodes = new Set();
                var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints
                var dagUndirected = new Map(); // undirected version of the dag
                var components = []; // weakly connected components
                // fill fixedNodes collection to use later
                if (constraints.fixedNodeConstraint) constraints.fixedNodeConstraint.forEach(function(nodeData) {
                    fixedNodes.add(nodeData.nodeId);
                });
                // construct dag from relative placement constraints 
                if (constraints.relativePlacementConstraint) {
                    // construct both directed and undirected version of the dag
                    constraints.relativePlacementConstraint.forEach(function(constraint) {
                        if (constraint.left) {
                            if (dag.has(constraint.left)) dag.get(constraint.left).push({
                                id: constraint.right,
                                gap: constraint.gap,
                                direction: "horizontal"
                            });
                            else dag.set(constraint.left, [
                                {
                                    id: constraint.right,
                                    gap: constraint.gap,
                                    direction: "horizontal"
                                }
                            ]);
                            if (!dag.has(constraint.right)) dag.set(constraint.right, []);
                        } else {
                            if (dag.has(constraint.top)) dag.get(constraint.top).push({
                                id: constraint.bottom,
                                gap: constraint.gap,
                                direction: "vertical"
                            });
                            else dag.set(constraint.top, [
                                {
                                    id: constraint.bottom,
                                    gap: constraint.gap,
                                    direction: "vertical"
                                }
                            ]);
                            if (!dag.has(constraint.bottom)) dag.set(constraint.bottom, []);
                        }
                    });
                    dagUndirected = dagToUndirected(dag);
                    components = findComponents(dagUndirected);
                }
                if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {
                    // first check fixed node constraint
                    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {
                        constraints.fixedNodeConstraint.forEach(function(nodeData, i) {
                            targetMatrix[i] = [
                                nodeData.position.x,
                                nodeData.position.y
                            ];
                            sourceMatrix[i] = [
                                xCoords[nodeIndexes.get(nodeData.nodeId)],
                                yCoords[nodeIndexes.get(nodeData.nodeId)]
                            ];
                        });
                        standardTransformation = true;
                    } else if (constraints.alignmentConstraint) (function() {
                        // then check alignment constraint
                        var count = 0;
                        if (constraints.alignmentConstraint.vertical) {
                            var verticalAlign = constraints.alignmentConstraint.vertical;
                            var _loop2 = function _loop2(_i4) {
                                var alignmentSet = new Set();
                                verticalAlign[_i4].forEach(function(nodeId) {
                                    alignmentSet.add(nodeId);
                                });
                                var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {
                                    return fixedNodes.has(x);
                                }));
                                var xPos = void 0;
                                if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];
                                else xPos = calculateAvgPosition(alignmentSet).x;
                                verticalAlign[_i4].forEach(function(nodeId) {
                                    targetMatrix[count] = [
                                        xPos,
                                        yCoords[nodeIndexes.get(nodeId)]
                                    ];
                                    sourceMatrix[count] = [
                                        xCoords[nodeIndexes.get(nodeId)],
                                        yCoords[nodeIndexes.get(nodeId)]
                                    ];
                                    count++;
                                });
                            };
                            for(var _i4 = 0; _i4 < verticalAlign.length; _i4++)_loop2(_i4);
                            standardTransformation = true;
                        }
                        if (constraints.alignmentConstraint.horizontal) {
                            var horizontalAlign = constraints.alignmentConstraint.horizontal;
                            var _loop3 = function _loop3(_i5) {
                                var alignmentSet = new Set();
                                horizontalAlign[_i5].forEach(function(nodeId) {
                                    alignmentSet.add(nodeId);
                                });
                                var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {
                                    return fixedNodes.has(x);
                                }));
                                var yPos = void 0;
                                if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];
                                else yPos = calculateAvgPosition(alignmentSet).y;
                                horizontalAlign[_i5].forEach(function(nodeId) {
                                    targetMatrix[count] = [
                                        xCoords[nodeIndexes.get(nodeId)],
                                        yPos
                                    ];
                                    sourceMatrix[count] = [
                                        xCoords[nodeIndexes.get(nodeId)],
                                        yCoords[nodeIndexes.get(nodeId)]
                                    ];
                                    count++;
                                });
                            };
                            for(var _i5 = 0; _i5 < horizontalAlign.length; _i5++)_loop3(_i5);
                            standardTransformation = true;
                        }
                        if (constraints.relativePlacementConstraint) reflectionType = true;
                    })();
                    else if (constraints.relativePlacementConstraint) {
                        // finally check relative placement constraint
                        // find largest component in dag
                        var largestComponentSize = 0;
                        var largestComponentIndex = 0;
                        for(var _i6 = 0; _i6 < components.length; _i6++)if (components[_i6].length > largestComponentSize) {
                            largestComponentSize = components[_i6].length;
                            largestComponentIndex = _i6;
                        }
                        // if largest component isn't dominant, then take the votes for reflection
                        if (largestComponentSize < dagUndirected.size / 2) {
                            applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);
                            standardTransformation = false;
                            reflectionType = false;
                        } else {
                            // use largest component for transformation
                            // construct horizontal and vertical subgraphs in the largest component
                            var subGraphOnHorizontal = new Map();
                            var subGraphOnVertical = new Map();
                            var constraintsInlargestComponent = [];
                            components[largestComponentIndex].forEach(function(nodeId) {
                                dag.get(nodeId).forEach(function(adjacent) {
                                    if (adjacent.direction == "horizontal") {
                                        if (subGraphOnHorizontal.has(nodeId)) subGraphOnHorizontal.get(nodeId).push(adjacent);
                                        else subGraphOnHorizontal.set(nodeId, [
                                            adjacent
                                        ]);
                                        if (!subGraphOnHorizontal.has(adjacent.id)) subGraphOnHorizontal.set(adjacent.id, []);
                                        constraintsInlargestComponent.push({
                                            left: nodeId,
                                            right: adjacent.id
                                        });
                                    } else {
                                        if (subGraphOnVertical.has(nodeId)) subGraphOnVertical.get(nodeId).push(adjacent);
                                        else subGraphOnVertical.set(nodeId, [
                                            adjacent
                                        ]);
                                        if (!subGraphOnVertical.has(adjacent.id)) subGraphOnVertical.set(adjacent.id, []);
                                        constraintsInlargestComponent.push({
                                            top: nodeId,
                                            bottom: adjacent.id
                                        });
                                    }
                                });
                            });
                            applyReflectionForRelativePlacement(constraintsInlargestComponent);
                            reflectionType = false;
                            // calculate appropriate positioning for subgraphs
                            var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, "horizontal");
                            var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, "vertical");
                            // construct source and target configuration
                            components[largestComponentIndex].forEach(function(nodeId, i) {
                                sourceMatrix[i] = [
                                    xCoords[nodeIndexes.get(nodeId)],
                                    yCoords[nodeIndexes.get(nodeId)]
                                ];
                                targetMatrix[i] = [];
                                if (positionMapHorizontal.has(nodeId)) targetMatrix[i][0] = positionMapHorizontal.get(nodeId);
                                else targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];
                                if (positionMapVertical.has(nodeId)) targetMatrix[i][1] = positionMapVertical.get(nodeId);
                                else targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];
                            });
                            standardTransformation = true;
                        }
                    }
                    // if transformation is required, then calculate and apply transformation matrix
                    if (standardTransformation) {
                        /* calculate transformation matrix */ var transformationMatrix = void 0;
                        var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'
                        var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'
                        // centralize transpose matrices
                        for(var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++){
                            targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);
                            sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);
                        }
                        // do actual calculation for transformation matrix
                        var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B
                        var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V 
                        transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'
                        /* apply found transformation matrix to obtain final draft layout */ for(var _i8 = 0; _i8 < nodeIndexes.size; _i8++){
                            var temp1 = [
                                xCoords[_i8],
                                yCoords[_i8]
                            ];
                            var temp2 = [
                                transformationMatrix[0][0],
                                transformationMatrix[1][0]
                            ];
                            var temp3 = [
                                transformationMatrix[0][1],
                                transformationMatrix[1][1]
                            ];
                            xCoords[_i8] = Matrix.dotProduct(temp1, temp2);
                            yCoords[_i8] = Matrix.dotProduct(temp1, temp3);
                        }
                        // applied only both alignment and rel. placement constraints exist
                        if (reflectionType) applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);
                    }
                }
                if (CoSEConstants.ENFORCE_CONSTRAINTS) {
                    /****  enforce constraints on the transformed draft layout ****/ /* first enforce fixed node constraint */ if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {
                        var translationAmount = {
                            x: 0,
                            y: 0
                        };
                        constraints.fixedNodeConstraint.forEach(function(nodeData, i) {
                            var posInTheory = {
                                x: xCoords[nodeIndexes.get(nodeData.nodeId)],
                                y: yCoords[nodeIndexes.get(nodeData.nodeId)]
                            };
                            var posDesired = nodeData.position;
                            var posDiff = calculatePositionDiff(posDesired, posInTheory);
                            translationAmount.x += posDiff.x;
                            translationAmount.y += posDiff.y;
                        });
                        translationAmount.x /= constraints.fixedNodeConstraint.length;
                        translationAmount.y /= constraints.fixedNodeConstraint.length;
                        xCoords.forEach(function(value, i) {
                            xCoords[i] += translationAmount.x;
                        });
                        yCoords.forEach(function(value, i) {
                            yCoords[i] += translationAmount.y;
                        });
                        constraints.fixedNodeConstraint.forEach(function(nodeData) {
                            xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;
                            yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;
                        });
                    }
                    /* then enforce alignment constraint */ if (constraints.alignmentConstraint) {
                        if (constraints.alignmentConstraint.vertical) {
                            var xAlign = constraints.alignmentConstraint.vertical;
                            var _loop4 = function _loop4(_i9) {
                                var alignmentSet = new Set();
                                xAlign[_i9].forEach(function(nodeId) {
                                    alignmentSet.add(nodeId);
                                });
                                var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {
                                    return fixedNodes.has(x);
                                }));
                                var xPos = void 0;
                                if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];
                                else xPos = calculateAvgPosition(alignmentSet).x;
                                alignmentSet.forEach(function(nodeId) {
                                    if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;
                                });
                            };
                            for(var _i9 = 0; _i9 < xAlign.length; _i9++)_loop4(_i9);
                        }
                        if (constraints.alignmentConstraint.horizontal) {
                            var yAlign = constraints.alignmentConstraint.horizontal;
                            var _loop5 = function _loop5(_i10) {
                                var alignmentSet = new Set();
                                yAlign[_i10].forEach(function(nodeId) {
                                    alignmentSet.add(nodeId);
                                });
                                var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {
                                    return fixedNodes.has(x);
                                }));
                                var yPos = void 0;
                                if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];
                                else yPos = calculateAvgPosition(alignmentSet).y;
                                alignmentSet.forEach(function(nodeId) {
                                    if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;
                                });
                            };
                            for(var _i10 = 0; _i10 < yAlign.length; _i10++)_loop5(_i10);
                        }
                    }
                    /* finally enforce relative placement constraint */ if (constraints.relativePlacementConstraint) (function() {
                        var nodeToDummyForVerticalAlignment = new Map();
                        var nodeToDummyForHorizontalAlignment = new Map();
                        var dummyToNodeForVerticalAlignment = new Map();
                        var dummyToNodeForHorizontalAlignment = new Map();
                        var dummyPositionsForVerticalAlignment = new Map();
                        var dummyPositionsForHorizontalAlignment = new Map();
                        var fixedNodesOnHorizontal = new Set();
                        var fixedNodesOnVertical = new Set();
                        // fill maps and sets      
                        fixedNodes.forEach(function(nodeId) {
                            fixedNodesOnHorizontal.add(nodeId);
                            fixedNodesOnVertical.add(nodeId);
                        });
                        if (constraints.alignmentConstraint) {
                            if (constraints.alignmentConstraint.vertical) {
                                var verticalAlignment = constraints.alignmentConstraint.vertical;
                                var _loop6 = function _loop6(_i11) {
                                    dummyToNodeForVerticalAlignment.set("dummy" + _i11, []);
                                    verticalAlignment[_i11].forEach(function(nodeId) {
                                        nodeToDummyForVerticalAlignment.set(nodeId, "dummy" + _i11);
                                        dummyToNodeForVerticalAlignment.get("dummy" + _i11).push(nodeId);
                                        if (fixedNodes.has(nodeId)) fixedNodesOnHorizontal.add("dummy" + _i11);
                                    });
                                    dummyPositionsForVerticalAlignment.set("dummy" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);
                                };
                                for(var _i11 = 0; _i11 < verticalAlignment.length; _i11++)_loop6(_i11);
                            }
                            if (constraints.alignmentConstraint.horizontal) {
                                var horizontalAlignment = constraints.alignmentConstraint.horizontal;
                                var _loop7 = function _loop7(_i12) {
                                    dummyToNodeForHorizontalAlignment.set("dummy" + _i12, []);
                                    horizontalAlignment[_i12].forEach(function(nodeId) {
                                        nodeToDummyForHorizontalAlignment.set(nodeId, "dummy" + _i12);
                                        dummyToNodeForHorizontalAlignment.get("dummy" + _i12).push(nodeId);
                                        if (fixedNodes.has(nodeId)) fixedNodesOnVertical.add("dummy" + _i12);
                                    });
                                    dummyPositionsForHorizontalAlignment.set("dummy" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);
                                };
                                for(var _i12 = 0; _i12 < horizontalAlignment.length; _i12++)_loop7(_i12);
                            }
                        }
                        // construct horizontal and vertical dags (subgraphs) from overall dag
                        var dagOnHorizontal = new Map();
                        var dagOnVertical = new Map();
                        var _loop8 = function _loop8(nodeId) {
                            dag.get(nodeId).forEach(function(adjacent) {
                                var sourceId = void 0;
                                var targetNode = void 0;
                                if (adjacent["direction"] == "horizontal") {
                                    sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;
                                    if (nodeToDummyForVerticalAlignment.get(adjacent.id)) targetNode = {
                                        id: nodeToDummyForVerticalAlignment.get(adjacent.id),
                                        gap: adjacent.gap,
                                        direction: adjacent.direction
                                    };
                                    else targetNode = adjacent;
                                    if (dagOnHorizontal.has(sourceId)) dagOnHorizontal.get(sourceId).push(targetNode);
                                    else dagOnHorizontal.set(sourceId, [
                                        targetNode
                                    ]);
                                    if (!dagOnHorizontal.has(targetNode.id)) dagOnHorizontal.set(targetNode.id, []);
                                } else {
                                    sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;
                                    if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) targetNode = {
                                        id: nodeToDummyForHorizontalAlignment.get(adjacent.id),
                                        gap: adjacent.gap,
                                        direction: adjacent.direction
                                    };
                                    else targetNode = adjacent;
                                    if (dagOnVertical.has(sourceId)) dagOnVertical.get(sourceId).push(targetNode);
                                    else dagOnVertical.set(sourceId, [
                                        targetNode
                                    ]);
                                    if (!dagOnVertical.has(targetNode.id)) dagOnVertical.set(targetNode.id, []);
                                }
                            });
                        };
                        var _iteratorNormalCompletion5 = true;
                        var _didIteratorError5 = false;
                        var _iteratorError5 = undefined;
                        try {
                            for(var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true){
                                var nodeId = _step5.value;
                                _loop8(nodeId);
                            }
                        // find source nodes of each component in horizontal and vertical dags
                        } catch (err) {
                            _didIteratorError5 = true;
                            _iteratorError5 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion5 && _iterator5.return) _iterator5.return();
                            } finally{
                                if (_didIteratorError5) throw _iteratorError5;
                            }
                        }
                        var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);
                        var undirectedOnVertical = dagToUndirected(dagOnVertical);
                        var componentsOnHorizontal = findComponents(undirectedOnHorizontal);
                        var componentsOnVertical = findComponents(undirectedOnVertical);
                        var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);
                        var reversedDagOnVertical = dagToReversed(dagOnVertical);
                        var componentSourcesOnHorizontal = [];
                        var componentSourcesOnVertical = [];
                        componentsOnHorizontal.forEach(function(component, index) {
                            componentSourcesOnHorizontal[index] = [];
                            component.forEach(function(nodeId) {
                                if (reversedDagOnHorizontal.get(nodeId).length == 0) componentSourcesOnHorizontal[index].push(nodeId);
                            });
                        });
                        componentsOnVertical.forEach(function(component, index) {
                            componentSourcesOnVertical[index] = [];
                            component.forEach(function(nodeId) {
                                if (reversedDagOnVertical.get(nodeId).length == 0) componentSourcesOnVertical[index].push(nodeId);
                            });
                        });
                        // calculate appropriate positioning for subgraphs
                        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, "horizontal", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);
                        var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, "vertical", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);
                        // update positions of the nodes based on relative placement constraints
                        var _loop9 = function _loop9(key) {
                            if (dummyToNodeForVerticalAlignment.get(key)) dummyToNodeForVerticalAlignment.get(key).forEach(function(nodeId) {
                                xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);
                            });
                            else xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);
                        };
                        var _iteratorNormalCompletion6 = true;
                        var _didIteratorError6 = false;
                        var _iteratorError6 = undefined;
                        try {
                            for(var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true){
                                var key = _step6.value;
                                _loop9(key);
                            }
                        } catch (err1) {
                            _didIteratorError6 = true;
                            _iteratorError6 = err1;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion6 && _iterator6.return) _iterator6.return();
                            } finally{
                                if (_didIteratorError6) throw _iteratorError6;
                            }
                        }
                        var _loop10 = function _loop10(key) {
                            if (dummyToNodeForHorizontalAlignment.get(key)) dummyToNodeForHorizontalAlignment.get(key).forEach(function(nodeId) {
                                yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);
                            });
                            else yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);
                        };
                        var _iteratorNormalCompletion7 = true;
                        var _didIteratorError7 = false;
                        var _iteratorError7 = undefined;
                        try {
                            for(var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true){
                                var key = _step7.value;
                                _loop10(key);
                            }
                        } catch (err2) {
                            _didIteratorError7 = true;
                            _iteratorError7 = err2;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion7 && _iterator7.return) _iterator7.return();
                            } finally{
                                if (_didIteratorError7) throw _iteratorError7;
                            }
                        }
                    })();
                }
                // assign new coordinates to nodes after constraint handling
                for(var _i13 = 0; _i13 < allNodes.length; _i13++){
                    var _node = allNodes[_i13];
                    if (_node.getChild() == null) _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);
                }
            };
            module1.exports = ConstraintHandler;
        /***/ },
        /* 7 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var FDLayout = __webpack_require__(0).FDLayout;
            var CoSEGraphManager = __webpack_require__(4);
            var CoSEGraph = __webpack_require__(3);
            var CoSENode = __webpack_require__(5);
            var CoSEEdge = __webpack_require__(2);
            var CoSEConstants = __webpack_require__(1);
            var ConstraintHandler = __webpack_require__(6);
            var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;
            var LayoutConstants = __webpack_require__(0).LayoutConstants;
            var Point = __webpack_require__(0).Point;
            var PointD = __webpack_require__(0).PointD;
            var DimensionD = __webpack_require__(0).DimensionD;
            var Layout = __webpack_require__(0).Layout;
            var Integer = __webpack_require__(0).Integer;
            var IGeometry = __webpack_require__(0).IGeometry;
            var LGraph = __webpack_require__(0).LGraph;
            var Transform = __webpack_require__(0).Transform;
            var LinkedList = __webpack_require__(0).LinkedList;
            function CoSELayout() {
                FDLayout.call(this);
                this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled
                this.constraints = {}; // keep layout constraints
            }
            CoSELayout.prototype = Object.create(FDLayout.prototype);
            for(var prop in FDLayout)CoSELayout[prop] = FDLayout[prop];
            CoSELayout.prototype.newGraphManager = function() {
                var gm = new CoSEGraphManager(this);
                this.graphManager = gm;
                return gm;
            };
            CoSELayout.prototype.newGraph = function(vGraph) {
                return new CoSEGraph(null, this.graphManager, vGraph);
            };
            CoSELayout.prototype.newNode = function(vNode) {
                return new CoSENode(this.graphManager, vNode);
            };
            CoSELayout.prototype.newEdge = function(vEdge) {
                return new CoSEEdge(null, null, vEdge);
            };
            CoSELayout.prototype.initParameters = function() {
                FDLayout.prototype.initParameters.call(this, arguments);
                if (!this.isSubLayout) {
                    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) this.idealEdgeLength = 10;
                    else this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;
                    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;
                    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;
                    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;
                    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;
                    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;
                    // variables for tree reduction support
                    this.prunedNodesAll = [];
                    this.growTreeIterations = 0;
                    this.afterGrowthIterations = 0;
                    this.isTreeGrowing = false;
                    this.isGrowthFinished = false;
                }
            };
            // This method is used to set CoSE related parameters used by spring embedder.
            CoSELayout.prototype.initSpringEmbedder = function() {
                FDLayout.prototype.initSpringEmbedder.call(this);
                // variables for cooling
                this.coolingCycle = 0;
                this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;
                this.finalTemperature = 0.04;
                this.coolingAdjuster = 1;
            };
            CoSELayout.prototype.layout = function() {
                var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;
                if (createBendsAsNeeded) {
                    this.createBendpoints();
                    this.graphManager.resetAllEdges();
                }
                this.level = 0;
                return this.classicLayout();
            };
            CoSELayout.prototype.classicLayout = function() {
                this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();
                this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);
                this.calcNoOfChildrenForAllNodes();
                this.graphManager.calcLowestCommonAncestors();
                this.graphManager.calcInclusionTreeDepths();
                this.graphManager.getRoot().calcEstimatedSize();
                this.calcIdealEdgeLengths();
                if (!this.incremental) {
                    var forest = this.getFlatForest();
                    // The graph associated with this layout is flat and a forest
                    if (forest.length > 0) this.positionNodesRadially(forest);
                    else {
                        // Reduce the trees when incremental mode is not enabled and graph is not a forest 
                        this.reduceTrees();
                        // Update nodes that gravity will be applied
                        this.graphManager.resetAllNodesToApplyGravitation();
                        var allNodes = new Set(this.getAllNodes());
                        var intersection = this.nodesWithGravity.filter(function(x) {
                            return allNodes.has(x);
                        });
                        this.graphManager.setAllNodesToApplyGravitation(intersection);
                        this.positionNodesRandomly();
                    }
                } else if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {
                    // Reduce the trees in incremental mode if only this constant is set to true 
                    this.reduceTrees();
                    // Update nodes that gravity will be applied
                    this.graphManager.resetAllNodesToApplyGravitation();
                    var allNodes = new Set(this.getAllNodes());
                    var intersection = this.nodesWithGravity.filter(function(x) {
                        return allNodes.has(x);
                    });
                    this.graphManager.setAllNodesToApplyGravitation(intersection);
                }
                if (Object.keys(this.constraints).length > 0) {
                    ConstraintHandler.handleConstraints(this);
                    this.initConstraintVariables();
                }
                this.initSpringEmbedder();
                if (CoSEConstants.APPLY_LAYOUT) this.runSpringEmbedder();
                return true;
            };
            CoSELayout.prototype.tick = function() {
                this.totalIterations++;
                if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {
                    if (this.prunedNodesAll.length > 0) this.isTreeGrowing = true;
                    else return true;
                }
                if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {
                    if (this.isConverged()) {
                        if (this.prunedNodesAll.length > 0) this.isTreeGrowing = true;
                        else return true;
                    }
                    this.coolingCycle++;
                    if (this.layoutQuality == 0) // quality - "draft"
                    this.coolingAdjuster = this.coolingCycle;
                    else if (this.layoutQuality == 1) // quality - "default"
                    this.coolingAdjuster = this.coolingCycle / 3;
                    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3
                    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);
                    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));
                }
                // Operations while tree is growing again 
                if (this.isTreeGrowing) {
                    if (this.growTreeIterations % 10 == 0) {
                        if (this.prunedNodesAll.length > 0) {
                            this.graphManager.updateBounds();
                            this.updateGrid();
                            this.growTree(this.prunedNodesAll);
                            // Update nodes that gravity will be applied
                            this.graphManager.resetAllNodesToApplyGravitation();
                            var allNodes = new Set(this.getAllNodes());
                            var intersection = this.nodesWithGravity.filter(function(x) {
                                return allNodes.has(x);
                            });
                            this.graphManager.setAllNodesToApplyGravitation(intersection);
                            this.graphManager.updateBounds();
                            this.updateGrid();
                            if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;
                            else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;
                        } else {
                            this.isTreeGrowing = false;
                            this.isGrowthFinished = true;
                        }
                    }
                    this.growTreeIterations++;
                }
                // Operations after growth is finished
                if (this.isGrowthFinished) {
                    if (this.isConverged()) return true;
                    if (this.afterGrowthIterations % 10 == 0) {
                        this.graphManager.updateBounds();
                        this.updateGrid();
                    }
                    if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);
                    else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);
                    this.afterGrowthIterations++;
                }
                var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;
                var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;
                this.totalDisplacement = 0;
                this.graphManager.updateBounds();
                this.calcSpringForces();
                this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);
                this.calcGravitationalForces();
                this.moveNodes();
                this.animate();
                return false; // Layout is not ended yet return false
            };
            CoSELayout.prototype.getPositionsData = function() {
                var allNodes = this.graphManager.getAllNodes();
                var pData = {};
                for(var i = 0; i < allNodes.length; i++){
                    var rect = allNodes[i].rect;
                    var id = allNodes[i].id;
                    pData[id] = {
                        id: id,
                        x: rect.getCenterX(),
                        y: rect.getCenterY(),
                        w: rect.width,
                        h: rect.height
                    };
                }
                return pData;
            };
            CoSELayout.prototype.runSpringEmbedder = function() {
                this.initialAnimationPeriod = 25;
                this.animationPeriod = this.initialAnimationPeriod;
                var layoutEnded = false;
                // If aminate option is 'during' signal that layout is supposed to start iterating
                if (FDLayoutConstants.ANIMATE === "during") this.emit("layoutstarted");
                else {
                    // If aminate option is 'during' tick() function will be called on index.js
                    while(!layoutEnded)layoutEnded = this.tick();
                    this.graphManager.updateBounds();
                }
            };
            // overrides moveNodes method in FDLayout
            CoSELayout.prototype.moveNodes = function() {
                var lNodes = this.getAllNodes();
                var node;
                // calculate displacement for each node 
                for(var i = 0; i < lNodes.length; i++){
                    node = lNodes[i];
                    node.calculateDisplacement();
                }
                if (Object.keys(this.constraints).length > 0) this.updateDisplacements();
                // move each node
                for(var i = 0; i < lNodes.length; i++){
                    node = lNodes[i];
                    node.move();
                }
            };
            // constraint related methods: initConstraintVariables and updateDisplacements
            // initialize constraint related variables
            CoSELayout.prototype.initConstraintVariables = function() {
                var self = this;
                this.idToNodeMap = new Map();
                this.fixedNodeSet = new Set();
                var allNodes = this.graphManager.getAllNodes();
                // fill idToNodeMap
                for(var i = 0; i < allNodes.length; i++){
                    var node = allNodes[i];
                    this.idToNodeMap.set(node.id, node);
                }
                // calculate fixed node weight for given compound node
                var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {
                    var nodes = compoundNode.getChild().getNodes();
                    var node;
                    var fixedNodeWeight = 0;
                    for(var i = 0; i < nodes.length; i++){
                        node = nodes[i];
                        if (node.getChild() == null) {
                            if (self.fixedNodeSet.has(node.id)) fixedNodeWeight += 100;
                        } else fixedNodeWeight += calculateCompoundWeight(node);
                    }
                    return fixedNodeWeight;
                };
                if (this.constraints.fixedNodeConstraint) {
                    // fill fixedNodeSet
                    this.constraints.fixedNodeConstraint.forEach(function(nodeData) {
                        self.fixedNodeSet.add(nodeData.nodeId);
                    });
                    // assign fixed node weights to compounds if they contain fixed nodes
                    var allNodes = this.graphManager.getAllNodes();
                    var node;
                    for(var i = 0; i < allNodes.length; i++){
                        node = allNodes[i];
                        if (node.getChild() != null) {
                            var fixedNodeWeight = calculateCompoundWeight(node);
                            if (fixedNodeWeight > 0) node.fixedNodeWeight = fixedNodeWeight;
                        }
                    }
                }
                if (this.constraints.relativePlacementConstraint) {
                    var nodeToDummyForVerticalAlignment = new Map();
                    var nodeToDummyForHorizontalAlignment = new Map();
                    this.dummyToNodeForVerticalAlignment = new Map();
                    this.dummyToNodeForHorizontalAlignment = new Map();
                    this.fixedNodesOnHorizontal = new Set();
                    this.fixedNodesOnVertical = new Set();
                    // fill maps and sets
                    this.fixedNodeSet.forEach(function(nodeId) {
                        self.fixedNodesOnHorizontal.add(nodeId);
                        self.fixedNodesOnVertical.add(nodeId);
                    });
                    if (this.constraints.alignmentConstraint) {
                        if (this.constraints.alignmentConstraint.vertical) {
                            var verticalAlignment = this.constraints.alignmentConstraint.vertical;
                            for(var i = 0; i < verticalAlignment.length; i++){
                                this.dummyToNodeForVerticalAlignment.set("dummy" + i, []);
                                verticalAlignment[i].forEach(function(nodeId) {
                                    nodeToDummyForVerticalAlignment.set(nodeId, "dummy" + i);
                                    self.dummyToNodeForVerticalAlignment.get("dummy" + i).push(nodeId);
                                    if (self.fixedNodeSet.has(nodeId)) self.fixedNodesOnHorizontal.add("dummy" + i);
                                });
                            }
                        }
                        if (this.constraints.alignmentConstraint.horizontal) {
                            var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;
                            for(var i = 0; i < horizontalAlignment.length; i++){
                                this.dummyToNodeForHorizontalAlignment.set("dummy" + i, []);
                                horizontalAlignment[i].forEach(function(nodeId) {
                                    nodeToDummyForHorizontalAlignment.set(nodeId, "dummy" + i);
                                    self.dummyToNodeForHorizontalAlignment.get("dummy" + i).push(nodeId);
                                    if (self.fixedNodeSet.has(nodeId)) self.fixedNodesOnVertical.add("dummy" + i);
                                });
                            }
                        }
                    }
                    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {
                        this.shuffle = function(array) {
                            var j, x, i;
                            for(i = array.length - 1; i >= 2 * array.length / 3; i--){
                                j = Math.floor(Math.random() * (i + 1));
                                x = array[i];
                                array[i] = array[j];
                                array[j] = x;
                            }
                            return array;
                        };
                        this.nodesInRelativeHorizontal = [];
                        this.nodesInRelativeVertical = [];
                        this.nodeToRelativeConstraintMapHorizontal = new Map();
                        this.nodeToRelativeConstraintMapVertical = new Map();
                        this.nodeToTempPositionMapHorizontal = new Map();
                        this.nodeToTempPositionMapVertical = new Map();
                        // fill arrays and maps
                        this.constraints.relativePlacementConstraint.forEach(function(constraint) {
                            if (constraint.left) {
                                var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;
                                var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;
                                if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {
                                    self.nodesInRelativeHorizontal.push(nodeIdLeft);
                                    self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);
                                    if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());
                                    else self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());
                                }
                                if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {
                                    self.nodesInRelativeHorizontal.push(nodeIdRight);
                                    self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);
                                    if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());
                                    else self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());
                                }
                                self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({
                                    right: nodeIdRight,
                                    gap: constraint.gap
                                });
                                self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({
                                    left: nodeIdLeft,
                                    gap: constraint.gap
                                });
                            } else {
                                var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;
                                var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;
                                if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {
                                    self.nodesInRelativeVertical.push(nodeIdTop);
                                    self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);
                                    if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());
                                    else self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());
                                }
                                if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {
                                    self.nodesInRelativeVertical.push(nodeIdBottom);
                                    self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);
                                    if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());
                                    else self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());
                                }
                                self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({
                                    bottom: nodeIdBottom,
                                    gap: constraint.gap
                                });
                                self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({
                                    top: nodeIdTop,
                                    gap: constraint.gap
                                });
                            }
                        });
                    } else {
                        var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints
                        var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints
                        // construct subgraphs from relative placement constraints 
                        this.constraints.relativePlacementConstraint.forEach(function(constraint) {
                            if (constraint.left) {
                                var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;
                                var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;
                                if (subGraphOnHorizontal.has(left)) subGraphOnHorizontal.get(left).push(right);
                                else subGraphOnHorizontal.set(left, [
                                    right
                                ]);
                                if (subGraphOnHorizontal.has(right)) subGraphOnHorizontal.get(right).push(left);
                                else subGraphOnHorizontal.set(right, [
                                    left
                                ]);
                            } else {
                                var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;
                                var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;
                                if (subGraphOnVertical.has(top)) subGraphOnVertical.get(top).push(bottom);
                                else subGraphOnVertical.set(top, [
                                    bottom
                                ]);
                                if (subGraphOnVertical.has(bottom)) subGraphOnVertical.get(bottom).push(top);
                                else subGraphOnVertical.set(bottom, [
                                    top
                                ]);
                            }
                        });
                        // function to construct components from a given graph 
                        // also returns an array that keeps whether each component contains fixed node
                        var constructComponents = function constructComponents(graph, fixedNodes) {
                            var components = [];
                            var isFixed = [];
                            var queue = new LinkedList();
                            var visited = new Set();
                            var count = 0;
                            graph.forEach(function(value, key) {
                                if (!visited.has(key)) {
                                    components[count] = [];
                                    isFixed[count] = false;
                                    var currentNode = key;
                                    queue.push(currentNode);
                                    visited.add(currentNode);
                                    components[count].push(currentNode);
                                    while(queue.length != 0){
                                        currentNode = queue.shift();
                                        if (fixedNodes.has(currentNode)) isFixed[count] = true;
                                        var neighbors = graph.get(currentNode);
                                        neighbors.forEach(function(neighbor) {
                                            if (!visited.has(neighbor)) {
                                                queue.push(neighbor);
                                                visited.add(neighbor);
                                                components[count].push(neighbor);
                                            }
                                        });
                                    }
                                    count++;
                                }
                            });
                            return {
                                components: components,
                                isFixed: isFixed
                            };
                        };
                        var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);
                        this.componentsOnHorizontal = resultOnHorizontal.components;
                        this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;
                        var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);
                        this.componentsOnVertical = resultOnVertical.components;
                        this.fixedComponentsOnVertical = resultOnVertical.isFixed;
                    }
                }
            };
            // updates node displacements based on constraints
            CoSELayout.prototype.updateDisplacements = function() {
                var self = this;
                if (this.constraints.fixedNodeConstraint) this.constraints.fixedNodeConstraint.forEach(function(nodeData) {
                    var fixedNode = self.idToNodeMap.get(nodeData.nodeId);
                    fixedNode.displacementX = 0;
                    fixedNode.displacementY = 0;
                });
                if (this.constraints.alignmentConstraint) {
                    if (this.constraints.alignmentConstraint.vertical) {
                        var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;
                        for(var i = 0; i < allVerticalAlignments.length; i++){
                            var totalDisplacementX = 0;
                            for(var j = 0; j < allVerticalAlignments[i].length; j++){
                                if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {
                                    totalDisplacementX = 0;
                                    break;
                                }
                                totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;
                            }
                            var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;
                            for(var j = 0; j < allVerticalAlignments[i].length; j++)this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;
                        }
                    }
                    if (this.constraints.alignmentConstraint.horizontal) {
                        var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;
                        for(var i = 0; i < allHorizontalAlignments.length; i++){
                            var totalDisplacementY = 0;
                            for(var j = 0; j < allHorizontalAlignments[i].length; j++){
                                if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {
                                    totalDisplacementY = 0;
                                    break;
                                }
                                totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;
                            }
                            var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;
                            for(var j = 0; j < allHorizontalAlignments[i].length; j++)this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;
                        }
                    }
                }
                if (this.constraints.relativePlacementConstraint) {
                    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {
                        // shuffle array to randomize node processing order
                        if (this.totalIterations % 10 == 0) {
                            this.shuffle(this.nodesInRelativeHorizontal);
                            this.shuffle(this.nodesInRelativeVertical);
                        }
                        this.nodesInRelativeHorizontal.forEach(function(nodeId) {
                            if (!self.fixedNodesOnHorizontal.has(nodeId)) {
                                var displacement = 0;
                                if (self.dummyToNodeForVerticalAlignment.has(nodeId)) displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;
                                else displacement = self.idToNodeMap.get(nodeId).displacementX;
                                self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function(constraint) {
                                    if (constraint.right) {
                                        var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;
                                        if (diff < constraint.gap) displacement -= constraint.gap - diff;
                                    } else {
                                        var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;
                                        if (diff < constraint.gap) displacement += constraint.gap - diff;
                                    }
                                });
                                self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);
                                if (self.dummyToNodeForVerticalAlignment.has(nodeId)) self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function(nodeId) {
                                    self.idToNodeMap.get(nodeId).displacementX = displacement;
                                });
                                else self.idToNodeMap.get(nodeId).displacementX = displacement;
                            }
                        });
                        this.nodesInRelativeVertical.forEach(function(nodeId) {
                            if (!self.fixedNodesOnHorizontal.has(nodeId)) {
                                var displacement = 0;
                                if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;
                                else displacement = self.idToNodeMap.get(nodeId).displacementY;
                                self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function(constraint) {
                                    if (constraint.bottom) {
                                        var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;
                                        if (diff < constraint.gap) displacement -= constraint.gap - diff;
                                    } else {
                                        var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;
                                        if (diff < constraint.gap) displacement += constraint.gap - diff;
                                    }
                                });
                                self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);
                                if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function(nodeId) {
                                    self.idToNodeMap.get(nodeId).displacementY = displacement;
                                });
                                else self.idToNodeMap.get(nodeId).displacementY = displacement;
                            }
                        });
                    } else {
                        for(var i = 0; i < this.componentsOnHorizontal.length; i++){
                            var component = this.componentsOnHorizontal[i];
                            if (this.fixedComponentsOnHorizontal[i]) {
                                for(var j = 0; j < component.length; j++)if (this.dummyToNodeForVerticalAlignment.has(component[j])) this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function(nodeId) {
                                    self.idToNodeMap.get(nodeId).displacementX = 0;
                                });
                                else this.idToNodeMap.get(component[j]).displacementX = 0;
                            } else {
                                var sum = 0;
                                var count = 0;
                                for(var j = 0; j < component.length; j++)if (this.dummyToNodeForVerticalAlignment.has(component[j])) {
                                    var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);
                                    sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;
                                    count += actualNodes.length;
                                } else {
                                    sum += this.idToNodeMap.get(component[j]).displacementX;
                                    count++;
                                }
                                var averageDisplacement = sum / count;
                                for(var j = 0; j < component.length; j++)if (this.dummyToNodeForVerticalAlignment.has(component[j])) this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function(nodeId) {
                                    self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;
                                });
                                else this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;
                            }
                        }
                        for(var i = 0; i < this.componentsOnVertical.length; i++){
                            var component = this.componentsOnVertical[i];
                            if (this.fixedComponentsOnVertical[i]) {
                                for(var j = 0; j < component.length; j++)if (this.dummyToNodeForHorizontalAlignment.has(component[j])) this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function(nodeId) {
                                    self.idToNodeMap.get(nodeId).displacementY = 0;
                                });
                                else this.idToNodeMap.get(component[j]).displacementY = 0;
                            } else {
                                var sum = 0;
                                var count = 0;
                                for(var j = 0; j < component.length; j++)if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {
                                    var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);
                                    sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;
                                    count += actualNodes.length;
                                } else {
                                    sum += this.idToNodeMap.get(component[j]).displacementY;
                                    count++;
                                }
                                var averageDisplacement = sum / count;
                                for(var j = 0; j < component.length; j++)if (this.dummyToNodeForHorizontalAlignment.has(component[j])) this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function(nodeId) {
                                    self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;
                                });
                                else this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;
                            }
                        }
                    }
                }
            };
            CoSELayout.prototype.calculateNodesToApplyGravitationTo = function() {
                var nodeList = [];
                var graph;
                var graphs = this.graphManager.getGraphs();
                var size = graphs.length;
                var i;
                for(i = 0; i < size; i++){
                    graph = graphs[i];
                    graph.updateConnected();
                    if (!graph.isConnected) nodeList = nodeList.concat(graph.getNodes());
                }
                return nodeList;
            };
            CoSELayout.prototype.createBendpoints = function() {
                var edges = [];
                edges = edges.concat(this.graphManager.getAllEdges());
                var visited = new Set();
                var i;
                for(i = 0; i < edges.length; i++){
                    var edge = edges[i];
                    if (!visited.has(edge)) {
                        var source = edge.getSource();
                        var target = edge.getTarget();
                        if (source == target) {
                            edge.getBendpoints().push(new PointD());
                            edge.getBendpoints().push(new PointD());
                            this.createDummyNodesForBendpoints(edge);
                            visited.add(edge);
                        } else {
                            var edgeList = [];
                            edgeList = edgeList.concat(source.getEdgeListToNode(target));
                            edgeList = edgeList.concat(target.getEdgeListToNode(source));
                            if (!visited.has(edgeList[0])) {
                                if (edgeList.length > 1) {
                                    var k;
                                    for(k = 0; k < edgeList.length; k++){
                                        var multiEdge = edgeList[k];
                                        multiEdge.getBendpoints().push(new PointD());
                                        this.createDummyNodesForBendpoints(multiEdge);
                                    }
                                }
                                edgeList.forEach(function(edge) {
                                    visited.add(edge);
                                });
                            }
                        }
                    }
                    if (visited.size == edges.length) break;
                }
            };
            CoSELayout.prototype.positionNodesRadially = function(forest) {
                // We tile the trees to a grid row by row; first tree starts at (0,0)
                var currentStartingPoint = new Point(0, 0);
                var numberOfColumns = Math.ceil(Math.sqrt(forest.length));
                var height = 0;
                var currentY = 0;
                var currentX = 0;
                var point = new PointD(0, 0);
                for(var i = 0; i < forest.length; i++){
                    if (i % numberOfColumns == 0) {
                        // Start of a new row, make the x coordinate 0, increment the
                        // y coordinate with the max height of the previous row
                        currentX = 0;
                        currentY = height;
                        if (i != 0) currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;
                        height = 0;
                    }
                    var tree = forest[i];
                    // Find the center of the tree
                    var centerNode = Layout.findCenterOfTree(tree);
                    // Set the staring point of the next tree
                    currentStartingPoint.x = currentX;
                    currentStartingPoint.y = currentY;
                    // Do a radial layout starting with the center
                    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);
                    if (point.y > height) height = Math.floor(point.y);
                    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);
                }
                this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));
            };
            CoSELayout.radialLayout = function(tree, centerNode, startingPoint) {
                var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);
                CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);
                var bounds = LGraph.calculateBounds(tree);
                var transform = new Transform();
                transform.setDeviceOrgX(bounds.getMinX());
                transform.setDeviceOrgY(bounds.getMinY());
                transform.setWorldOrgX(startingPoint.x);
                transform.setWorldOrgY(startingPoint.y);
                for(var i = 0; i < tree.length; i++){
                    var node = tree[i];
                    node.transform(transform);
                }
                var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());
                return transform.inverseTransformPoint(bottomRight);
            };
            CoSELayout.branchRadialLayout = function(node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {
                // First, position this node by finding its angle.
                var halfInterval = (endAngle - startAngle + 1) / 2;
                if (halfInterval < 0) halfInterval += 180;
                var nodeAngle = (halfInterval + startAngle) % 360;
                var teta = nodeAngle * IGeometry.TWO_PI / 360;
                // Make polar to java cordinate conversion.
                var cos_teta = Math.cos(teta);
                var x_ = distance * Math.cos(teta);
                var y_ = distance * Math.sin(teta);
                node.setCenter(x_, y_);
                // Traverse all neighbors of this node and recursively call this
                // function.
                var neighborEdges = [];
                neighborEdges = neighborEdges.concat(node.getEdges());
                var childCount = neighborEdges.length;
                if (parentOfNode != null) childCount--;
                var branchCount = 0;
                var incEdgesCount = neighborEdges.length;
                var startIndex;
                var edges = node.getEdgesBetween(parentOfNode);
                // If there are multiple edges, prune them until there remains only one
                // edge.
                while(edges.length > 1){
                    //neighborEdges.remove(edges.remove(0));
                    var temp = edges[0];
                    edges.splice(0, 1);
                    var index = neighborEdges.indexOf(temp);
                    if (index >= 0) neighborEdges.splice(index, 1);
                    incEdgesCount--;
                    childCount--;
                }
                if (parentOfNode != null) //assert edges.length == 1;
                startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;
                else startIndex = 0;
                var stepAngle = Math.abs(endAngle - startAngle) / childCount;
                for(var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount){
                    var currentNeighbor = neighborEdges[i].getOtherEnd(node);
                    // Don't back traverse to root node in current tree.
                    if (currentNeighbor == parentOfNode) continue;
                    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;
                    var childEndAngle = (childStartAngle + stepAngle) % 360;
                    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);
                    branchCount++;
                }
            };
            CoSELayout.maxDiagonalInTree = function(tree) {
                var maxDiagonal = Integer.MIN_VALUE;
                for(var i = 0; i < tree.length; i++){
                    var node = tree[i];
                    var diagonal = node.getDiagonal();
                    if (diagonal > maxDiagonal) maxDiagonal = diagonal;
                }
                return maxDiagonal;
            };
            CoSELayout.prototype.calcRepulsionRange = function() {
                // formula is 2 x (level + 1) x idealEdgeLength
                return 2 * (this.level + 1) * this.idealEdgeLength;
            };
            // Tiling methods
            // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's
            CoSELayout.prototype.groupZeroDegreeMembers = function() {
                var self = this;
                // array of [parent_id x oneDegreeNode_id]
                var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members
                this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled
                this.idToDummyNode = {}; // A map of id to dummy node 
                var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled
                var allNodes = this.graphManager.getAllNodes();
                // Fill zero degree list
                for(var i = 0; i < allNodes.length; i++){
                    var node = allNodes[i];
                    var parent = node.getParent();
                    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list
                    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) zeroDegree.push(node);
                }
                // Create a map of parent node and its zero degree members
                for(var i = 0; i < zeroDegree.length; i++){
                    var node = zeroDegree[i]; // Zero degree node itself
                    var p_id = node.getParent().id; // Parent id
                    if (typeof tempMemberGroups[p_id] === "undefined") tempMemberGroups[p_id] = [];
                    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups
                }
                // If there are at least two nodes at a level, create a dummy compound for them
                Object.keys(tempMemberGroups).forEach(function(p_id) {
                    if (tempMemberGroups[p_id].length > 1) {
                        var dummyCompoundId = "DummyCompound_" + p_id; // The id of dummy compound which will be created soon
                        self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups
                        var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound
                        // Create a dummy compound with calculated id
                        var dummyCompound = new CoSENode(self.graphManager);
                        dummyCompound.id = dummyCompoundId;
                        dummyCompound.paddingLeft = parent.paddingLeft || 0;
                        dummyCompound.paddingRight = parent.paddingRight || 0;
                        dummyCompound.paddingBottom = parent.paddingBottom || 0;
                        dummyCompound.paddingTop = parent.paddingTop || 0;
                        self.idToDummyNode[dummyCompoundId] = dummyCompound;
                        var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);
                        var parentGraph = parent.getChild();
                        // Add dummy compound to parent the graph
                        parentGraph.add(dummyCompound);
                        // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent
                        for(var i = 0; i < tempMemberGroups[p_id].length; i++){
                            var node = tempMemberGroups[p_id][i];
                            parentGraph.remove(node);
                            dummyParentGraph.add(node);
                        }
                    }
                });
            };
            CoSELayout.prototype.clearCompounds = function() {
                var childGraphMap = {};
                var idToNode = {};
                // Get compound ordering by finding the inner one first
                this.performDFSOnCompounds();
                for(var i = 0; i < this.compoundOrder.length; i++){
                    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];
                    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());
                    // Remove children of compounds
                    this.graphManager.remove(this.compoundOrder[i].getChild());
                    this.compoundOrder[i].child = null;
                }
                this.graphManager.resetAllNodes();
                // Tile the removed children
                this.tileCompoundMembers(childGraphMap, idToNode);
            };
            CoSELayout.prototype.clearZeroDegreeMembers = function() {
                var self = this;
                var tiledZeroDegreePack = this.tiledZeroDegreePack = [];
                Object.keys(this.memberGroups).forEach(function(id) {
                    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound
                    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);
                    // Set the width and height of the dummy compound as calculated
                    compoundNode.rect.width = tiledZeroDegreePack[id].width;
                    compoundNode.rect.height = tiledZeroDegreePack[id].height;
                    compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);
                    // compound left and top margings for labels
                    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,
                    // otherwise they stay as zero
                    compoundNode.labelMarginLeft = 0;
                    compoundNode.labelMarginTop = 0;
                    // Update compound bounds considering its label properties and set label margins for left and top
                    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {
                        var width = compoundNode.rect.width;
                        var height = compoundNode.rect.height;
                        if (compoundNode.labelWidth) {
                            if (compoundNode.labelPosHorizontal == "left") {
                                compoundNode.rect.x -= compoundNode.labelWidth;
                                compoundNode.setWidth(width + compoundNode.labelWidth);
                                compoundNode.labelMarginLeft = compoundNode.labelWidth;
                            } else if (compoundNode.labelPosHorizontal == "center" && compoundNode.labelWidth > width) {
                                compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;
                                compoundNode.setWidth(compoundNode.labelWidth);
                                compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;
                            } else if (compoundNode.labelPosHorizontal == "right") compoundNode.setWidth(width + compoundNode.labelWidth);
                        }
                        if (compoundNode.labelHeight) {
                            if (compoundNode.labelPosVertical == "top") {
                                compoundNode.rect.y -= compoundNode.labelHeight;
                                compoundNode.setHeight(height + compoundNode.labelHeight);
                                compoundNode.labelMarginTop = compoundNode.labelHeight;
                            } else if (compoundNode.labelPosVertical == "center" && compoundNode.labelHeight > height) {
                                compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;
                                compoundNode.setHeight(compoundNode.labelHeight);
                                compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;
                            } else if (compoundNode.labelPosVertical == "bottom") compoundNode.setHeight(height + compoundNode.labelHeight);
                        }
                    }
                });
            };
            CoSELayout.prototype.repopulateCompounds = function() {
                for(var i = this.compoundOrder.length - 1; i >= 0; i--){
                    var lCompoundNode = this.compoundOrder[i];
                    var id = lCompoundNode.id;
                    var horizontalMargin = lCompoundNode.paddingLeft;
                    var verticalMargin = lCompoundNode.paddingTop;
                    var labelMarginLeft = lCompoundNode.labelMarginLeft;
                    var labelMarginTop = lCompoundNode.labelMarginTop;
                    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);
                }
            };
            CoSELayout.prototype.repopulateZeroDegreeMembers = function() {
                var self = this;
                var tiledPack = this.tiledZeroDegreePack;
                Object.keys(tiledPack).forEach(function(id) {
                    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id
                    var horizontalMargin = compoundNode.paddingLeft;
                    var verticalMargin = compoundNode.paddingTop;
                    var labelMarginLeft = compoundNode.labelMarginLeft;
                    var labelMarginTop = compoundNode.labelMarginTop;
                    // Adjust the positions of nodes wrt its compound
                    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);
                });
            };
            CoSELayout.prototype.getToBeTiled = function(node) {
                var id = node.id;
                //firstly check the previous results
                if (this.toBeTiled[id] != null) return this.toBeTiled[id];
                //only compound nodes are to be tiled
                var childGraph = node.getChild();
                if (childGraph == null) {
                    this.toBeTiled[id] = false;
                    return false;
                }
                var children = childGraph.getNodes(); // Get the children nodes
                //a compound node is not to be tiled if all of its compound children are not to be tiled
                for(var i = 0; i < children.length; i++){
                    var theChild = children[i];
                    if (this.getNodeDegree(theChild) > 0) {
                        this.toBeTiled[id] = false;
                        return false;
                    }
                    //pass the children not having the compound structure
                    if (theChild.getChild() == null) {
                        this.toBeTiled[theChild.id] = false;
                        continue;
                    }
                    if (!this.getToBeTiled(theChild)) {
                        this.toBeTiled[id] = false;
                        return false;
                    }
                }
                this.toBeTiled[id] = true;
                return true;
            };
            // Get degree of a node depending of its edges and independent of its children
            CoSELayout.prototype.getNodeDegree = function(node) {
                var id = node.id;
                var edges = node.getEdges();
                var degree = 0;
                // For the edges connected
                for(var i = 0; i < edges.length; i++){
                    var edge = edges[i];
                    if (edge.getSource().id !== edge.getTarget().id) degree = degree + 1;
                }
                return degree;
            };
            // Get degree of a node with its children
            CoSELayout.prototype.getNodeDegreeWithChildren = function(node) {
                var degree = this.getNodeDegree(node);
                if (node.getChild() == null) return degree;
                var children = node.getChild().getNodes();
                for(var i = 0; i < children.length; i++){
                    var child = children[i];
                    degree += this.getNodeDegreeWithChildren(child);
                }
                return degree;
            };
            CoSELayout.prototype.performDFSOnCompounds = function() {
                this.compoundOrder = [];
                this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());
            };
            CoSELayout.prototype.fillCompexOrderByDFS = function(children) {
                for(var i = 0; i < children.length; i++){
                    var child = children[i];
                    if (child.getChild() != null) this.fillCompexOrderByDFS(child.getChild().getNodes());
                    if (this.getToBeTiled(child)) this.compoundOrder.push(child);
                }
            };
            /**
* This method places each zero degree member wrt given (x,y) coordinates (top left).
*/ CoSELayout.prototype.adjustLocations = function(organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {
                x += compoundHorizontalMargin + compoundLabelMarginLeft;
                y += compoundVerticalMargin + compoundLabelMarginTop;
                var left = x;
                for(var i = 0; i < organization.rows.length; i++){
                    var row = organization.rows[i];
                    x = left;
                    var maxHeight = 0;
                    for(var j = 0; j < row.length; j++){
                        var lnode = row[j];
                        lnode.rect.x = x; // + lnode.rect.width / 2;
                        lnode.rect.y = y; // + lnode.rect.height / 2;
                        x += lnode.rect.width + organization.horizontalPadding;
                        if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;
                    }
                    y += maxHeight + organization.verticalPadding;
                }
            };
            CoSELayout.prototype.tileCompoundMembers = function(childGraphMap, idToNode) {
                var self = this;
                this.tiledMemberPack = [];
                Object.keys(childGraphMap).forEach(function(id) {
                    // Get the compound node
                    var compoundNode = idToNode[id];
                    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);
                    compoundNode.rect.width = self.tiledMemberPack[id].width;
                    compoundNode.rect.height = self.tiledMemberPack[id].height;
                    compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);
                    // compound left and top margings for labels
                    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,
                    // otherwise they stay as zero
                    compoundNode.labelMarginLeft = 0;
                    compoundNode.labelMarginTop = 0;
                    // Update compound bounds considering its label properties and set label margins for left and top
                    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {
                        var width = compoundNode.rect.width;
                        var height = compoundNode.rect.height;
                        if (compoundNode.labelWidth) {
                            if (compoundNode.labelPosHorizontal == "left") {
                                compoundNode.rect.x -= compoundNode.labelWidth;
                                compoundNode.setWidth(width + compoundNode.labelWidth);
                                compoundNode.labelMarginLeft = compoundNode.labelWidth;
                            } else if (compoundNode.labelPosHorizontal == "center" && compoundNode.labelWidth > width) {
                                compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;
                                compoundNode.setWidth(compoundNode.labelWidth);
                                compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;
                            } else if (compoundNode.labelPosHorizontal == "right") compoundNode.setWidth(width + compoundNode.labelWidth);
                        }
                        if (compoundNode.labelHeight) {
                            if (compoundNode.labelPosVertical == "top") {
                                compoundNode.rect.y -= compoundNode.labelHeight;
                                compoundNode.setHeight(height + compoundNode.labelHeight);
                                compoundNode.labelMarginTop = compoundNode.labelHeight;
                            } else if (compoundNode.labelPosVertical == "center" && compoundNode.labelHeight > height) {
                                compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;
                                compoundNode.setHeight(compoundNode.labelHeight);
                                compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;
                            } else if (compoundNode.labelPosVertical == "bottom") compoundNode.setHeight(height + compoundNode.labelHeight);
                        }
                    }
                });
            };
            CoSELayout.prototype.tileNodes = function(nodes, minWidth) {
                var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;
                var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;
                var organization = {
                    rows: [],
                    rowWidth: [],
                    rowHeight: [],
                    width: 0,
                    height: minWidth,
                    verticalPadding: verticalPadding,
                    horizontalPadding: horizontalPadding,
                    centerX: 0,
                    centerY: 0
                };
                // Sort the nodes in ascending order of their areas
                nodes.sort(function(n1, n2) {
                    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;
                    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;
                    return 0;
                });
                // Create the organization -> calculate compound center
                var sumCenterX = 0;
                var sumCenterY = 0;
                for(var i = 0; i < nodes.length; i++){
                    var lNode = nodes[i];
                    sumCenterX += lNode.getCenterX();
                    sumCenterY += lNode.getCenterY();
                }
                organization.centerX = sumCenterX / nodes.length;
                organization.centerY = sumCenterY / nodes.length;
                // Create the organization -> tile members
                for(var i = 0; i < nodes.length; i++){
                    var lNode = nodes[i];
                    if (organization.rows.length == 0) this.insertNodeToRow(organization, lNode, 0, minWidth);
                    else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);
                    else this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);
                    this.shiftToLastRow(organization);
                }
                return organization;
            };
            CoSELayout.prototype.insertNodeToRow = function(organization, node, rowIndex, minWidth) {
                var minCompoundSize = minWidth;
                // Add new row if needed
                if (rowIndex == organization.rows.length) {
                    var secondDimension = [];
                    organization.rows.push(secondDimension);
                    organization.rowWidth.push(minCompoundSize);
                    organization.rowHeight.push(0);
                }
                // Update row width
                var w = organization.rowWidth[rowIndex] + node.rect.width;
                if (organization.rows[rowIndex].length > 0) w += organization.horizontalPadding;
                organization.rowWidth[rowIndex] = w;
                // Update compound width
                if (organization.width < w) organization.width = w;
                // Update height
                var h = node.rect.height;
                if (rowIndex > 0) h += organization.verticalPadding;
                var extraHeight = 0;
                if (h > organization.rowHeight[rowIndex]) {
                    extraHeight = organization.rowHeight[rowIndex];
                    organization.rowHeight[rowIndex] = h;
                    extraHeight = organization.rowHeight[rowIndex] - extraHeight;
                }
                organization.height += extraHeight;
                // Insert node
                organization.rows[rowIndex].push(node);
            };
            //Scans the rows of an organization and returns the one with the min width
            CoSELayout.prototype.getShortestRowIndex = function(organization) {
                var r = -1;
                var min = Number.MAX_VALUE;
                for(var i = 0; i < organization.rows.length; i++)if (organization.rowWidth[i] < min) {
                    r = i;
                    min = organization.rowWidth[i];
                }
                return r;
            };
            //Scans the rows of an organization and returns the one with the max width
            CoSELayout.prototype.getLongestRowIndex = function(organization) {
                var r = -1;
                var max = Number.MIN_VALUE;
                for(var i = 0; i < organization.rows.length; i++)if (organization.rowWidth[i] > max) {
                    r = i;
                    max = organization.rowWidth[i];
                }
                return r;
            };
            /**
* This method checks whether adding extra width to the organization violates
* the aspect ratio(1) or not.
*/ CoSELayout.prototype.canAddHorizontal = function(organization, extraWidth, extraHeight) {
                var sri = this.getShortestRowIndex(organization);
                if (sri < 0) return true;
                var min = organization.rowWidth[sri];
                if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;
                var hDiff = 0;
                // Adding to an existing row
                if (organization.rowHeight[sri] < extraHeight) {
                    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];
                }
                var add_to_row_ratio;
                if (organization.width - min >= extraWidth + organization.horizontalPadding) add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);
                else add_to_row_ratio = (organization.height + hDiff) / organization.width;
                // Adding a new row for this node
                hDiff = extraHeight + organization.verticalPadding;
                var add_new_row_ratio;
                if (organization.width < extraWidth) add_new_row_ratio = (organization.height + hDiff) / extraWidth;
                else add_new_row_ratio = (organization.height + hDiff) / organization.width;
                if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;
                if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;
                return add_to_row_ratio < add_new_row_ratio;
            };
            //If moving the last node from the longest row and adding it to the last
            //row makes the bounding box smaller, do it.
            CoSELayout.prototype.shiftToLastRow = function(organization) {
                var longest = this.getLongestRowIndex(organization);
                var last = organization.rowWidth.length - 1;
                var row = organization.rows[longest];
                var node = row[row.length - 1];
                var diff = node.width + organization.horizontalPadding;
                // Check if there is enough space on the last row
                if (organization.width - organization.rowWidth[last] > diff && longest != last) {
                    // Remove the last element of the longest row
                    row.splice(-1, 1);
                    // Push it to the last row
                    organization.rows[last].push(node);
                    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;
                    organization.rowWidth[last] = organization.rowWidth[last] + diff;
                    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];
                    // Update heights of the organization
                    var maxHeight = Number.MIN_VALUE;
                    for(var i = 0; i < row.length; i++)if (row[i].height > maxHeight) maxHeight = row[i].height;
                    if (longest > 0) maxHeight += organization.verticalPadding;
                    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];
                    organization.rowHeight[longest] = maxHeight;
                    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;
                    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];
                    organization.height += finalTotal - prevTotal;
                    this.shiftToLastRow(organization);
                }
            };
            CoSELayout.prototype.tilingPreLayout = function() {
                if (CoSEConstants.TILE) {
                    // Find zero degree nodes and create a compound for each level
                    this.groupZeroDegreeMembers();
                    // Tile and clear children of each compound
                    this.clearCompounds();
                    // Separately tile and clear zero degree nodes for each level
                    this.clearZeroDegreeMembers();
                }
            };
            CoSELayout.prototype.tilingPostLayout = function() {
                if (CoSEConstants.TILE) {
                    this.repopulateZeroDegreeMembers();
                    this.repopulateCompounds();
                }
            };
            // -----------------------------------------------------------------------------
            // Section: Tree Reduction methods
            // -----------------------------------------------------------------------------
            // Reduce trees 
            CoSELayout.prototype.reduceTrees = function() {
                var prunedNodesAll = [];
                var containsLeaf = true;
                var node;
                while(containsLeaf){
                    var allNodes = this.graphManager.getAllNodes();
                    var prunedNodesInStepTemp = [];
                    containsLeaf = false;
                    for(var i = 0; i < allNodes.length; i++){
                        node = allNodes[i];
                        if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {
                            if (CoSEConstants.PURE_INCREMENTAL) {
                                var otherEnd = node.getEdges()[0].getOtherEnd(node);
                                var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());
                                prunedNodesInStepTemp.push([
                                    node,
                                    node.getEdges()[0],
                                    node.getOwner(),
                                    relativePosition
                                ]);
                            } else prunedNodesInStepTemp.push([
                                node,
                                node.getEdges()[0],
                                node.getOwner()
                            ]);
                            containsLeaf = true;
                        }
                    }
                    if (containsLeaf == true) {
                        var prunedNodesInStep = [];
                        for(var j = 0; j < prunedNodesInStepTemp.length; j++)if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {
                            prunedNodesInStep.push(prunedNodesInStepTemp[j]);
                            prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);
                        }
                        prunedNodesAll.push(prunedNodesInStep);
                        this.graphManager.resetAllNodes();
                        this.graphManager.resetAllEdges();
                    }
                }
                this.prunedNodesAll = prunedNodesAll;
            };
            // Grow tree one step 
            CoSELayout.prototype.growTree = function(prunedNodesAll) {
                var lengthOfPrunedNodesInStep = prunedNodesAll.length;
                var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];
                var nodeData;
                for(var i = 0; i < prunedNodesInStep.length; i++){
                    nodeData = prunedNodesInStep[i];
                    this.findPlaceforPrunedNode(nodeData);
                    nodeData[2].add(nodeData[0]);
                    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);
                }
                prunedNodesAll.splice(prunedNodesAll.length - 1, 1);
                this.graphManager.resetAllNodes();
                this.graphManager.resetAllEdges();
            };
            // Find an appropriate position to replace pruned node, this method can be improved
            CoSELayout.prototype.findPlaceforPrunedNode = function(nodeData) {
                var gridForPrunedNode;
                var nodeToConnect;
                var prunedNode = nodeData[0];
                if (prunedNode == nodeData[1].source) nodeToConnect = nodeData[1].target;
                else nodeToConnect = nodeData[1].source;
                if (CoSEConstants.PURE_INCREMENTAL) prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());
                else {
                    var startGridX = nodeToConnect.startX;
                    var finishGridX = nodeToConnect.finishX;
                    var startGridY = nodeToConnect.startY;
                    var finishGridY = nodeToConnect.finishY;
                    var upNodeCount = 0;
                    var downNodeCount = 0;
                    var rightNodeCount = 0;
                    var leftNodeCount = 0;
                    var controlRegions = [
                        upNodeCount,
                        rightNodeCount,
                        downNodeCount,
                        leftNodeCount
                    ];
                    if (startGridY > 0) for(var i = startGridX; i <= finishGridX; i++)controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;
                    if (finishGridX < this.grid.length - 1) for(var i = startGridY; i <= finishGridY; i++)controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;
                    if (finishGridY < this.grid[0].length - 1) for(var i = startGridX; i <= finishGridX; i++)controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;
                    if (startGridX > 0) for(var i = startGridY; i <= finishGridY; i++)controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;
                    var min = Integer.MAX_VALUE;
                    var minCount;
                    var minIndex;
                    for(var j = 0; j < controlRegions.length; j++){
                        if (controlRegions[j] < min) {
                            min = controlRegions[j];
                            minCount = 1;
                            minIndex = j;
                        } else if (controlRegions[j] == min) minCount++;
                    }
                    if (minCount == 3 && min == 0) {
                        if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) gridForPrunedNode = 1;
                        else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) gridForPrunedNode = 0;
                        else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) gridForPrunedNode = 3;
                        else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) gridForPrunedNode = 2;
                    } else if (minCount == 2 && min == 0) {
                        var random = Math.floor(Math.random() * 2);
                        if (controlRegions[0] == 0 && controlRegions[1] == 0) {
                            if (random == 0) gridForPrunedNode = 0;
                            else gridForPrunedNode = 1;
                        } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {
                            if (random == 0) gridForPrunedNode = 0;
                            else gridForPrunedNode = 2;
                        } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {
                            if (random == 0) gridForPrunedNode = 0;
                            else gridForPrunedNode = 3;
                        } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {
                            if (random == 0) gridForPrunedNode = 1;
                            else gridForPrunedNode = 2;
                        } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {
                            if (random == 0) gridForPrunedNode = 1;
                            else gridForPrunedNode = 3;
                        } else if (random == 0) gridForPrunedNode = 2;
                        else gridForPrunedNode = 3;
                    } else if (minCount == 4 && min == 0) {
                        var random = Math.floor(Math.random() * 4);
                        gridForPrunedNode = random;
                    } else gridForPrunedNode = minIndex;
                    if (gridForPrunedNode == 0) prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);
                    else if (gridForPrunedNode == 1) prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());
                    else if (gridForPrunedNode == 2) prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);
                    else prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());
                }
            };
            module1.exports = CoSELayout;
        /***/ },
        /* 8 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var coseBase = {};
            coseBase.layoutBase = __webpack_require__(0);
            coseBase.CoSEConstants = __webpack_require__(1);
            coseBase.CoSEEdge = __webpack_require__(2);
            coseBase.CoSEGraph = __webpack_require__(3);
            coseBase.CoSEGraphManager = __webpack_require__(4);
            coseBase.CoSELayout = __webpack_require__(7);
            coseBase.CoSENode = __webpack_require__(5);
            coseBase.ConstraintHandler = __webpack_require__(6);
            module1.exports = coseBase;
        /***/ }
    ]);
});

},{"layout-base":"9RdbU"}],"9RdbU":[function(require,module,exports) {
(function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory();
})(this, function() {
    return /******/ function(modules) {
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/ /******/ // The require function
        /******/ function __webpack_require__(moduleId) {
            /******/ /******/ // Check if module is in cache
            /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: false,
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __webpack_require__);
            /******/ /******/ // Flag the module as loaded
            /******/ module1.l = true;
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)
        /******/ __webpack_require__.m = modules;
        /******/ /******/ // expose the module cache
        /******/ __webpack_require__.c = installedModules;
        /******/ /******/ // identity function for calling harmony imports with the correct context
        /******/ __webpack_require__.i = function(value) {
            return value;
        };
        /******/ /******/ // define getter function for harmony exports
        /******/ __webpack_require__.d = function(exports, name, getter) {
            /******/ if (!__webpack_require__.o(exports, name)) /******/ Object.defineProperty(exports, name, {
                /******/ configurable: false,
                /******/ enumerable: true,
                /******/ get: getter
            });
        /******/ };
        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = function(module1) {
            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {
                return module1["default"];
            } : /******/ function getModuleExports() {
                return module1;
            };
            /******/ __webpack_require__.d(getter, "a", getter);
            /******/ return getter;
        /******/ };
        /******/ /******/ // Object.prototype.hasOwnProperty.call
        /******/ __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/ /******/ // __webpack_public_path__
        /******/ __webpack_require__.p = "";
        /******/ /******/ // Load entry module and return exports
        /******/ return __webpack_require__(__webpack_require__.s = 28);
    /******/ }([
        /* 0 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function LayoutConstants() {}
            /**
 * Layout Quality: 0:draft, 1:default, 2:proof
 */ LayoutConstants.QUALITY = 1;
            /**
 * Default parameters
 */ LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;
            LayoutConstants.DEFAULT_INCREMENTAL = false;
            LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;
            LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;
            LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;
            LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;
            // -----------------------------------------------------------------------------
            // Section: General other constants
            // -----------------------------------------------------------------------------
            /*
 * Margins of a graph to be applied on bouding rectangle of its contents. We
 * assume margins on all four sides to be uniform.
 */ LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;
            /*
 * Whether to consider labels in node dimensions or not
 */ LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;
            /*
 * Default dimension of a non-compound node.
 */ LayoutConstants.SIMPLE_NODE_SIZE = 40;
            /*
 * Default dimension of a non-compound node.
 */ LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;
            /*
 * Empty compound node size. When a compound node is empty, its both
 * dimensions should be of this value.
 */ LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;
            /*
 * Minimum length that an edge should take during layout
 */ LayoutConstants.MIN_EDGE_LENGTH = 1;
            /*
 * World boundaries that layout operates on
 */ LayoutConstants.WORLD_BOUNDARY = 1000000;
            /*
 * World boundaries that random positioning can be performed with
 */ LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;
            /*
 * Coordinates of the world center
 */ LayoutConstants.WORLD_CENTER_X = 1200;
            LayoutConstants.WORLD_CENTER_Y = 900;
            module1.exports = LayoutConstants;
        /***/ },
        /* 1 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var LGraphObject = __webpack_require__(2);
            var IGeometry = __webpack_require__(8);
            var IMath = __webpack_require__(9);
            function LEdge(source, target, vEdge) {
                LGraphObject.call(this, vEdge);
                this.isOverlapingSourceAndTarget = false;
                this.vGraphObject = vEdge;
                this.bendpoints = [];
                this.source = source;
                this.target = target;
            }
            LEdge.prototype = Object.create(LGraphObject.prototype);
            for(var prop in LGraphObject)LEdge[prop] = LGraphObject[prop];
            LEdge.prototype.getSource = function() {
                return this.source;
            };
            LEdge.prototype.getTarget = function() {
                return this.target;
            };
            LEdge.prototype.isInterGraph = function() {
                return this.isInterGraph;
            };
            LEdge.prototype.getLength = function() {
                return this.length;
            };
            LEdge.prototype.isOverlapingSourceAndTarget = function() {
                return this.isOverlapingSourceAndTarget;
            };
            LEdge.prototype.getBendpoints = function() {
                return this.bendpoints;
            };
            LEdge.prototype.getLca = function() {
                return this.lca;
            };
            LEdge.prototype.getSourceInLca = function() {
                return this.sourceInLca;
            };
            LEdge.prototype.getTargetInLca = function() {
                return this.targetInLca;
            };
            LEdge.prototype.getOtherEnd = function(node) {
                if (this.source === node) return this.target;
                else if (this.target === node) return this.source;
                else throw "Node is not incident with this edge";
            };
            LEdge.prototype.getOtherEndInGraph = function(node, graph) {
                var otherEnd = this.getOtherEnd(node);
                var root = graph.getGraphManager().getRoot();
                while(true){
                    if (otherEnd.getOwner() == graph) return otherEnd;
                    if (otherEnd.getOwner() == root) break;
                    otherEnd = otherEnd.getOwner().getParent();
                }
                return null;
            };
            LEdge.prototype.updateLength = function() {
                var clipPointCoordinates = new Array(4);
                this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);
                if (!this.isOverlapingSourceAndTarget) {
                    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];
                    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];
                    if (Math.abs(this.lengthX) < 1.0) this.lengthX = IMath.sign(this.lengthX);
                    if (Math.abs(this.lengthY) < 1.0) this.lengthY = IMath.sign(this.lengthY);
                    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
                }
            };
            LEdge.prototype.updateLengthSimple = function() {
                this.lengthX = this.target.getCenterX() - this.source.getCenterX();
                this.lengthY = this.target.getCenterY() - this.source.getCenterY();
                if (Math.abs(this.lengthX) < 1.0) this.lengthX = IMath.sign(this.lengthX);
                if (Math.abs(this.lengthY) < 1.0) this.lengthY = IMath.sign(this.lengthY);
                this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
            };
            module1.exports = LEdge;
        /***/ },
        /* 2 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function LGraphObject(vGraphObject) {
                this.vGraphObject = vGraphObject;
            }
            module1.exports = LGraphObject;
        /***/ },
        /* 3 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var LGraphObject = __webpack_require__(2);
            var Integer = __webpack_require__(10);
            var RectangleD = __webpack_require__(13);
            var LayoutConstants = __webpack_require__(0);
            var RandomSeed = __webpack_require__(16);
            var PointD = __webpack_require__(5);
            function LNode(gm, loc, size, vNode) {
                //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)
                if (size == null && vNode == null) vNode = loc;
                LGraphObject.call(this, vNode);
                //Alternative constructor 2 : LNode(Layout layout, Object vNode)
                if (gm.graphManager != null) gm = gm.graphManager;
                this.estimatedSize = Integer.MIN_VALUE;
                this.inclusionTreeDepth = Integer.MAX_VALUE;
                this.vGraphObject = vNode;
                this.edges = [];
                this.graphManager = gm;
                if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);
                else this.rect = new RectangleD();
            }
            LNode.prototype = Object.create(LGraphObject.prototype);
            for(var prop in LGraphObject)LNode[prop] = LGraphObject[prop];
            LNode.prototype.getEdges = function() {
                return this.edges;
            };
            LNode.prototype.getChild = function() {
                return this.child;
            };
            LNode.prototype.getOwner = function() {
                //  if (this.owner != null) {
                //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {
                //      throw "assert failed";
                //    }
                //  }
                return this.owner;
            };
            LNode.prototype.getWidth = function() {
                return this.rect.width;
            };
            LNode.prototype.setWidth = function(width) {
                this.rect.width = width;
            };
            LNode.prototype.getHeight = function() {
                return this.rect.height;
            };
            LNode.prototype.setHeight = function(height) {
                this.rect.height = height;
            };
            LNode.prototype.getCenterX = function() {
                return this.rect.x + this.rect.width / 2;
            };
            LNode.prototype.getCenterY = function() {
                return this.rect.y + this.rect.height / 2;
            };
            LNode.prototype.getCenter = function() {
                return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);
            };
            LNode.prototype.getLocation = function() {
                return new PointD(this.rect.x, this.rect.y);
            };
            LNode.prototype.getRect = function() {
                return this.rect;
            };
            LNode.prototype.getDiagonal = function() {
                return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);
            };
            /**
 * This method returns half the diagonal length of this node.
 */ LNode.prototype.getHalfTheDiagonal = function() {
                return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;
            };
            LNode.prototype.setRect = function(upperLeft, dimension) {
                this.rect.x = upperLeft.x;
                this.rect.y = upperLeft.y;
                this.rect.width = dimension.width;
                this.rect.height = dimension.height;
            };
            LNode.prototype.setCenter = function(cx, cy) {
                this.rect.x = cx - this.rect.width / 2;
                this.rect.y = cy - this.rect.height / 2;
            };
            LNode.prototype.setLocation = function(x, y) {
                this.rect.x = x;
                this.rect.y = y;
            };
            LNode.prototype.moveBy = function(dx, dy) {
                this.rect.x += dx;
                this.rect.y += dy;
            };
            LNode.prototype.getEdgeListToNode = function(to) {
                var edgeList = [];
                var edge;
                var self = this;
                self.edges.forEach(function(edge) {
                    if (edge.target == to) {
                        if (edge.source != self) throw "Incorrect edge source!";
                        edgeList.push(edge);
                    }
                });
                return edgeList;
            };
            LNode.prototype.getEdgesBetween = function(other) {
                var edgeList = [];
                var edge;
                var self = this;
                self.edges.forEach(function(edge) {
                    if (!(edge.source == self || edge.target == self)) throw "Incorrect edge source and/or target";
                    if (edge.target == other || edge.source == other) edgeList.push(edge);
                });
                return edgeList;
            };
            LNode.prototype.getNeighborsList = function() {
                var neighbors = new Set();
                var self = this;
                self.edges.forEach(function(edge) {
                    if (edge.source == self) neighbors.add(edge.target);
                    else {
                        if (edge.target != self) throw "Incorrect incidency!";
                        neighbors.add(edge.source);
                    }
                });
                return neighbors;
            };
            LNode.prototype.withChildren = function() {
                var withNeighborsList = new Set();
                var childNode;
                var children;
                withNeighborsList.add(this);
                if (this.child != null) {
                    var nodes = this.child.getNodes();
                    for(var i = 0; i < nodes.length; i++){
                        childNode = nodes[i];
                        children = childNode.withChildren();
                        children.forEach(function(node) {
                            withNeighborsList.add(node);
                        });
                    }
                }
                return withNeighborsList;
            };
            LNode.prototype.getNoOfChildren = function() {
                var noOfChildren = 0;
                var childNode;
                if (this.child == null) noOfChildren = 1;
                else {
                    var nodes = this.child.getNodes();
                    for(var i = 0; i < nodes.length; i++){
                        childNode = nodes[i];
                        noOfChildren += childNode.getNoOfChildren();
                    }
                }
                if (noOfChildren == 0) noOfChildren = 1;
                return noOfChildren;
            };
            LNode.prototype.getEstimatedSize = function() {
                if (this.estimatedSize == Integer.MIN_VALUE) throw "assert failed";
                return this.estimatedSize;
            };
            LNode.prototype.calcEstimatedSize = function() {
                if (this.child == null) return this.estimatedSize = (this.rect.width + this.rect.height) / 2;
                else {
                    this.estimatedSize = this.child.calcEstimatedSize();
                    this.rect.width = this.estimatedSize;
                    this.rect.height = this.estimatedSize;
                    return this.estimatedSize;
                }
            };
            LNode.prototype.scatter = function() {
                var randomCenterX;
                var randomCenterY;
                var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;
                var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;
                randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;
                var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;
                var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;
                randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;
                this.rect.x = randomCenterX;
                this.rect.y = randomCenterY;
            };
            LNode.prototype.updateBounds = function() {
                if (this.getChild() == null) throw "assert failed";
                if (this.getChild().getNodes().length != 0) {
                    // wrap the children nodes by re-arranging the boundaries
                    var childGraph = this.getChild();
                    childGraph.updateBounds(true);
                    this.rect.x = childGraph.getLeft();
                    this.rect.y = childGraph.getTop();
                    this.setWidth(childGraph.getRight() - childGraph.getLeft());
                    this.setHeight(childGraph.getBottom() - childGraph.getTop());
                    // Update compound bounds considering its label properties    
                    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {
                        var width = childGraph.getRight() - childGraph.getLeft();
                        var height = childGraph.getBottom() - childGraph.getTop();
                        if (this.labelWidth) {
                            if (this.labelPosHorizontal == "left") {
                                this.rect.x -= this.labelWidth;
                                this.setWidth(width + this.labelWidth);
                            } else if (this.labelPosHorizontal == "center" && this.labelWidth > width) {
                                this.rect.x -= (this.labelWidth - width) / 2;
                                this.setWidth(this.labelWidth);
                            } else if (this.labelPosHorizontal == "right") this.setWidth(width + this.labelWidth);
                        }
                        if (this.labelHeight) {
                            if (this.labelPosVertical == "top") {
                                this.rect.y -= this.labelHeight;
                                this.setHeight(height + this.labelHeight);
                            } else if (this.labelPosVertical == "center" && this.labelHeight > height) {
                                this.rect.y -= (this.labelHeight - height) / 2;
                                this.setHeight(this.labelHeight);
                            } else if (this.labelPosVertical == "bottom") this.setHeight(height + this.labelHeight);
                        }
                    }
                }
            };
            LNode.prototype.getInclusionTreeDepth = function() {
                if (this.inclusionTreeDepth == Integer.MAX_VALUE) throw "assert failed";
                return this.inclusionTreeDepth;
            };
            LNode.prototype.transform = function(trans) {
                var left = this.rect.x;
                if (left > LayoutConstants.WORLD_BOUNDARY) left = LayoutConstants.WORLD_BOUNDARY;
                else if (left < -LayoutConstants.WORLD_BOUNDARY) left = -LayoutConstants.WORLD_BOUNDARY;
                var top = this.rect.y;
                if (top > LayoutConstants.WORLD_BOUNDARY) top = LayoutConstants.WORLD_BOUNDARY;
                else if (top < -LayoutConstants.WORLD_BOUNDARY) top = -LayoutConstants.WORLD_BOUNDARY;
                var leftTop = new PointD(left, top);
                var vLeftTop = trans.inverseTransformPoint(leftTop);
                this.setLocation(vLeftTop.x, vLeftTop.y);
            };
            LNode.prototype.getLeft = function() {
                return this.rect.x;
            };
            LNode.prototype.getRight = function() {
                return this.rect.x + this.rect.width;
            };
            LNode.prototype.getTop = function() {
                return this.rect.y;
            };
            LNode.prototype.getBottom = function() {
                return this.rect.y + this.rect.height;
            };
            LNode.prototype.getParent = function() {
                if (this.owner == null) return null;
                return this.owner.getParent();
            };
            module1.exports = LNode;
        /***/ },
        /* 4 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var LayoutConstants = __webpack_require__(0);
            function FDLayoutConstants() {}
            //FDLayoutConstants inherits static props in LayoutConstants
            for(var prop in LayoutConstants)FDLayoutConstants[prop] = LayoutConstants[prop];
            FDLayoutConstants.MAX_ITERATIONS = 2500;
            FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;
            FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;
            FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;
            FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;
            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;
            FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;
            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;
            FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;
            FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;
            FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;
            FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;
            FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;
            FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;
            FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;
            FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;
            FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;
            FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;
            FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;
            FDLayoutConstants.MIN_EDGE_LENGTH = 1;
            FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;
            module1.exports = FDLayoutConstants;
        /***/ },
        /* 5 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function PointD(x, y) {
                if (x == null && y == null) {
                    this.x = 0;
                    this.y = 0;
                } else {
                    this.x = x;
                    this.y = y;
                }
            }
            PointD.prototype.getX = function() {
                return this.x;
            };
            PointD.prototype.getY = function() {
                return this.y;
            };
            PointD.prototype.setX = function(x) {
                this.x = x;
            };
            PointD.prototype.setY = function(y) {
                this.y = y;
            };
            PointD.prototype.getDifference = function(pt) {
                return new DimensionD(this.x - pt.x, this.y - pt.y);
            };
            PointD.prototype.getCopy = function() {
                return new PointD(this.x, this.y);
            };
            PointD.prototype.translate = function(dim) {
                this.x += dim.width;
                this.y += dim.height;
                return this;
            };
            module1.exports = PointD;
        /***/ },
        /* 6 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var LGraphObject = __webpack_require__(2);
            var Integer = __webpack_require__(10);
            var LayoutConstants = __webpack_require__(0);
            var LGraphManager = __webpack_require__(7);
            var LNode = __webpack_require__(3);
            var LEdge = __webpack_require__(1);
            var RectangleD = __webpack_require__(13);
            var Point1 = __webpack_require__(12);
            var LinkedList = __webpack_require__(11);
            function LGraph(parent, obj2, vGraph) {
                LGraphObject.call(this, vGraph);
                this.estimatedSize = Integer.MIN_VALUE;
                this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;
                this.edges = [];
                this.nodes = [];
                this.isConnected = false;
                this.parent = parent;
                if (obj2 != null && obj2 instanceof LGraphManager) this.graphManager = obj2;
                else if (obj2 != null && obj2 instanceof Layout) this.graphManager = obj2.graphManager;
            }
            LGraph.prototype = Object.create(LGraphObject.prototype);
            for(var prop in LGraphObject)LGraph[prop] = LGraphObject[prop];
            LGraph.prototype.getNodes = function() {
                return this.nodes;
            };
            LGraph.prototype.getEdges = function() {
                return this.edges;
            };
            LGraph.prototype.getGraphManager = function() {
                return this.graphManager;
            };
            LGraph.prototype.getParent = function() {
                return this.parent;
            };
            LGraph.prototype.getLeft = function() {
                return this.left;
            };
            LGraph.prototype.getRight = function() {
                return this.right;
            };
            LGraph.prototype.getTop = function() {
                return this.top;
            };
            LGraph.prototype.getBottom = function() {
                return this.bottom;
            };
            LGraph.prototype.isConnected = function() {
                return this.isConnected;
            };
            LGraph.prototype.add = function(obj1, sourceNode, targetNode) {
                if (sourceNode == null && targetNode == null) {
                    var newNode = obj1;
                    if (this.graphManager == null) throw "Graph has no graph mgr!";
                    if (this.getNodes().indexOf(newNode) > -1) throw "Node already in graph!";
                    newNode.owner = this;
                    this.getNodes().push(newNode);
                    return newNode;
                } else {
                    var newEdge = obj1;
                    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) throw "Source or target not in graph!";
                    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) throw "Both owners must be this graph!";
                    if (sourceNode.owner != targetNode.owner) return null;
                    // set source and target
                    newEdge.source = sourceNode;
                    newEdge.target = targetNode;
                    // set as intra-graph edge
                    newEdge.isInterGraph = false;
                    // add to graph edge list
                    this.getEdges().push(newEdge);
                    // add to incidency lists
                    sourceNode.edges.push(newEdge);
                    if (targetNode != sourceNode) targetNode.edges.push(newEdge);
                    return newEdge;
                }
            };
            LGraph.prototype.remove = function(obj) {
                var node = obj;
                if (obj instanceof LNode) {
                    if (node == null) throw "Node is null!";
                    if (!(node.owner != null && node.owner == this)) throw "Owner graph is invalid!";
                    if (this.graphManager == null) throw "Owner graph manager is invalid!";
                    // remove incident edges first (make a copy to do it safely)
                    var edgesToBeRemoved = node.edges.slice();
                    var edge;
                    var s = edgesToBeRemoved.length;
                    for(var i = 0; i < s; i++){
                        edge = edgesToBeRemoved[i];
                        if (edge.isInterGraph) this.graphManager.remove(edge);
                        else edge.source.owner.remove(edge);
                    }
                    // now the node itself
                    var index = this.nodes.indexOf(node);
                    if (index == -1) throw "Node not in owner node list!";
                    this.nodes.splice(index, 1);
                } else if (obj instanceof LEdge) {
                    var edge = obj;
                    if (edge == null) throw "Edge is null!";
                    if (!(edge.source != null && edge.target != null)) throw "Source and/or target is null!";
                    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) throw "Source and/or target owner is invalid!";
                    var sourceIndex = edge.source.edges.indexOf(edge);
                    var targetIndex = edge.target.edges.indexOf(edge);
                    if (!(sourceIndex > -1 && targetIndex > -1)) throw "Source and/or target doesn't know this edge!";
                    edge.source.edges.splice(sourceIndex, 1);
                    if (edge.target != edge.source) edge.target.edges.splice(targetIndex, 1);
                    var index = edge.source.owner.getEdges().indexOf(edge);
                    if (index == -1) throw "Not in owner's edge list!";
                    edge.source.owner.getEdges().splice(index, 1);
                }
            };
            LGraph.prototype.updateLeftTop = function() {
                var top = Integer.MAX_VALUE;
                var left = Integer.MAX_VALUE;
                var nodeTop;
                var nodeLeft;
                var margin;
                var nodes = this.getNodes();
                var s = nodes.length;
                for(var i = 0; i < s; i++){
                    var lNode = nodes[i];
                    nodeTop = lNode.getTop();
                    nodeLeft = lNode.getLeft();
                    if (top > nodeTop) top = nodeTop;
                    if (left > nodeLeft) left = nodeLeft;
                }
                // Do we have any nodes in this graph?
                if (top == Integer.MAX_VALUE) return null;
                if (nodes[0].getParent().paddingLeft != undefined) margin = nodes[0].getParent().paddingLeft;
                else margin = this.margin;
                this.left = left - margin;
                this.top = top - margin;
                // Apply the margins and return the result
                return new Point1(this.left, this.top);
            };
            LGraph.prototype.updateBounds = function(recursive) {
                // calculate bounds
                var left = Integer.MAX_VALUE;
                var right = -Integer.MAX_VALUE;
                var top = Integer.MAX_VALUE;
                var bottom = -Integer.MAX_VALUE;
                var nodeLeft;
                var nodeRight;
                var nodeTop;
                var nodeBottom;
                var margin;
                var nodes = this.nodes;
                var s = nodes.length;
                for(var i = 0; i < s; i++){
                    var lNode = nodes[i];
                    if (recursive && lNode.child != null) lNode.updateBounds();
                    nodeLeft = lNode.getLeft();
                    nodeRight = lNode.getRight();
                    nodeTop = lNode.getTop();
                    nodeBottom = lNode.getBottom();
                    if (left > nodeLeft) left = nodeLeft;
                    if (right < nodeRight) right = nodeRight;
                    if (top > nodeTop) top = nodeTop;
                    if (bottom < nodeBottom) bottom = nodeBottom;
                }
                var boundingRect = new RectangleD(left, top, right - left, bottom - top);
                if (left == Integer.MAX_VALUE) {
                    this.left = this.parent.getLeft();
                    this.right = this.parent.getRight();
                    this.top = this.parent.getTop();
                    this.bottom = this.parent.getBottom();
                }
                if (nodes[0].getParent().paddingLeft != undefined) margin = nodes[0].getParent().paddingLeft;
                else margin = this.margin;
                this.left = boundingRect.x - margin;
                this.right = boundingRect.x + boundingRect.width + margin;
                this.top = boundingRect.y - margin;
                this.bottom = boundingRect.y + boundingRect.height + margin;
            };
            LGraph.calculateBounds = function(nodes) {
                var left = Integer.MAX_VALUE;
                var right = -Integer.MAX_VALUE;
                var top = Integer.MAX_VALUE;
                var bottom = -Integer.MAX_VALUE;
                var nodeLeft;
                var nodeRight;
                var nodeTop;
                var nodeBottom;
                var s = nodes.length;
                for(var i = 0; i < s; i++){
                    var lNode = nodes[i];
                    nodeLeft = lNode.getLeft();
                    nodeRight = lNode.getRight();
                    nodeTop = lNode.getTop();
                    nodeBottom = lNode.getBottom();
                    if (left > nodeLeft) left = nodeLeft;
                    if (right < nodeRight) right = nodeRight;
                    if (top > nodeTop) top = nodeTop;
                    if (bottom < nodeBottom) bottom = nodeBottom;
                }
                var boundingRect = new RectangleD(left, top, right - left, bottom - top);
                return boundingRect;
            };
            LGraph.prototype.getInclusionTreeDepth = function() {
                if (this == this.graphManager.getRoot()) return 1;
                else return this.parent.getInclusionTreeDepth();
            };
            LGraph.prototype.getEstimatedSize = function() {
                if (this.estimatedSize == Integer.MIN_VALUE) throw "assert failed";
                return this.estimatedSize;
            };
            LGraph.prototype.calcEstimatedSize = function() {
                var size = 0;
                var nodes = this.nodes;
                var s = nodes.length;
                for(var i = 0; i < s; i++){
                    var lNode = nodes[i];
                    size += lNode.calcEstimatedSize();
                }
                if (size == 0) this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;
                else this.estimatedSize = size / Math.sqrt(this.nodes.length);
                return this.estimatedSize;
            };
            LGraph.prototype.updateConnected = function() {
                var self = this;
                if (this.nodes.length == 0) {
                    this.isConnected = true;
                    return;
                }
                var queue = new LinkedList();
                var visited = new Set();
                var currentNode = this.nodes[0];
                var neighborEdges;
                var currentNeighbor;
                var childrenOfNode = currentNode.withChildren();
                childrenOfNode.forEach(function(node) {
                    queue.push(node);
                    visited.add(node);
                });
                while(queue.length !== 0){
                    currentNode = queue.shift();
                    // Traverse all neighbors of this node
                    neighborEdges = currentNode.getEdges();
                    var size = neighborEdges.length;
                    for(var i = 0; i < size; i++){
                        var neighborEdge = neighborEdges[i];
                        currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);
                        // Add unvisited neighbors to the list to visit
                        if (currentNeighbor != null && !visited.has(currentNeighbor)) {
                            var childrenOfNeighbor = currentNeighbor.withChildren();
                            childrenOfNeighbor.forEach(function(node) {
                                queue.push(node);
                                visited.add(node);
                            });
                        }
                    }
                }
                this.isConnected = false;
                if (visited.size >= this.nodes.length) {
                    var noOfVisitedInThisGraph = 0;
                    visited.forEach(function(visitedNode) {
                        if (visitedNode.owner == self) noOfVisitedInThisGraph++;
                    });
                    if (noOfVisitedInThisGraph == this.nodes.length) this.isConnected = true;
                }
            };
            module1.exports = LGraph;
        /***/ },
        /* 7 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var LGraph;
            var LEdge = __webpack_require__(1);
            function LGraphManager(layout) {
                LGraph = __webpack_require__(6); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.
                this.layout = layout;
                this.graphs = [];
                this.edges = [];
            }
            LGraphManager.prototype.addRoot = function() {
                var ngraph = this.layout.newGraph();
                var nnode = this.layout.newNode(null);
                var root = this.add(ngraph, nnode);
                this.setRootGraph(root);
                return this.rootGraph;
            };
            LGraphManager.prototype.add = function(newGraph, parentNode, newEdge, sourceNode, targetNode) {
                //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge
                if (newEdge == null && sourceNode == null && targetNode == null) {
                    if (newGraph == null) throw "Graph is null!";
                    if (parentNode == null) throw "Parent node is null!";
                    if (this.graphs.indexOf(newGraph) > -1) throw "Graph already in this graph mgr!";
                    this.graphs.push(newGraph);
                    if (newGraph.parent != null) throw "Already has a parent!";
                    if (parentNode.child != null) throw "Already has a child!";
                    newGraph.parent = parentNode;
                    parentNode.child = newGraph;
                    return newGraph;
                } else {
                    //change the order of the parameters
                    targetNode = newEdge;
                    sourceNode = parentNode;
                    newEdge = newGraph;
                    var sourceGraph = sourceNode.getOwner();
                    var targetGraph = targetNode.getOwner();
                    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) throw "Source not in this graph mgr!";
                    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) throw "Target not in this graph mgr!";
                    if (sourceGraph == targetGraph) {
                        newEdge.isInterGraph = false;
                        return sourceGraph.add(newEdge, sourceNode, targetNode);
                    } else {
                        newEdge.isInterGraph = true;
                        // set source and target
                        newEdge.source = sourceNode;
                        newEdge.target = targetNode;
                        // add edge to inter-graph edge list
                        if (this.edges.indexOf(newEdge) > -1) throw "Edge already in inter-graph edge list!";
                        this.edges.push(newEdge);
                        // add edge to source and target incidency lists
                        if (!(newEdge.source != null && newEdge.target != null)) throw "Edge source and/or target is null!";
                        if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) throw "Edge already in source and/or target incidency list!";
                        newEdge.source.edges.push(newEdge);
                        newEdge.target.edges.push(newEdge);
                        return newEdge;
                    }
                }
            };
            LGraphManager.prototype.remove = function(lObj) {
                if (lObj instanceof LGraph) {
                    var graph = lObj;
                    if (graph.getGraphManager() != this) throw "Graph not in this graph mgr";
                    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) throw "Invalid parent node!";
                    // first the edges (make a copy to do it safely)
                    var edgesToBeRemoved = [];
                    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());
                    var edge;
                    var s = edgesToBeRemoved.length;
                    for(var i = 0; i < s; i++){
                        edge = edgesToBeRemoved[i];
                        graph.remove(edge);
                    }
                    // then the nodes (make a copy to do it safely)
                    var nodesToBeRemoved = [];
                    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());
                    var node;
                    s = nodesToBeRemoved.length;
                    for(var i = 0; i < s; i++){
                        node = nodesToBeRemoved[i];
                        graph.remove(node);
                    }
                    // check if graph is the root
                    if (graph == this.rootGraph) this.setRootGraph(null);
                    // now remove the graph itself
                    var index = this.graphs.indexOf(graph);
                    this.graphs.splice(index, 1);
                    // also reset the parent of the graph
                    graph.parent = null;
                } else if (lObj instanceof LEdge) {
                    edge = lObj;
                    if (edge == null) throw "Edge is null!";
                    if (!edge.isInterGraph) throw "Not an inter-graph edge!";
                    if (!(edge.source != null && edge.target != null)) throw "Source and/or target is null!";
                    // remove edge from source and target nodes' incidency lists
                    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) throw "Source and/or target doesn't know this edge!";
                    var index = edge.source.edges.indexOf(edge);
                    edge.source.edges.splice(index, 1);
                    index = edge.target.edges.indexOf(edge);
                    edge.target.edges.splice(index, 1);
                    // remove edge from owner graph manager's inter-graph edge list
                    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) throw "Edge owner graph or owner graph manager is null!";
                    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) throw "Not in owner graph manager's edge list!";
                    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);
                    edge.source.owner.getGraphManager().edges.splice(index, 1);
                }
            };
            LGraphManager.prototype.updateBounds = function() {
                this.rootGraph.updateBounds(true);
            };
            LGraphManager.prototype.getGraphs = function() {
                return this.graphs;
            };
            LGraphManager.prototype.getAllNodes = function() {
                if (this.allNodes == null) {
                    var nodeList = [];
                    var graphs = this.getGraphs();
                    var s = graphs.length;
                    for(var i = 0; i < s; i++)nodeList = nodeList.concat(graphs[i].getNodes());
                    this.allNodes = nodeList;
                }
                return this.allNodes;
            };
            LGraphManager.prototype.resetAllNodes = function() {
                this.allNodes = null;
            };
            LGraphManager.prototype.resetAllEdges = function() {
                this.allEdges = null;
            };
            LGraphManager.prototype.resetAllNodesToApplyGravitation = function() {
                this.allNodesToApplyGravitation = null;
            };
            LGraphManager.prototype.getAllEdges = function() {
                if (this.allEdges == null) {
                    var edgeList = [];
                    var graphs = this.getGraphs();
                    var s = graphs.length;
                    for(var i = 0; i < graphs.length; i++)edgeList = edgeList.concat(graphs[i].getEdges());
                    edgeList = edgeList.concat(this.edges);
                    this.allEdges = edgeList;
                }
                return this.allEdges;
            };
            LGraphManager.prototype.getAllNodesToApplyGravitation = function() {
                return this.allNodesToApplyGravitation;
            };
            LGraphManager.prototype.setAllNodesToApplyGravitation = function(nodeList) {
                if (this.allNodesToApplyGravitation != null) throw "assert failed";
                this.allNodesToApplyGravitation = nodeList;
            };
            LGraphManager.prototype.getRoot = function() {
                return this.rootGraph;
            };
            LGraphManager.prototype.setRootGraph = function(graph) {
                if (graph.getGraphManager() != this) throw "Root not in this graph mgr!";
                this.rootGraph = graph;
                // root graph must have a root node associated with it for convenience
                if (graph.parent == null) graph.parent = this.layout.newNode("Root node");
            };
            LGraphManager.prototype.getLayout = function() {
                return this.layout;
            };
            LGraphManager.prototype.isOneAncestorOfOther = function(firstNode, secondNode) {
                if (!(firstNode != null && secondNode != null)) throw "assert failed";
                if (firstNode == secondNode) return true;
                // Is second node an ancestor of the first one?
                var ownerGraph = firstNode.getOwner();
                var parentNode;
                do {
                    parentNode = ownerGraph.getParent();
                    if (parentNode == null) break;
                    if (parentNode == secondNode) return true;
                    ownerGraph = parentNode.getOwner();
                    if (ownerGraph == null) break;
                }while (true);
                // Is first node an ancestor of the second one?
                ownerGraph = secondNode.getOwner();
                do {
                    parentNode = ownerGraph.getParent();
                    if (parentNode == null) break;
                    if (parentNode == firstNode) return true;
                    ownerGraph = parentNode.getOwner();
                    if (ownerGraph == null) break;
                }while (true);
                return false;
            };
            LGraphManager.prototype.calcLowestCommonAncestors = function() {
                var edge;
                var sourceNode;
                var targetNode;
                var sourceAncestorGraph;
                var targetAncestorGraph;
                var edges = this.getAllEdges();
                var s = edges.length;
                for(var i = 0; i < s; i++){
                    edge = edges[i];
                    sourceNode = edge.source;
                    targetNode = edge.target;
                    edge.lca = null;
                    edge.sourceInLca = sourceNode;
                    edge.targetInLca = targetNode;
                    if (sourceNode == targetNode) {
                        edge.lca = sourceNode.getOwner();
                        continue;
                    }
                    sourceAncestorGraph = sourceNode.getOwner();
                    while(edge.lca == null){
                        edge.targetInLca = targetNode;
                        targetAncestorGraph = targetNode.getOwner();
                        while(edge.lca == null){
                            if (targetAncestorGraph == sourceAncestorGraph) {
                                edge.lca = targetAncestorGraph;
                                break;
                            }
                            if (targetAncestorGraph == this.rootGraph) break;
                            if (edge.lca != null) throw "assert failed";
                            edge.targetInLca = targetAncestorGraph.getParent();
                            targetAncestorGraph = edge.targetInLca.getOwner();
                        }
                        if (sourceAncestorGraph == this.rootGraph) break;
                        if (edge.lca == null) {
                            edge.sourceInLca = sourceAncestorGraph.getParent();
                            sourceAncestorGraph = edge.sourceInLca.getOwner();
                        }
                    }
                    if (edge.lca == null) throw "assert failed";
                }
            };
            LGraphManager.prototype.calcLowestCommonAncestor = function(firstNode, secondNode) {
                if (firstNode == secondNode) return firstNode.getOwner();
                var firstOwnerGraph = firstNode.getOwner();
                do {
                    if (firstOwnerGraph == null) break;
                    var secondOwnerGraph = secondNode.getOwner();
                    do {
                        if (secondOwnerGraph == null) break;
                        if (secondOwnerGraph == firstOwnerGraph) return secondOwnerGraph;
                        secondOwnerGraph = secondOwnerGraph.getParent().getOwner();
                    }while (true);
                    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();
                }while (true);
                return firstOwnerGraph;
            };
            LGraphManager.prototype.calcInclusionTreeDepths = function(graph, depth) {
                if (graph == null && depth == null) {
                    graph = this.rootGraph;
                    depth = 1;
                }
                var node;
                var nodes = graph.getNodes();
                var s = nodes.length;
                for(var i = 0; i < s; i++){
                    node = nodes[i];
                    node.inclusionTreeDepth = depth;
                    if (node.child != null) this.calcInclusionTreeDepths(node.child, depth + 1);
                }
            };
            LGraphManager.prototype.includesInvalidEdge = function() {
                var edge;
                var edgesToRemove = [];
                var s = this.edges.length;
                for(var i = 0; i < s; i++){
                    edge = this.edges[i];
                    if (this.isOneAncestorOfOther(edge.source, edge.target)) edgesToRemove.push(edge);
                }
                // Remove invalid edges from graph manager
                for(var i = 0; i < edgesToRemove.length; i++)this.remove(edgesToRemove[i]);
                // Invalid edges are cleared, so return false
                return false;
            };
            module1.exports = LGraphManager;
        /***/ },
        /* 8 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            /**
 * This class maintains a list of static geometry related utility methods.
 *
 *
 * Copyright: i-Vis Research Group, Bilkent University, 2007 - present
 */ var Point1 = __webpack_require__(12);
            function IGeometry() {}
            /**
 * This method calculates *half* the amount in x and y directions of the two
 * input rectangles needed to separate them keeping their respective
 * positioning, and returns the result in the input array. An input
 * separation buffer added to the amount in both directions. We assume that
 * the two rectangles do intersect.
 */ IGeometry.calcSeparationAmount = function(rectA, rectB, overlapAmount, separationBuffer) {
                if (!rectA.intersects(rectB)) throw "assert failed";
                var directions = new Array(2);
                this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);
                overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);
                overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);
                // update the overlapping amounts for the following cases:
                if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) /* Case x.1:
    *
    * rectA
    * 	|                       |
    * 	|        _________      |
    * 	|        |       |      |
    * 	|________|_______|______|
    * 			 |       |
    *           |       |
    *        rectB
    */ overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());
                else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) /* Case x.2:
    *
    * rectB
    * 	|                       |
    * 	|        _________      |
    * 	|        |       |      |
    * 	|________|_______|______|
    * 			 |       |
    *           |       |
    *        rectA
    */ overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());
                if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) /* Case y.1:
     *          ________ rectA
     *         |
     *         |
     *   ______|____  rectB
     *         |    |
     *         |    |
     *   ______|____|
     *         |
     *         |
     *         |________
     *
     */ overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());
                else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) /* Case y.2:
    *          ________ rectB
    *         |
    *         |
    *   ______|____  rectA
    *         |    |
    *         |    |
    *   ______|____|
    *         |
    *         |
    *         |________
    *
    */ overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());
                // find slope of the line passes two centers
                var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));
                // if centers are overlapped
                if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) // assume the slope is 1 (45 degree)
                slope = 1.0;
                var moveByY = slope * overlapAmount[0];
                var moveByX = overlapAmount[1] / slope;
                if (overlapAmount[0] < moveByX) moveByX = overlapAmount[0];
                else moveByY = overlapAmount[1];
                // return half the amount so that if each rectangle is moved by these
                // amounts in opposite directions, overlap will be resolved
                overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);
                overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);
            };
            /**
 * This method decides the separation direction of overlapping nodes
 *
 * if directions[0] = -1, then rectA goes left
 * if directions[0] = 1,  then rectA goes right
 * if directions[1] = -1, then rectA goes up
 * if directions[1] = 1,  then rectA goes down
 */ IGeometry.decideDirectionsForOverlappingNodes = function(rectA, rectB, directions) {
                if (rectA.getCenterX() < rectB.getCenterX()) directions[0] = -1;
                else directions[0] = 1;
                if (rectA.getCenterY() < rectB.getCenterY()) directions[1] = -1;
                else directions[1] = 1;
            };
            /**
 * This method calculates the intersection (clipping) points of the two
 * input rectangles with line segment defined by the centers of these two
 * rectangles. The clipping points are saved in the input double array and
 * whether or not the two rectangles overlap is returned.
 */ IGeometry.getIntersection2 = function(rectA, rectB, result) {
                //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB
                var p1x = rectA.getCenterX();
                var p1y = rectA.getCenterY();
                var p2x = rectB.getCenterX();
                var p2y = rectB.getCenterY();
                //if two rectangles intersect, then clipping points are centers
                if (rectA.intersects(rectB)) {
                    result[0] = p1x;
                    result[1] = p1y;
                    result[2] = p2x;
                    result[3] = p2y;
                    return true;
                }
                //variables for rectA
                var topLeftAx = rectA.getX();
                var topLeftAy = rectA.getY();
                var topRightAx = rectA.getRight();
                var bottomLeftAx = rectA.getX();
                var bottomLeftAy = rectA.getBottom();
                var bottomRightAx = rectA.getRight();
                var halfWidthA = rectA.getWidthHalf();
                var halfHeightA = rectA.getHeightHalf();
                //variables for rectB
                var topLeftBx = rectB.getX();
                var topLeftBy = rectB.getY();
                var topRightBx = rectB.getRight();
                var bottomLeftBx = rectB.getX();
                var bottomLeftBy = rectB.getBottom();
                var bottomRightBx = rectB.getRight();
                var halfWidthB = rectB.getWidthHalf();
                var halfHeightB = rectB.getHeightHalf();
                //flag whether clipping points are found
                var clipPointAFound = false;
                var clipPointBFound = false;
                // line is vertical
                if (p1x === p2x) {
                    if (p1y > p2y) {
                        result[0] = p1x;
                        result[1] = topLeftAy;
                        result[2] = p2x;
                        result[3] = bottomLeftBy;
                        return false;
                    } else if (p1y < p2y) {
                        result[0] = p1x;
                        result[1] = bottomLeftAy;
                        result[2] = p2x;
                        result[3] = topLeftBy;
                        return false;
                    }
                } else if (p1y === p2y) {
                    if (p1x > p2x) {
                        result[0] = topLeftAx;
                        result[1] = p1y;
                        result[2] = topRightBx;
                        result[3] = p2y;
                        return false;
                    } else if (p1x < p2x) {
                        result[0] = topRightAx;
                        result[1] = p1y;
                        result[2] = topLeftBx;
                        result[3] = p2y;
                        return false;
                    }
                } else {
                    //slopes of rectA's and rectB's diagonals
                    var slopeA = rectA.height / rectA.width;
                    var slopeB = rectB.height / rectB.width;
                    //slope of line between center of rectA and center of rectB
                    var slopePrime = (p2y - p1y) / (p2x - p1x);
                    var cardinalDirectionA = void 0;
                    var cardinalDirectionB = void 0;
                    var tempPointAx = void 0;
                    var tempPointAy = void 0;
                    var tempPointBx = void 0;
                    var tempPointBy = void 0;
                    //determine whether clipping point is the corner of nodeA
                    if (-slopeA === slopePrime) {
                        if (p1x > p2x) {
                            result[0] = bottomLeftAx;
                            result[1] = bottomLeftAy;
                            clipPointAFound = true;
                        } else {
                            result[0] = topRightAx;
                            result[1] = topLeftAy;
                            clipPointAFound = true;
                        }
                    } else if (slopeA === slopePrime) {
                        if (p1x > p2x) {
                            result[0] = topLeftAx;
                            result[1] = topLeftAy;
                            clipPointAFound = true;
                        } else {
                            result[0] = bottomRightAx;
                            result[1] = bottomLeftAy;
                            clipPointAFound = true;
                        }
                    }
                    //determine whether clipping point is the corner of nodeB
                    if (-slopeB === slopePrime) {
                        if (p2x > p1x) {
                            result[2] = bottomLeftBx;
                            result[3] = bottomLeftBy;
                            clipPointBFound = true;
                        } else {
                            result[2] = topRightBx;
                            result[3] = topLeftBy;
                            clipPointBFound = true;
                        }
                    } else if (slopeB === slopePrime) {
                        if (p2x > p1x) {
                            result[2] = topLeftBx;
                            result[3] = topLeftBy;
                            clipPointBFound = true;
                        } else {
                            result[2] = bottomRightBx;
                            result[3] = bottomLeftBy;
                            clipPointBFound = true;
                        }
                    }
                    //if both clipping points are corners
                    if (clipPointAFound && clipPointBFound) return false;
                    //determine Cardinal Direction of rectangles
                    if (p1x > p2x) {
                        if (p1y > p2y) {
                            cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);
                            cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);
                        } else {
                            cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);
                            cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);
                        }
                    } else if (p1y > p2y) {
                        cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);
                        cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);
                    } else {
                        cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);
                        cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);
                    }
                    //calculate clipping Point if it is not found before
                    if (!clipPointAFound) switch(cardinalDirectionA){
                        case 1:
                            tempPointAy = topLeftAy;
                            tempPointAx = p1x + -halfHeightA / slopePrime;
                            result[0] = tempPointAx;
                            result[1] = tempPointAy;
                            break;
                        case 2:
                            tempPointAx = bottomRightAx;
                            tempPointAy = p1y + halfWidthA * slopePrime;
                            result[0] = tempPointAx;
                            result[1] = tempPointAy;
                            break;
                        case 3:
                            tempPointAy = bottomLeftAy;
                            tempPointAx = p1x + halfHeightA / slopePrime;
                            result[0] = tempPointAx;
                            result[1] = tempPointAy;
                            break;
                        case 4:
                            tempPointAx = bottomLeftAx;
                            tempPointAy = p1y + -halfWidthA * slopePrime;
                            result[0] = tempPointAx;
                            result[1] = tempPointAy;
                            break;
                    }
                    if (!clipPointBFound) switch(cardinalDirectionB){
                        case 1:
                            tempPointBy = topLeftBy;
                            tempPointBx = p2x + -halfHeightB / slopePrime;
                            result[2] = tempPointBx;
                            result[3] = tempPointBy;
                            break;
                        case 2:
                            tempPointBx = bottomRightBx;
                            tempPointBy = p2y + halfWidthB * slopePrime;
                            result[2] = tempPointBx;
                            result[3] = tempPointBy;
                            break;
                        case 3:
                            tempPointBy = bottomLeftBy;
                            tempPointBx = p2x + halfHeightB / slopePrime;
                            result[2] = tempPointBx;
                            result[3] = tempPointBy;
                            break;
                        case 4:
                            tempPointBx = bottomLeftBx;
                            tempPointBy = p2y + -halfWidthB * slopePrime;
                            result[2] = tempPointBx;
                            result[3] = tempPointBy;
                            break;
                    }
                }
                return false;
            };
            /**
 * This method returns in which cardinal direction does input point stays
 * 1: North
 * 2: East
 * 3: South
 * 4: West
 */ IGeometry.getCardinalDirection = function(slope, slopePrime, line) {
                if (slope > slopePrime) return line;
                else return 1 + line % 4;
            };
            /**
 * This method calculates the intersection of the two lines defined by
 * point pairs (s1,s2) and (f1,f2).
 */ IGeometry.getIntersection = function(s1, s2, f1, f2) {
                if (f2 == null) return this.getIntersection2(s1, s2, f1);
                var x1 = s1.x;
                var y1 = s1.y;
                var x2 = s2.x;
                var y2 = s2.y;
                var x3 = f1.x;
                var y3 = f1.y;
                var x4 = f2.x;
                var y4 = f2.y;
                var x = void 0, y = void 0; // intersection point
                var a1 = void 0, a2 = void 0, b1 = void 0, b2 = void 0, c1 = void 0, c2 = void 0; // coefficients of line eqns.
                var denom = void 0;
                a1 = y2 - y1;
                b1 = x1 - x2;
                c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }
                a2 = y4 - y3;
                b2 = x3 - x4;
                c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }
                denom = a1 * b2 - a2 * b1;
                if (denom === 0) return null;
                x = (b1 * c2 - b2 * c1) / denom;
                y = (a2 * c1 - a1 * c2) / denom;
                return new Point1(x, y);
            };
            /**
 * This method finds and returns the angle of the vector from the + x-axis
 * in clockwise direction (compatible w/ Java coordinate system!).
 */ IGeometry.angleOfVector = function(Cx, Cy, Nx, Ny) {
                var C_angle = void 0;
                if (Cx !== Nx) {
                    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));
                    if (Nx < Cx) C_angle += Math.PI;
                    else if (Ny < Cy) C_angle += this.TWO_PI;
                } else if (Ny < Cy) C_angle = this.ONE_AND_HALF_PI; // 270 degrees
                else C_angle = this.HALF_PI; // 90 degrees
                return C_angle;
            };
            /**
 * This method checks whether the given two line segments (one with point
 * p1 and p2, the other with point p3 and p4) intersect at a point other
 * than these points.
 */ IGeometry.doIntersect = function(p1, p2, p3, p4) {
                var a = p1.x;
                var b = p1.y;
                var c = p2.x;
                var d = p2.y;
                var p = p3.x;
                var q = p3.y;
                var r = p4.x;
                var s = p4.y;
                var det = (c - a) * (s - q) - (r - p) * (d - b);
                if (det === 0) return false;
                else {
                    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
                    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
                    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;
                }
            };
            /**
 * This method checks and calculates the intersection of 
 * a line segment and a circle.
 */ IGeometry.findCircleLineIntersections = function(Ex, Ey, Lx, Ly, Cx, Cy, r) {
                // E is the starting point of the ray,
                // L is the end point of the ray,
                // C is the center of sphere you're testing against
                // r is the radius of that sphere
                // Compute:
                // d = L - E ( Direction vector of ray, from start to end )
                // f = E - C ( Vector from center sphere to ray start )
                // Then the intersection is found by..
                // P = E + t * d
                // This is a parametric equation:
                // Px = Ex + tdx
                // Py = Ey + tdy
                // get a, b, c values
                var a = (Lx - Ex) * (Lx - Ex) + (Ly - Ey) * (Ly - Ey);
                var b = 2 * ((Ex - Cx) * (Lx - Ex) + (Ey - Cy) * (Ly - Ey));
                var c = (Ex - Cx) * (Ex - Cx) + (Ey - Cy) * (Ey - Cy) - r * r;
                // get discriminant
                var disc = b * b - 4 * a * c;
                if (disc >= 0) {
                    // insert into quadratic formula
                    var t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
                    var t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);
                    var intersections = null;
                    if (t1 >= 0 && t1 <= 1) // t1 is the intersection, and it's closer than t2
                    // (since t1 uses -b - discriminant)
                    // Impale, Poke
                    return [
                        t1
                    ];
                    // here t1 didn't intersect so we are either started
                    // inside the sphere or completely past it
                    if (t2 >= 0 && t2 <= 1) // ExitWound
                    return [
                        t2
                    ];
                    return intersections;
                } else return null;
            };
            // -----------------------------------------------------------------------------
            // Section: Class Constants
            // -----------------------------------------------------------------------------
            /**
 * Some useful pre-calculated constants
 */ IGeometry.HALF_PI = 0.5 * Math.PI;
            IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;
            IGeometry.TWO_PI = 2.0 * Math.PI;
            IGeometry.THREE_PI = 3.0 * Math.PI;
            module1.exports = IGeometry;
        /***/ },
        /* 9 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function IMath() {}
            /**
 * This method returns the sign of the input value.
 */ IMath.sign = function(value) {
                if (value > 0) return 1;
                else if (value < 0) return -1;
                else return 0;
            };
            IMath.floor = function(value) {
                return value < 0 ? Math.ceil(value) : Math.floor(value);
            };
            IMath.ceil = function(value) {
                return value < 0 ? Math.floor(value) : Math.ceil(value);
            };
            module1.exports = IMath;
        /***/ },
        /* 10 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function Integer() {}
            Integer.MAX_VALUE = 2147483647;
            Integer.MIN_VALUE = -2147483648;
            module1.exports = Integer;
        /***/ },
        /* 11 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            var nodeFrom = function nodeFrom(value) {
                return {
                    value: value,
                    next: null,
                    prev: null
                };
            };
            var add = function add(prev, node, next, list) {
                if (prev !== null) prev.next = node;
                else list.head = node;
                if (next !== null) next.prev = node;
                else list.tail = node;
                node.prev = prev;
                node.next = next;
                list.length++;
                return node;
            };
            var _remove = function _remove(node, list) {
                var prev = node.prev, next = node.next;
                if (prev !== null) prev.next = next;
                else list.head = next;
                if (next !== null) next.prev = prev;
                else list.tail = prev;
                node.prev = node.next = null;
                list.length--;
                return node;
            };
            var LinkedList = function() {
                function LinkedList(vals) {
                    var _this = this;
                    _classCallCheck(this, LinkedList);
                    this.length = 0;
                    this.head = null;
                    this.tail = null;
                    if (vals != null) vals.forEach(function(v) {
                        return _this.push(v);
                    });
                }
                _createClass(LinkedList, [
                    {
                        key: "size",
                        value: function size() {
                            return this.length;
                        }
                    },
                    {
                        key: "insertBefore",
                        value: function insertBefore(val, otherNode) {
                            return add(otherNode.prev, nodeFrom(val), otherNode, this);
                        }
                    },
                    {
                        key: "insertAfter",
                        value: function insertAfter(val, otherNode) {
                            return add(otherNode, nodeFrom(val), otherNode.next, this);
                        }
                    },
                    {
                        key: "insertNodeBefore",
                        value: function insertNodeBefore(newNode, otherNode) {
                            return add(otherNode.prev, newNode, otherNode, this);
                        }
                    },
                    {
                        key: "insertNodeAfter",
                        value: function insertNodeAfter(newNode, otherNode) {
                            return add(otherNode, newNode, otherNode.next, this);
                        }
                    },
                    {
                        key: "push",
                        value: function push(val) {
                            return add(this.tail, nodeFrom(val), null, this);
                        }
                    },
                    {
                        key: "unshift",
                        value: function unshift(val) {
                            return add(null, nodeFrom(val), this.head, this);
                        }
                    },
                    {
                        key: "remove",
                        value: function remove(node) {
                            return _remove(node, this);
                        }
                    },
                    {
                        key: "pop",
                        value: function pop() {
                            return _remove(this.tail, this).value;
                        }
                    },
                    {
                        key: "popNode",
                        value: function popNode() {
                            return _remove(this.tail, this);
                        }
                    },
                    {
                        key: "shift",
                        value: function shift() {
                            return _remove(this.head, this).value;
                        }
                    },
                    {
                        key: "shiftNode",
                        value: function shiftNode() {
                            return _remove(this.head, this);
                        }
                    },
                    {
                        key: "get_object_at",
                        value: function get_object_at(index) {
                            if (index <= this.length()) {
                                var i = 1;
                                var current = this.head;
                                while(i < index){
                                    current = current.next;
                                    i++;
                                }
                                return current.value;
                            }
                        }
                    },
                    {
                        key: "set_object_at",
                        value: function set_object_at(index, value) {
                            if (index <= this.length()) {
                                var i = 1;
                                var current = this.head;
                                while(i < index){
                                    current = current.next;
                                    i++;
                                }
                                current.value = value;
                            }
                        }
                    }
                ]);
                return LinkedList;
            }();
            module1.exports = LinkedList;
        /***/ },
        /* 12 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            /*
 *This class is the javascript implementation of the Point.java class in jdk
 */ function Point1(x, y, p) {
                this.x = null;
                this.y = null;
                if (x == null && y == null && p == null) {
                    this.x = 0;
                    this.y = 0;
                } else if (typeof x == "number" && typeof y == "number" && p == null) {
                    this.x = x;
                    this.y = y;
                } else if (x.constructor.name == "Point" && y == null && p == null) {
                    p = x;
                    this.x = p.x;
                    this.y = p.y;
                }
            }
            Point1.prototype.getX = function() {
                return this.x;
            };
            Point1.prototype.getY = function() {
                return this.y;
            };
            Point1.prototype.getLocation = function() {
                return new Point1(this.x, this.y);
            };
            Point1.prototype.setLocation = function(x, y, p) {
                if (x.constructor.name == "Point" && y == null && p == null) {
                    p = x;
                    this.setLocation(p.x, p.y);
                } else if (typeof x == "number" && typeof y == "number" && p == null) {
                    //if both parameters are integer just move (x,y) location
                    if (parseInt(x) == x && parseInt(y) == y) this.move(x, y);
                    else {
                        this.x = Math.floor(x + 0.5);
                        this.y = Math.floor(y + 0.5);
                    }
                }
            };
            Point1.prototype.move = function(x, y) {
                this.x = x;
                this.y = y;
            };
            Point1.prototype.translate = function(dx, dy) {
                this.x += dx;
                this.y += dy;
            };
            Point1.prototype.equals = function(obj) {
                if (obj.constructor.name == "Point") {
                    var pt = obj;
                    return this.x == pt.x && this.y == pt.y;
                }
                return this == obj;
            };
            Point1.prototype.toString = function() {
                return new Point1().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";
            };
            module1.exports = Point1;
        /***/ },
        /* 13 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function RectangleD(x, y, width, height) {
                this.x = 0;
                this.y = 0;
                this.width = 0;
                this.height = 0;
                if (x != null && y != null && width != null && height != null) {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                }
            }
            RectangleD.prototype.getX = function() {
                return this.x;
            };
            RectangleD.prototype.setX = function(x) {
                this.x = x;
            };
            RectangleD.prototype.getY = function() {
                return this.y;
            };
            RectangleD.prototype.setY = function(y) {
                this.y = y;
            };
            RectangleD.prototype.getWidth = function() {
                return this.width;
            };
            RectangleD.prototype.setWidth = function(width) {
                this.width = width;
            };
            RectangleD.prototype.getHeight = function() {
                return this.height;
            };
            RectangleD.prototype.setHeight = function(height) {
                this.height = height;
            };
            RectangleD.prototype.getRight = function() {
                return this.x + this.width;
            };
            RectangleD.prototype.getBottom = function() {
                return this.y + this.height;
            };
            RectangleD.prototype.intersects = function(a) {
                if (this.getRight() < a.x) return false;
                if (this.getBottom() < a.y) return false;
                if (a.getRight() < this.x) return false;
                if (a.getBottom() < this.y) return false;
                return true;
            };
            RectangleD.prototype.getCenterX = function() {
                return this.x + this.width / 2;
            };
            RectangleD.prototype.getMinX = function() {
                return this.getX();
            };
            RectangleD.prototype.getMaxX = function() {
                return this.getX() + this.width;
            };
            RectangleD.prototype.getCenterY = function() {
                return this.y + this.height / 2;
            };
            RectangleD.prototype.getMinY = function() {
                return this.getY();
            };
            RectangleD.prototype.getMaxY = function() {
                return this.getY() + this.height;
            };
            RectangleD.prototype.getWidthHalf = function() {
                return this.width / 2;
            };
            RectangleD.prototype.getHeightHalf = function() {
                return this.height / 2;
            };
            module1.exports = RectangleD;
        /***/ },
        /* 14 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            function UniqueIDGeneretor() {}
            UniqueIDGeneretor.lastID = 0;
            UniqueIDGeneretor.createID = function(obj) {
                if (UniqueIDGeneretor.isPrimitive(obj)) return obj;
                if (obj.uniqueID != null) return obj.uniqueID;
                obj.uniqueID = UniqueIDGeneretor.getString();
                UniqueIDGeneretor.lastID++;
                return obj.uniqueID;
            };
            UniqueIDGeneretor.getString = function(id) {
                if (id == null) id = UniqueIDGeneretor.lastID;
                return "Object#" + id + "";
            };
            UniqueIDGeneretor.isPrimitive = function(arg) {
                var type = typeof arg === "undefined" ? "undefined" : _typeof(arg);
                return arg == null || type != "object" && type != "function";
            };
            module1.exports = UniqueIDGeneretor;
        /***/ },
        /* 15 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];
                    return arr2;
                } else return Array.from(arr);
            }
            var LayoutConstants = __webpack_require__(0);
            var LGraphManager = __webpack_require__(7);
            var LNode = __webpack_require__(3);
            var LEdge = __webpack_require__(1);
            var LGraph = __webpack_require__(6);
            var PointD = __webpack_require__(5);
            var Transform = __webpack_require__(17);
            var Emitter = __webpack_require__(29);
            function Layout1(isRemoteUse) {
                Emitter.call(this);
                //Layout Quality: 0:draft, 1:default, 2:proof
                this.layoutQuality = LayoutConstants.QUALITY;
                //Whether layout should create bendpoints as needed or not
                this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;
                //Whether layout should be incremental or not
                this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;
                //Whether we animate from before to after layout node positions
                this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;
                //Whether we animate the layout process or not
                this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;
                //Number iterations that should be done between two successive animations
                this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;
                /**
   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When
   * they are, both spring and repulsion forces between two leaf nodes can be
   * calculated without the expensive clipping point calculations, resulting
   * in major speed-up.
   */ this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;
                /**
   * This is used for creation of bendpoints by using dummy nodes and edges.
   * Maps an LEdge to its dummy bendpoint path.
   */ this.edgeToDummyNodes = new Map();
                this.graphManager = new LGraphManager(this);
                this.isLayoutFinished = false;
                this.isSubLayout = false;
                this.isRemoteUse = false;
                if (isRemoteUse != null) this.isRemoteUse = isRemoteUse;
            }
            Layout1.RANDOM_SEED = 1;
            Layout1.prototype = Object.create(Emitter.prototype);
            Layout1.prototype.getGraphManager = function() {
                return this.graphManager;
            };
            Layout1.prototype.getAllNodes = function() {
                return this.graphManager.getAllNodes();
            };
            Layout1.prototype.getAllEdges = function() {
                return this.graphManager.getAllEdges();
            };
            Layout1.prototype.getAllNodesToApplyGravitation = function() {
                return this.graphManager.getAllNodesToApplyGravitation();
            };
            Layout1.prototype.newGraphManager = function() {
                var gm = new LGraphManager(this);
                this.graphManager = gm;
                return gm;
            };
            Layout1.prototype.newGraph = function(vGraph) {
                return new LGraph(null, this.graphManager, vGraph);
            };
            Layout1.prototype.newNode = function(vNode) {
                return new LNode(this.graphManager, vNode);
            };
            Layout1.prototype.newEdge = function(vEdge) {
                return new LEdge(null, null, vEdge);
            };
            Layout1.prototype.checkLayoutSuccess = function() {
                return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();
            };
            Layout1.prototype.runLayout = function() {
                this.isLayoutFinished = false;
                if (this.tilingPreLayout) this.tilingPreLayout();
                this.initParameters();
                var isLayoutSuccessfull;
                if (this.checkLayoutSuccess()) isLayoutSuccessfull = false;
                else isLayoutSuccessfull = this.layout();
                if (LayoutConstants.ANIMATE === "during") // If this is a 'during' layout animation. Layout is not finished yet. 
                // We need to perform these in index.js when layout is really finished.
                return false;
                if (isLayoutSuccessfull) {
                    if (!this.isSubLayout) this.doPostLayout();
                }
                if (this.tilingPostLayout) this.tilingPostLayout();
                this.isLayoutFinished = true;
                return isLayoutSuccessfull;
            };
            /**
 * This method performs the operations required after layout.
 */ Layout1.prototype.doPostLayout = function() {
                //assert !isSubLayout : "Should not be called on sub-layout!";
                // Propagate geometric changes to v-level objects
                if (!this.incremental) this.transform();
                this.update();
            };
            /**
 * This method updates the geometry of the target graph according to
 * calculated layout.
 */ Layout1.prototype.update2 = function() {
                // update bend points
                if (this.createBendsAsNeeded) {
                    this.createBendpointsFromDummyNodes();
                    // reset all edges, since the topology has changed
                    this.graphManager.resetAllEdges();
                }
                // perform edge, node and root updates if layout is not called
                // remotely
                if (!this.isRemoteUse) {
                    // update all edges
                    var edge;
                    var allEdges = this.graphManager.getAllEdges();
                    for(var i = 0; i < allEdges.length; i++)edge = allEdges[i];
                    // recursively update nodes
                    var node;
                    var nodes = this.graphManager.getRoot().getNodes();
                    for(var i = 0; i < nodes.length; i++)node = nodes[i];
                    // update root graph
                    this.update(this.graphManager.getRoot());
                }
            };
            Layout1.prototype.update = function(obj) {
                if (obj == null) this.update2();
                else if (obj instanceof LNode) {
                    var node = obj;
                    if (node.getChild() != null) {
                        // since node is compound, recursively update child nodes
                        var nodes = node.getChild().getNodes();
                        for(var i = 0; i < nodes.length; i++)update(nodes[i]);
                    }
                    // if the l-level node is associated with a v-level graph object,
                    // then it is assumed that the v-level node implements the
                    // interface Updatable.
                    if (node.vGraphObject != null) {
                        // cast to Updatable without any type check
                        var vNode = node.vGraphObject;
                        // call the update method of the interface
                        vNode.update(node);
                    }
                } else if (obj instanceof LEdge) {
                    var edge = obj;
                    // if the l-level edge is associated with a v-level graph object,
                    // then it is assumed that the v-level edge implements the
                    // interface Updatable.
                    if (edge.vGraphObject != null) {
                        // cast to Updatable without any type check
                        var vEdge = edge.vGraphObject;
                        // call the update method of the interface
                        vEdge.update(edge);
                    }
                } else if (obj instanceof LGraph) {
                    var graph = obj;
                    // if the l-level graph is associated with a v-level graph object,
                    // then it is assumed that the v-level object implements the
                    // interface Updatable.
                    if (graph.vGraphObject != null) {
                        // cast to Updatable without any type check
                        var vGraph = graph.vGraphObject;
                        // call the update method of the interface
                        vGraph.update(graph);
                    }
                }
            };
            /**
 * This method is used to set all layout parameters to default values
 * determined at compile time.
 */ Layout1.prototype.initParameters = function() {
                if (!this.isSubLayout) {
                    this.layoutQuality = LayoutConstants.QUALITY;
                    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;
                    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;
                    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;
                    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;
                    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;
                    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;
                }
                if (this.animationDuringLayout) this.animationOnLayout = false;
            };
            Layout1.prototype.transform = function(newLeftTop) {
                if (newLeftTop == undefined) this.transform(new PointD(0, 0));
                else {
                    // create a transformation object (from Eclipse to layout). When an
                    // inverse transform is applied, we get upper-left coordinate of the
                    // drawing or the root graph at given input coordinate (some margins
                    // already included in calculation of left-top).
                    var trans = new Transform();
                    var leftTop = this.graphManager.getRoot().updateLeftTop();
                    if (leftTop != null) {
                        trans.setWorldOrgX(newLeftTop.x);
                        trans.setWorldOrgY(newLeftTop.y);
                        trans.setDeviceOrgX(leftTop.x);
                        trans.setDeviceOrgY(leftTop.y);
                        var nodes = this.getAllNodes();
                        var node;
                        for(var i = 0; i < nodes.length; i++){
                            node = nodes[i];
                            node.transform(trans);
                        }
                    }
                }
            };
            Layout1.prototype.positionNodesRandomly = function(graph) {
                if (graph == undefined) {
                    //assert !this.incremental;
                    this.positionNodesRandomly(this.getGraphManager().getRoot());
                    this.getGraphManager().getRoot().updateBounds(true);
                } else {
                    var lNode;
                    var childGraph;
                    var nodes = graph.getNodes();
                    for(var i = 0; i < nodes.length; i++){
                        lNode = nodes[i];
                        childGraph = lNode.getChild();
                        if (childGraph == null) lNode.scatter();
                        else if (childGraph.getNodes().length == 0) lNode.scatter();
                        else {
                            this.positionNodesRandomly(childGraph);
                            lNode.updateBounds();
                        }
                    }
                }
            };
            /**
 * This method returns a list of trees where each tree is represented as a
 * list of l-nodes. The method returns a list of size 0 when:
 * - The graph is not flat or
 * - One of the component(s) of the graph is not a tree.
 */ Layout1.prototype.getFlatForest = function() {
                var flatForest = [];
                var isForest = true;
                // Quick reference for all nodes in the graph manager associated with
                // this layout. The list should not be changed.
                var allNodes = this.graphManager.getRoot().getNodes();
                // First be sure that the graph is flat
                var isFlat = true;
                for(var i = 0; i < allNodes.length; i++)if (allNodes[i].getChild() != null) isFlat = false;
                // Return empty forest if the graph is not flat.
                if (!isFlat) return flatForest;
                // Run BFS for each component of the graph.
                var visited = new Set();
                var toBeVisited = [];
                var parents = new Map();
                var unProcessedNodes = [];
                unProcessedNodes = unProcessedNodes.concat(allNodes);
                // Each iteration of this loop finds a component of the graph and
                // decides whether it is a tree or not. If it is a tree, adds it to the
                // forest and continued with the next component.
                while(unProcessedNodes.length > 0 && isForest){
                    toBeVisited.push(unProcessedNodes[0]);
                    // Start the BFS. Each iteration of this loop visits a node in a
                    // BFS manner.
                    while(toBeVisited.length > 0 && isForest){
                        //pool operation
                        var currentNode = toBeVisited[0];
                        toBeVisited.splice(0, 1);
                        visited.add(currentNode);
                        // Traverse all neighbors of this node
                        var neighborEdges = currentNode.getEdges();
                        for(var i = 0; i < neighborEdges.length; i++){
                            var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);
                            // If BFS is not growing from this neighbor.
                            if (parents.get(currentNode) != currentNeighbor) {
                                // We haven't previously visited this neighbor.
                                if (!visited.has(currentNeighbor)) {
                                    toBeVisited.push(currentNeighbor);
                                    parents.set(currentNeighbor, currentNode);
                                } else {
                                    isForest = false;
                                    break;
                                }
                            }
                        }
                    }
                    // The graph contains a component that is not a tree. Empty
                    // previously found trees. The method will end.
                    if (!isForest) flatForest = [];
                    else {
                        var temp = [].concat(_toConsumableArray(visited));
                        flatForest.push(temp);
                        //flatForest = flatForest.concat(temp);
                        //unProcessedNodes.removeAll(visited);
                        for(var i = 0; i < temp.length; i++){
                            var value = temp[i];
                            var index = unProcessedNodes.indexOf(value);
                            if (index > -1) unProcessedNodes.splice(index, 1);
                        }
                        visited = new Set();
                        parents = new Map();
                    }
                }
                return flatForest;
            };
            /**
 * This method creates dummy nodes (an l-level node with minimal dimensions)
 * for the given edge (one per bendpoint). The existing l-level structure
 * is updated accordingly.
 */ Layout1.prototype.createDummyNodesForBendpoints = function(edge) {
                var dummyNodes = [];
                var prev = edge.source;
                var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);
                for(var i = 0; i < edge.bendpoints.length; i++){
                    // create new dummy node
                    var dummyNode = this.newNode(null);
                    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));
                    graph.add(dummyNode);
                    // create new dummy edge between prev and dummy node
                    var dummyEdge = this.newEdge(null);
                    this.graphManager.add(dummyEdge, prev, dummyNode);
                    dummyNodes.add(dummyNode);
                    prev = dummyNode;
                }
                var dummyEdge = this.newEdge(null);
                this.graphManager.add(dummyEdge, prev, edge.target);
                this.edgeToDummyNodes.set(edge, dummyNodes);
                // remove real edge from graph manager if it is inter-graph
                if (edge.isInterGraph()) this.graphManager.remove(edge);
                else graph.remove(edge);
                return dummyNodes;
            };
            /**
 * This method creates bendpoints for edges from the dummy nodes
 * at l-level.
 */ Layout1.prototype.createBendpointsFromDummyNodes = function() {
                var edges = [];
                edges = edges.concat(this.graphManager.getAllEdges());
                edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);
                for(var k = 0; k < edges.length; k++){
                    var lEdge = edges[k];
                    if (lEdge.bendpoints.length > 0) {
                        var path = this.edgeToDummyNodes.get(lEdge);
                        for(var i = 0; i < path.length; i++){
                            var dummyNode = path[i];
                            var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());
                            // update bendpoint's location according to dummy node
                            var ebp = lEdge.bendpoints.get(i);
                            ebp.x = p.x;
                            ebp.y = p.y;
                            // remove the dummy node, dummy edges incident with this
                            // dummy node is also removed (within the remove method)
                            dummyNode.getOwner().remove(dummyNode);
                        }
                        // add the real edge to graph
                        this.graphManager.add(lEdge, lEdge.source, lEdge.target);
                    }
                }
            };
            Layout1.transform = function(sliderValue, defaultValue, minDiv, maxMul) {
                if (minDiv != undefined && maxMul != undefined) {
                    var value = defaultValue;
                    if (sliderValue <= 50) {
                        var minValue = defaultValue / minDiv;
                        value -= (defaultValue - minValue) / 50 * (50 - sliderValue);
                    } else {
                        var maxValue = defaultValue * maxMul;
                        value += (maxValue - defaultValue) / 50 * (sliderValue - 50);
                    }
                    return value;
                } else {
                    var a, b;
                    if (sliderValue <= 50) {
                        a = 9.0 * defaultValue / 500.0;
                        b = defaultValue / 10.0;
                    } else {
                        a = 9.0 * defaultValue / 50.0;
                        b = -8 * defaultValue;
                    }
                    return a * sliderValue + b;
                }
            };
            /**
 * This method finds and returns the center of the given nodes, assuming
 * that the given nodes form a tree in themselves.
 */ Layout1.findCenterOfTree = function(nodes) {
                var list = [];
                list = list.concat(nodes);
                var removedNodes = [];
                var remainingDegrees = new Map();
                var foundCenter = false;
                var centerNode = null;
                if (list.length == 1 || list.length == 2) {
                    foundCenter = true;
                    centerNode = list[0];
                }
                for(var i = 0; i < list.length; i++){
                    var node = list[i];
                    var degree = node.getNeighborsList().size;
                    remainingDegrees.set(node, node.getNeighborsList().size);
                    if (degree == 1) removedNodes.push(node);
                }
                var tempList = [];
                tempList = tempList.concat(removedNodes);
                while(!foundCenter){
                    var tempList2 = [];
                    tempList2 = tempList2.concat(tempList);
                    tempList = [];
                    for(var i = 0; i < list.length; i++){
                        var node = list[i];
                        var index = list.indexOf(node);
                        if (index >= 0) list.splice(index, 1);
                        var neighbours = node.getNeighborsList();
                        neighbours.forEach(function(neighbour) {
                            if (removedNodes.indexOf(neighbour) < 0) {
                                var otherDegree = remainingDegrees.get(neighbour);
                                var newDegree = otherDegree - 1;
                                if (newDegree == 1) tempList.push(neighbour);
                                remainingDegrees.set(neighbour, newDegree);
                            }
                        });
                    }
                    removedNodes = removedNodes.concat(tempList);
                    if (list.length == 1 || list.length == 2) {
                        foundCenter = true;
                        centerNode = list[0];
                    }
                }
                return centerNode;
            };
            /**
 * During the coarsening process, this layout may be referenced by two graph managers
 * this setter function grants access to change the currently being used graph manager
 */ Layout1.prototype.setGraphManager = function(gm) {
                this.graphManager = gm;
            };
            module1.exports = Layout1;
        /***/ },
        /* 16 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function RandomSeed() {}
            // adapted from: https://stackoverflow.com/a/19303725
            RandomSeed.seed = 1;
            RandomSeed.x = 0;
            RandomSeed.nextDouble = function() {
                RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;
                return RandomSeed.x - Math.floor(RandomSeed.x);
            };
            module1.exports = RandomSeed;
        /***/ },
        /* 17 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var PointD = __webpack_require__(5);
            function Transform(x, y) {
                this.lworldOrgX = 0.0;
                this.lworldOrgY = 0.0;
                this.ldeviceOrgX = 0.0;
                this.ldeviceOrgY = 0.0;
                this.lworldExtX = 1.0;
                this.lworldExtY = 1.0;
                this.ldeviceExtX = 1.0;
                this.ldeviceExtY = 1.0;
            }
            Transform.prototype.getWorldOrgX = function() {
                return this.lworldOrgX;
            };
            Transform.prototype.setWorldOrgX = function(wox) {
                this.lworldOrgX = wox;
            };
            Transform.prototype.getWorldOrgY = function() {
                return this.lworldOrgY;
            };
            Transform.prototype.setWorldOrgY = function(woy) {
                this.lworldOrgY = woy;
            };
            Transform.prototype.getWorldExtX = function() {
                return this.lworldExtX;
            };
            Transform.prototype.setWorldExtX = function(wex) {
                this.lworldExtX = wex;
            };
            Transform.prototype.getWorldExtY = function() {
                return this.lworldExtY;
            };
            Transform.prototype.setWorldExtY = function(wey) {
                this.lworldExtY = wey;
            };
            /* Device related */ Transform.prototype.getDeviceOrgX = function() {
                return this.ldeviceOrgX;
            };
            Transform.prototype.setDeviceOrgX = function(dox) {
                this.ldeviceOrgX = dox;
            };
            Transform.prototype.getDeviceOrgY = function() {
                return this.ldeviceOrgY;
            };
            Transform.prototype.setDeviceOrgY = function(doy) {
                this.ldeviceOrgY = doy;
            };
            Transform.prototype.getDeviceExtX = function() {
                return this.ldeviceExtX;
            };
            Transform.prototype.setDeviceExtX = function(dex) {
                this.ldeviceExtX = dex;
            };
            Transform.prototype.getDeviceExtY = function() {
                return this.ldeviceExtY;
            };
            Transform.prototype.setDeviceExtY = function(dey) {
                this.ldeviceExtY = dey;
            };
            Transform.prototype.transformX = function(x) {
                var xDevice = 0.0;
                var worldExtX = this.lworldExtX;
                if (worldExtX != 0.0) xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;
                return xDevice;
            };
            Transform.prototype.transformY = function(y) {
                var yDevice = 0.0;
                var worldExtY = this.lworldExtY;
                if (worldExtY != 0.0) yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;
                return yDevice;
            };
            Transform.prototype.inverseTransformX = function(x) {
                var xWorld = 0.0;
                var deviceExtX = this.ldeviceExtX;
                if (deviceExtX != 0.0) xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;
                return xWorld;
            };
            Transform.prototype.inverseTransformY = function(y) {
                var yWorld = 0.0;
                var deviceExtY = this.ldeviceExtY;
                if (deviceExtY != 0.0) yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;
                return yWorld;
            };
            Transform.prototype.inverseTransformPoint = function(inPoint) {
                var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));
                return outPoint;
            };
            module1.exports = Transform;
        /***/ },
        /* 18 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];
                    return arr2;
                } else return Array.from(arr);
            }
            var Layout1 = __webpack_require__(15);
            var FDLayoutConstants = __webpack_require__(4);
            var LayoutConstants = __webpack_require__(0);
            var IGeometry = __webpack_require__(8);
            var IMath = __webpack_require__(9);
            function FDLayout() {
                Layout1.call(this);
                this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;
                this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;
                this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;
                this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;
                this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;
                this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;
                this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;
                this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;
                this.totalDisplacement = 0.0;
                this.oldTotalDisplacement = 0.0;
                this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;
            }
            FDLayout.prototype = Object.create(Layout1.prototype);
            for(var prop in Layout1)FDLayout[prop] = Layout1[prop];
            FDLayout.prototype.initParameters = function() {
                Layout1.prototype.initParameters.call(this, arguments);
                this.totalIterations = 0;
                this.notAnimatedIterations = 0;
                this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;
                this.grid = [];
            };
            FDLayout.prototype.calcIdealEdgeLengths = function() {
                var edge;
                var originalIdealLength;
                var lcaDepth;
                var source;
                var target;
                var sizeOfSourceInLca;
                var sizeOfTargetInLca;
                var allEdges = this.getGraphManager().getAllEdges();
                for(var i = 0; i < allEdges.length; i++){
                    edge = allEdges[i];
                    originalIdealLength = edge.idealLength;
                    if (edge.isInterGraph) {
                        source = edge.getSource();
                        target = edge.getTarget();
                        sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();
                        sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();
                        if (this.useSmartIdealEdgeLengthCalculation) edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;
                        lcaDepth = edge.getLca().getInclusionTreeDepth();
                        edge.idealLength += originalIdealLength * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);
                    }
                }
            };
            FDLayout.prototype.initSpringEmbedder = function() {
                var s = this.getAllNodes().length;
                if (this.incremental) {
                    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));
                    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;
                } else {
                    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));
                    else this.coolingFactor = 1.0;
                    this.initialCoolingFactor = this.coolingFactor;
                    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;
                }
                this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);
                // Reassign this attribute by using new constant value
                this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;
                this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;
                this.repulsionRange = this.calcRepulsionRange();
            };
            FDLayout.prototype.calcSpringForces = function() {
                var lEdges = this.getAllEdges();
                var edge;
                for(var i = 0; i < lEdges.length; i++){
                    edge = lEdges[i];
                    this.calcSpringForce(edge, edge.idealLength);
                }
            };
            FDLayout.prototype.calcRepulsionForces = function() {
                var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var i, j;
                var nodeA, nodeB;
                var lNodes = this.getAllNodes();
                var processedNodeSet;
                if (this.useFRGridVariant) {
                    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) this.updateGrid();
                    processedNodeSet = new Set();
                    // calculate repulsion forces between each nodes and its surrounding
                    for(i = 0; i < lNodes.length; i++){
                        nodeA = lNodes[i];
                        this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);
                        processedNodeSet.add(nodeA);
                    }
                } else for(i = 0; i < lNodes.length; i++){
                    nodeA = lNodes[i];
                    for(j = i + 1; j < lNodes.length; j++){
                        nodeB = lNodes[j];
                        // If both nodes are not members of the same graph, skip.
                        if (nodeA.getOwner() != nodeB.getOwner()) continue;
                        this.calcRepulsionForce(nodeA, nodeB);
                    }
                }
            };
            FDLayout.prototype.calcGravitationalForces = function() {
                var node;
                var lNodes = this.getAllNodesToApplyGravitation();
                for(var i = 0; i < lNodes.length; i++){
                    node = lNodes[i];
                    this.calcGravitationalForce(node);
                }
            };
            FDLayout.prototype.moveNodes = function() {
                var lNodes = this.getAllNodes();
                var node;
                for(var i = 0; i < lNodes.length; i++){
                    node = lNodes[i];
                    node.move();
                }
            };
            FDLayout.prototype.calcSpringForce = function(edge, idealLength) {
                var sourceNode = edge.getSource();
                var targetNode = edge.getTarget();
                var length;
                var springForce;
                var springForceX;
                var springForceY;
                // Update edge length
                if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) edge.updateLengthSimple();
                else {
                    edge.updateLength();
                    if (edge.isOverlapingSourceAndTarget) return;
                }
                length = edge.getLength();
                if (length == 0) return;
                // Calculate spring forces
                springForce = edge.edgeElasticity * (length - idealLength);
                // Project force onto x and y axes
                springForceX = springForce * (edge.lengthX / length);
                springForceY = springForce * (edge.lengthY / length);
                // Apply forces on the end nodes
                sourceNode.springForceX += springForceX;
                sourceNode.springForceY += springForceY;
                targetNode.springForceX -= springForceX;
                targetNode.springForceY -= springForceY;
            };
            FDLayout.prototype.calcRepulsionForce = function(nodeA, nodeB) {
                var rectA = nodeA.getRect();
                var rectB = nodeB.getRect();
                var overlapAmount = new Array(2);
                var clipPoints = new Array(4);
                var distanceX;
                var distanceY;
                var distanceSquared;
                var distance;
                var repulsionForce;
                var repulsionForceX;
                var repulsionForceY;
                if (rectA.intersects(rectB)) {
                    // calculate separation amount in x and y directions
                    IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);
                    repulsionForceX = 2 * overlapAmount[0];
                    repulsionForceY = 2 * overlapAmount[1];
                    var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);
                    // Apply forces on the two nodes
                    nodeA.repulsionForceX -= childrenConstant * repulsionForceX;
                    nodeA.repulsionForceY -= childrenConstant * repulsionForceY;
                    nodeB.repulsionForceX += childrenConstant * repulsionForceX;
                    nodeB.repulsionForceY += childrenConstant * repulsionForceY;
                } else {
                    // calculate distance
                    if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) {
                        distanceX = rectB.getCenterX() - rectA.getCenterX();
                        distanceY = rectB.getCenterY() - rectA.getCenterY();
                    } else {
                        IGeometry.getIntersection(rectA, rectB, clipPoints);
                        distanceX = clipPoints[2] - clipPoints[0];
                        distanceY = clipPoints[3] - clipPoints[1];
                    }
                    // No repulsion range. FR grid variant should take care of this.
                    if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;
                    if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;
                    distanceSquared = distanceX * distanceX + distanceY * distanceY;
                    distance = Math.sqrt(distanceSquared);
                    // Here we use half of the nodes' repulsion values for backward compatibility
                    repulsionForce = (nodeA.nodeRepulsion / 2 + nodeB.nodeRepulsion / 2) * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;
                    // Project force onto x and y axes
                    repulsionForceX = repulsionForce * distanceX / distance;
                    repulsionForceY = repulsionForce * distanceY / distance;
                    // Apply forces on the two nodes    
                    nodeA.repulsionForceX -= repulsionForceX;
                    nodeA.repulsionForceY -= repulsionForceY;
                    nodeB.repulsionForceX += repulsionForceX;
                    nodeB.repulsionForceY += repulsionForceY;
                }
            };
            FDLayout.prototype.calcGravitationalForce = function(node) {
                var ownerGraph;
                var ownerCenterX;
                var ownerCenterY;
                var distanceX;
                var distanceY;
                var absDistanceX;
                var absDistanceY;
                var estimatedSize;
                ownerGraph = node.getOwner();
                ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;
                ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;
                distanceX = node.getCenterX() - ownerCenterX;
                distanceY = node.getCenterY() - ownerCenterY;
                absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;
                absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;
                if (node.getOwner() == this.graphManager.getRoot()) {
                    estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;
                    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {
                        node.gravitationForceX = -this.gravityConstant * distanceX;
                        node.gravitationForceY = -this.gravityConstant * distanceY;
                    }
                } else {
                    estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;
                    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {
                        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;
                        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;
                    }
                }
            };
            FDLayout.prototype.isConverged = function() {
                var converged;
                var oscilating = false;
                if (this.totalIterations > this.maxIterations / 3) oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;
                converged = this.totalDisplacement < this.totalDisplacementThreshold;
                this.oldTotalDisplacement = this.totalDisplacement;
                return converged || oscilating;
            };
            FDLayout.prototype.animate = function() {
                if (this.animationDuringLayout && !this.isSubLayout) {
                    if (this.notAnimatedIterations == this.animationPeriod) {
                        this.update();
                        this.notAnimatedIterations = 0;
                    } else this.notAnimatedIterations++;
                }
            };
            //This method calculates the number of children (weight) for all nodes
            FDLayout.prototype.calcNoOfChildrenForAllNodes = function() {
                var node;
                var allNodes = this.graphManager.getAllNodes();
                for(var i = 0; i < allNodes.length; i++){
                    node = allNodes[i];
                    node.noOfChildren = node.getNoOfChildren();
                }
            };
            // -----------------------------------------------------------------------------
            // Section: FR-Grid Variant Repulsion Force Calculation
            // -----------------------------------------------------------------------------
            FDLayout.prototype.calcGrid = function(graph) {
                var sizeX = 0;
                var sizeY = 0;
                sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));
                sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));
                var grid = new Array(sizeX);
                for(var i = 0; i < sizeX; i++)grid[i] = new Array(sizeY);
                for(var i = 0; i < sizeX; i++)for(var j = 0; j < sizeY; j++)grid[i][j] = new Array();
                return grid;
            };
            FDLayout.prototype.addNodeToGrid = function(v, left, top) {
                var startX = 0;
                var finishX = 0;
                var startY = 0;
                var finishY = 0;
                startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));
                finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));
                startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));
                finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));
                for(var i = startX; i <= finishX; i++)for(var j = startY; j <= finishY; j++){
                    this.grid[i][j].push(v);
                    v.setGridCoordinates(startX, finishX, startY, finishY);
                }
            };
            FDLayout.prototype.updateGrid = function() {
                var i;
                var nodeA;
                var lNodes = this.getAllNodes();
                this.grid = this.calcGrid(this.graphManager.getRoot());
                // put all nodes to proper grid cells
                for(i = 0; i < lNodes.length; i++){
                    nodeA = lNodes[i];
                    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());
                }
            };
            FDLayout.prototype.calculateRepulsionForceOfANode = function(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {
                if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {
                    var surrounding = new Set();
                    nodeA.surrounding = new Array();
                    var nodeB;
                    var grid = this.grid;
                    for(var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++)for(var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++){
                        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) for(var k = 0; k < grid[i][j].length; k++){
                            nodeB = grid[i][j][k];
                            // If both nodes are not members of the same graph, 
                            // or both nodes are the same, skip.
                            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) continue;
                            // check if the repulsion force between
                            // nodeA and nodeB has already been calculated
                            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {
                                var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);
                                var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);
                                // if the distance between nodeA and nodeB 
                                // is less then calculation range
                                if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) //then add nodeB to surrounding of nodeA
                                surrounding.add(nodeB);
                            }
                        }
                    }
                    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));
                }
                for(i = 0; i < nodeA.surrounding.length; i++)this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);
            };
            FDLayout.prototype.calcRepulsionRange = function() {
                return 0.0;
            };
            module1.exports = FDLayout;
        /***/ },
        /* 19 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var LEdge = __webpack_require__(1);
            var FDLayoutConstants = __webpack_require__(4);
            function FDLayoutEdge(source, target, vEdge) {
                LEdge.call(this, source, target, vEdge);
                // Ideal length and elasticity value for this edge
                this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;
                this.edgeElasticity = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;
            }
            FDLayoutEdge.prototype = Object.create(LEdge.prototype);
            for(var prop in LEdge)FDLayoutEdge[prop] = LEdge[prop];
            module1.exports = FDLayoutEdge;
        /***/ },
        /* 20 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var LNode = __webpack_require__(3);
            var FDLayoutConstants = __webpack_require__(4);
            function FDLayoutNode(gm, loc, size, vNode) {
                // alternative constructor is handled inside LNode
                LNode.call(this, gm, loc, size, vNode);
                // Repulsion value of this node
                this.nodeRepulsion = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;
                //Spring, repulsion and gravitational forces acting on this node
                this.springForceX = 0;
                this.springForceY = 0;
                this.repulsionForceX = 0;
                this.repulsionForceY = 0;
                this.gravitationForceX = 0;
                this.gravitationForceY = 0;
                //Amount by which this node is to be moved in this iteration
                this.displacementX = 0;
                this.displacementY = 0;
                //Start and finish grid coordinates that this node is fallen into
                this.startX = 0;
                this.finishX = 0;
                this.startY = 0;
                this.finishY = 0;
                //Geometric neighbors of this node
                this.surrounding = [];
            }
            FDLayoutNode.prototype = Object.create(LNode.prototype);
            for(var prop in LNode)FDLayoutNode[prop] = LNode[prop];
            FDLayoutNode.prototype.setGridCoordinates = function(_startX, _finishX, _startY, _finishY) {
                this.startX = _startX;
                this.finishX = _finishX;
                this.startY = _startY;
                this.finishY = _finishY;
            };
            module1.exports = FDLayoutNode;
        /***/ },
        /* 21 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function DimensionD1(width, height) {
                this.width = 0;
                this.height = 0;
                if (width !== null && height !== null) {
                    this.height = height;
                    this.width = width;
                }
            }
            DimensionD1.prototype.getWidth = function() {
                return this.width;
            };
            DimensionD1.prototype.setWidth = function(width) {
                this.width = width;
            };
            DimensionD1.prototype.getHeight = function() {
                return this.height;
            };
            DimensionD1.prototype.setHeight = function(height) {
                this.height = height;
            };
            module1.exports = DimensionD1;
        /***/ },
        /* 22 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var UniqueIDGeneretor = __webpack_require__(14);
            function HashMap() {
                this.map = {};
                this.keys = [];
            }
            HashMap.prototype.put = function(key, value) {
                var theId = UniqueIDGeneretor.createID(key);
                if (!this.contains(theId)) {
                    this.map[theId] = value;
                    this.keys.push(key);
                }
            };
            HashMap.prototype.contains = function(key) {
                var theId = UniqueIDGeneretor.createID(key);
                return this.map[key] != null;
            };
            HashMap.prototype.get = function(key) {
                var theId = UniqueIDGeneretor.createID(key);
                return this.map[theId];
            };
            HashMap.prototype.keySet = function() {
                return this.keys;
            };
            module1.exports = HashMap;
        /***/ },
        /* 23 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var UniqueIDGeneretor = __webpack_require__(14);
            function HashSet() {
                this.set = {};
            }
            HashSet.prototype.add = function(obj) {
                var theId = UniqueIDGeneretor.createID(obj);
                if (!this.contains(theId)) this.set[theId] = obj;
            };
            HashSet.prototype.remove = function(obj) {
                delete this.set[UniqueIDGeneretor.createID(obj)];
            };
            HashSet.prototype.clear = function() {
                this.set = {};
            };
            HashSet.prototype.contains = function(obj) {
                return this.set[UniqueIDGeneretor.createID(obj)] == obj;
            };
            HashSet.prototype.isEmpty = function() {
                return this.size() === 0;
            };
            HashSet.prototype.size = function() {
                return Object.keys(this.set).length;
            };
            //concats this.set to the given list
            HashSet.prototype.addAllTo = function(list) {
                var keys = Object.keys(this.set);
                var length = keys.length;
                for(var i = 0; i < length; i++)list.push(this.set[keys[i]]);
            };
            HashSet.prototype.size = function() {
                return Object.keys(this.set).length;
            };
            HashSet.prototype.addAll = function(list) {
                var s = list.length;
                for(var i = 0; i < s; i++){
                    var v = list[i];
                    this.add(v);
                }
            };
            module1.exports = HashSet;
        /***/ },
        /* 24 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            // Some matrix (1d and 2d array) operations
            function Matrix() {}
            /**
 * matrix multiplication
 * array1, array2 and result are 2d arrays
 */ Matrix.multMat = function(array1, array2) {
                var result = [];
                for(var i = 0; i < array1.length; i++){
                    result[i] = [];
                    for(var j = 0; j < array2[0].length; j++){
                        result[i][j] = 0;
                        for(var k = 0; k < array1[0].length; k++)result[i][j] += array1[i][k] * array2[k][j];
                    }
                }
                return result;
            };
            /**
 * matrix transpose
 * array and result are 2d arrays
 */ Matrix.transpose = function(array) {
                var result = [];
                for(var i = 0; i < array[0].length; i++){
                    result[i] = [];
                    for(var j = 0; j < array.length; j++)result[i][j] = array[j][i];
                }
                return result;
            };
            /**
 * multiply array with constant
 * array and result are 1d arrays
 */ Matrix.multCons = function(array, constant) {
                var result = [];
                for(var i = 0; i < array.length; i++)result[i] = array[i] * constant;
                return result;
            };
            /**
 * substract two arrays
 * array1, array2 and result are 1d arrays
 */ Matrix.minusOp = function(array1, array2) {
                var result = [];
                for(var i = 0; i < array1.length; i++)result[i] = array1[i] - array2[i];
                return result;
            };
            /**
 * dot product of two arrays with same size
 * array1 and array2 are 1d arrays
 */ Matrix.dotProduct = function(array1, array2) {
                var product = 0;
                for(var i = 0; i < array1.length; i++)product += array1[i] * array2[i];
                return product;
            };
            /**
 * magnitude of an array
 * array is 1d array
 */ Matrix.mag = function(array) {
                return Math.sqrt(this.dotProduct(array, array));
            };
            /**
 * normalization of an array
 * array and result are 1d array
 */ Matrix.normalize = function(array) {
                var result = [];
                var magnitude = this.mag(array);
                for(var i = 0; i < array.length; i++)result[i] = array[i] / magnitude;
                return result;
            };
            /**
 * multiply an array with centering matrix
 * array and result are 1d array
 */ Matrix.multGamma = function(array) {
                var result = [];
                var sum = 0;
                for(var i = 0; i < array.length; i++)sum += array[i];
                sum *= -1 / array.length;
                for(var _i = 0; _i < array.length; _i++)result[_i] = sum + array[_i];
                return result;
            };
            /**
 * a special matrix multiplication
 * result = 0.5 * C * INV * C^T * array
 * array and result are 1d, C and INV are 2d arrays
 */ Matrix.multL = function(array, C, INV) {
                var result = [];
                var temp1 = [];
                var temp2 = [];
                // multiply by C^T
                for(var i = 0; i < C[0].length; i++){
                    var sum = 0;
                    for(var j = 0; j < C.length; j++)sum += -0.5 * C[j][i] * array[j];
                    temp1[i] = sum;
                }
                // multiply the result by INV
                for(var _i2 = 0; _i2 < INV.length; _i2++){
                    var _sum = 0;
                    for(var _j = 0; _j < INV.length; _j++)_sum += INV[_i2][_j] * temp1[_j];
                    temp2[_i2] = _sum;
                }
                // multiply the result by C
                for(var _i3 = 0; _i3 < C.length; _i3++){
                    var _sum2 = 0;
                    for(var _j2 = 0; _j2 < C[0].length; _j2++)_sum2 += C[_i3][_j2] * temp2[_j2];
                    result[_i3] = _sum2;
                }
                return result;
            };
            module1.exports = Matrix;
        /***/ },
        /* 25 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            /**
 * A classic Quicksort algorithm with Hoare's partition
 * - Works also on LinkedList objects
 *
 * Copyright: i-Vis Research Group, Bilkent University, 2007 - present
 */ var LinkedList = __webpack_require__(11);
            var Quicksort = function() {
                function Quicksort(A, compareFunction) {
                    _classCallCheck(this, Quicksort);
                    if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;
                    var length = void 0;
                    if (A instanceof LinkedList) length = A.size();
                    else length = A.length;
                    this._quicksort(A, 0, length - 1);
                }
                _createClass(Quicksort, [
                    {
                        key: "_quicksort",
                        value: function _quicksort(A, p, r) {
                            if (p < r) {
                                var q = this._partition(A, p, r);
                                this._quicksort(A, p, q);
                                this._quicksort(A, q + 1, r);
                            }
                        }
                    },
                    {
                        key: "_partition",
                        value: function _partition(A, p, r) {
                            var x = this._get(A, p);
                            var i = p;
                            var j = r;
                            while(true){
                                while(this.compareFunction(x, this._get(A, j)))j--;
                                while(this.compareFunction(this._get(A, i), x))i++;
                                if (i < j) {
                                    this._swap(A, i, j);
                                    i++;
                                    j--;
                                } else return j;
                            }
                        }
                    },
                    {
                        key: "_get",
                        value: function _get(object, index) {
                            if (object instanceof LinkedList) return object.get_object_at(index);
                            else return object[index];
                        }
                    },
                    {
                        key: "_set",
                        value: function _set(object, index, value) {
                            if (object instanceof LinkedList) object.set_object_at(index, value);
                            else object[index] = value;
                        }
                    },
                    {
                        key: "_swap",
                        value: function _swap(A, i, j) {
                            var temp = this._get(A, i);
                            this._set(A, i, this._get(A, j));
                            this._set(A, j, temp);
                        }
                    },
                    {
                        key: "_defaultCompareFunction",
                        value: function _defaultCompareFunction(a, b) {
                            return b > a;
                        }
                    }
                ]);
                return Quicksort;
            }();
            module1.exports = Quicksort;
        /***/ },
        /* 26 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            // Singular Value Decomposition implementation
            function SVD() {}
            /* Below singular value decomposition (svd) code including hypot function is adopted from https://github.com/dragonfly-ai/JamaJS
   Some changes are applied to make the code compatible with the fcose code and to make it independent from Jama.
   Input matrix is changed to a 2D array instead of Jama matrix. Matrix dimensions are taken according to 2D array instead of using Jama functions.
   An object that includes singular value components is created for return. 
   The types of input parameters of the hypot function are removed. 
   let is used instead of var for the variable initialization.
*/ /*
                               Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/ SVD.svd = function(A) {
                this.U = null;
                this.V = null;
                this.s = null;
                this.m = 0;
                this.n = 0;
                this.m = A.length;
                this.n = A[0].length;
                var nu = Math.min(this.m, this.n);
                this.s = function(s) {
                    var a = [];
                    while(s-- > 0)a.push(0);
                    return a;
                }(Math.min(this.m + 1, this.n));
                this.U = function(dims) {
                    var allocate = function allocate(dims) {
                        if (dims.length == 0) return 0;
                        else {
                            var array = [];
                            for(var i = 0; i < dims[0]; i++)array.push(allocate(dims.slice(1)));
                            return array;
                        }
                    };
                    return allocate(dims);
                }([
                    this.m,
                    nu
                ]);
                this.V = function(dims) {
                    var allocate = function allocate(dims) {
                        if (dims.length == 0) return 0;
                        else {
                            var array = [];
                            for(var i = 0; i < dims[0]; i++)array.push(allocate(dims.slice(1)));
                            return array;
                        }
                    };
                    return allocate(dims);
                }([
                    this.n,
                    this.n
                ]);
                var e = function(s) {
                    var a = [];
                    while(s-- > 0)a.push(0);
                    return a;
                }(this.n);
                var work = function(s) {
                    var a = [];
                    while(s-- > 0)a.push(0);
                    return a;
                }(this.m);
                var wantu = true;
                var wantv = true;
                var nct = Math.min(this.m - 1, this.n);
                var nrt = Math.max(0, Math.min(this.n - 2, this.m));
                for(var k = 0; k < Math.max(nct, nrt); k++){
                    if (k < nct) {
                        this.s[k] = 0;
                        for(var i = k; i < this.m; i++)this.s[k] = SVD.hypot(this.s[k], A[i][k]);
                        if (this.s[k] !== 0.0) {
                            if (A[k][k] < 0.0) this.s[k] = -this.s[k];
                            for(var _i = k; _i < this.m; _i++)A[_i][k] /= this.s[k];
                            A[k][k] += 1.0;
                        }
                        this.s[k] = -this.s[k];
                    }
                    for(var j = k + 1; j < this.n; j++){
                        if (function(lhs, rhs) {
                            return lhs && rhs;
                        }(k < nct, this.s[k] !== 0.0)) {
                            var t = 0;
                            for(var _i2 = k; _i2 < this.m; _i2++)t += A[_i2][k] * A[_i2][j];
                            t = -t / A[k][k];
                            for(var _i3 = k; _i3 < this.m; _i3++)A[_i3][j] += t * A[_i3][k];
                        }
                        e[j] = A[k][j];
                    }
                    if (function(lhs, rhs) {
                        return lhs && rhs;
                    }(wantu, k < nct)) for(var _i4 = k; _i4 < this.m; _i4++)this.U[_i4][k] = A[_i4][k];
                    if (k < nrt) {
                        e[k] = 0;
                        for(var _i5 = k + 1; _i5 < this.n; _i5++)e[k] = SVD.hypot(e[k], e[_i5]);
                        if (e[k] !== 0.0) {
                            if (e[k + 1] < 0.0) e[k] = -e[k];
                            for(var _i6 = k + 1; _i6 < this.n; _i6++)e[_i6] /= e[k];
                            e[k + 1] += 1.0;
                        }
                        e[k] = -e[k];
                        if (function(lhs, rhs) {
                            return lhs && rhs;
                        }(k + 1 < this.m, e[k] !== 0.0)) {
                            for(var _i7 = k + 1; _i7 < this.m; _i7++)work[_i7] = 0.0;
                            for(var _j = k + 1; _j < this.n; _j++)for(var _i8 = k + 1; _i8 < this.m; _i8++)work[_i8] += e[_j] * A[_i8][_j];
                            for(var _j2 = k + 1; _j2 < this.n; _j2++){
                                var _t = -e[_j2] / e[k + 1];
                                for(var _i9 = k + 1; _i9 < this.m; _i9++)A[_i9][_j2] += _t * work[_i9];
                            }
                        }
                        if (wantv) for(var _i10 = k + 1; _i10 < this.n; _i10++)this.V[_i10][k] = e[_i10];
                    }
                }
                var p = Math.min(this.n, this.m + 1);
                if (nct < this.n) this.s[nct] = A[nct][nct];
                if (this.m < p) this.s[p - 1] = 0.0;
                if (nrt + 1 < p) e[nrt] = A[nrt][p - 1];
                e[p - 1] = 0.0;
                if (wantu) {
                    for(var _j3 = nct; _j3 < nu; _j3++){
                        for(var _i11 = 0; _i11 < this.m; _i11++)this.U[_i11][_j3] = 0.0;
                        this.U[_j3][_j3] = 1.0;
                    }
                    for(var _k = nct - 1; _k >= 0; _k--)if (this.s[_k] !== 0.0) {
                        for(var _j4 = _k + 1; _j4 < nu; _j4++){
                            var _t2 = 0;
                            for(var _i12 = _k; _i12 < this.m; _i12++)_t2 += this.U[_i12][_k] * this.U[_i12][_j4];
                            _t2 = -_t2 / this.U[_k][_k];
                            for(var _i13 = _k; _i13 < this.m; _i13++)this.U[_i13][_j4] += _t2 * this.U[_i13][_k];
                        }
                        for(var _i14 = _k; _i14 < this.m; _i14++)this.U[_i14][_k] = -this.U[_i14][_k];
                        this.U[_k][_k] = 1.0 + this.U[_k][_k];
                        for(var _i15 = 0; _i15 < _k - 1; _i15++)this.U[_i15][_k] = 0.0;
                    } else {
                        for(var _i16 = 0; _i16 < this.m; _i16++)this.U[_i16][_k] = 0.0;
                        this.U[_k][_k] = 1.0;
                    }
                }
                if (wantv) for(var _k2 = this.n - 1; _k2 >= 0; _k2--){
                    if (function(lhs, rhs) {
                        return lhs && rhs;
                    }(_k2 < nrt, e[_k2] !== 0.0)) for(var _j5 = _k2 + 1; _j5 < nu; _j5++){
                        var _t3 = 0;
                        for(var _i17 = _k2 + 1; _i17 < this.n; _i17++)_t3 += this.V[_i17][_k2] * this.V[_i17][_j5];
                        _t3 = -_t3 / this.V[_k2 + 1][_k2];
                        for(var _i18 = _k2 + 1; _i18 < this.n; _i18++)this.V[_i18][_j5] += _t3 * this.V[_i18][_k2];
                    }
                    for(var _i19 = 0; _i19 < this.n; _i19++)this.V[_i19][_k2] = 0.0;
                    this.V[_k2][_k2] = 1.0;
                }
                var pp = p - 1;
                var iter = 0;
                var eps = Math.pow(2.0, -52);
                var tiny = Math.pow(2.0, -966);
                while(p > 0){
                    var _k3 = void 0;
                    var kase = void 0;
                    for(_k3 = p - 2; _k3 >= -1; _k3--){
                        if (_k3 === -1) break;
                        if (Math.abs(e[_k3]) <= tiny + eps * (Math.abs(this.s[_k3]) + Math.abs(this.s[_k3 + 1]))) {
                            e[_k3] = 0.0;
                            break;
                        }
                    }
                    if (_k3 === p - 2) kase = 4;
                    else {
                        var ks = void 0;
                        for(ks = p - 1; ks >= _k3; ks--){
                            if (ks === _k3) break;
                            var _t4 = (ks !== p ? Math.abs(e[ks]) : 0.0) + (ks !== _k3 + 1 ? Math.abs(e[ks - 1]) : 0.0);
                            if (Math.abs(this.s[ks]) <= tiny + eps * _t4) {
                                this.s[ks] = 0.0;
                                break;
                            }
                        }
                        if (ks === _k3) kase = 3;
                        else if (ks === p - 1) kase = 1;
                        else {
                            kase = 2;
                            _k3 = ks;
                        }
                    }
                    _k3++;
                    switch(kase){
                        case 1:
                            var f = e[p - 2];
                            e[p - 2] = 0.0;
                            for(var _j6 = p - 2; _j6 >= _k3; _j6--){
                                var _t5 = SVD.hypot(this.s[_j6], f);
                                var cs = this.s[_j6] / _t5;
                                var sn = f / _t5;
                                this.s[_j6] = _t5;
                                if (_j6 !== _k3) {
                                    f = -sn * e[_j6 - 1];
                                    e[_j6 - 1] = cs * e[_j6 - 1];
                                }
                                if (wantv) for(var _i20 = 0; _i20 < this.n; _i20++){
                                    _t5 = cs * this.V[_i20][_j6] + sn * this.V[_i20][p - 1];
                                    this.V[_i20][p - 1] = -sn * this.V[_i20][_j6] + cs * this.V[_i20][p - 1];
                                    this.V[_i20][_j6] = _t5;
                                }
                            }
                            break;
                        case 2:
                            var _f = e[_k3 - 1];
                            e[_k3 - 1] = 0.0;
                            for(var _j7 = _k3; _j7 < p; _j7++){
                                var _t6 = SVD.hypot(this.s[_j7], _f);
                                var _cs = this.s[_j7] / _t6;
                                var _sn = _f / _t6;
                                this.s[_j7] = _t6;
                                _f = -_sn * e[_j7];
                                e[_j7] = _cs * e[_j7];
                                if (wantu) for(var _i21 = 0; _i21 < this.m; _i21++){
                                    _t6 = _cs * this.U[_i21][_j7] + _sn * this.U[_i21][_k3 - 1];
                                    this.U[_i21][_k3 - 1] = -_sn * this.U[_i21][_j7] + _cs * this.U[_i21][_k3 - 1];
                                    this.U[_i21][_j7] = _t6;
                                }
                            }
                            break;
                        case 3:
                            var scale = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[p - 1]), Math.abs(this.s[p - 2])), Math.abs(e[p - 2])), Math.abs(this.s[_k3])), Math.abs(e[_k3]));
                            var sp = this.s[p - 1] / scale;
                            var spm1 = this.s[p - 2] / scale;
                            var epm1 = e[p - 2] / scale;
                            var sk = this.s[_k3] / scale;
                            var ek = e[_k3] / scale;
                            var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;
                            var c = sp * epm1 * (sp * epm1);
                            var shift = 0.0;
                            if (function(lhs, rhs) {
                                return lhs || rhs;
                            }(b !== 0.0, c !== 0.0)) {
                                shift = Math.sqrt(b * b + c);
                                if (b < 0.0) shift = -shift;
                                shift = c / (b + shift);
                            }
                            var _f2 = (sk + sp) * (sk - sp) + shift;
                            var g = sk * ek;
                            for(var _j8 = _k3; _j8 < p - 1; _j8++){
                                var _t7 = SVD.hypot(_f2, g);
                                var _cs2 = _f2 / _t7;
                                var _sn2 = g / _t7;
                                if (_j8 !== _k3) e[_j8 - 1] = _t7;
                                _f2 = _cs2 * this.s[_j8] + _sn2 * e[_j8];
                                e[_j8] = _cs2 * e[_j8] - _sn2 * this.s[_j8];
                                g = _sn2 * this.s[_j8 + 1];
                                this.s[_j8 + 1] = _cs2 * this.s[_j8 + 1];
                                if (wantv) for(var _i22 = 0; _i22 < this.n; _i22++){
                                    _t7 = _cs2 * this.V[_i22][_j8] + _sn2 * this.V[_i22][_j8 + 1];
                                    this.V[_i22][_j8 + 1] = -_sn2 * this.V[_i22][_j8] + _cs2 * this.V[_i22][_j8 + 1];
                                    this.V[_i22][_j8] = _t7;
                                }
                                _t7 = SVD.hypot(_f2, g);
                                _cs2 = _f2 / _t7;
                                _sn2 = g / _t7;
                                this.s[_j8] = _t7;
                                _f2 = _cs2 * e[_j8] + _sn2 * this.s[_j8 + 1];
                                this.s[_j8 + 1] = -_sn2 * e[_j8] + _cs2 * this.s[_j8 + 1];
                                g = _sn2 * e[_j8 + 1];
                                e[_j8 + 1] = _cs2 * e[_j8 + 1];
                                if (wantu && _j8 < this.m - 1) for(var _i23 = 0; _i23 < this.m; _i23++){
                                    _t7 = _cs2 * this.U[_i23][_j8] + _sn2 * this.U[_i23][_j8 + 1];
                                    this.U[_i23][_j8 + 1] = -_sn2 * this.U[_i23][_j8] + _cs2 * this.U[_i23][_j8 + 1];
                                    this.U[_i23][_j8] = _t7;
                                }
                            }
                            e[p - 2] = _f2;
                            iter = iter + 1;
                            break;
                        case 4:
                            if (this.s[_k3] <= 0.0) {
                                this.s[_k3] = this.s[_k3] < 0.0 ? -this.s[_k3] : 0.0;
                                if (wantv) for(var _i24 = 0; _i24 <= pp; _i24++)this.V[_i24][_k3] = -this.V[_i24][_k3];
                            }
                            while(_k3 < pp){
                                if (this.s[_k3] >= this.s[_k3 + 1]) break;
                                var _t8 = this.s[_k3];
                                this.s[_k3] = this.s[_k3 + 1];
                                this.s[_k3 + 1] = _t8;
                                if (wantv && _k3 < this.n - 1) for(var _i25 = 0; _i25 < this.n; _i25++){
                                    _t8 = this.V[_i25][_k3 + 1];
                                    this.V[_i25][_k3 + 1] = this.V[_i25][_k3];
                                    this.V[_i25][_k3] = _t8;
                                }
                                if (wantu && _k3 < this.m - 1) for(var _i26 = 0; _i26 < this.m; _i26++){
                                    _t8 = this.U[_i26][_k3 + 1];
                                    this.U[_i26][_k3 + 1] = this.U[_i26][_k3];
                                    this.U[_i26][_k3] = _t8;
                                }
                                _k3++;
                            }
                            iter = 0;
                            p--;
                            break;
                    }
                }
                var result = {
                    U: this.U,
                    V: this.V,
                    S: this.s
                };
                return result;
            };
            // sqrt(a^2 + b^2) without under/overflow.
            SVD.hypot = function(a, b) {
                var r = void 0;
                if (Math.abs(a) > Math.abs(b)) {
                    r = b / a;
                    r = Math.abs(a) * Math.sqrt(1 + r * r);
                } else if (b != 0) {
                    r = a / b;
                    r = Math.abs(b) * Math.sqrt(1 + r * r);
                } else r = 0.0;
                return r;
            };
            module1.exports = SVD;
        /***/ },
        /* 27 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            /**
 *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string
 *   sequences by S.B.Needleman and C.D.Wunsch (1970).
 *
 *   Aside from the inputs, you can assign the scores for,
 *   - Match: The two characters at the current index are same.
 *   - Mismatch: The two characters at the current index are different.
 *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.
 */ var NeedlemanWunsch = function() {
                function NeedlemanWunsch(sequence1, sequence2) {
                    var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
                    var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
                    var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;
                    _classCallCheck(this, NeedlemanWunsch);
                    this.sequence1 = sequence1;
                    this.sequence2 = sequence2;
                    this.match_score = match_score;
                    this.mismatch_penalty = mismatch_penalty;
                    this.gap_penalty = gap_penalty;
                    // Just the remove redundancy
                    this.iMax = sequence1.length + 1;
                    this.jMax = sequence2.length + 1;
                    // Grid matrix of scores
                    this.grid = new Array(this.iMax);
                    for(var i = 0; i < this.iMax; i++){
                        this.grid[i] = new Array(this.jMax);
                        for(var j = 0; j < this.jMax; j++)this.grid[i][j] = 0;
                    }
                    // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)
                    this.tracebackGrid = new Array(this.iMax);
                    for(var _i = 0; _i < this.iMax; _i++){
                        this.tracebackGrid[_i] = new Array(this.jMax);
                        for(var _j = 0; _j < this.jMax; _j++)this.tracebackGrid[_i][_j] = [
                            null,
                            null,
                            null
                        ];
                    }
                    // The aligned sequences (return multiple possibilities)
                    this.alignments = [];
                    // Final alignment score
                    this.score = -1;
                    // Calculate scores and tracebacks
                    this.computeGrids();
                }
                _createClass(NeedlemanWunsch, [
                    {
                        key: "getScore",
                        value: function getScore() {
                            return this.score;
                        }
                    },
                    {
                        key: "getAlignments",
                        value: function getAlignments() {
                            return this.alignments;
                        }
                    },
                    {
                        key: "computeGrids",
                        value: function computeGrids() {
                            // Fill in the first row
                            for(var j = 1; j < this.jMax; j++){
                                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;
                                this.tracebackGrid[0][j] = [
                                    false,
                                    false,
                                    true
                                ];
                            }
                            // Fill in the first column
                            for(var i = 1; i < this.iMax; i++){
                                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;
                                this.tracebackGrid[i][0] = [
                                    false,
                                    true,
                                    false
                                ];
                            }
                            // Fill the rest of the grid
                            for(var _i2 = 1; _i2 < this.iMax; _i2++)for(var _j2 = 1; _j2 < this.jMax; _j2++){
                                // Find the max score(s) among [`Diag`, `Up`, `Left`]
                                var diag = void 0;
                                if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;
                                else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;
                                var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;
                                var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;
                                // If there exists multiple max values, capture them for multiple paths
                                var maxOf = [
                                    diag,
                                    up,
                                    left
                                ];
                                var indices = this.arrayAllMaxIndexes(maxOf);
                                // Update Grids
                                this.grid[_i2][_j2] = maxOf[indices[0]];
                                this.tracebackGrid[_i2][_j2] = [
                                    indices.includes(0),
                                    indices.includes(1),
                                    indices.includes(2)
                                ];
                            }
                            // Update alignment score
                            this.score = this.grid[this.iMax - 1][this.jMax - 1];
                        }
                    },
                    {
                        key: "alignmentTraceback",
                        value: function alignmentTraceback() {
                            var inProcessAlignments = [];
                            inProcessAlignments.push({
                                pos: [
                                    this.sequence1.length,
                                    this.sequence2.length
                                ],
                                seq1: "",
                                seq2: ""
                            });
                            while(inProcessAlignments[0]){
                                var current = inProcessAlignments[0];
                                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];
                                if (directions[0]) inProcessAlignments.push({
                                    pos: [
                                        current.pos[0] - 1,
                                        current.pos[1] - 1
                                    ],
                                    seq1: this.sequence1[current.pos[0] - 1] + current.seq1,
                                    seq2: this.sequence2[current.pos[1] - 1] + current.seq2
                                });
                                if (directions[1]) inProcessAlignments.push({
                                    pos: [
                                        current.pos[0] - 1,
                                        current.pos[1]
                                    ],
                                    seq1: this.sequence1[current.pos[0] - 1] + current.seq1,
                                    seq2: "-" + current.seq2
                                });
                                if (directions[2]) inProcessAlignments.push({
                                    pos: [
                                        current.pos[0],
                                        current.pos[1] - 1
                                    ],
                                    seq1: "-" + current.seq1,
                                    seq2: this.sequence2[current.pos[1] - 1] + current.seq2
                                });
                                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({
                                    sequence1: current.seq1,
                                    sequence2: current.seq2
                                });
                                inProcessAlignments.shift();
                            }
                            return this.alignments;
                        }
                    },
                    {
                        key: "getAllIndexes",
                        value: function getAllIndexes(arr, val) {
                            var indexes = [], i = -1;
                            while((i = arr.indexOf(val, i + 1)) !== -1)indexes.push(i);
                            return indexes;
                        }
                    },
                    {
                        key: "arrayAllMaxIndexes",
                        value: function arrayAllMaxIndexes(array) {
                            return this.getAllIndexes(array, Math.max.apply(null, array));
                        }
                    }
                ]);
                return NeedlemanWunsch;
            }();
            module1.exports = NeedlemanWunsch;
        /***/ },
        /* 28 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var layoutBase = function layoutBase() {
                return;
            };
            layoutBase.FDLayout = __webpack_require__(18);
            layoutBase.FDLayoutConstants = __webpack_require__(4);
            layoutBase.FDLayoutEdge = __webpack_require__(19);
            layoutBase.FDLayoutNode = __webpack_require__(20);
            layoutBase.DimensionD = __webpack_require__(21);
            layoutBase.HashMap = __webpack_require__(22);
            layoutBase.HashSet = __webpack_require__(23);
            layoutBase.IGeometry = __webpack_require__(8);
            layoutBase.IMath = __webpack_require__(9);
            layoutBase.Integer = __webpack_require__(10);
            layoutBase.Point = __webpack_require__(12);
            layoutBase.PointD = __webpack_require__(5);
            layoutBase.RandomSeed = __webpack_require__(16);
            layoutBase.RectangleD = __webpack_require__(13);
            layoutBase.Transform = __webpack_require__(17);
            layoutBase.UniqueIDGeneretor = __webpack_require__(14);
            layoutBase.Quicksort = __webpack_require__(25);
            layoutBase.LinkedList = __webpack_require__(11);
            layoutBase.LGraphObject = __webpack_require__(2);
            layoutBase.LGraph = __webpack_require__(6);
            layoutBase.LEdge = __webpack_require__(1);
            layoutBase.LGraphManager = __webpack_require__(7);
            layoutBase.LNode = __webpack_require__(3);
            layoutBase.Layout = __webpack_require__(15);
            layoutBase.LayoutConstants = __webpack_require__(0);
            layoutBase.NeedlemanWunsch = __webpack_require__(27);
            layoutBase.Matrix = __webpack_require__(24);
            layoutBase.SVD = __webpack_require__(26);
            module1.exports = layoutBase;
        /***/ },
        /* 29 */ /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            function Emitter() {
                this.listeners = [];
            }
            var p = Emitter.prototype;
            p.addListener = function(event, callback) {
                this.listeners.push({
                    event: event,
                    callback: callback
                });
            };
            p.removeListener = function(event, callback) {
                for(var i = this.listeners.length; i >= 0; i--){
                    var l = this.listeners[i];
                    if (l.event === event && l.callback === callback) this.listeners.splice(i, 1);
                }
            };
            p.emit = function(event, data) {
                for(var i = 0; i < this.listeners.length; i++){
                    var l = this.listeners[i];
                    if (event === l.event) l.callback(data);
                }
            };
            module1.exports = Emitter;
        /***/ }
    ]);
});

},{}]},["7Aums","bNKaB"], "bNKaB", "parcelRequire066f")

//# sourceMappingURL=homepage.0641b553.js.map
