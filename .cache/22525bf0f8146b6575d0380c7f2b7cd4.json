{"dependencies":[{"name":"@polkadot/util","loc":{"line":3,"column":43}},{"name":"../keccak/index.js","loc":{"line":4,"column":28}},{"name":"../secp256k1/index.js","loc":{"line":5,"column":32}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ethereumEncode = ethereumEncode;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _index = require(\"../keccak/index.js\");\n\nvar _index2 = require(\"../secp256k1/index.js\");\n\nfunction getH160(u8a) {\n  if ([33, 65].includes(u8a.length)) {\n    u8a = (0, _index.keccakAsU8a)((0, _index2.secp256k1Expand)(u8a));\n  }\n\n  return u8a.slice(-20);\n} // Copyright 2017-2022 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction ethereumEncode(addressOrPublic) {\n  if (!addressOrPublic) {\n    return '0x';\n  }\n\n  const u8aAddress = (0, _util.u8aToU8a)(addressOrPublic);\n  (0, _util.assert)([20, 32, 33, 65].includes(u8aAddress.length), 'Invalid address or publicKey passed');\n  const address = (0, _util.u8aToHex)(getH160(u8aAddress), -1, false);\n  const hash = (0, _util.u8aToHex)((0, _index.keccakAsU8a)(address), -1, false);\n  let result = '';\n\n  for (let i = 0; i < 40; i++) {\n    result = `${result}${parseInt(hash[i], 16) > 7 ? address[i].toUpperCase() : address[i]}`;\n  }\n\n  return `0x${result}`;\n}"},"hash":"4fcd3f216da5b0a01c358c29f7dfd6ba"}