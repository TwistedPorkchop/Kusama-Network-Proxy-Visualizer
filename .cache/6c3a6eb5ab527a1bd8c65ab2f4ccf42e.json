{"dependencies":[{"name":"@polkadot/util","loc":{"line":3,"column":25}},{"name":"@polkadot/x-bigint","loc":{"line":4,"column":23}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.xxhash64 = xxhash64;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _xBigint = require(\"@polkadot/x-bigint\");\n\n// Adapted from https://github.com/pierrec/js-xxhash/blob/0504e76f3d31a21ae8528a7f590c7289c9e431d2/lib/xxhash64.js\n//\n// xxHash64 implementation in pure Javascript\n// Copyright (C) 2016, Pierre Curto\n// MIT license\n//\n// Changes made:\n//   - converted to TypeScript\n//   - uses native JS BigInt (no external dependencies)\n//   - support only for Uint8Array inputs\n//   - no constructor function, straight fill & digest\n//   - update code removed, only called once, no streams\n\n// Copyright 2017-2022 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst P64_1 = (0, _xBigint.BigInt)('11400714785074694791');\nconst P64_2 = (0, _xBigint.BigInt)('14029467366897019727');\nconst P64_3 = (0, _xBigint.BigInt)('1609587929392839161');\nconst P64_4 = (0, _xBigint.BigInt)('9650029242287828579');\nconst P64_5 = (0, _xBigint.BigInt)('2870177450012600261'); // mask for a u64, all bits set\n\nconst U64 = (0, _xBigint.BigInt)('0xffffffffffffffff'); // various constants\n\nconst _7n = (0, _xBigint.BigInt)(7);\n\nconst _11n = (0, _xBigint.BigInt)(11);\n\nconst _12n = (0, _xBigint.BigInt)(12);\n\nconst _16n = (0, _xBigint.BigInt)(16);\n\nconst _18n = (0, _xBigint.BigInt)(18);\n\nconst _23n = (0, _xBigint.BigInt)(23);\n\nconst _27n = (0, _xBigint.BigInt)(27);\n\nconst _29n = (0, _xBigint.BigInt)(29);\n\nconst _31n = (0, _xBigint.BigInt)(31);\n\nconst _32n = (0, _xBigint.BigInt)(32);\n\nconst _33n = (0, _xBigint.BigInt)(33);\n\nconst _64n = (0, _xBigint.BigInt)(64);\n\nconst _256n = (0, _xBigint.BigInt)(256);\n\nfunction rotl(a, b) {\n  const c = a & U64;\n  return (c << b | c >> _64n - b) & U64;\n}\n\nfunction fromU8a(u8a, p, count) {\n  const bigints = new Array(count);\n  let offset = 0;\n\n  for (let i = 0; i < count; i++, offset += 2) {\n    bigints[i] = (0, _xBigint.BigInt)(u8a[p + offset] | u8a[p + 1 + offset] << 8);\n  }\n\n  let result = _util._0n;\n\n  for (let i = count - 1; i >= 0; i--) {\n    result = (result << _16n) + bigints[i];\n  }\n\n  return result;\n}\n\nfunction toU8a(h64) {\n  const result = new Uint8Array(8);\n\n  for (let i = 7; i >= 0; i--) {\n    result[i] = Number(h64 % _256n);\n    h64 = h64 / _256n;\n  }\n\n  return result;\n}\n\nfunction state(initSeed) {\n  const seed = (0, _xBigint.BigInt)(initSeed);\n  return {\n    seed,\n    u8a: new Uint8Array(32),\n    u8asize: 0,\n    v1: seed + P64_1 + P64_2,\n    v2: seed + P64_2,\n    v3: seed,\n    v4: seed - P64_1\n  };\n}\n\nfunction init(state, input) {\n  if (input.length < 32) {\n    state.u8a.set(input);\n    state.u8asize = input.length;\n    return state;\n  }\n\n  const limit = input.length - 32;\n  let p = 0;\n\n  if (limit >= 0) {\n    const adjustV = v => P64_1 * rotl(v + P64_2 * fromU8a(input, p, 4), _31n);\n\n    do {\n      state.v1 = adjustV(state.v1);\n      p += 8;\n      state.v2 = adjustV(state.v2);\n      p += 8;\n      state.v3 = adjustV(state.v3);\n      p += 8;\n      state.v4 = adjustV(state.v4);\n      p += 8;\n    } while (p <= limit);\n  }\n\n  if (p < input.length) {\n    state.u8a.set(input.subarray(p, input.length));\n    state.u8asize = input.length - p;\n  }\n\n  return state;\n}\n\nfunction xxhash64(input, initSeed) {\n  const {\n    seed,\n    u8a,\n    u8asize,\n    v1,\n    v2,\n    v3,\n    v4\n  } = init(state(initSeed), input);\n  let p = 0;\n  let h64 = U64 & (0, _xBigint.BigInt)(input.length) + (input.length >= 32 ? ((((rotl(v1, _util._1n) + rotl(v2, _7n) + rotl(v3, _12n) + rotl(v4, _18n) ^ P64_1 * rotl(v1 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v2 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v3 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v4 * P64_2, _31n)) * P64_1 + P64_4 : seed + P64_5);\n\n  while (p <= u8asize - 8) {\n    h64 = U64 & P64_4 + P64_1 * rotl(h64 ^ P64_1 * rotl(P64_2 * fromU8a(u8a, p, 4), _31n), _27n);\n    p += 8;\n  }\n\n  if (p + 4 <= u8asize) {\n    h64 = U64 & P64_3 + P64_2 * rotl(h64 ^ P64_1 * fromU8a(u8a, p, 2), _23n);\n    p += 4;\n  }\n\n  while (p < u8asize) {\n    h64 = U64 & P64_1 * rotl(h64 ^ P64_5 * (0, _xBigint.BigInt)(u8a[p++]), _11n);\n  }\n\n  h64 = U64 & P64_2 * (h64 ^ h64 >> _33n);\n  h64 = U64 & P64_3 * (h64 ^ h64 >> _29n);\n  return toU8a(U64 & (h64 ^ h64 >> _32n));\n}"},"hash":"313c326136d4643f998eb6a954c93e20"}