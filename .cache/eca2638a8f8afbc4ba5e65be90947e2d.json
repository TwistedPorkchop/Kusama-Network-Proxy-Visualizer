{"dependencies":[{"name":"@polkadot/util","loc":{"line":3,"column":24}},{"name":"../bn.js","loc":{"line":4,"column":27}},{"name":"./defaults.js","loc":{"line":5,"column":31}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scryptFromU8a = scryptFromU8a;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _bn = require(\"../bn.js\");\n\nvar _defaults = require(\"./defaults.js\");\n\nfunction scryptFromU8a(data) {\n  const salt = data.subarray(0, 32);\n  const N = (0, _util.u8aToBn)(data.subarray(32 + 0, 32 + 4), _bn.BN_LE_OPTS).toNumber();\n  const p = (0, _util.u8aToBn)(data.subarray(32 + 4, 32 + 8), _bn.BN_LE_OPTS).toNumber();\n  const r = (0, _util.u8aToBn)(data.subarray(32 + 8, 32 + 12), _bn.BN_LE_OPTS).toNumber(); // FIXME At this moment we assume these to be fixed params, this is not a great idea since we lose flexibility\n  // and updates for greater security. However we need some protection against carefully-crafted params that can\n  // eat up CPU since these are user inputs. So we need to get very clever here, but atm we only allow the defaults\n  // and if no match, bail out\n\n  if (N !== _defaults.DEFAULT_PARAMS.N || p !== _defaults.DEFAULT_PARAMS.p || r !== _defaults.DEFAULT_PARAMS.r) {\n    throw new Error('Invalid injected scrypt params found');\n  }\n\n  return {\n    params: {\n      N,\n      p,\n      r\n    },\n    salt\n  };\n} // Copyright 2017-2022 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0"},"hash":"9f92db2f030925809cb7ccacd9588b38"}