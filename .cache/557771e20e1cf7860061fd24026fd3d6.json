{"dependencies":[{"name":"../bn/index.js","loc":{"line":3,"column":19}},{"name":"../u8a/index.js","loc":{"line":4,"column":34}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compactFromU8a = compactFromU8a;\nexports.compactFromU8aLim = compactFromU8aLim;\n\nvar _index = require(\"../bn/index.js\");\n\nvar _index2 = require(\"../u8a/index.js\");\n\n/**\n * @name compactFromU8a\n * @description Retrives the offset and encoded length from a compact-prefixed value\n * @example\n * <BR>\n *\n * ```javascript\n * import { compactFromU8a } from '@polkadot/util';\n *\n * const [offset, length] = compactFromU8a(new Uint8Array([254, 255, 3, 0]));\n *\n * console.log('value offset=', offset, 'length=', length); // 4, 0xffff\n * ```\n */\n\n// Copyright 2017-2022 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction compactFromU8a(input) {\n  const u8a = (0, _index2.u8aToU8a)(input); // The u8a is manually converted here for 1, 2 & 4 lengths, it is 2x faster\n  // than doing an additional call to u8aToBn (as with variable length)\n\n  switch (u8a[0] & 0b11) {\n    case 0b00:\n      return [1, new _index.BN(u8a[0] >>> 2)];\n\n    case 0b01:\n      return [2, new _index.BN(u8a[0] + (u8a[1] << 8) >>> 2)];\n\n    case 0b10:\n      // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n      // 32-bit, in the case where the top-most bit is set this yields a negative value\n      return [4, new _index.BN(u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + u8a[3] * 0x1000000 >>> 2)];\n    // 0b11\n\n    default:\n      {\n        // add 5 to shifted (4 for base length, 1 for this byte)\n        const offset = (u8a[0] >>> 2) + 5; // we unroll the loop\n\n        switch (offset) {\n          // there still could be 4 bytes data, similar to 0b10 above (with offsets)\n          case 5:\n            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n            // 32-bit, in the case where the top-most bit is set this yields a negative value\n            return [5, new _index.BN(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + u8a[4] * 0x1000000)];\n\n          case 6:\n            return [6, new _index.BN(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8)) * 0x1000000)];\n          // 6 bytes data is the maximum, 48 bits (56 would overflow)\n\n          case 7:\n            return [7, new _index.BN(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 0x1000000)];\n          // for anything else, use the non-unrolled version\n\n          default:\n            return [offset, (0, _index2.u8aToBn)(u8a.subarray(1, offset))];\n        }\n      }\n  }\n}\n/**\n * @name compactFromU8aLim\n * @description A limited version of [[compactFromU8a]], accepting only Uint8Array inputs for values <= 48 bits\n */\n\nfunction compactFromU8aLim(u8a) {\n  // The u8a is manually converted here for 1, 2 & 4 lengths, it is 2x faster\n  // than doing an additional call to u8aToBn (as with variable length)\n  switch (u8a[0] & 0b11) {\n    case 0b00:\n      return [1, u8a[0] >>> 2];\n\n    case 0b01:\n      return [2, u8a[0] + (u8a[1] << 8) >>> 2];\n\n    case 0b10:\n      // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n      // 32-bit, in the case where the top-most bit is set this yields a negative value\n      return [4, u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + u8a[3] * 0x1000000 >>> 2];\n    // 0b11\n\n    default:\n      {\n        // add 5 to shifted (4 for base length, 1 for this byte)\n        // we unroll the loop\n        switch ((u8a[0] >>> 2) + 5) {\n          // there still could be 4 bytes data, similar to 0b10 above (with offsets)\n          case 5:\n            return [5, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + u8a[4] * 0x1000000];\n\n          case 6:\n            return [6, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8)) * 0x1000000];\n          // 6 bytes data is the maximum, 48 bits (56 would overflow)\n\n          case 7:\n            return [7, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 0x1000000];\n          // for anything else, we are above the actual MAX_SAFE_INTEGER - bail out\n\n          default:\n            throw new Error('Compact input is > Number.MAX_SAFE_INTEGER');\n        }\n      }\n  }\n}"},"hash":"a6c0d8c68055db3e8833414948375585"}