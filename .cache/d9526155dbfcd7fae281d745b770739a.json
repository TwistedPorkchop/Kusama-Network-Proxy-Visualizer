{"dependencies":[{"name":"rxjs","loc":{"line":3,"column":39}},{"name":"@polkadot/util","loc":{"line":4,"column":45}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.promiseTracker = promiseTracker;\nexports.toPromiseMethod = toPromiseMethod;\n\nvar _rxjs = require(\"rxjs\");\n\nvar _util = require(\"@polkadot/util\");\n\n// a Promise completion tracker, wrapping an isComplete variable that ensures\n// that the promise only resolves once\n// Copyright 2017-2022 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction promiseTracker(resolve, reject) {\n  let isCompleted = false;\n  return {\n    reject: error => {\n      if (!isCompleted) {\n        isCompleted = true;\n        reject(error);\n      }\n\n      return _rxjs.EMPTY;\n    },\n    resolve: value => {\n      if (!isCompleted) {\n        isCompleted = true;\n        resolve(value);\n      }\n    }\n  };\n} // extract the arguments and callback params from a value array possibly containing a callback\n\nfunction extractArgs(args, needsCallback) {\n  const actualArgs = args.slice(); // If the last arg is a function, we pop it, put it into callback.\n  // actualArgs will then hold the actual arguments to be passed to `method`\n\n  const callback = args.length && (0, _util.isFunction)(args[args.length - 1]) ? actualArgs.pop() : undefined; // When we need a subscription, ensure that a valid callback is actually passed\n\n  (0, _util.assert)(!needsCallback || (0, _util.isFunction)(callback), 'Expected a callback to be passed with subscriptions');\n  return [actualArgs, callback];\n} // Decorate a call for a single-shot result - retrieve and then immediate unsubscribe\n\n\nfunction decorateCall(method, args) {\n  return new Promise((resolve, reject) => {\n    // single result tracker - either reject with Error or resolve with Codec result\n    const tracker = promiseTracker(resolve, reject); // encoding errors reject immediately, any result unsubscribes and resolves\n\n    const subscription = method(...args).pipe((0, _rxjs.catchError)(error => tracker.reject(error))).subscribe(result => {\n      tracker.resolve(result);\n      (0, _util.nextTick)(() => subscription.unsubscribe());\n    });\n  });\n} // Decorate a subscription where we have a result callback specified\n\n\nfunction decorateSubscribe(method, args, resultCb) {\n  return new Promise((resolve, reject) => {\n    // either reject with error or resolve with unsubscribe callback\n    const tracker = promiseTracker(resolve, reject); // errors reject immediately, the first result resolves with an unsubscribe promise, all results via callback\n\n    const subscription = method(...args).pipe((0, _rxjs.catchError)(error => tracker.reject(error)), (0, _rxjs.tap)(() => tracker.resolve(() => subscription.unsubscribe()))).subscribe(result => {\n      // queue result (back of queue to clear current)\n      (0, _util.nextTick)(() => resultCb(result));\n    });\n  });\n}\n/**\n * @description Decorate method for ApiPromise, where the results are converted to the Promise equivalent\n */\n\nfunction toPromiseMethod(method, options) {\n  const needsCallback = !!(options && options.methodName && options.methodName.includes('subscribe'));\n  return function (...args) {\n    const [actualArgs, resultCb] = extractArgs(args, needsCallback);\n    return resultCb ? decorateSubscribe(method, actualArgs, resultCb) : decorateCall((options === null || options === void 0 ? void 0 : options.overrideNoSub) || method, actualArgs);\n  };\n}"},"hash":"2b4e5186c2a2fa5ee2770d875891e64d"}