{"dependencies":[{"name":"@polkadot/util","loc":{"line":3,"column":56}},{"name":"../../bn.js","loc":{"line":4,"column":30}},{"name":"../../hmac/index.js","loc":{"line":5,"column":29}},{"name":"../../secp256k1/index.js","loc":{"line":6,"column":67}},{"name":"../validatePath.js","loc":{"line":7,"column":41}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hdEthereum = hdEthereum;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _bn = require(\"../../bn.js\");\n\nvar _index = require(\"../../hmac/index.js\");\n\nvar _index2 = require(\"../../secp256k1/index.js\");\n\nvar _validatePath = require(\"../validatePath.js\");\n\nconst MASTER_SECRET = (0, _util.stringToU8a)('Bitcoin seed'); // Copyright 2017-2022 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nfunction createCoded(secretKey, chainCode) {\n  return {\n    chainCode,\n    publicKey: (0, _index2.secp256k1PairFromSeed)(secretKey).publicKey,\n    secretKey\n  };\n}\n\nfunction deriveChild(hd, index) {\n  const indexBuffer = (0, _util.bnToU8a)(index, _bn.BN_BE_32_OPTS);\n  const data = index >= _validatePath.HARDENED ? (0, _util.u8aConcat)(new Uint8Array(1), hd.secretKey, indexBuffer) : (0, _util.u8aConcat)(hd.publicKey, indexBuffer);\n\n  try {\n    const I = (0, _index.hmacShaAsU8a)(hd.chainCode, data, 512);\n    return createCoded((0, _index2.secp256k1PrivateKeyTweakAdd)(hd.secretKey, I.slice(0, 32)), I.slice(32));\n  } catch (err) {\n    // In case parse256(IL) >= n or ki == 0, proceed with the next value for i\n    return deriveChild(hd, index + 1);\n  }\n}\n\nfunction hdEthereum(seed, path = '') {\n  const I = (0, _index.hmacShaAsU8a)(MASTER_SECRET, seed, 512);\n  let hd = createCoded(I.slice(0, 32), I.slice(32));\n\n  if (!path || path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return hd;\n  }\n\n  (0, _util.assert)((0, _validatePath.hdValidatePath)(path), 'Invalid derivation path');\n  const parts = path.split('/').slice(1);\n\n  for (const p of parts) {\n    hd = deriveChild(hd, parseInt(p, 10) + (p.length > 1 && p.endsWith(\"'\") ? _validatePath.HARDENED : 0));\n  }\n\n  return hd;\n}"},"hash":"2bb7e452499d80f9da20715e81844683"}