{"dependencies":[{"name":"@polkadot/util","loc":{"line":15,"column":46}},{"name":"../pbkdf2/index.js","loc":{"line":16,"column":29}},{"name":"../random/index.js","loc":{"line":17,"column":28}},{"name":"../sha/index.js","loc":{"line":18,"column":28}},{"name":"./bip39-en.js","loc":{"line":19,"column":29}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nexports.mnemonicToEntropy = mnemonicToEntropy;\nexports.entropyToMnemonic = entropyToMnemonic;\nexports.generateMnemonic = generateMnemonic;\nexports.validateMnemonic = validateMnemonic;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _index = require(\"../pbkdf2/index.js\");\n\nvar _index2 = require(\"../random/index.js\");\n\nvar _index3 = require(\"../sha/index.js\");\n\nvar _bip39En = require(\"./bip39-en.js\");\n\nvar _bip39En2 = _interopRequireDefault(_bip39En);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst INVALID_MNEMONIC = 'Invalid mnemonic'; // Copyright 2017-2022 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Adapted from the bitcoinjs/bip39 source\n// https://github.com/bitcoinjs/bip39/blob/1d063b6a6aee4145b34d701037cd3e67f5446ff9/ts_src/index.ts\n// Copyright (c) 2014, Wei Lu <luwei.here@gmail.com> and Daniel Cousens <email@dcousens.com>\n// ISC Licence\n//\n// Change made in this version -\n//   - Adjust formatting (just eslint differences)\n//   - Only English wordlist (this aligns with the wasm-crypto implementation)\n//   - Use util-crypto randomAsU8a (instead of randombytes)\n//   - Remove setting of wordlist passing of wordlist in functions\n//   - Remove mnemonicToSeed (we only use the sync variant)\n//   - generateMnemonic takes number of words (instead of strength)\n\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => x.toString(2).padStart(8, '0')).join('');\n}\n\nfunction deriveChecksumBits(entropyBuffer) {\n  return bytesToBinary(Array.from((0, _index3.sha256AsU8a)(entropyBuffer))).slice(0, entropyBuffer.length * 8 / 32);\n}\n\nfunction mnemonicToSeedSync(mnemonic, password) {\n  return (0, _index.pbkdf2Encode)((0, _util.stringToU8a)(normalize(mnemonic)), (0, _util.stringToU8a)(`mnemonic${normalize(password)}`)).password;\n}\nfunction mnemonicToEntropy(mnemonic) {\n  var _entropyBits$match;\n\n  const words = normalize(mnemonic).split(' ');\n  (0, _util.assert)(words.length % 3 === 0, INVALID_MNEMONIC); // convert word indices to 11 bit binary strings\n\n  const bits = words.map(word => {\n    const index = _bip39En2.default.indexOf(word);\n    (0, _util.assert)(index !== -1, INVALID_MNEMONIC);\n    return index.toString(2).padStart(11, '0');\n  }).join(''); // split the binary string into ENT/CS\n\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n  const entropyBytes = (_entropyBits$match = entropyBits.match(/(.{1,8})/g)) === null || _entropyBits$match === void 0 ? void 0 : _entropyBits$match.map(binaryToByte);\n  (0, _util.assert)(entropyBytes && entropyBytes.length % 4 === 0 && entropyBytes.length >= 16 && entropyBytes.length <= 32, INVALID_ENTROPY);\n  const entropy = (0, _util.u8aToU8a)(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n  (0, _util.assert)(newChecksum === checksumBits, INVALID_CHECKSUM);\n  return entropy;\n}\nfunction entropyToMnemonic(entropy) {\n  // 128 <= ENT <= 256\n  (0, _util.assert)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, INVALID_ENTROPY);\n  const entropyBits = bytesToBinary(Array.from(entropy));\n  const checksumBits = deriveChecksumBits(entropy); // we just set it prior, so this is a safe check\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n  return (entropyBits + checksumBits).match(/(.{1,11})/g).map(binary => _bip39En2.default[binaryToByte(binary)]).join(' ');\n}\nfunction generateMnemonic(numWords) {\n  return entropyToMnemonic((0, _index2.randomAsU8a)(numWords / 3 * 4));\n}\nfunction validateMnemonic(mnemonic) {\n  try {\n    mnemonicToEntropy(mnemonic);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}"},"hash":"0676c9f3475e2b8f519d0713019c229b"}