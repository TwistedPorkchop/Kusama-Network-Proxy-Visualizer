{"dependencies":[{"name":"../is/hex.js","loc":{"line":3,"column":55}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hexToU8a = hexToU8a;\n\nvar _hex = require(\"../is/hex.js\");\n\nconst CHARS = '0123456789abcdef'; // Copyright 2017-2022 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nconst UNHEX = new Array(256);\n\nfor (let i = 0; i < CHARS.length; i++) {\n  UNHEX[CHARS[i].charCodeAt(0)] = i;\n\n  if (i > 9) {\n    UNHEX[CHARS[i].toUpperCase().charCodeAt(0)] = i;\n  }\n}\n/**\n * @name hexToU8a\n * @summary Creates a Uint8Array object from a hex string.\n * @description\n * `null` inputs returns an empty `Uint8Array` result. Hex input values return the actual bytes value converted to a Uint8Array. Anything that is not a hex string (including the `0x` prefix) throws an error.\n * @example\n * <BR>\n *\n * ```javascript\n * import { hexToU8a } from '@polkadot/util';\n *\n * hexToU8a('0x80001f'); // Uint8Array([0x80, 0x00, 0x1f])\n * hexToU8a('0x80001f', 32); // Uint8Array([0x00, 0x80, 0x00, 0x1f])\n * ```\n */\n\nfunction hexToU8a(value, bitLength = -1) {\n  if (!value || value === '0x') {\n    return new Uint8Array();\n  }\n\n  let s = 0; // we don't use hexStringPrefix here - that has substring which adds\n  // additional overhead. Instead we duplicate the logic, just incrementing\n  // the sactual string pointer, ignoring the prefix as required\n\n  if (_hex.REGEX_HEX_PREFIXED.test(value)) {\n    s = 2;\n  } else if (!_hex.REGEX_HEX_NOPREFIX.test(value)) {\n    throw new Error(`Expected hex value to convert, found '${value}'`);\n  }\n\n  const strLength = (value.length - s) / 2;\n  const endLength = Math.ceil(bitLength === -1 ? strLength : bitLength / 8);\n  const result = new Uint8Array(endLength);\n  const offset = endLength > strLength ? endLength - strLength : 0;\n\n  for (let i = offset; i < endLength; i++, s += 2) {\n    // The big factor here is actually the string lookups. If we do\n    // HEX_TO_U16[value.substring()] we get an 10x slowdown. In the\n    // same vein using charCodeAt (as opposed to value[s] or value.charAt(s)) is\n    // also the faster operation by at least 2x with the character map above\n    result[i] = (UNHEX[value.charCodeAt(s)] << 4) + UNHEX[value.charCodeAt(s + 1)];\n  }\n\n  return result;\n}"},"hash":"354b595667a4a3c5eb0dc94abea6c433"}