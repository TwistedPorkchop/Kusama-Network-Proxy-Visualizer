{"dependencies":[{"name":"./format/formatDate.js","loc":{"line":3,"column":27}},{"name":"./is/bn.js","loc":{"line":4,"column":21}},{"name":"./is/buffer.js","loc":{"line":5,"column":25}},{"name":"./is/function.js","loc":{"line":6,"column":27}},{"name":"./is/object.js","loc":{"line":7,"column":25}},{"name":"./is/u8a.js","loc":{"line":8,"column":22}},{"name":"./u8a/toHex.js","loc":{"line":9,"column":25}},{"name":"./u8a/toU8a.js","loc":{"line":10,"column":25}},{"name":"./has.js","loc":{"line":11,"column":27}},{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loggerFormat = loggerFormat;\nexports.logger = logger;\n\nvar _formatDate = require(\"./format/formatDate.js\");\n\nvar _bn = require(\"./is/bn.js\");\n\nvar _buffer = require(\"./is/buffer.js\");\n\nvar _function = require(\"./is/function.js\");\n\nvar _object = require(\"./is/object.js\");\n\nvar _u8a = require(\"./is/u8a.js\");\n\nvar _toHex = require(\"./u8a/toHex.js\");\n\nvar _toU8a = require(\"./u8a/toU8a.js\");\n\nvar _has = require(\"./has.js\");\n\nconst logTo = {\n  debug: 'log',\n  error: 'error',\n  log: 'log',\n  warn: 'warn'\n}; // Copyright 2017-2022 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nfunction formatOther(value) {\n  if (value && (0, _object.isObject)(value) && value.constructor === Object) {\n    const result = {};\n\n    for (const k of Object.keys(value)) {\n      result[k] = loggerFormat(value[k]);\n    }\n\n    return result;\n  }\n\n  return value;\n}\n\nfunction loggerFormat(value) {\n  if (Array.isArray(value)) {\n    return value.map(loggerFormat);\n  } else if ((0, _bn.isBn)(value)) {\n    return value.toString();\n  } else if ((0, _u8a.isU8a)(value) || (0, _buffer.isBuffer)(value)) {\n    return (0, _toHex.u8aToHex)((0, _toU8a.u8aToU8a)(value));\n  }\n\n  return formatOther(value);\n}\n\nfunction formatWithLength(maxLength) {\n  return v => {\n    if (maxLength <= 0) {\n      return v;\n    }\n\n    const r = `${v}`;\n    return r.length < maxLength ? v : `${r.substring(0, maxLength)} ...`;\n  };\n}\n\nfunction apply(log, type, values, maxSize = -1) {\n  if (values.length === 1 && (0, _function.isFunction)(values[0])) {\n    const fnResult = values[0]();\n    return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult], maxSize);\n  }\n\n  console[logTo[log]]((0, _formatDate.formatDate)(new Date()), type, ...values.map(loggerFormat).map(formatWithLength(maxSize)));\n}\n\nfunction noop() {// noop\n}\n\nfunction isDebugOn(e, type) {\n  return !!e && (e === '*' || type === e || e.endsWith('*') && type.startsWith(e.slice(0, -1)));\n}\n\nfunction isDebugOff(e, type) {\n  return !!e && e.startsWith('-') && (type === e.slice(1) || e.endsWith('*') && type.startsWith(e.slice(1, -1)));\n}\n\nfunction getDebugFlag(env, type) {\n  let flag = false;\n\n  for (const e of env) {\n    if (isDebugOn(e, type)) {\n      flag = true;\n    } else if (isDebugOff(e, type)) {\n      flag = false;\n    }\n  }\n\n  return flag;\n}\n\nfunction parseEnv(type) {\n  const env = (_has.hasProcess ? process : {}).env || {};\n  const maxSize = parseInt(env.DEBUG_MAX || '-1', 10);\n  return [getDebugFlag((env.DEBUG || '').toLowerCase().split(','), type), isNaN(maxSize) ? -1 : maxSize];\n}\n/**\n * @name Logger\n * @summary Creates a consistent log interface for messages\n * @description\n * Returns a `Logger` that has `.log`, `.error`, `.warn` and `.debug` (controlled with environment `DEBUG=typeA,typeB`) methods. Logging is done with a consistent prefix (type of logger, date) followed by the actual message using the underlying console.\n * @example\n * <BR>\n *\n * ```javascript\n * import { logger } from '@polkadot/util';\n *\n * const l = logger('test');\n * ```\n */\n\nfunction logger(_type) {\n  const type = `${_type.toUpperCase()}:`.padStart(16);\n  const [isDebug, maxSize] = parseEnv(_type.toLowerCase());\n  return {\n    debug: isDebug ? (...values) => apply('debug', type, values, maxSize) : noop,\n    error: (...values) => apply('error', type, values),\n    log: (...values) => apply('log', type, values),\n    noop,\n    warn: (...values) => apply('warn', type, values)\n  };\n}"},"hash":"47b8543c7072a4ff4ecfa7bee460f700"}