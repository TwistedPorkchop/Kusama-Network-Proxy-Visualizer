{"dependencies":[{"name":"@polkadot/util","loc":{"line":3,"column":33}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDecode = createDecode;\nexports.createEncode = createEncode;\nexports.createIs = createIs;\nexports.createValidate = createValidate;\n\nvar _util = require(\"@polkadot/util\");\n\n// re-export the type so *.d.ts files don't have ../src imports\n\n/** @internal */\nfunction createDecode({\n  coder,\n  ipfs\n}, validate) {\n  return (value, ipfsCompat) => {\n    validate(value, ipfsCompat);\n    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);\n  };\n}\n/** @internal */\n\n// Copyright 2017-2022 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction createEncode({\n  coder,\n  ipfs\n}) {\n  return (value, ipfsCompat) => {\n    const out = coder.encode((0, _util.u8aToU8a)(value));\n    return ipfs && ipfsCompat ? `${ipfs}${out}` : out;\n  };\n}\n/** @internal */\n\nfunction createIs(validate) {\n  return (value, ipfsCompat) => {\n    try {\n      return validate(value, ipfsCompat);\n    } catch (error) {\n      return false;\n    }\n  };\n}\n/** @internal */\n\nfunction createValidate({\n  chars,\n  ipfs,\n  type\n}) {\n  return (value, ipfsCompat) => {\n    (0, _util.assert)(value && typeof value === 'string', () => `Expected non-null, non-empty ${type} string input`);\n\n    if (ipfs && ipfsCompat) {\n      (0, _util.assert)(value[0] === ipfs, () => `Expected ipfs-compatible ${type} to start with '${ipfs}'`);\n    }\n\n    for (let i = ipfsCompat ? 1 : 0; i < value.length; i++) {\n      (0, _util.assert)(chars.includes(value[i]) || value[i] === '=' && (i === value.length - 1 || !chars.includes(value[i + 1])), () => `Invalid ${type} character \"${value[i]}\" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);\n    }\n\n    return true;\n  };\n}"},"hash":"3943b4764f24e5d152f18ff904e421b3"}