{"dependencies":[{"name":"../bn/bn.js","loc":{"line":3,"column":19}},{"name":"../is/boolean.js","loc":{"line":4,"column":26}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.u8aToBn = undefined;\n\nvar _bn = require(\"../bn/bn.js\");\n\nvar _boolean = require(\"../is/boolean.js\");\n\n/**\n * @name u8aToBn\n * @summary Creates a BN from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual BN. `null` or `undefined` values returns an `0x0` value.\n * @param value The value to convert\n * @param options Options to pass while converting\n * @param options.isLe Convert using Little Endian (default)\n * @param options.isNegative Convert using two's complement\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToBn } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */\n\n/** @deprecated Use u8aToBn (value?: string | null, options?: ToBnOptions) */\n// Copyright 2017-2022 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction u8aToBn(value, options = {}) {\n  // NOTE: This is the same process as followed in the hexToBn conversion\n  // For Uint8Array, default to LE\n  const {\n    isLe = true,\n    isNegative = false\n  } = (0, _boolean.isBoolean)(options) ? {\n    isLe: options\n  } : options;\n  const count = value.length; // shortcut for <= u48 values - in this case the manual conversion\n  // here seems to be more efficient than passing the full array\n\n  if (count <= 6) {\n    if (isNegative) {\n      let result = 0;\n\n      if (isLe) {\n        // Most common case i{8, 16, 32} default LE SCALE-encoded\n        // For <= 32, we also optimize the xor to a single op\n        // (see the comments around unrolling in the next section)\n        switch (count) {\n          case 0:\n            return new _bn.BN(0);\n\n          case 1:\n            result = value[0] ^ 0x000000ff;\n            break;\n\n          case 2:\n            result = value[0] + (value[1] << 8) ^ 0x0000ffff;\n            break;\n\n          case 3:\n            result = value[0] + (value[1] << 8) + (value[2] << 16) ^ 0x00ffffff;\n            break;\n\n          case 4:\n            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n            // 32-bit, in the case where the top-most bit is set this yields a negative value\n            result = value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000 ^ 0xffffffff;\n            break;\n\n          case 5:\n            result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000 ^ 0xffffffff) + (value[4] ^ 0xff) * 0x100000000;\n            break;\n\n          default:\n            // 6\n            result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000 ^ 0xffffffff) + (value[4] + (value[5] << 8) ^ 0x0000ffff) * 0x100000000;\n            break;\n        }\n      } else {\n        for (let i = 0; i < count; i++) {\n          result = result * 0x100 + (value[i] ^ 0xff);\n        }\n      }\n\n      return count ? new _bn.BN(result * -1 - 1) : new _bn.BN(0);\n    } else if (isLe) {\n      // Most common case - u{8, 16, 32} default LE SCALE-encoded\n      //\n      // There are some slight benefits in unrolling this specific loop,\n      // however it comes with diminishing returns since here the actual\n      // `new BN` does seem to take up the bulk of the time\n      switch (count) {\n        case 0:\n          return new _bn.BN(0);\n\n        case 1:\n          return new _bn.BN(value[0]);\n\n        case 2:\n          return new _bn.BN(value[0] + (value[1] << 8));\n\n        case 3:\n          return new _bn.BN(value[0] + (value[1] << 8) + (value[2] << 16));\n\n        case 4:\n          // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n          // 32-bit, in the case where the top-most bit is set this yields a negative value\n          return new _bn.BN(value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1000000);\n\n        case 5:\n          return new _bn.BN(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 0x1000000);\n\n        default:\n          // 6\n          return new _bn.BN(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 0x1000000);\n      }\n    } else {\n      let result = 0;\n\n      for (let i = 0; i < count; i++) {\n        result = result * 0x100 + value[i];\n      }\n\n      return new _bn.BN(result);\n    }\n  }\n\n  return isNegative ? new _bn.BN(value, isLe ? 'le' : 'be').fromTwos(value.length * 8) : new _bn.BN(value, isLe ? 'le' : 'be');\n}\n\nexports.u8aToBn = u8aToBn;"},"hash":"4de098bd837fc17ba1341cc70f553a52"}