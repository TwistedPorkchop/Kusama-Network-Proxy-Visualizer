{"dependencies":[{"name":"@polkadot/x-bigint","loc":{"line":3,"column":23}},{"name":"../bi/consts.js","loc":{"line":4,"column":20}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.u8aToBigInt = u8aToBigInt;\n\nvar _xBigint = require(\"@polkadot/x-bigint\");\n\nvar _consts = require(\"../bi/consts.js\");\n\n// Copyright 2017-2022 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst U8_MAX = (0, _xBigint.BigInt)(256);\nconst U16_MAX = (0, _xBigint.BigInt)(256 * 256);\n/**\n * @name u8aToBigInt\n * @summary Creates a BigInt from a Uint8Array object.\n */\n\nfunction u8aToBigInt(value, {\n  isLe = true,\n  isNegative = false\n} = {}) {\n  if (!value || !value.length) {\n    return (0, _xBigint.BigInt)(0);\n  }\n\n  const u8a = isLe ? value : value.reverse();\n  const dvI = new DataView(u8a.buffer, u8a.byteOffset);\n  const mod = u8a.length % 2;\n  let result = (0, _xBigint.BigInt)(0); // This is mostly written for readability (with the single isNegative shortcut),\n  // as opposed to performance, e.g. `u8aToBn` does loop unrolling, etc.\n\n  if (isNegative) {\n    for (let i = u8a.length - 2; i >= mod; i -= 2) {\n      result = result * U16_MAX + (0, _xBigint.BigInt)(dvI.getUint16(i, true) ^ 0xffff);\n    }\n\n    if (mod) {\n      result = result * U8_MAX + (0, _xBigint.BigInt)(dvI.getUint8(0) ^ 0xff);\n    }\n  } else {\n    for (let i = u8a.length - 2; i >= mod; i -= 2) {\n      result = result * U16_MAX + (0, _xBigint.BigInt)(dvI.getUint16(i, true));\n    }\n\n    if (mod) {\n      result = result * U8_MAX + (0, _xBigint.BigInt)(dvI.getUint8(0));\n    }\n  }\n\n  return isNegative ? result * -_consts._1n - _consts._1n : result;\n}"},"hash":"e1bec6471e3ed1e94cc9ce304e1bd5bc"}