{"dependencies":[{"name":"@polkadot/x-bigint","loc":{"line":3,"column":23}},{"name":"../object/spread.js","loc":{"line":4,"column":29}},{"name":"./consts.js","loc":{"line":5,"column":25}},{"name":"./toBigInt.js","loc":{"line":6,"column":26}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nToU8a = nToU8a;\n\nvar _xBigint = require(\"@polkadot/x-bigint\");\n\nvar _spread = require(\"../object/spread.js\");\n\nvar _consts = require(\"./consts.js\");\n\nvar _toBigInt = require(\"./toBigInt.js\");\n\n// Copyright 2017-2022 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst DIV = (0, _xBigint.BigInt)(256);\nconst NEG_MASK = (0, _xBigint.BigInt)(0xff);\n\nfunction toU8a(value, {\n  isLe,\n  isNegative\n}) {\n  const arr = [];\n\n  if (isNegative) {\n    value = (value + _consts._1n) * -_consts._1n;\n  }\n\n  while (value !== _consts._0n) {\n    const mod = value % DIV;\n    const val = Number(isNegative ? mod ^ NEG_MASK : mod);\n\n    if (isLe) {\n      arr.push(val);\n    } else {\n      arr.unshift(val);\n    }\n\n    value = (value - mod) / DIV;\n  }\n\n  return Uint8Array.from(arr);\n}\n/**\n * @name nToU8a\n * @summary Creates a Uint8Array object from a bigint.\n */\n\nfunction nToU8a(value, options) {\n  const opts = (0, _spread.objectSpread)({\n    bitLength: -1,\n    isLe: true,\n    isNegative: false\n  }, options);\n  const valueBi = (0, _toBigInt.nToBigInt)(value);\n\n  if (valueBi === _consts._0n) {\n    return opts.bitLength === -1 ? new Uint8Array() : new Uint8Array(Math.ceil((opts.bitLength || 0) / 8));\n  }\n\n  const u8a = toU8a(valueBi, opts);\n\n  if (opts.bitLength === -1) {\n    return u8a;\n  }\n\n  const byteLength = Math.ceil((opts.bitLength || 0) / 8);\n  const output = new Uint8Array(byteLength);\n\n  if (opts.isNegative) {\n    output.fill(0xff);\n  }\n\n  output.set(u8a, opts.isLe ? 0 : byteLength - u8a.length);\n  return output;\n}"},"hash":"0280240c3882fa54f4470666a39fb936"}