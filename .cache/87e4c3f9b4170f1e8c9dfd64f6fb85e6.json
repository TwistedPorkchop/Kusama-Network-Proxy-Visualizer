{"dependencies":[],"generated":{"js":"//Requirements\r\n\r\n// Construct\r\nconst wsProvider = new WsProvider('wss://kusama-rpc.polkadot.io');\r\nconst api = await ApiPromise.create({ provider: wsProvider });\r\n\r\n\r\n(function($){\r\n\r\n  var Renderer = function(canvas){\r\n    var canvas = $(canvas).get(0)\r\n    var ctx = canvas.getContext(\"2d\");\r\n    var particleSystem\r\n\r\n    var that = {\r\n      init:function(system){\r\n        // the particle system will call the init function once, right before the\r\n        // first frame is to be drawn. it's a good place to set up the canvas and\r\n        // to pass the canvas size to the particle system\r\n        //\r\n        // save a reference to the particle system for use in the .redraw() loop\r\n        particleSystem = system\r\n\r\n        // inform the system of the screen dimensions so it can map coords for us.\r\n        // if the canvas is ever resized, screenSize should be called again with\r\n        // the new dimensions\r\n        particleSystem.screenSize(canvas.width, canvas.height) \r\n        particleSystem.screenPadding(80) // leave an extra 80px of whitespace per side\r\n        \r\n        // set up some event handlers to allow for node-dragging\r\n        that.initMouseHandling()\r\n      },\r\n      \r\n      redraw:function(){\r\n        // \r\n        // redraw will be called repeatedly during the run whenever the node positions\r\n        // change. the new positions for the nodes can be accessed by looking at the\r\n        // .p attribute of a given node. however the p.x & p.y values are in the coordinates\r\n        // of the particle system rather than the screen. you can either map them to\r\n        // the screen yourself, or use the convenience iterators .eachNode (and .eachEdge)\r\n        // which allow you to step through the actual node objects but also pass an\r\n        // x,y point in the screen's coordinate system\r\n        // \r\n        ctx.fillStyle = \"white\"\r\n        ctx.fillRect(0,0, canvas.width, canvas.height)\r\n        \r\n        particleSystem.eachEdge(function(edge, pt1, pt2){\r\n          // edge: {source:Node, target:Node, length:#, data:{}}\r\n          // pt1:  {x:#, y:#}  source position in screen coords\r\n          // pt2:  {x:#, y:#}  target position in screen coords\r\n\r\n          // draw a line from pt1 to pt2\r\n          ctx.strokeStyle = \"rgba(0,0,0, .333)\"\r\n          ctx.lineWidth = 1\r\n          ctx.beginPath()\r\n          ctx.moveTo(pt1.x, pt1.y)\r\n          ctx.lineTo(pt2.x, pt2.y)\r\n          ctx.stroke()\r\n        })\r\n\r\n        particleSystem.eachNode(function(node, pt){\r\n          // node: {mass:#, p:{x,y}, name:\"\", data:{}}\r\n          // pt:   {x:#, y:#}  node position in screen coords\r\n\r\n          // draw a rectangle centered at pt\r\n          var w = 10\r\n          ctx.fillStyle = (node.data.alone) ? \"red\" : \"blue\"\r\n          ctx.fillRect(pt.x-w/2, pt.y-w/2, w,w)\r\n        })    \t\t\t\r\n      },\r\n      \r\n      initMouseHandling:function(){\r\n        // no-nonsense drag and drop (thanks springy.js)\r\n        var dragged = null;\r\n\r\n        // set up a handler object that will initially listen for mousedowns then\r\n        // for moves and mouseups while dragging\r\n        var handler = {\r\n          clicked:function(e){\r\n            var pos = $(canvas).offset();\r\n            _mouseP = arbor.Point(e.pageX-pos.left, e.pageY-pos.top)\r\n            dragged = particleSystem.nearest(_mouseP);\r\n\r\n            if (dragged && dragged.node !== null){\r\n              // while we're dragging, don't let physics move the node\r\n              dragged.node.fixed = true\r\n            }\r\n\r\n            $(canvas).bind('mousemove', handler.dragged)\r\n            $(window).bind('mouseup', handler.dropped)\r\n\r\n            return false\r\n          },\r\n          dragged:function(e){\r\n            var pos = $(canvas).offset();\r\n            var s = arbor.Point(e.pageX-pos.left, e.pageY-pos.top)\r\n\r\n            if (dragged && dragged.node !== null){\r\n              var p = particleSystem.fromScreen(s)\r\n              dragged.node.p = p\r\n            }\r\n\r\n            return false\r\n          },\r\n\r\n          dropped:function(e){\r\n            if (dragged===null || dragged.node===undefined) return\r\n            if (dragged.node !== null) dragged.node.fixed = false\r\n            dragged.node.tempMass = 1000\r\n            dragged = null\r\n            $(canvas).unbind('mousemove', handler.dragged)\r\n            $(window).unbind('mouseup', handler.dropped)\r\n            _mouseP = null\r\n            return false\r\n          }\r\n        }\r\n        \r\n        // start listening\r\n        $(canvas).mousedown(handler.clicked);\r\n\r\n      },\r\n      \r\n    }\r\n    return that\r\n  }    \r\n\r\n  $(document).ready(function(){\r\n    //arbor.ParticleSystem(repulsion, stiffness, friction, gravity, fps, dt, precision)\r\n    var sys = arbor.ParticleSystem(1000, 600, 0.5, true, 55, 0.02, 0.6);\r\n\r\n    sys.renderer = Renderer(\"#viewport\") ;\r\n\r\n    /* add some nodes to the graph and watch it go...\r\n    sys.addEdge('a','b')\r\n    sys.addEdge('a','c')\r\n    sys.addEdge('a','d')\r\n    sys.addEdge('a','e')\r\n    sys.addNode('f', {alone:true, mass:.25})\r\n*/\r\n    // or, equivalently:\r\n    //\r\n    // sys.graft({\r\n    //   nodes:{\r\n    //     f:{alone:true, mass:.25}\r\n    //   }, \r\n    //   edges:{\r\n    //     a:{ b:{},\r\n    //         c:{},\r\n    //         d:{},\r\n    //         e:{}\r\n    //     }\r\n    //   }\r\n    // })\r\n    \r\n  })\r\n\r\n})(this.jQuery)\r\n\r\nasync function draw() {\r\n  \r\n  // Do all of this in a subscription\r\n\r\n  nodes = await api.query.proxy.proxies.entries()\r\n  proxy_actions = await api.query.proxy.announcements.entries()\r\n  for(node in nodes){\r\n    node_point = nodes[node][0].toHuman() //nodes in graph\r\n    edges = nodes[node][1] //node edges/graph connections\r\n    \r\n    console.log(node_point)\r\n  }\r\n}"},"hash":"52929f47c0fc27a981bf018455abde8a"}