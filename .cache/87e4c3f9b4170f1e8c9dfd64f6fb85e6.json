{"dependencies":[{"name":"@polkadot/api","loc":{"line":2,"column":39}}],"generated":{"js":"\"use strict\";\n\nvar _api = require(\"@polkadot/api\");\n\n//arbor\n(function ($) {\n\n  var Renderer = function (canvas) {\n    var canvas = $(canvas).get(0);\n    var ctx = canvas.getContext(\"2d\");\n    var particleSystem;\n\n    var that = {\n      init: function (system) {\n        // the particle system will call the init function once, right before the\n        // first frame is to be drawn. it's a good place to set up the canvas and\n        // to pass the canvas size to the particle system\n        //\n        // save a reference to the particle system for use in the .redraw() loop\n        particleSystem = system;\n\n        // inform the system of the screen dimensions so it can map coords for us.\n        // if the canvas is ever resized, screenSize should be called again with\n        // the new dimensions\n        particleSystem.screenSize(canvas.width, canvas.height);\n        particleSystem.screenPadding(80); // leave an extra 80px of whitespace per side\n\n        // set up some event handlers to allow for node-dragging\n        that.initMouseHandling();\n      },\n\n      redraw: function () {\n        // \n        // redraw will be called repeatedly during the run whenever the node positions\n        // change. the new positions for the nodes can be accessed by looking at the\n        // .p attribute of a given node. however the p.x & p.y values are in the coordinates\n        // of the particle system rather than the screen. you can either map them to\n        // the screen yourself, or use the convenience iterators .eachNode (and .eachEdge)\n        // which allow you to step through the actual node objects but also pass an\n        // x,y point in the screen's coordinate system\n        // \n        ctx.fillStyle = \"white\";\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        particleSystem.eachEdge(function (edge, pt1, pt2) {\n          // edge: {source:Node, target:Node, length:#, data:{}}\n          // pt1:  {x:#, y:#}  source position in screen coords\n          // pt2:  {x:#, y:#}  target position in screen coords\n\n          // draw a line from pt1 to pt2\n          ctx.strokeStyle = \"rgba(0,0,0, .333)\";\n          ctx.lineWidth = 1;\n          ctx.beginPath();\n          ctx.moveTo(pt1.x, pt1.y);\n          ctx.lineTo(pt2.x, pt2.y);\n          ctx.stroke();\n        });\n\n        particleSystem.eachNode(function (node, pt) {\n          // node: {mass:#, p:{x,y}, name:\"\", data:{}}\n          // pt:   {x:#, y:#}  node position in screen coords\n\n          // draw a rectangle centered at pt\n          var w = 10;\n          ctx.fillStyle = node.data.alone ? \"red\" : \"blue\";\n          ctx.fillRect(pt.x - w / 2, pt.y - w / 2, w, w);\n        });\n      },\n\n      initMouseHandling: function () {\n        // no-nonsense drag and drop (thanks springy.js)\n        var dragged = null;\n\n        // set up a handler object that will initially listen for mousedowns then\n        // for moves and mouseups while dragging\n        var handler = {\n          clicked: function (e) {\n            var pos = $(canvas).offset();\n            _mouseP = arbor.Point(e.pageX - pos.left, e.pageY - pos.top);\n            dragged = particleSystem.nearest(_mouseP);\n\n            if (dragged && dragged.node !== null) {\n              // while we're dragging, don't let physics move the node\n              dragged.node.fixed = true;\n            }\n\n            $(canvas).bind('mousemove', handler.dragged);\n            $(window).bind('mouseup', handler.dropped);\n\n            return false;\n          },\n          dragged: function (e) {\n            var pos = $(canvas).offset();\n            var s = arbor.Point(e.pageX - pos.left, e.pageY - pos.top);\n\n            if (dragged && dragged.node !== null) {\n              var p = particleSystem.fromScreen(s);\n              dragged.node.p = p;\n            }\n\n            return false;\n          },\n\n          dropped: function (e) {\n            if (dragged === null || dragged.node === undefined) return;\n            if (dragged.node !== null) dragged.node.fixed = false;\n            dragged.node.tempMass = 1000;\n            dragged = null;\n            $(canvas).unbind('mousemove', handler.dragged);\n            $(window).unbind('mouseup', handler.dropped);\n            _mouseP = null;\n            return false;\n          }\n\n          // start listening\n        };$(canvas).mousedown(handler.clicked);\n      }\n\n    };\n    return that;\n  };\n\n  $(document).ready(function () {\n    //arbor.ParticleSystem(repulsion, stiffness, friction, gravity, fps, dt, precision)\n    var sys = arbor.ParticleSystem(1000, 600, 0.5, true, 55, 0.02, 0.6);\n\n    sys.renderer = Renderer(\"#viewport\");\n\n    /* add some nodes to the graph and watch it go...\r\n    sys.addEdge('a','b')\r\n    sys.addEdge('a','c')\r\n    sys.addEdge('a','d')\r\n    sys.addEdge('a','e')\r\n    sys.addNode('f', {alone:true, mass:.25})\r\n    */\n    // or, equivalently:\n    //\n    // sys.graft({\n    //   nodes:{\n    //     f:{alone:true, mass:.25}\n    //   }, \n    //   edges:{\n    //     a:{ b:{},\n    //         c:{},\n    //         d:{},\n    //         e:{}\n    //     }\n    //   }\n    // })\n  });\n})(undefined.jQuery); //Imports\n\n\nasync function draw() {\n  // Construct\n  const wsProvider = new _api.WsProvider('wss://kusama-rpc.polkadot.io');\n  const api = await _api.ApiPromise.create({ provider: wsProvider });\n\n  // Do all of this in a subscription\n\n  nodes = await api.query.proxy.proxies.entries();\n  proxy_actions = await api.query.proxy.announcements.entries();\n  for (node in nodes) {\n    node_point = nodes[node][0].toHuman(); //nodes in graph\n    edges = nodes[node][1]; //node edges/graph connections\n\n    console.log(node_point);\n  }\n}"},"hash":"5951e9d95cedbb4759ad8d110bdad99f"}