{"dependencies":[{"name":"@polkadot/util","loc":{"line":3,"column":85}},{"name":"@polkadot/util-crypto","loc":{"line":4,"column":418}},{"name":"./decode.js","loc":{"line":5,"column":27}},{"name":"./encode.js","loc":{"line":6,"column":27}},{"name":"./toJson.js","loc":{"line":7,"column":27}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createPair = createPair;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _decode = require(\"./decode.js\");\n\nvar _encode = require(\"./encode.js\");\n\nvar _toJson = require(\"./toJson.js\");\n\nconst SIG_TYPE_NONE = new Uint8Array(); // Copyright 2017-2022 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nconst TYPE_FROM_SEED = {\n  ecdsa: _utilCrypto.secp256k1PairFromSeed,\n  ed25519: _utilCrypto.ed25519PairFromSeed,\n  ethereum: _utilCrypto.secp256k1PairFromSeed,\n  sr25519: _utilCrypto.sr25519PairFromSeed\n};\nconst TYPE_PREFIX = {\n  ecdsa: new Uint8Array([2]),\n  ed25519: new Uint8Array([0]),\n  ethereum: new Uint8Array([2]),\n  sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n  ecdsa: (m, p) => (0, _utilCrypto.secp256k1Sign)(m, p, 'blake2'),\n  ed25519: _utilCrypto.ed25519Sign,\n  ethereum: (m, p) => (0, _utilCrypto.secp256k1Sign)(m, p, 'keccak'),\n  sr25519: _utilCrypto.sr25519Sign\n};\nconst TYPE_ADDRESS = {\n  ecdsa: p => p.length > 32 ? (0, _utilCrypto.blake2AsU8a)(p) : p,\n  ed25519: p => p,\n  ethereum: p => p.length === 20 ? p : (0, _utilCrypto.keccakAsU8a)((0, _utilCrypto.secp256k1Expand)(p)),\n  sr25519: p => p\n};\n\nfunction isLocked(secretKey) {\n  return !secretKey || (0, _util.u8aEmpty)(secretKey);\n}\n\nfunction vrfHash(proof, context, extra) {\n  return (0, _utilCrypto.blake2AsU8a)((0, _util.u8aConcat)(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\n\nfunction createPair({\n  toSS58,\n  type\n}, {\n  publicKey,\n  secretKey\n}, meta = {}, encoded = null, encTypes) {\n  const decodePkcs8 = (passphrase, userEncoded) => {\n    const decoded = (0, _decode.decodePair)(passphrase, userEncoded || encoded, encTypes);\n\n    if (decoded.secretKey.length === 64) {\n      publicKey = decoded.publicKey;\n      secretKey = decoded.secretKey;\n    } else {\n      const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n      publicKey = pair.publicKey;\n      secretKey = pair.secretKey;\n    }\n  };\n\n  const recode = passphrase => {\n    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n    encoded = (0, _encode.encodePair)({\n      publicKey,\n      secretKey\n    }, passphrase); // re-encode, latest version\n\n    encTypes = undefined; // swap to defaults, latest version follows\n\n    return encoded;\n  };\n\n  const encodeAddress = () => {\n    const raw = TYPE_ADDRESS[type](publicKey);\n    return type === 'ethereum' ? (0, _utilCrypto.ethereumEncode)(raw) : toSS58(raw);\n  };\n\n  return {\n    get address() {\n      return encodeAddress();\n    },\n\n    get addressRaw() {\n      const raw = TYPE_ADDRESS[type](publicKey);\n      return type === 'ethereum' ? raw.slice(-20) : raw;\n    },\n\n    get isLocked() {\n      return isLocked(secretKey);\n    },\n\n    get meta() {\n      return meta;\n    },\n\n    get publicKey() {\n      return publicKey;\n    },\n\n    get type() {\n      return type;\n    },\n\n    // eslint-disable-next-line sort-keys\n    decodePkcs8,\n    decryptMessage: (encryptedMessageWithNonce, senderPublicKey) => {\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot encrypt with a locked key pair');\n      (0, _util.assert)(!['ecdsa', 'ethereum'].includes(type), 'Secp256k1 not supported yet');\n      const messageU8a = (0, _util.u8aToU8a)(encryptedMessageWithNonce);\n      return (0, _utilCrypto.naclOpen)(messageU8a.slice(24, messageU8a.length), messageU8a.slice(0, 24), (0, _utilCrypto.convertPublicKeyToCurve25519)((0, _util.u8aToU8a)(senderPublicKey)), (0, _utilCrypto.convertSecretKeyToCurve25519)(secretKey));\n    },\n    derive: (suri, meta) => {\n      (0, _util.assert)(type !== 'ethereum', 'Unable to derive on this keypair');\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot derive on a locked keypair');\n      const {\n        path\n      } = (0, _utilCrypto.keyExtractPath)(suri);\n      const derived = (0, _utilCrypto.keyFromPath)({\n        publicKey,\n        secretKey\n      }, path, type);\n      return createPair({\n        toSS58,\n        type\n      }, derived, meta, null);\n    },\n    encodePkcs8: passphrase => {\n      return recode(passphrase);\n    },\n    encryptMessage: (message, recipientPublicKey, nonceIn) => {\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot encrypt with a locked key pair');\n      (0, _util.assert)(!['ecdsa', 'ethereum'].includes(type), 'Secp256k1 not supported yet');\n      const {\n        nonce,\n        sealed\n      } = (0, _utilCrypto.naclSeal)((0, _util.u8aToU8a)(message), (0, _utilCrypto.convertSecretKeyToCurve25519)(secretKey), (0, _utilCrypto.convertPublicKeyToCurve25519)((0, _util.u8aToU8a)(recipientPublicKey)), nonceIn);\n      return (0, _util.u8aConcat)(nonce, sealed);\n    },\n    lock: () => {\n      secretKey = new Uint8Array();\n    },\n    setMeta: additional => {\n      meta = (0, _util.objectSpread)({}, meta, additional);\n    },\n    sign: (message, options = {}) => {\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n      return (0, _util.u8aConcat)(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type]((0, _util.u8aToU8a)(message), {\n        publicKey,\n        secretKey\n      }));\n    },\n    toJson: passphrase => {\n      // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these\n      // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)\n      // unless the publicKey is already an address\n      const address = ['ecdsa', 'ethereum'].includes(type) ? publicKey.length === 20 ? (0, _util.u8aToHex)(publicKey) : (0, _util.u8aToHex)((0, _utilCrypto.secp256k1Compress)(publicKey)) : encodeAddress();\n      return (0, _toJson.pairToJson)(type, {\n        address,\n        meta\n      }, recode(passphrase), !!passphrase);\n    },\n    unlock: passphrase => {\n      return decodePkcs8(passphrase);\n    },\n    verify: (message, signature, signerPublic) => {\n      return (0, _utilCrypto.signatureVerify)(message, signature, TYPE_ADDRESS[type]((0, _util.u8aToU8a)(signerPublic))).isValid;\n    },\n    vrfSign: (message, context, extra) => {\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n\n      if (type === 'sr25519') {\n        return (0, _utilCrypto.sr25519VrfSign)(message, {\n          secretKey\n        }, context, extra);\n      }\n\n      const proof = TYPE_SIGNATURE[type]((0, _util.u8aToU8a)(message), {\n        publicKey,\n        secretKey\n      });\n      return (0, _util.u8aConcat)(vrfHash(proof, context, extra), proof);\n    },\n    vrfVerify: (message, vrfResult, signerPublic, context, extra) => {\n      if (type === 'sr25519') {\n        return (0, _utilCrypto.sr25519VrfVerify)(message, vrfResult, publicKey, context, extra);\n      }\n\n      const result = (0, _utilCrypto.signatureVerify)(message, (0, _util.u8aConcat)(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type]((0, _util.u8aToU8a)(signerPublic)));\n      return result.isValid && (0, _util.u8aEq)(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n    }\n  };\n}"},"hash":"c6f0f314763ec7b6671fbcf3e175f385"}